# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-26 18:44+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/rest-json.adoc:6
#, no-wrap
msgid "Quarkus - Writing JSON REST Services"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:11
msgid "JSON is now the _lingua franca_ between microservices."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:13
msgid ""
"In this guide, we see how you can get your REST services to consume and "
"produce JSON payloads."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:15
msgid ""
"there is another guide if you need a link:rest-client[REST client] "
"(including support for JSON)."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:16
#, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:19
msgid "To complete this guide, you need:"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:21
msgid "less than 15 minutes"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:22
msgid "an IDE"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:23
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:24
msgid "Apache Maven {maven-version}"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:25
#, no-wrap
msgid "Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:28
msgid ""
"The application built in this guide is quite simple: the user can add "
"elements in a list using a form and the list is updated."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:30
msgid ""
"All the information between the browser and the server are formatted as "
"JSON."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:31
#, no-wrap
msgid "Solution"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:35
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step.  However, you can go right to the "
"completed example."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:37
msgid ""
"Clone the Git repository: `git clone {quickstarts-clone-url}`, or download "
"an {quickstarts-archive-url}[archive]."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:39
msgid ""
"The solution is located in the `rest-json-quickstart` "
"{quickstarts-tree-url}/rest-json-quickstart[directory]."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:40
#, no-wrap
msgid "Creating the Maven project"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:43
msgid ""
"First, we need a new project. Create a new project with the following "
"command:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:53
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json-quickstart \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jackson\"\n"
"cd rest-json-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:57
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS and "
"https://github.com/FasterXML/jackson[Jackson] extensions, and in particular "
"adds the following dependency:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:64
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:69
msgid ""
"To improve user experience, Quarkus registers the three Jackson "
"https://github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you "
"don't need to do it manually."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:72
msgid ""
"Quarkus also supports http://json-b.net/[JSON-B] so, if you prefer JSON-B "
"over Jackson, you can create a project relying on the RESTEasy JSON-B "
"extension instead:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:82
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json-quickstart \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jsonb\"\n"
"cd rest-json-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:86
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS and "
"http://json-b.net/[JSON-B] extensions, and in particular adds the following "
"dependency:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:93
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:95
#, no-wrap
msgid "Creating your first JSON REST service"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:98
msgid "In this example, we will create an application to manage a list of fruits."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:100
msgid "First, let's create the `Fruit` bean as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:104 upstream/_guides/rest-json.adoc:127 upstream/_guides/rest-json.adoc:311 upstream/_guides/rest-json.adoc:334 upstream/_guides/rest-json.adoc:464
#, no-wrap
msgid "package org.acme.rest.json;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:106
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:109 upstream/_guides/rest-json.adoc:316
#, no-wrap
msgid ""
"    public String name;\n"
"    public String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:112
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:118
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:121
msgid ""
"Nothing fancy. One important thing to note is that having a default "
"constructor is required by the JSON serialization layer."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:123
msgid "Now, edit the `org.acme.rest.json.FruitResource` class as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:131
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.LinkedHashMap;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:136
#, no-wrap
msgid ""
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:139
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:141
#, no-wrap
msgid ""
"    private Set<Fruit> fruits = "
"Collections.newSetFromMap(Collections.synchronizedMap(new "
"LinkedHashMap<>()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:146
#, no-wrap
msgid ""
"    public FruitResource() {\n"
"        fruits.add(new Fruit(\"Apple\", \"Winter fruit\"));\n"
"        fruits.add(new Fruit(\"Pineapple\", \"Tropical fruit\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:151
#, no-wrap
msgid ""
"    @GET\n"
"    public Set<Fruit> list() {\n"
"        return fruits;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:157
#, no-wrap
msgid ""
"    @POST\n"
"    public Set<Fruit> add(Fruit fruit) {\n"
"        fruits.add(fruit);\n"
"        return fruits;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:164
#, no-wrap
msgid ""
"    @DELETE\n"
"    public Set<Fruit> delete(Fruit fruit) {\n"
"        fruits.removeIf(existingFruit -> "
"existingFruit.name.contentEquals(fruit.name));\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:167
msgid ""
"The implementation is pretty straightforward and you just need to define "
"your endpoints using the JAX-RS annotations."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:170
msgid ""
"The `Fruit` objects will be automatically serialized/deserialized by "
"http://json-b.net/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], "
"depending on the extension you chose when initializing the project."
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:177
msgid ""
"When a JSON extension is installed such as `quarkus-resteasy-jackson` or "
"`quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type "
"by default for most return values, unless the media type is explicitly set "
"via `@Produces` or `@Consumes` annotations (there are some exceptions for "
"well known types, such as `String` and `File`, which default to `text/plain` "
"and `application/octet-stream` respectively)."
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:180
msgid ""
"If you don't want JSON by default you can set "
"`quarkus.resteasy-json.default-json=false` and the default will change back "
"to being auto-negotiated. If you set this you will need to add "
"`@Produces(MediaType.APPLICATION_JSON)` and "
"`@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to use "
"JSON."
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:183
msgid ""
"If you don't rely on the JSON default, it is heavily recommended to annotate "
"your endpoints with the `@Produces` and `@Consumes` annotations to define "
"precisely the expected content-types.  It will allow to narrow down the "
"number of JAX-RS providers (which can be seen as converters) included in the "
"native executable."
msgstr ""

#. type: Title ===
#: upstream/_guides/rest-json.adoc:185
#, no-wrap
msgid "Configuring JSON support"
msgstr ""

#. type: Title ====
#: upstream/_guides/rest-json.adoc:187
#, no-wrap
msgid "Jackson"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:191
msgid ""
"Quarkus makes it very easy to configure various Jackson settings via CDI "
"beans. The simplest (and suggested) approach is to define a CDI bean of type "
"`io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson "
"configuration can be applied."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:193
msgid "An example where a custom module needs to be registered would look like so:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:199
#, no-wrap
msgid ""
"import com.fasterxml.jackson.databind.ObjectMapper;\n"
"import io.quarkus.jackson.ObjectMapperCustomizer;\n"
"import javax.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:202
#, no-wrap
msgid ""
"@Singleton\n"
"public class RegisterCustomModuleCustomizer implements "
"ObjectMapperCustomizer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:207
#, no-wrap
msgid ""
"    public void customize(ObjectMapper mapper) {\n"
"        mapper.registerModule(new CustomModule());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:212
msgid ""
"Users can even provide their own `ObjectMapper` bean if they so choose.  If "
"this is done, it is very important to manually inject and apply all "
"`io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that "
"produces `ObjectMapper`.  Failure to do so will prevent Jackson specific "
"customizations provided by various extensions from being applied."
msgstr ""

#. type: Title ====
#: upstream/_guides/rest-json.adoc:213
#, no-wrap
msgid "JSON-B"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:216
msgid ""
"As stated above, Quarkus provides the option of using JSON-B instead of "
"Jackson via the use of the `quarkus-resteasy-jsonb` extension."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:218
msgid ""
"Following the same approach as described in the previous section, JSON-B can "
"be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:220
msgid ""
"If for example a custom serializer named `FooSerializer` for type "
"`com.example.Foo` needs to be registered with JSON-B, the addition of a bean "
"like the following would suffice:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:227
#, no-wrap
msgid ""
"import io.quarkus.jsonb.JsonbConfigCustomizer;\n"
"import javax.inject.Singleton;\n"
"import javax.json.bind.JsonbConfig;\n"
"import javax.json.bind.serializer.JsonbSerializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:230
#, no-wrap
msgid ""
"@Singleton\n"
"public class FooSerializerRegistrationCustomizer implements "
"JsonbConfigCustomizer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:235
#, no-wrap
msgid ""
"    public void customize(JsonbConfig config) {\n"
"        config.withSerializers(new FooSerializer());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:240
msgid ""
"A more advanced option would be to directly provide a bean of "
"`javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme "
"case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` "
"scope).  If the latter approach is leveraged it is very important to "
"manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans "
"in the CDI producer that produces `javax.json.bind.Jsonb`.  Failure to do so "
"will prevent JSON-B specific customizations provided by various extensions "
"from being applied."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:241
#, no-wrap
msgid "Creating a frontend"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:246
msgid ""
"Now let's add a simple web page to interact with our `FruitResource`.  "
"Quarkus automatically serves static resources located under the "
"`META-INF/resources` directory.  In the "
"`src/main/resources/META-INF/resources` directory, add a `fruits.html` file "
"with the content from this "
"{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] "
"file in it."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:248
msgid "You can now interact with your REST service:"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:250
msgid "start Quarkus with `./mvnw compile quarkus:dev`"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:251
msgid "open a browser to `http://localhost:8080/fruits.html`"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:252
msgid "add new fruits to the list via the form"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:253
#, no-wrap
msgid "Building a native executable"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:256
msgid ""
"You can build a native executable with the usual command `./mvnw package "
"-Pnative`."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:258
msgid ""
"Running it is as simple as executing "
"`./target/rest-json-quickstart-1.0-SNAPSHOT-runner`."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:260
msgid ""
"You can then point your browser to `http://localhost:8080/fruits.html` and "
"use your application."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:261
#, no-wrap
msgid "About serialization"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:264
msgid ""
"JSON serialization libraries use Java reflection to get the properties of an "
"object and serialize them."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:268
msgid ""
"When using native executables with GraalVM, all classes that will be used "
"with reflection need to be registered.  The good news is that Quarkus does "
"that work for you most of the time.  So far, we haven't registered any "
"class, not even `Fruit`, for reflection usage and everything is working "
"fine."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:271
msgid ""
"Quarkus performs some magic when it is capable of inferring the serialized "
"types from the REST methods.  When you have the following REST method, "
"Quarkus determines that `Fruit` will be serialized:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:278
#, no-wrap
msgid ""
"@GET\n"
"public List<Fruit> list() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:282
msgid ""
"Quarkus does that for you automatically by analyzing the REST methods at "
"build time and that's why we didn't need any reflection registration in the "
"first part of this guide."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:285
msgid ""
"Another common pattern in the JAX-RS world is to use the `Response` object.  "
"`Response` comes with some nice perks:"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:287
msgid ""
"you can return different entity types depending on what happens in your "
"method (a `Legume` or an `Error` for instance);"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:288
msgid ""
"you can set the attributes of the `Response` (the status comes to mind in "
"the case of an error)."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:290
msgid "Your REST method then looks like this:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:297
#, no-wrap
msgid ""
"@GET\n"
"public Response list() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:301
msgid ""
"It is not possible for Quarkus to determine at build time the type included "
"in the `Response` as the information is not available.  In this case, "
"Quarkus won't be able to automatically register for reflection the required "
"classes."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:303
msgid "This leads us to our next section."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:304
#, no-wrap
msgid "Using Response"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:307
msgid ""
"Let's create the `Legume` class which will be serialized as JSON, following "
"the same model as for our `Fruit` class:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:313
#, no-wrap
msgid "public class Legume {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:319
#, no-wrap
msgid ""
"    public Legume() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:325
#, no-wrap
msgid ""
"    public Legume(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:328
msgid ""
"Now let's create a `LegumeResource` REST service with only one method which "
"returns the list of legumes."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:330
msgid "This method returns a `Response` and not a list of `Legume`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:338
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.LinkedHashSet;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:345
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:350
#, no-wrap
msgid ""
"@Path(\"/legumes\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class LegumeResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:352
#, no-wrap
msgid ""
"    private Set<Legume> legumes = Collections.synchronizedSet(new "
"LinkedHashSet<>());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:357
#, no-wrap
msgid ""
"    public LegumeResource() {\n"
"        legumes.add(new Legume(\"Carrot\", \"Root vegetable, usually "
"orange\"));\n"
"        legumes.add(new Legume(\"Zucchini\", \"Summer squash\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:363
#, no-wrap
msgid ""
"    @GET\n"
"    public Response list() {\n"
"        return Response.ok(legumes).build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:368
msgid ""
"Now let's add a simple web page to display our list of legumes.  In the "
"`src/main/resources/META-INF/resources` directory, add a `legumes.html` file "
"with the content from this "
"{quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] "
"file in it."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:370
msgid ""
"Open a browser to http://localhost:8080/legumes.html and you will see our "
"list of legumes."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:372
msgid ""
"The interesting part starts when running the application as a native "
"executable:"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:374 upstream/_guides/rest-json.adoc:405
msgid "create the native executable with `./mvnw package -Pnative`."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:375 upstream/_guides/rest-json.adoc:406
msgid "execute it with `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:376 upstream/_guides/rest-json.adoc:407
msgid "open a browser and go to http://localhost:8080/legumes.html"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:378
msgid "No legumes there."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:381
msgid ""
"As mentioned above, the issue is that Quarkus was not able to determine the "
"`Legume` class will require some reflection by analyzing the REST "
"endpoints.  The JSON serialization library tries to get the list of fields "
"of `Legume` and gets an empty list so it does not serialize the fields' "
"data."
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:386
msgid ""
"At the moment, when JSON-B or Jackson tries to get the list of fields of a "
"class, if the class is not registered for reflection, no exception will be "
"thrown.  GraalVM will simply return an empty list of fields."
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:388
msgid "Hopefully, this will change in the future and make the error more obvious."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:391
msgid ""
"We can register `Legume` for reflection manually by adding the "
"`@RegisterForReflection` annotation on our `Legume` class:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:394
#, no-wrap
msgid "import io.quarkus.runtime.annotations.RegisterForReflection;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:399
#, no-wrap
msgid ""
"@RegisterForReflection\n"
"public class Legume {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:402
msgid "Let's do that and follow the same steps as before:"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:404
msgid "hit `Ctrl+C` to stop the application"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:409
msgid "This time, you can see our list of legumes."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:411
#, no-wrap
msgid "Being reactive"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:415
msgid ""
"You can return _reactive types_ to handle asynchronous processing.  Quarkus "
"recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write "
"reactive and asynchronous code."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:417
msgid ""
"To integrate Mutiny and RESTEasy, you need to add the "
"`quarkus-resteasy-mutiny` dependency to your project:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:424
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:427
msgid "Then, your endpoint can return `Uni` or `Multi` instances:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:436
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/{name}\")\n"
"public Uni<Fruit> getOne(@PathParam String name) {\n"
"    return findByName(name);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:441
#, no-wrap
msgid ""
"@GET\n"
"public Multi<Fruit> getAll() {\n"
"    return findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:445
msgid ""
"Use `Uni` when you have a single result.  Use `Multi` when you have multiple "
"items that may be emitted asynchronously."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:447
msgid ""
"You can use `Uni` and `Response` to return asynchronous HTTP responses: "
"`Uni<Response>`."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:449
msgid ""
"More details about Mutiny can be found in the "
"link:getting-started-reactive#mutiny[Getting Started with Reactive guide]."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:451
#, no-wrap
msgid "HTTP filters and interceptors"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:457
msgid ""
"Both HTTP request and response can be intercepted by providing "
"`ContainerRequestFilter` or `ContainerResponseFilter` implementations "
"respectively. These filters are suitable for processing the metadata "
"associated with a message: HTTP headers, query parameters, media type, and "
"other metadata. They also have the capability to abort the request "
"processing, for instance when the user does not have the permissions to "
"access the endpoint."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:460
msgid ""
"Let's use `ContainerRequestFilter` to add logging capability to our "
"service. We can do that by implementing `ContainerRequestFilter` and "
"annotating it with the `@Provider` annotation:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:467
#, no-wrap
msgid ""
"import io.vertx.core.http.HttpServerRequest;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:473
#, no-wrap
msgid ""
"import javax.ws.rs.container.ContainerRequestContext;\n"
"import javax.ws.rs.container.ContainerRequestFilter;\n"
"import javax.ws.rs.core.Context;\n"
"import javax.ws.rs.core.UriInfo;\n"
"import javax.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:476
#, no-wrap
msgid ""
"@Provider\n"
"public class LoggingFilter implements ContainerRequestFilter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:478
#, no-wrap
msgid ""
"    private static final Logger LOG = "
"Logger.getLogger(LoggingFilter.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:481
#, no-wrap
msgid ""
"    @Context\n"
"    UriInfo info;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:484
#, no-wrap
msgid ""
"    @Context\n"
"    HttpServerRequest request;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:487
#, no-wrap
msgid ""
"    @Override\n"
"    public void filter(ContainerRequestContext context) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:491
#, no-wrap
msgid ""
"        final String method = context.getMethod();\n"
"        final String path = info.getPath();\n"
"        final String address = request.remoteAddress().toString();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:495
#, no-wrap
msgid ""
"        LOG.infof(\"Request %s %s from IP %s\", method, path, address);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:498
msgid ""
"Now, whenever a REST method is invoked, the request will be logged into the "
"console:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:505
#, no-wrap
msgid ""
"2019-06-05 12:44:26,526 INFO  [org.acm.res.jso.LoggingFilter] "
"(executor-thread-1) Request GET /legumes from IP 127.0.0.1\n"
"2019-06-05 12:49:19,623 INFO  [org.acm.res.jso.LoggingFilter] "
"(executor-thread-1) Request GET /fruits from IP 0:0:0:0:0:0:0:1\n"
"2019-06-05 12:50:44,019 INFO  [org.acm.res.jso.LoggingFilter] "
"(executor-thread-1) Request POST /fruits from IP 0:0:0:0:0:0:0:1\n"
"2019-06-05 12:51:04,485 INFO  [org.acm.res.jso.LoggingFilter] "
"(executor-thread-1) Request GET /fruits from IP 127.0.0.1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:507
#, no-wrap
msgid "CORS filter"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:512
msgid ""
"link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin "
"resource sharing] (CORS) is a mechanism that allows restricted resources on "
"a web page to be requested from another domain outside the domain from which "
"the first resource was served."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:515
msgid ""
"Quarkus comes with a CORS filter. Read the "
"link:http-reference#cors-filter[HTTP Reference Documentation] to learn how "
"to use it."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:516
#, no-wrap
msgid "GZip Support"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:519
msgid ""
"Quarkus comes with GZip support (even though it is not enabled by "
"default). The following configuration knobs allow to configure GZip support."
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:524
#, no-wrap
msgid ""
"quarkus.resteasy.gzip.enabled=true // <1>\n"
"quarkus.resteasy.gzip.max-input=10M // <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:527
msgid "Enable Gzip support."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:529
msgid ""
"Configure the upper limit on deflated request body. This is useful to "
"mitigate potential attacks by limiting their reach. The default value is "
"`10M`.  This configuration option would recognize strings in this format "
"(shown as a regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix "
"is given, assume bytes."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:530
#, no-wrap
msgid "Multipart Support"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:533
msgid ""
"RESTEasy supports multipart via the "
"https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy "
"Multipart Provider]."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:535
msgid ""
"Quarkus provides an extension called `quarkus-resteasy-multipart` to make "
"things easier for you."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:537
msgid ""
"This extension slightly differs from the RESTEasy default behavior as the "
"default charset (if none is specified in your request) is UTF-8 rather than "
"US-ASCII."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:539
msgid "You can configure this behavior with the following configuration properties:"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:542
#, no-wrap
msgid "Servlet compatibility"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:545
msgid ""
"In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP "
"server, or on top of Undertow if you have any servlet dependency."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:552
msgid ""
"As a result, certain classes, such as `HttpServletRequest` are not always "
"available for injection. Most use-cases for this particular class are "
"covered by JAX-RS equivalents, except for getting the remote client's "
"IP. RESTEasy comes with a replacement API which you can inject: "
"https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`], "
"which has the methods "
"https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] "
"and "
"https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] "
"to solve this problem."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:553
#, no-wrap
msgid "RESTEasy and REST Client interactions"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:557
msgid ""
"In Quarkus, the RESTEasy extension and link:rest-client[the REST Client "
"extension] share the same infrastructure.  One important consequence of this "
"consideration is that they share the same list of providers (in the JAX-RS "
"meaning of the word)."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:560
msgid ""
"For instance, if you declare a `WriterInterceptor`, it will by default "
"intercept both the servers calls and the client calls, which might not be "
"the desired behavior."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:562
msgid "However, you can change this default behavior and constrain a provider to:"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:564
msgid ""
"only consider *server* calls by adding the "
"`@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider;"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:565
msgid ""
"only consider *client* calls by adding the "
"`@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:566
#, no-wrap
msgid "What's Different from Jakarta EE Development"
msgstr ""

#. type: Title ===
#: upstream/_guides/rest-json.adoc:568
#, no-wrap
msgid "No Need for `Application` Class"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:571
msgid ""
"Configuration via an application-supplied subclass of `Application` is "
"supported, but not required."
msgstr ""

#. type: Title ===
#: upstream/_guides/rest-json.adoc:572
#, no-wrap
msgid "Only a single JAX-RS application"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:576
msgid ""
"In contrast to JAX-RS (and RESTeasy) running in a standard "
"servlet-container, Quarkus only supports the deployment of a single JAX-RS "
"application.  If multiple JAX-RS `Application` classes are defined, the "
"build will fail with the message `Multiple classes have been annotated with "
"@ApplicationPath which is currently not supported`."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:578
msgid ""
"If multiple JAX-RS applications are defined, the property "
"`quarkus.resteasy.ignoreApplicationClasses=true` can be used to ignore all "
"explicit `Application` classes. This makes all resource-classes available "
"via the application-path as defined by `quarkus.resteasy.path` (default: "
"`/`)."
msgstr ""

#. type: Title ===
#: upstream/_guides/rest-json.adoc:579
#, no-wrap
msgid "Lifecycle of Resources"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:583
msgid ""
"In Quarkus all JAX-RS resources are treated as CDI beans.  It's possible to "
"inject other beans via `@Inject`, bind interceptors using bindings such as "
"`@Transactional`, define `@PostConstruct` callbacks, etc."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:589
msgid ""
"If there is no scope annotation declared on the resource class then the "
"scope is defaulted.  The default scope can be controlled through the "
"`quarkus.resteasy.singleton-resources` property.  If set to `true` (default) "
"then a *single instance* of a resource class is created to service all "
"requests (as defined by `@javax.inject.Singleton`).  If set to `false` then "
"a *new instance* of the resource class is created per each request.  An "
"explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, etc.) "
"always overrides the default behavior and specifies the lifecycle of "
"resource instances."
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:590
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:593
msgid ""
"Creating JSON REST services with Quarkus is easy as it relies on proven and "
"well known technologies."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:595
msgid ""
"As usual, Quarkus further simplifies things under the hood when running your "
"application as a native executable."
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:596
msgid ""
"There is only one thing to remember: if you use `Response` and Quarkus can't "
"determine the beans that are serialized, you need to annotate them with "
"`@RegisterForReflection`."
msgstr ""
