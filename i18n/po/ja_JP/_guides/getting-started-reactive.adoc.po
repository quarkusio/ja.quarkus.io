# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr "Project-Id-Version: PACKAGE VERSION\nPOT-Creation-Date: 2021-02-04 15:41+0000\nPO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\nLast-Translator: FULL NAME <EMAIL@ADDRESS>\nLanguage-Team: LANGUAGE <LL@li.org>\nLanguage: \nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-reactive.adoc:6
#, no-wrap
msgid "Quarkus - Getting started with Reactive"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:12
msgid "Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:14
msgid "A quick glance at the Quarkus engine and how it enables reactive"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:15
msgid "A brief introduction to Mutiny - the reactive programming library used by Quarkus"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:16
msgid "The difference between RESTEasy, RESTEasy Reactive and Reactive Routes"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:17
msgid "The bootstrap of a reactive application using RESTEasy Reactive"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:18
msgid "Creating a reactive JAX-RS endpoint (asynchronous, streams...)"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:19
msgid "Using reactive database access"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:20
msgid "Interacting with other reactive APIs"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:21
#, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:24
msgid "To complete this guide, you need:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:26
msgid "less than 15 minutes"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:27
msgid "an IDE"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:28
msgid "JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:29
msgid "Apache Maven {maven-version}"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:30
#, no-wrap
msgid "Solutions"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:33
msgid "We recommend that you follow the instructions from <<bootstrapping-the-project,Bootstrapping project>> and onwards to create the application step by step."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:35
msgid "However, you can go right to the completed example."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:37
msgid "Download an {quickstarts-archive-url}[archive] or clone the git repository:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:41
#, no-wrap
msgid "git clone {quickstarts-clone-url}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:44
msgid "The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories."
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:45
#, no-wrap
msgid "The multiple reactive facets of Quarkus"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:51
msgid "Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:53
msgid "image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:61
msgid "Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:63
msgid "image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:65
msgid "But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:67
msgid "image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:74
msgid "Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:78
msgid "As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  Thatâ€™s where having a reactive API is an ultimate weapon."
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:80
#, no-wrap
msgid "Mutiny - A reactive programming library"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:84
msgid "https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:86
msgid "`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:87
msgid "`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:90
msgid "Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:97
#, no-wrap
msgid "uni.subscribe().with(\n    result -> System.out.println(\"result is \" + result),\n    failure -> failure.printStackTrace()\n);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:102
#, no-wrap
msgid "multi.subscribe().with(\n    item -> System.out.println(\"Got \" + item),\n    failure -> failure.printStackTrace()\n);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:108
msgid "Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive."
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:113
#, no-wrap
msgid "httpCall\n    .onFailure().recoverWithItem(\"my fallback\");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:119
msgid "You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:122
msgid "Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:127
#, no-wrap
msgid "// Block until the result is available\nString result = uni.await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:130
#, no-wrap
msgid "// Transform an asynchronous stream into a blocking iterable\nstream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:134
msgid "At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:139
#, no-wrap
msgid "Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\nFlux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:144
msgid "But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:164
#, no-wrap
msgid "// Use io.vertx.mutiny.ext.web.client.WebClient\nclient = WebClient.create(vertx,\n                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n                        .setTrustAll(true));\n// ...\nUni<JsonObject> uni =\n    client.get(\"/api/fruit/\" + name)\n        .send()\n        .onItem().transform(resp -> {\n            if (resp.statusCode() == 200) {\n                return resp.bodyAsJsonObject();\n            } else {\n                return new JsonObject()\n                        .put(\"code\", resp.statusCode())\n                        .put(\"message\", resp.bodyAsString());\n            }\n        });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:167
msgid "Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:169
msgid "But enough talking, let's get our hands dirty!"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:170
#, no-wrap
msgid "Bootstrapping the project"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:175
msgid "There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:178
msgid "While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:180
msgid "The easiest way to create a new Quarkus project is to open a terminal and run the following command:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:182
msgid "For Linux and macOS users"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:192
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n    -DprojectGroupId=org.acme \\\n    -DprojectArtifactId=getting-started-reactive \\\n    -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" \\\n    -Dpath=\"/hello\" \\\n    -Dextensions=\"resteasy-reactive\"\ncd getting-started-reactive\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:195
msgid "For Windows users"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:197
msgid "If using cmd, (don't use forward slash `\\`)"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:201
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:204
msgid "If using Powershell, wrap `-D` parameters in double quotes"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:208
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.getting.started.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:211
msgid "It generates the following in `./getting-started-reactive`:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:213
msgid "the Maven structure"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:214
msgid "an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:215
msgid "an associated unit test"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:216
msgid "a landing page that is accessible on `http://localhost:8080` after starting the application"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:217
msgid "example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:218
msgid "the application configuration file"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:219
#, no-wrap
msgid "Reactive JAX-RS resources"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:222
msgid "During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:226
#: upstream/_guides/getting-started-reactive.adoc:269
#: upstream/_guides/getting-started-reactive.adoc:291
#, no-wrap
msgid "package org.acme.getting.started;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:231
#, no-wrap
msgid "import javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:234
#: upstream/_guides/getting-started-reactive.adoc:304
#, no-wrap
msgid "@Path(\"/hello\")\npublic class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:241
#, no-wrap
msgid "    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    public String hello() {\n        return \"Hello RESTEasy Reactive\";\n    }\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:245
msgid "It's a very simple REST endpoint, returning \"Hello RESTEasy Reactive\" to requests on \"/hello\".  As it uses RESTEAsy Reactive, this method is called on the I/O thread."
msgstr ""

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:250
msgid "To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:256
#, no-wrap
msgid "import javax.ws.rs.ApplicationPath;\nimport javax.ws.rs.core.Application;\nimport io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:261
#, no-wrap
msgid "@ApplicationPath(\"/\")\n@Blocking\npublic class RestBlockingApplication extends Application {\n}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:265
msgid "Let's now create a `ReactiveGreetingService` class with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:272
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:275
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\nimport java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:278
#, no-wrap
msgid "@ApplicationScoped\npublic class ReactiveGreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:284
#, no-wrap
msgid "    public Uni<String> greeting(String name) {\n        return Uni.createFrom().item(name)\n                .onItem().transform(n -> String.format(\"hello %s\", n));\n    }\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:287
msgid "Then, edit the `ReactiveGreetingResource` class to match the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:297
#, no-wrap
msgid "import javax.inject.Inject;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:301
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\nimport org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:307
#, no-wrap
msgid "    @Inject\n    ReactiveGreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:314
#, no-wrap
msgid "    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    @Path(\"/greeting/{name}\")\n    public Uni<String> greeting(String name) {\n        return service.greeting(name);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:321
#, no-wrap
msgid "    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    public String hello() {\n        return \"hello\";\n    }\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:326
msgid "The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:328
msgid "Now, start the application using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:332
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:335
msgid "Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo."
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:336
#, no-wrap
msgid "Handling streams"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:340
msgid "So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:342
msgid "In the `ReactiveGreetingService`, add the following method:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:350
#, no-wrap
msgid "public Multi<String> greetings(int count, String name) {\n  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n        .onItem().transform(n -> String.format(\"hello %s - %d\", name, n))\n        .transform().byTakingFirstItems(count);\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:353
msgid "you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:355
msgid "It generates a greeting message every second and stops after `count` messages."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:357
msgid "In the `ReactiveGreetingResource` add the following method:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:366
#, no-wrap
msgid "@GET\n@Produces(MediaType.APPLICATION_JSON)\n@Path(\"/greeting/{count}/{name}\")\npublic Multi<String> greetings(int count, String name) {\n  return service.greetings(count, name);\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:370
msgid "This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:372
msgid "So calling the endpoint produces something like:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:377
#, no-wrap
msgid "$ curl http://localhost:8080/hello/greeting/3/neo\n[\"hello neo - 0\", \"hello neo - 1\", \"hello neo - 2\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:380
msgid "We can also generate Server-Sent Event responses by returning a `Multi`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:390
#, no-wrap
msgid "@GET\n@Produces(MediaType.SERVER_SENT_EVENTS)\n@RestSseElementType(MediaType.TEXT_PLAIN)\n@Path(\"/stream/{count}/{name}\")\npublic Multi<String> greetingsAsStream(int count, String name) {\n    return service.greetings(count, name);\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:394
msgid "The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:396
msgid "You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:398
msgid "You can see the result using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:403
#, no-wrap
msgid "$ curl -N http://localhost:8080/hello/stream/5/neo\ndata: hello neo - 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:405
#, no-wrap
msgid "data: hello neo - 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:407
#, no-wrap
msgid "data: hello neo - 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:409
#, no-wrap
msgid "data: hello neo - 3\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:411
#, no-wrap
msgid "data: hello neo - 4\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:413
#, no-wrap
msgid "Using Reactive APIs"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:415
#, no-wrap
msgid "Using Quarkus reactive APIs"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:419
msgid "Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:421
msgid "Create a new project using:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:431
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n    -DprojectGroupId=org.acme \\\n    -DprojectArtifactId=getting-started-reactive-crud \\\n    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n    -Dpath=\"/fruits\" \\\n    -Dextensions=\"resteasy-reactive,resteasy-reactive-jackson,reactive-pg-client\"\ncd getting-started-reactive-crud\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:434
msgid "This application is interacting with a PostgreSQL database, so you need one:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:441
#, no-wrap
msgid "docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n           -p 5432:5432 postgres:11.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:445
msgid "Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:453
#, no-wrap
msgid "quarkus.datasource.db-kind=postgresql\nquarkus.datasource.username=quarkus_test\nquarkus.datasource.password=quarkus_test\nquarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\nmyapp.schema.create=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:457
msgid "The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:460
msgid "Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:464
#: upstream/_guides/getting-started-reactive.adoc:538
#: upstream/_guides/getting-started-reactive.adoc:581
#, no-wrap
msgid "package org.acme.reactive.crud;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:471
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\nimport io.vertx.mutiny.pgclient.PgPool;\nimport io.vertx.mutiny.sqlclient.Row;\nimport io.vertx.mutiny.sqlclient.RowSet;\nimport io.vertx.mutiny.sqlclient.Tuple;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:473
#, no-wrap
msgid "import java.util.stream.StreamSupport;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:475
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:477
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:479
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:483
#, no-wrap
msgid "    public Fruit() {\n        // default constructor.\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:487
#, no-wrap
msgid "    public Fruit(String name) {\n        this.name = name;\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:492
#, no-wrap
msgid "    public Fruit(Long id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:500
#, no-wrap
msgid "    public static Multi<Fruit> findAll(PgPool client) {\n        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute()\n                // Create a Multi from the set of rows:\n                .onItem().transformToMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n                // For each row create a fruit instance\n                .onItem().transform(Fruit::from);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:506
#, no-wrap
msgid "    public static Uni<Fruit> findById(PgPool client, Long id) {\n        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n                .onItem().transform(RowSet::iterator)\n                .onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:511
#, no-wrap
msgid "    public Uni<Long> save(PgPool client) {\n        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\").execute(Tuple.of(name))\n                .onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:516
#, no-wrap
msgid "    public Uni<Boolean> update(PgPool client) {\n        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\").execute(Tuple.of(name, id))\n                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:521
#, no-wrap
msgid "    public static Uni<Boolean> delete(PgPool client, Long id) {\n        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:526
#, no-wrap
msgid "    private static Fruit from(Row row) {\n        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n    }\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:532
msgid "This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:534
msgid "For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:542
#, no-wrap
msgid "import io.quarkus.runtime.StartupEvent;\nimport io.vertx.mutiny.pgclient.PgPool;\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:545
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\nimport javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:548
#, no-wrap
msgid "@ApplicationScoped\npublic class DBInit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:551
#, no-wrap
msgid "    private final PgPool client;\n    private final boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:556
#, no-wrap
msgid "    public DBInit(PgPool client, @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\") boolean schemaCreate) {\n        this.client = client;\n        this.schemaCreate = schemaCreate;\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:562
#, no-wrap
msgid "    void onStart(@Observes StartupEvent ev) {\n        if (schemaCreate) {\n            initdb();\n        }\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:573
#, no-wrap
msgid "    private void initdb() {\n        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n                .await().indefinitely();\n    }\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:577
msgid "Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:583
#, no-wrap
msgid "import java.net.URI;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:595
#, no-wrap
msgid "import javax.ws.rs.Consumes;\nimport javax.ws.rs.DELETE;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.Response.ResponseBuilder;\nimport javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:599
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\nimport io.vertx.mutiny.pgclient.PgPool;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:604
#, no-wrap
msgid "@Path(\"fruits\")\n@Produces(MediaType.APPLICATION_JSON)\n@Consumes(MediaType.APPLICATION_JSON)\npublic class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:606
#, no-wrap
msgid "    private final PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:610
#, no-wrap
msgid "    public FruitResource(PgPool client) {\n        this.client = client;\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:620
#, no-wrap
msgid "    private void initdb() {\n        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n                .await().indefinitely();\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:625
#, no-wrap
msgid "    @GET\n    public Multi<Fruit> get() {\n        return Fruit.findAll(client);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:633
#, no-wrap
msgid "    @GET\n    @Path(\"{id}\")\n    public Uni<Response> getSingle(Long id) {\n        return Fruit.findById(client, id)\n                .onItem().transform(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n                .onItem().transform(ResponseBuilder::build);\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:640
#, no-wrap
msgid "    @POST\n    public Uni<Response> create(Fruit fruit) {\n        return fruit.save(client)\n                .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n                .onItem().transform(uri -> Response.created(uri).build());\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:648
#, no-wrap
msgid "    @PUT\n    @Path(\"{id}\")\n    public Uni<Response> update(Long id, Fruit fruit) {\n        return fruit.update(client)\n                .onItem().transform(updated -> updated ? Status.OK : Status.NOT_FOUND)\n                .onItem().transform(status -> Response.status(status).build());\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:657
#, no-wrap
msgid "    @DELETE\n    @Path(\"{id}\")\n    public Uni<Response> delete(Long id) {\n        return Fruit.delete(client, id)\n                .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n                .onItem().transform(status -> Response.status(status).build());\n    }\n}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:660
msgid "This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class."
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:661
#, no-wrap
msgid "Using Vert.x clients"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:665
msgid "The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:667
msgid "First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:672
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n    -Dextensions=vertx\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:675
msgid "Or add `quarkus-vertx` into your dependencies manually."
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:682
#, no-wrap
msgid "<dependency>\n\t<groupId>io.quarkus</groupId>\n\t<artifactId>quarkus-vertx</artifactId>\n</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:686
msgid "There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:"
msgstr ""

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:719
#, no-wrap
msgid "|groupId:artifactId | Description\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n|Mutiny API for Vert.x Core\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n|Mutiny API for the Vert.x Mail Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n|Mutiny API for the Vert.x Web Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n|Mutiny API for the Vert.x Mongo Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n|Mutiny API for the Vert.x Redis Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n|Mutiny API for the Vert.x Cassandra Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n|Mutiny API for the Vert.x Consul Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n|Mutiny API for the Vert.x Kafka Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n|Mutiny API for the Vert.x AMQP Client\n\n|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n|Mutiny API for the Vert.x RabbitMQ Client\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:722
msgid "You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:725
msgid "Let's take an example.  Add the following dependency to your application:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:732
#, no-wrap
msgid "<dependency>\n    <groupId>io.smallrye.reactive</groupId>\n    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:736
msgid "It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:740
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:747
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.web.client.WebClientOptions;\nimport io.vertx.mutiny.core.Vertx;\nimport io.vertx.mutiny.ext.web.client.WebClient;\nimport org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:754
#, no-wrap
msgid "import javax.annotation.PostConstruct;\nimport javax.inject.Inject;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:757
#, no-wrap
msgid "@Path(\"/fruit-data\")\npublic class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:760
#, no-wrap
msgid "    @Inject\n    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:762
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:769
#, no-wrap
msgid "    @PostConstruct\n    void initialize() {\n        this.client = WebClient.create(vertx,\n                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n                        .setTrustAll(true));\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:786
#, no-wrap
msgid "    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @Path(\"/{name}\")\n    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n        return client.get(\"/api/fruit/\" + name)\n                .send()\n                .map(resp -> {\n                    if (resp.statusCode() == 200) {\n                        return resp.bodyAsJsonObject();\n                    } else {\n                        return new JsonObject()\n                                .put(\"code\", resp.statusCode())\n                                .put(\"message\", resp.bodyAsString());\n                    }\n                });\n    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:788
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:791
msgid "There are 2 important points:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:793
msgid "The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:794
msgid "The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:796
msgid "The Mutiny version of the Vert.x APIs also offers:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:799
msgid "`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:803
msgid "`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:804
msgid "`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:805
msgid "`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:806
#, no-wrap
msgid "Using RxJava or Reactor APIs"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:809
msgid "Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:811
msgid "RxJava 2 converters are available in the following dependency:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:818
#, no-wrap
msgid "<dependency>\n    <groupId>io.smallrye.reactive</groupId>\n    <artifactId>mutiny-rxjava</artifactId>\n</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:821
msgid "So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:833
#, no-wrap
msgid "import io.smallrye.mutiny.converters.multi.MultiRxConverters;\nimport io.smallrye.mutiny.converters.uni.UniRxConverters;\n// ...\nUni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\nUni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\nUni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\nUni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\nUni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\nUni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:840
#, no-wrap
msgid "Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\nMulti<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\nMulti<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\nMulti<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\nMulti<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\nMulti<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:843
msgid "You can also transform `Unis` and `Multis` into RxJava types:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:860
#, no-wrap
msgid "Completable completable = uni.convert().with(UniRxConverters.toCompletable());\nSingle<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\nSingle<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\nMaybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\nObservable<String> observable = uni.convert().with(UniRxConverters.toObservable());\nFlowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n// ...\nCompletable completable = multi.convert().with(MultiRxConverters.toCompletable());\nSingle<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\nSingle<String> single2 = multi.convert().with(MultiRxConverters\n        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\nMaybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\nObservable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\nFlowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:863
msgid "Project Reactor converters are available in the following dependency:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:870
#, no-wrap
msgid "<dependency>\n    <groupId>io.smallrye.reactive</groupId>\n    <artifactId>mutiny-reactor</artifactId>\n</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:873
msgid "So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:881
#, no-wrap
msgid "import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\nimport io.smallrye.mutiny.converters.uni.UniReactorConverters;\n// ...\nUni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters.fromMono(), mono);\nUni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:884
#, no-wrap
msgid "Multi<String> multiFromMono = Multi.createFrom().converter(MultiReactorConverters.fromMono(), mono);\nMulti<String> multiFromFlux = Multi.createFrom().converter(MultiReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:887
msgid "You can also transform `Unis` and `Multis` into Reactor types:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:892
#, no-wrap
msgid "Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\nFlux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:895
#, no-wrap
msgid "Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\nFlux<String> flux2 = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:897
#, no-wrap
msgid "Using CompletionStages or Publisher API"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:901
msgid "If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier<CompletionStage>`. For example:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:907
#, no-wrap
msgid "CompletableFuture<String> future = Uni\n        // Create from a Completion Stage\n        .createFrom().completionStage(CompletableFuture.supplyAsync(() -> \"hello\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:910
msgid "On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:914
msgid "You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`."
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:915
#, no-wrap
msgid "What's next?"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:920
msgid "This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:922
msgid "link:rest-json#reactive[Using Mutiny with RestEasy]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:923
msgid "link:mailer[Sending email]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:924
msgid "link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:925
msgid "link:reactive-sql-clients[Reactive Database Clients]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:926
msgid "link:vertx[Using Vert.x]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:927
msgid "link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:neo4j#reactive[Using Neo4J]"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:reactive-routes[Using reactive routes]"
msgstr ""
