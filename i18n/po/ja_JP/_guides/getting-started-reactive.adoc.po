# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-29 14:10+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-reactive.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Getting started with Reactive"
msgstr "Quarkus - リアクティブを始める"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:12
#, fuzzy
msgid ""
"Learn how to create a reactive application with Quarkus and explore the "
"different reactive features offered by Quarkus.  This guide covers:"
msgstr ""
"Quarkusを使用してリアクティブアプリケーションを作成する方法と、Quarkusが提供するさまざまなリアクティブ機能について説明します。このガイドでは、以下の内容を説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:14
#, fuzzy
msgid "A quick glance at the Quarkus engine and how it enables reactive"
msgstr "Quarkusエンジンの概要と、それがどのようにリアクティブを可能にしているかを簡単に説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:15
#, fuzzy
msgid ""
"A brief introduction to Mutiny - the reactive programming library used by "
"Quarkus"
msgstr "Mutiny - Quarkusで使用されるリアクティブプログラミングライブラリの簡単な紹介"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:16
#, fuzzy
msgid "Bootstrapping a reactive application"
msgstr "リアクティブなアプリケーションのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:17
#, fuzzy
msgid "Creating a reactive JAX-RS endpoint (asynchronous, streams...)"
msgstr "リアクティブなJAX-RSエンドポイントの作成（非同期、ストリーム..."

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:18
#, fuzzy
msgid "Using reactive database access"
msgstr "リアクティブなデータベースアクセスの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:19
#, fuzzy
msgid "Interacting with other reactive APIs"
msgstr "他のリアクティブ API との相互作用"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:20
#, no-wrap, fuzzy
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:23
#, fuzzy
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下のものが必要です。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:25
#, fuzzy
msgid "less than 15 minutes"
msgstr "15分以内"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:26
#, fuzzy
msgid "an IDE"
msgstr "アイディーイーイー"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:27
#, fuzzy
msgid "JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 8 または 11+ がインストールされ、 `JAVA_HOME` が適切に設定されています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:28
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version} の場合"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:29
#, no-wrap, fuzzy
msgid "Solutions"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:32
#, fuzzy
msgid ""
"We recommend that you follow the instructions from <<bootstrapping-the-"
"project,Bootstrapping project>> and onwards to create the application step "
"by step."
msgstr ""
"link:#bootstrapping-the-"
"project[Bootstrappingプロジェクト]以降の手順に沿って、一歩一歩アプリを作成していくことをお勧めします。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:34
#, fuzzy
msgid "However, you can go right to the completed example."
msgstr "しかし、完成した例にすぐに行くことができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:36
#, fuzzy
msgid ""
"Download an {quickstarts-archive-url}[archive] or clone the git repository:"
msgstr "クイックスタート-アーカイブ-URL}[アーカイブ]をダウンロードするか、git リポジトリをクローンします。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:40
#, no-wrap
msgid "git clone {quickstarts-clone-url}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:43
#, fuzzy
msgid ""
"The solutions are located in the `getting-started-reactive` and `getting-"
"started-reactive-crud` directories."
msgstr ""
"ソリューションは `getting-started-reactive` と `getting-started-reactive-crud` "
"のディレクトリにあります。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:44
#, no-wrap, fuzzy
msgid "The multiple reactive facets of Quarkus"
msgstr "クオークスの複数の反応性ファセット"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:50
#, fuzzy
msgid ""
"Quarkus is reactive.  If you look under the hood, you will find a reactive "
"engine powering your Quarkus application.  This engine is Eclipse Vert.x "
"(https://vertx.io).  Every IO interaction passes through the non-blocking "
"and reactive Vert.x engine."
msgstr ""
"Quarkusはリアクティブです。ボンネットの下を見ると、Quarkusアプリケーションの動力源となっているリアクティブエンジンを見つけることができます。このエンジンはEclipse "
"Vert.x（ https://vertx.io ）です。すべてのIOインタラクションは、ノンブロッキングでリアクティブなVert."
"xエンジンを通過します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:52
#, fuzzy
msgid ""
"image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, "
"50%]"
msgstr ""
"image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:59
#, fuzzy
msgid ""
"Let's take 2 examples to explain how it works.  Imagine an incoming HTTP "
"request.  The (Vert.x) HTTP server receives the request and then routes it "
"to the application.  If the request targets a JAX-RS resource, the routing "
"layer invokes the resource method in a worker thread and writes the response "
"when the data is available.  So far, nothing new or outstanding.  The "
"following picture depicts this behavior."
msgstr ""
"2つの例を挙げて、その仕組みを説明してみましょう。HTTP リクエストが入ってくると想像してください。(Vert.x) HTTP "
"サーバーがリクエストを受け取り、アプリケーションにルーティングします。リクエストが JAX-RS "
"リソースをターゲットにしている場合、ルーティング層はワーカースレッドでリソースメソッドを呼び出し、データが利用可能になるとレスポンスを書き込みます。今のところ、目新しいものも、目立ったものもありません。次の図は、この動作を示しています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:61
#, fuzzy
msgid ""
"image:http-blocking-sequence.png[alt=Behavior when using the imperative "
"routes, 50%]"
msgstr ""
"image:http-blocking-sequence.png[alt=Behavior when using the imperative "
"routes]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:63
#, fuzzy
msgid ""
"But if the HTTP request targets a reactive (non-blocking) route, the routing "
"layer invokes the route on the IO thread giving lots of benefits such as "
"higher concurrency and performance:"
msgstr ""
"しかし、HTTP リクエストがリアクティブ（ノンブロッキング）なルートをターゲットにしている場合、ルーティングレイヤーは IO "
"スレッド上でルートを呼び出し、より高い同時実行性とパフォーマンスなどの多くの利点をもたらします。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:65
#, fuzzy
msgid ""
"image:http-reactive-sequence.png[alt=Behavior when using the reactive "
"routes, 50%]"
msgstr ""
"image:http-reactive-sequence.png[alt=Behavior when using the reactive "
"routes]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:69
#, fuzzy
msgid ""
"As a consequence, many Quarkus components are designed with reactive in "
"mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application "
"services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so "
"on.  But, to fully benefit from this model, the application code should be "
"written in a non-blocking manner.  That’s where having a reactive API is an "
"ultimate weapon."
msgstr ""
"結果として、多くのQuarkusコンポーネントは、データベースアクセス（PostgreSQL、MySQL、Mongoなど）、アプリケーションサービス（メール、テンプレートエンジンなど）、メッセージング（Kafka、AMQPなど）など、リアクティブを念頭に置いて設計されています。しかし、このモデルの恩恵を十分に受けるためには、アプリケーションコードはノンブロッキングで書かれなければなりません。そこで、リアクティブ "
"API を持つことが究極の武器となります。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:71
#, no-wrap, fuzzy
msgid "Mutiny - A reactive programming library"
msgstr "Mutiny - リアクティブプログラミングライブラリ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:75
#, fuzzy
msgid ""
"https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive "
"programming library allowing to express and compose asynchronous actions.  "
"It offers 2 types:"
msgstr ""
"link:https://github.com/smallrye/smallrye-"
"mutiny[Mutiny]は、非同期アクションを表現したり構成したりすることができるリアクティブプログラミングライブラリです。2つのタイプがあります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:77
#, fuzzy
msgid ""
"`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result"
msgstr "`io.smallrye.mutiny.Uni` - 0 または 1 の結果を提供する非同期アクション用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:78
#, fuzzy
msgid ""
"`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams"
msgstr "`io.smallrye.mutiny.Multi` - マルチアイテム（背圧付き）ストリーム用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:81
#, fuzzy
msgid ""
"Both types are lazy and follow a subscription pattern.  The computation only "
"starts once there is an actual need for it (i.e. a subscriber enlists)."
msgstr "どちらのタイプも怠け者で、加入者パターンに従います。計算は、実際に必要とされる場合にのみ開始されます (すなわち、加入者が加入した場合)。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:88
#, no-wrap
msgid ""
"uni.subscribe().with(\n"
"    result -> System.out.println(\"result is \" + result),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:93
#, no-wrap
msgid ""
"multi.subscribe().with(\n"
"    item -> System.out.println(\"Got \" + item),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:99
#, fuzzy
msgid ""
"Both `Uni` and `Multi` expose event-driven APIs: you express what you want "
"to do upon a given event (success, failure, etc.).  These APIs are divided "
"into groups (types of operations) to make it more expressive and avoid "
"having 100s of methods attached to a single class.  The main types of "
"operations are about reacting to failure, completion, manipulating items, "
"extracting, or collecting them.  It provides a smooth coding experience, "
"with a navigable API, and the result does not require too much knowledge "
"around reactive."
msgstr ""
"`Uni` も `Multi` もイベント駆動型の API を公開しています: 与えられたイベント (成功、失敗など) "
"に対して何をしたいかを表現します。これらのAPIはグループ(操作の種類)に分けられており、より表現力を高め、1つのクラスに100個ものメソッドをアタッチすることを避けています。主な操作の種類は、失敗に反応するもの、完了するもの、アイテムを操作するもの、抽出するもの、収集するものなどです。ナビゲーション可能なAPIでスムーズなコーディングを実現し、結果的にリアクティブ周りの知識をあまり必要としないようにしています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:104
#, no-wrap
msgid "httpCall\n"
"    .onFailure().recoverWithItem(\"my fallback\");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:110
#, fuzzy
msgid ""
"You may wonder about Reactive Streams (https://www.reactive-streams.org/).  "
"`Multi` implements Reactive Streams `Publisher`, and so implements the "
"Reactive Streams back-pressure mechanism.  `Uni` does not implement "
"`Publisher` as the subscription to the `Uni` is enough to indicate you are "
"interested in the result.  It is again with the idea of simpler and smoother "
"APIs in mind as the Reactive Streams subscription/request ceremony is more "
"complex."
msgstr ""
"https://www.reactive-streams.org/  `Multi` は Reactive Streams `Publisher` "
"を実装しているので、Reactive Streams の背圧メカニズムを実装しています。 `Uni` "
"へのサブスクリプションは結果に興味があることを示すのに十分なので、 `Uni` は `Publisher` を実装していません。これは、Reactive "
"Streams のサブスクリプション/リクエスト式がより複雑であるため、よりシンプルでスムーズな API のアイデアを念頭に置いたものです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:113
#, fuzzy
msgid ""
"Embracing the unification of reactive and imperative pillars from Quarkus, "
"both `Uni` and `Multi` provide bridges to imperative constructs.  For "
"example, you can transform a `Multi` into an `Iterable` or _await_ the item "
"produced by a `Uni`."
msgstr ""
"Quarkusの反応的支柱と命令的支柱の統合を採用した `Uni` と `Multi` は、両方とも命令的構造への橋渡しをしてくれます。たとえば、 "
"`Multi` を `Iterable` に変換したり、 `Uni`.NET で生成されたアイテムを _待っ_たりすることができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:118
#, no-wrap
msgid ""
"// Block until the result is available\n"
"String result = uni.await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:121
#, no-wrap
msgid ""
"// Transform an asynchronous stream into a blocking iterable\n"
"stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" "
"+ s));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:125
#, fuzzy
msgid ""
"At that point, if you are a RxJava or a Reactor user, you may wonder how you "
"can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows "
"converting `Unis` and `Multis` from and to RX Java and Reactor types:"
msgstr ""
"この時点で、あなたがRxJavaやReactorのユーザーであれば、お馴染みの `Flowable`, `Single`, `Flux`, , "
"`Mono`... Mutinyでは、 `Unis` と `Multis` をRX JavaやReactorの型に変換することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:130
#, no-wrap
msgid ""
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:135
#, fuzzy
msgid ""
"But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  "
"The following snippet shows a usage of the Vert.x Web Client:"
msgstr ""
"しかし、Vert.xはどうでしょうか？Vert.xのAPIはMutiny型を使っても利用できます。以下のスニペットは、Vert.x Web "
"Clientの使い方を示しています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:155
#, no-wrap
msgid ""
"// Use io.vertx.mutiny.ext.web.client.WebClient\n"
"client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\")."
"setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"// ...\n"
"Uni<JsonObject> uni =\n"
"    client.get(\"/api/fruit/\" + name)\n"
"        .send()\n"
"        .onItem().transform(resp -> {\n"
"            if (resp.statusCode() == 200) {\n"
"                return resp.bodyAsJsonObject();\n"
"            } else {\n"
"                return new JsonObject()\n"
"                        .put(\"code\", resp.statusCode())\n"
"                        .put(\"message\", resp.bodyAsString());\n"
"            }\n"
"        });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:158
#, fuzzy
msgid ""
"Last but not least, Mutiny has built-in integration with MicroProfile "
"Context Propagation so you can propagate transactions, traceability data, "
"and so on in your reactive pipeline."
msgstr ""
"最後になりますが、MutinyにはMicroProfile Context "
"Propagationとの統合が組み込まれているので、リアクティブパイプラインでトランザクションやトレーサビリティデータなどを伝搬することができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:160
#, fuzzy
msgid "But enough talking, let's get our hands dirty!"
msgstr "話はもういい、手を汚すんだ！"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:161
#, no-wrap, fuzzy
msgid "Bootstrapping the project"
msgstr "プロジェクトのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:164
#, fuzzy
msgid ""
"The easiest way to create a new Quarkus project is to open a terminal and "
"run the following command:"
msgstr "新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行することです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:166
#, fuzzy
msgid "For Linux and macOS users"
msgstr "LinuxおよびmacOSユーザーの場合"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:176
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive \\\n"
"    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"resteasy-mutiny, resteasy-jackson\"\n"
"cd getting-started-reactive\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:179
#, fuzzy
msgid "For Windows users"
msgstr "Windowsユーザーの方へ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:181
#, fuzzy
msgid "If using cmd, (don't use forward slash `\\`)"
msgstr "cmd を使用する場合は、(前方スラッシュを使用しないでください `\\`)"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:185
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -"
"DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -"
"DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/"
"hello\" -Dextensions=\"resteasy-mutiny,resteasy-jackson\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:188
#, fuzzy
msgid "If using Powershell, wrap `-D` parameters in double quotes"
msgstr "Powershell を使用する場合は、 `-D` のパラメータを二重引用符で囲みます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:192
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-"
"DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" "
"\"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/"
"hello\" \"-Dextensions=resteasy-mutiny,resteasy-jackson\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:195
#, fuzzy
msgid "It generates the following in `./getting-started-reactive`:"
msgstr "`./getting-started-reactive` で以下のように生成されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:197
#, fuzzy
msgid "the Maven structure"
msgstr "メイヴン構造体"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:198
#, fuzzy
msgid ""
"an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/"
"hello`"
msgstr "で公開されている `org.acme.quickstart.ReactiveGreetingResource` リソース `/hello`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:199
#, fuzzy
msgid "an associated unit test"
msgstr "関連ユニットテスト"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:200
#, fuzzy
msgid ""
"a landing page that is accessible on `http://localhost:8080` after starting "
"the application"
msgstr ""
"でアクセス可能なランディングページ `&lt;a href=\"http://localhost:8080\" class="
"\"bare\"&gt;http://localhost:8080&lt;/a&gt;`アプリケーション起動後"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:201
#, fuzzy
msgid ""
"example `Dockerfile` files for both `native` and `jvm` modes in `src/main/"
"docker`"
msgstr "の `native` と `jvm` の両方のモードに対応する `Dockerfile` ファイルの例 `src/main/docker`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:202
#, fuzzy
msgid "the application configuration file"
msgstr "アプリケーション設定ファイル"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:204
#, fuzzy
msgid ""
"The generated `pom.xml` also declares the RESTEasy Mutiny support and "
"RESTEasy Jackson to serialize payloads."
msgstr ""
"生成された `pom.xml` はまた、ペイロードをシリアライズするために RESTEasy Mutiny サポートと RESTEasy Jackson "
"を宣言しています。"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:205
#, no-wrap, fuzzy
msgid "Reactive JAX-RS resources"
msgstr "リアクティブな JAX-RS リソース"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:208
#, fuzzy
msgid ""
"During the project creation, the `src/main/java/org/acme/quickstart/"
"ReactiveGreetingResource.java` file has been created with the following "
"content:"
msgstr ""
"プロジェクト作成時に、 `src/main/java/org/acme/quickstart/ReactiveGreetingResource."
"java` ファイルは以下の内容で作成されています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:212
#, no-wrap
msgid "package org.acme.quickstart;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:217
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:220
#: upstream/_guides/getting-started-reactive.adoc:273
#, no-wrap
msgid "@Path(\"/hello\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:227
#: upstream/_guides/getting-started-reactive.adoc:290
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:230
#, fuzzy
msgid ""
"It's a very simple REST endpoint, returning \"hello\" to requests on \"/"
"hello\"."
msgstr "これは非常にシンプルなRESTエンドポイントで、\"/hello\"上のリクエストに\"hello\"を返します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:232
#, fuzzy
msgid ""
"Let's now create a `ReactiveGreetingService` class with the following "
"content:"
msgstr "それでは、以下の内容の `ReactiveGreetingService` クラスを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:236
#: upstream/_guides/getting-started-reactive.adoc:258
#, no-wrap
msgid "package org.acme.getting.started;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:239
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:242
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:245
#, no-wrap
msgid "@ApplicationScoped\n"
"public class ReactiveGreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:251
#, no-wrap
msgid ""
"    public Uni<String> greeting(String name) {\n"
"        return Uni.createFrom().item(name)\n"
"                .onItem().transform(n -> String.format(\"hello %s\", n));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:254
#, fuzzy
msgid ""
"Then, edit the `ReactiveGreetingResource` class to match the following "
"content:"
msgstr "次に、 `ReactiveGreetingResource` クラスを以下の内容に合わせて編集します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:264
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:270
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:276
#, no-wrap
msgid "    @Inject\n"
"    ReactiveGreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:283
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"/greeting/{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return service.greeting(name);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:294
#, fuzzy
msgid ""
"The `ReactiveGreetingService` class contains a straightforward method "
"producing a `Uni`.  While, in this example, the resulting item is emitted "
"immediately, you can imagine any async API producing a `Uni`. We cover this "
"later in this guide."
msgstr ""
"`ReactiveGreetingService` クラスには、 `Uni` "
"を生成する簡単なメソッドが含まれています。この例では、結果として得られるアイテムがすぐに出力されますが、非同期 API で `Uni` "
"を生成することは想像できます。これについては、このガイドで後ほど説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:296
#, fuzzy
msgid ""
"In order to get Mutiny working properly with JAX-RS resources, make sure the "
"Mutiny support for RESTEasy extension (`io.quarkus:quarkus-resteasy-mutiny`) "
"is present, otherwise add the extension by executing the following command:"
msgstr ""
"JAX-RSリソースでMutinyを正しく動作させるためには、RESTEasy拡張機能のMutinyサポート( `io.quarkus:quarkus-"
"resteasy-mutiny`)が存在することを確認してください。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:301
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n"
"    -Dextensions=\"io.quarkus:quarkus-resteasy-mutiny\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:304
#, fuzzy
msgid "Or add `quarkus-resteasy-mutiny` into your dependencies manually."
msgstr "または、手動で `quarkus-resteasy-mutiny` を依存関係に追加してください。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:311
#, no-wrap
msgid ""
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"    </dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:314
#, fuzzy
msgid "Now, start the application using:"
msgstr "では、使用してアプリケーションを起動します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:318
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:321
#, fuzzy
msgid ""
"Once running, check that you get the expected greeting message by opening "
"http://localhost:8080/hello/greeting/neo."
msgstr ""
"実行したら、 http://localhost:8080/hello/greeting/neo  "
"を開いて、期待通りのグリーティングメッセージが表示されることを確認してください。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:322
#, no-wrap, fuzzy
msgid "Handling streams"
msgstr "ストリームの取り扱い"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:326
#, fuzzy
msgid ""
"So far, we only return an asynchronous result.  In this section, we extend "
"the application with streams conveying multiple items.  These streams could "
"come from Kafka or any other source of data, but to keep things simple, we "
"just generate periodic greeting messages."
msgstr ""
"これまでは、非同期の結果を返すだけでした。このセクションでは、複数のアイテムを伝えるストリームを使ってアプリケーションを拡張します。これらのストリームは "
"Kafka や他のデータソースからのものでも構いませんが、物事をシンプルに保つために、定期的にグリーティングメッセージを生成しています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:328
#, fuzzy
msgid "In the `ReactiveGreetingService`, add the following method:"
msgstr "`ReactiveGreetingService` で、以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:336
#, no-wrap
msgid ""
"public Multi<String> greetings(int count, String name) {\n"
"  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .onItem().transform(n -> String.format(\"hello %s - %d\", name, n))\n"
"        .transform().byTakingFirstItems(count);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:339
#, fuzzy
msgid ""
"It generates a greeting message every second and stops after `count` "
"messages."
msgstr "1秒ごとに挨拶メッセージを生成し、 `count` メッセージの後に停止します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:341
#, fuzzy
msgid "In the `ReactiveGreetingResource` add the following method:"
msgstr "`ReactiveGreetingResource` で、以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:350
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Path(\"/greeting/{count}/{name}\")\n"
"public Multi<String> greetings(@PathParam int count, @PathParam String name) "
"{\n"
"  return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:354
#, fuzzy
msgid ""
"This endpoint streams the items to the client as a JSON Array.  The name and "
"number of messages are parameterized using path parameters."
msgstr ""
"このエンドポイントは、アイテムをJSON配列としてクライアントにストリームします。メッセージの名前と数は、パスパラメータを使用してパラメータ化されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:356
#, fuzzy
msgid "So calling the endpoint produces something like:"
msgstr "そのため、エンドポイントを呼び出すと、次のようなものが生成されます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:361
#, no-wrap
msgid ""
"$ curl http://localhost:8080/hello/greeting/3/neo\n"
"[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:364
#, fuzzy
msgid ""
"We can also generate Server-Sent Event responses by returning a `Multi`:"
msgstr "また、 `Multi` を返すことで Server-Sent Event レスポンスを生成することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:374
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@SseElementType(MediaType.TEXT_PLAIN)\n"
"@Path(\"/stream/{count}/{name}\")\n"
"public Multi<String> greetingsAsStream(@PathParam int count, @PathParam "
"String name) {\n"
"    return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:378
#, fuzzy
msgid ""
"The only difference with the previous snippet is the produced type and the "
"`@SseElementType` annotation indicating the type of each event.  As the "
"`@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to "
"knows the content type of each (nested) event."
msgstr ""
"先ほどのスニペットとの違いは、生成される型と、各イベントの型を示す `@SseElementType` アノテーションだけです。 `@Produces` "
"アノテーションは `SERVER_SENT_EVENTS` を定義しているので、JAX-RS "
"は各（入れ子になった）イベントのコンテンツタイプを知るために必要です。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:380
#, fuzzy
msgid "You can see the result using:"
msgstr "を使って結果を見ることができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:385
#, no-wrap
msgid ""
"$ curl -N http://localhost:8080/hello/stream/5/neo\n"
"data: hello neo - 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:387
#, no-wrap
msgid "data: hello neo - 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:389
#, no-wrap
msgid "data: hello neo - 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:391
#, no-wrap
msgid "data: hello neo - 3\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:393
#, no-wrap
msgid "data: hello neo - 4\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:395
#, no-wrap, fuzzy
msgid "Using Reactive APIs"
msgstr "リアクティブ API の使用"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:397
#, no-wrap, fuzzy
msgid "Using Quarkus reactive APIs"
msgstr "QuarkusのリアクティブAPIを使用する"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:401
#, fuzzy
msgid ""
"Quarkus provides many reactive APIs using the Mutiny model.  In this "
"section, we are going to see how you can use the Reactive PostgreSQL driver "
"to interact with your database in a non-blocking and reactive way."
msgstr ""
"QuarkusはMutinyモデルを使用した多くのリアクティブAPIを提供しています。このセクションでは、リアクティブPostgreSQLドライバを使用して、ノンブロッキングでリアクティブな方法でデータベースと対話する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:403
#, fuzzy
msgid "Create a new project using:"
msgstr "を使用して新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:413
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive-crud \\\n"
"    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-mutiny, resteasy-jackson, reactive-pg-client\"\n"
"cd getting-started-reactive-crud\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:416
#, fuzzy
msgid ""
"This application is interacting with a PostgreSQL database, so you need one:"
msgstr "このアプリケーションはPostgreSQLデータベースと対話しているので、それが必要です。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:423
#, no-wrap
msgid ""
"docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n"
"           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n"
"           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n"
"           -p 5432:5432 postgres:11.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:427
#, fuzzy
msgid ""
"Then, let's configure our datasource.  Open the `src/main/resources/"
"application.properties` and add the following content:"
msgstr ""
"続いて、データソースを設定してみましょう。 `src/main/resources/application.properties` "
"を開き、以下の内容を追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:435
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n"
"myapp.schema.create=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:439
#, fuzzy
msgid ""
"The 3 first lines define the datasource.  The last line is going to be used "
"in the application to indicate whether we insert a few items when the "
"application gets initialized."
msgstr ""
"最初の3行はデータソースを定義しています。最後の行は、アプリケーションが初期化されたときにいくつかの項目を挿入するかどうかを示すためにアプリケーションで使用されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:442
#, fuzzy
msgid ""
"Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` "
"class with the following content:"
msgstr "では、 _エンティティを_作成しましょう。以下の内容で `org.acme.reactive.crud.Fruit` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:446
#: upstream/_guides/getting-started-reactive.adoc:521
#, no-wrap
msgid "package org.acme.reactive.crud;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:453
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import io.vertx.mutiny.sqlclient.Row;\n"
"import io.vertx.mutiny.sqlclient.RowSet;\n"
"import io.vertx.mutiny.sqlclient.Tuple;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:455
#, no-wrap
msgid "import java.util.stream.StreamSupport;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:457
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:459
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:461
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:465
#, no-wrap
msgid "    public Fruit() {\n"
"        // default constructor.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:469
#, no-wrap
msgid "    public Fruit(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:474
#, no-wrap
msgid ""
"    public Fruit(Long id, String name) {\n"
"        this.id = id;\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:482
#, no-wrap
msgid ""
"    public static Multi<Fruit> findAll(PgPool client) {\n"
"        return client.query(\"SELECT id, name FROM fruits ORDER BY name "
"ASC\").execute()\n"
"                // Create a Multi from the set of rows:\n"
"                .onItem().transformToMulti(set -> Multi.createFrom()."
"items(() -> StreamSupport.stream(set.spliterator(), false)))\n"
"                // For each row create a fruit instance\n"
"                .onItem().transform(Fruit::from);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:488
#, no-wrap
msgid ""
"    public static Uni<Fruit> findById(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = "
"$1\").execute(Tuple.of(id))\n"
"                .onItem().transform(RowSet::iterator)\n"
"                .onItem().transform(iterator -> iterator.hasNext() ? "
"from(iterator.next()) : null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:493
#, no-wrap
msgid ""
"    public Uni<Long> save(PgPool client) {\n"
"        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) "
"RETURNING (id)\").execute(Tuple.of(name))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.iterator().next()."
"getLong(\"id\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:498
#, no-wrap
msgid ""
"    public Uni<Boolean> update(PgPool client) {\n"
"        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = "
"$2\").execute(Tuple.of(name, id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:503
#, no-wrap
msgid ""
"    public static Uni<Boolean> delete(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\")."
"execute(Tuple.of(id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:508
#, no-wrap
msgid ""
"    private static Fruit from(Row row) {\n"
"        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:514
#, fuzzy
msgid ""
"This _entity_ contains a few fields and methods to find, update, and delete "
"rows from the database.  These methods return either `Unis` or `Multis` as "
"the produced items are emitted asynchronously when the results have been "
"retrieved.  Notice that the reactive PostgreSQL client already provides "
"`Uni` and `Multi` instances.  So you only transform the results from the "
"database into _business-friendly_ objects."
msgstr ""
"この "
"_エンティティに_は、データベースから行を検索、更新、削除するためのいくつかのフィールドとメソッドが含まれています。これらのメソッドは、結果が取得されると非同期的に生成されるので、 "
"`Unis` または `Multis` のいずれかを返します。反応型PostgreSQLクライアントは既に `Uni` と `Multi` "
"のインスタンスを提供していることに注意してください。つまり、データベースからの結果を _ビジネスに適した_オブジェクトに変換するだけです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:517
#, fuzzy
msgid ""
"Then, let's use this `Fruit` class in the `FruitResource`.  Edit the "
"`FruitResource` class to match the following content:"
msgstr ""
"次に、この `Fruit` クラスを `FruitResource`. `FruitResource` クラスを以下の内容に合わせて編集します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:527
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:542
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.PUT;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.ResponseBuilder;\n"
"import javax.ws.rs.core.Response.Status;\n"
"import java.net.URI;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:545
#, no-wrap
msgid "@Path(\"fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:549
#, no-wrap
msgid ""
"    @Inject\n"
"    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n"
"    boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:552
#, no-wrap
msgid "    @Inject\n"
"    PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:559
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void config() {\n"
"        if (schemaCreate) {\n"
"            initdb();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:569
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL "
"PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) "
"VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) "
"VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) "
"VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) "
"VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:574
#, no-wrap
msgid ""
"    @GET\n"
"    public Multi<Fruit> get() {\n"
"        return Fruit.findAll(client);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:582
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> getSingle(@PathParam Long id) {\n"
"        return Fruit.findById(client, id)\n"
"                .onItem().transform(fruit -> fruit != null ? Response."
"ok(fruit) : Response.status(Status.NOT_FOUND))\n"
"                .onItem().transform(ResponseBuilder::build);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:589
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<Response> create(Fruit fruit) {\n"
"        return fruit.save(client)\n"
"                .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n"
"                .onItem().transform(uri -> Response.created(uri).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:597
#, no-wrap
msgid ""
"    @PUT\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n"
"        return fruit.update(client)\n"
"                .onItem().transform(updated -> updated ? Status.OK : Status."
"NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status)."
"build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:606
#, no-wrap
msgid ""
"    @DELETE\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> delete(@PathParam Long id) {\n"
"        return Fruit.delete(client, id)\n"
"                .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : "
"Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status)."
"build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:609
#, fuzzy
msgid ""
"This resource returns `Uni` and `Multi` instances based on the result "
"produced by the `Fruit` class."
msgstr "このリソースは、 `Fruit` クラスが生成した結果に基づいて `Uni` と `Multi` のインスタンスを返します。"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:610
#, no-wrap, fuzzy
msgid "Using Vert.x clients"
msgstr "Vert.xクライアントの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:614
#, fuzzy
msgid ""
"The previous example uses a _service_ provided by Quarkus.  Also, you can "
"use Vert.x clients directly."
msgstr "先ほどの例では、Quarkusが提供する _サービスを_使用しています。また、Vert.xクライアントを直接使用することもできます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:616
#, fuzzy
msgid ""
"First of all, make sure the `quarkus-vertx` extension is present. If not, "
"activate the extension by executing the following command:"
msgstr ""
"まず、 `quarkus-vertx` の拡張子が存在することを確認してください。存在しない場合は、以下のコマンドを実行して拡張機能を有効にします。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:621
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n"
"    -Dextensions=vertx\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:624
#, fuzzy
msgid "Or add `quarkus-vertx` into your dependencies manually."
msgstr "または、手動で `quarkus-vertx` を依存関係に追加してください。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:631
#, no-wrap
msgid ""
"<dependency>\n"
"\t<groupId>io.quarkus</groupId>\n"
"\t<artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:635
#, fuzzy
msgid ""
"There is a Mutiny version of the Vert.x APIs.  This API is divided into "
"several artifacts you can import independently:"
msgstr "Vert.x APIのMutinyバージョンがあります。このAPIは独立してインポートできるいくつかのアーティファクトに分かれています。"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:668
#, no-wrap, fuzzy
msgid ""
"|groupId:artifactId | Description\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n"
"|Mutiny API for Vert.x Core\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n"
"|Mutiny API for the Vert.x Mail Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n"
"|Mutiny API for the Vert.x Web Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n"
"|Mutiny API for the Vert.x Mongo Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n"
"|Mutiny API for the Vert.x Redis Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n"
"|Mutiny API for the Vert.x Cassandra Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n"
"|Mutiny API for the Vert.x Consul Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n"
"|Mutiny API for the Vert.x Kafka Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n"
"|Mutiny API for the Vert.x AMQP Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n"
"|Mutiny API for the Vert.x RabbitMQ Client\n"
msgstr "|groupId:artifactId |説明"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:671
#, fuzzy
msgid ""
"You can also check the available APIs on http://smallrye.io/smallrye-"
"reactive-utils/apidocs/."
msgstr ""
"また、 http://smallrye.io/smallrye-reactive-utils/apidocs/  で利用可能な API を確認できます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:674
#, fuzzy
msgid ""
"Let's take an example.  Add the following dependency to your application:"
msgstr "例を挙げてみましょう。以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:681
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:685
#, fuzzy
msgid ""
"It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the "
"web client as follows:"
msgstr "Vert.x Web ClientのMutiny APIを提供します。すると、以下のようにWebクライアントを利用することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:689
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:696
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:703
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:706
#, no-wrap
msgid "@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:709
#, no-wrap
msgid "    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:711
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:718
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\")."
"setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:735
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .map(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:737
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:740
#, fuzzy
msgid "There are 2 important points:"
msgstr "重要なポイントは2つあります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:742
#, fuzzy
msgid ""
"The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which "
"is the Mutiny variant of Vert.x;"
msgstr ""
"インジェクションされた Vert.x インスタンスは `io.vertx.mutiny.core.Vertx` タイプで、これは Vert.x の "
"Mutiny バリアントです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:743
#, fuzzy
msgid ""
"The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`."
msgstr "Web クライアントは `io.vertx.mutiny.ext.web.client.WebClient` から作成されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:745
#, fuzzy
msgid "The Mutiny version of the Vert.x APIs also offers:"
msgstr "Vert.x APIのMutinyバージョンでも提供されています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:748
#, fuzzy
msgid ""
"`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the "
"caller thread is blocked until the result is available.  Be aware not to "
"block the event loop / IO thread that way."
msgstr ""
"`sendAndAwait`. `andAwait` のような `andAwait` "
"メソッドは、結果が得られるまで呼び出し元のスレッドがブロックされていることを示しています。そのような方法でイベントループ/"
"IOスレッドをブロックしないように注意してください。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:752
#, fuzzy
msgid ""
"`andForget` methods such as `writeAndForget`. `andForget` is available for "
"method returning a `Uni`.  `andForget` indicates that you don't need the "
"resulting `Uni` indicating the success or failure of the operation.  "
"However, remember that if you don't subscribe, the operation would not be "
"triggered.  `andForget` manages this for you and manage the subscription."
msgstr ""
"`andForget` `writeAndForget` のような を返すメソッドには . は、操作の成否を示す結果の "
"を必要としないことを示しています。しかし、サブスクライブしないと操作が発動しないことを覚えておいてください。 "
"はこれを管理して、サブスクライブを管理しています。 `andForget` `Uni` `andForget` `Uni` `andForget`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:753
#, fuzzy
msgid ""
"`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`"
msgstr "`toMulti` メソッドで Vert.x `ReadStream` を `Multi`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:754
#, fuzzy
msgid ""
"`toBlockingIterable` / `toBlockingStream` methods allowing to transform a "
"Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`"
msgstr ""
"`toBlockingIterable` / `toBlockingStream` メソッドは、Vert.x `ReadStream` "
"をブロッキング可能なイテレータブルまたはブロッキング可能なイテレータブルに変換することができます。 `java.util.Stream`"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:755
#, no-wrap, fuzzy
msgid "Using RxJava or Reactor APIs"
msgstr "RxJavaやReactor APIを使う"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:758
#, fuzzy
msgid ""
"Mutiny provides utilities to convert RxJava 2 and Project Reactor types to "
"`Uni` and `Multi`."
msgstr ""
"Mutiny は RxJava 2 と Project Reactor の型を `Uni` と `Multi` に変換するユーティリティを提供します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:760
#, fuzzy
msgid "RxJava 2 converters are available in the following dependency:"
msgstr "RxJava 2のコンバータは以下の依存関係にあります。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:767
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-rxjava</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:770
#, fuzzy
msgid ""
"So if you have an API returning RxJava 2 types (`Completable`, `Single`, "
"`Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as "
"follows:"
msgstr ""
"そこで、RxJava 2 の型を返す API ( `Completable`, `Single`, `Maybe`, `Observable`, "
"`Flowable`) を持っている場合は、以下のように `Unis` と `Multis` を作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:782
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniRxConverters;\n"
"// ...\n"
"Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters."
"fromCompletable(), completable);\n"
"Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters."
"fromSingle(), single);\n"
"Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters."
"fromMaybe(), maybe);\n"
"Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters."
"fromMaybe(), emptyMaybe);\n"
"Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters."
"fromObservable(), observable);\n"
"Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters."
"fromFlowable(), flowable);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:789
#, no-wrap
msgid ""
"Multi<Void> multiFromCompletable = Multi.createFrom()."
"converter(MultiRxConverters.fromCompletable(), completable);\n"
"Multi<String> multiFromSingle = Multi.createFrom()."
"converter(MultiRxConverters.fromSingle(), single);\n"
"Multi<String> multiFromMaybe = Multi.createFrom()."
"converter(MultiRxConverters.fromMaybe(), maybe);\n"
"Multi<String> multiFromEmptyMaybe = Multi.createFrom()."
"converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n"
"Multi<String> multiFromObservable = Multi.createFrom()."
"converter(MultiRxConverters.fromObservable(), observable);\n"
"Multi<String> multiFromFlowable = Multi.createFrom()."
"converter(MultiRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:792
#, fuzzy
msgid "You can also transform `Unis` and `Multis` into RxJava types:"
msgstr "`Unis` と `Multis` を RxJava 型に変換することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:809
#, no-wrap
msgid ""
"Completable completable = uni.convert().with(UniRxConverters."
"toCompletable());\n"
"Single<Optional<String>> single = uni.convert().with(UniRxConverters."
"toSingle());\n"
"Single<String> single2 = uni.convert().with(UniRxConverters.toSingle()."
"failOnNull());\n"
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Observable<String> observable = uni.convert().with(UniRxConverters."
"toObservable());\n"
"Flowable<String> flowable = uni.convert().with(UniRxConverters."
"toFlowable());\n"
"// ...\n"
"Completable completable = multi.convert().with(MultiRxConverters."
"toCompletable());\n"
"Single<Optional<String>> single = multi.convert().with(MultiRxConverters."
"toSingle());\n"
"Single<String> single2 = multi.convert().with(MultiRxConverters\n"
"        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n"
"Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n"
"Observable<String> observable = multi.convert().with(MultiRxConverters."
"toObservable());\n"
"Flowable<String> flowable = multi.convert().with(MultiRxConverters."
"toFlowable());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:812
#, fuzzy
msgid "Project Reactor converters are available in the following dependency:"
msgstr "Project Reactorコンバータは、以下の依存関係で利用できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:819
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-reactor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:822
#, fuzzy
msgid ""
"So if you have an API returning Reactor types (`Mono`, `Flux`), you can "
"create `Unis` and `Multis` as follows:"
msgstr ""
"そこで、Reactorの型を返すAPI( `Mono`, `Flux`)を持っている場合は、以下のように `Unis` と `Multis` "
"を作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:830
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n"
"// ...\n"
"Uni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters."
"fromMono(), mono);\n"
"Uni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters."
"fromFlux(), flux);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:833
#, no-wrap
msgid ""
"Multi<String> multiFromMono = Multi.createFrom()."
"converter(MultiReactorConverters.fromMono(), mono);\n"
"Multi<String> multiFromFlux = Multi.createFrom()."
"converter(MultiReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:836
#, fuzzy
msgid "You can also transform `Unis` and `Multis` into Reactor types:"
msgstr "また、 `Unis` と `Multis` を Reactor タイプに変換することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:841
#, no-wrap
msgid ""
"Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\n"
"Flux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:844
#, no-wrap
msgid ""
"Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\n"
"Flux<String> flux2 = multi.convert().with(MultiReactorConverters."
"toFlux());\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:846
#, no-wrap, fuzzy
msgid "Using CompletionStages or Publisher API"
msgstr "CompletionStagesまたはPublisher APIを使用する"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:850
#, fuzzy
msgid ""
"If you are facing an API using `CompletionStage`, `CompletableFuture`, or "
"`Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` "
"can be created from a `CompletionStage` or from a "
"`Supplier<CompletionStage>`. For example:"
msgstr ""
"`CompletionStage`, `CompletableFuture`, `Publisher` を使った API "
"に直面している場合、前後に変換することができます。まず、 `Uni` も `Multi` も `CompletionStage` から作成することも、 "
"`Supplier&amp;lt;CompletionStage&amp;gt;` から作成することもできます。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:856
#, no-wrap
msgid ""
"CompletableFuture<String> future = Uni\n"
"        // Create from a Completion Stage\n"
"        .createFrom().completionStage(CompletableFuture.supplyAsync(() -> "
"\"hello\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:859
#, fuzzy
msgid ""
"On `Uni`, you can also produce a `CompletionStage` using "
"`subscribeAsCompletionStage()` that produces a `CompletionStage` that would "
"get the item or failure emitted by the `Uni`."
msgstr ""
"`Uni` 上で、あなたはまた、 `subscribeAsCompletionStage()` を使用して `CompletionStage` "
"を生成することができます `Uni` によって放出されたアイテムまたは障害を取得するだろう `CompletionStage` を生成します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:863
#, fuzzy
msgid ""
"You can also create `Unis` and `Multis` from instances of `Publisher` using "
"`createFrom().publisher(Publisher)`.  You can transform a `Uni` into a "
"`Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`."
msgstr ""
"`createFrom().publisher(Publisher)` を使って `Unis` と `Multis` を `Publisher` "
"のインスタンスから作成することもできます。 `Uni` を `toMulti` を使って `Publisher` に変換することもできます。実際、 "
"`Multi` は `Publisher` を実装しています。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:864
#, no-wrap, fuzzy
msgid "What's next?"
msgstr "次は何をするの？"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:869
#, fuzzy
msgid ""
"This guide is an introduction to reactive in Quarkus.  There are plenty of "
"Quarkus features that are already reactive.  The following list gives you a "
"few examples:"
msgstr ""
"このガイドでは、Quarkusでのリアクティブについて紹介します。Quarkusの機能の中には、すでにリアクティブになっているものがたくさんあります。以下のリストでは、いくつかの例を紹介します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:871
#, fuzzy
msgid "link:rest-json#reactive[Using Mutiny with RestEasy]"
msgstr "link:rest-json#reactive[RestEasyでMutinyを使用する]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:872
#, fuzzy
msgid "link:mailer[Sending email]"
msgstr "link:mailer[メール送信]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:873
#, fuzzy
msgid ""
"link:mongodb#reactive[Using MongoDB] and link:mongodb-"
"panache#reactive[MongoDB with Panache]"
msgstr ""
"link:mongodb#reactive[MongoDB]と link:mongodb-"
"panache#reactive[MongoDBをPanacheで] link:mongodb#reactive[使う]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:874
#, fuzzy
msgid "link:reactive-sql-clients[Reactive Database Clients]"
msgstr "link:reactive-sql-clients[リアクティブデータベースクライアント]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:875
#, fuzzy
msgid "link:vertx[Using Vert.x]"
msgstr "link:vertx[Vert.xの使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:876
#, fuzzy
msgid ""
"link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"
msgstr "link:kafka[Kafkaとの]インタラクションと link:amqp[AMQPとのインタラクション]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:877
#, fuzzy
msgid "link:neo4j#reactive[Using Neo4J]"
msgstr "link:neo4j#reactive[Neo4Jの使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:877
#, fuzzy
msgid "link:reactive-routes[Using reactive routes]"
msgstr "link:reactive-routes[リアクティブルートの使用]"
