# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid   ""
msgstr  "Project-Id-Version: PACKAGE VERSION\n"
        "POT-Creation-Date: 2021-02-04 15:41+0000\n"
        "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
        "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
        "Language-Team: LANGUAGE <LL@li.org>\n"
        "Language: \n"
        "MIME-Version: 1.0\n"
        "Content-Type: text/plain; charset=UTF-8\n"
        "Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, no-wrap
msgid   "Quarkus - Using Apache Kafka with Reactive Messaging"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:11
msgid   "This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka."
msgstr  "このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してApache Kafkaと対話する方法を説明します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:12
#, no-wrap
msgid   "Prerequisites"
msgstr  "前提条件"

#. type: Plain text
#: upstream/_guides/kafka.adoc:15
msgid   "To complete this guide, you need:"
msgstr  "このガイドを完成させるには、以下が必要です："

#. type: Plain text
#: upstream/_guides/kafka.adoc:17
msgid   "less than 15 minutes"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:18
msgid   "an IDE"
msgstr  "IDE"

#. type: Plain text
#: upstream/_guides/kafka.adoc:19
msgid   "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr  "JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/kafka.adoc:20
msgid   "Apache Maven {maven-version}"
msgstr  "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/kafka.adoc:21
msgid   "A running Kafka cluster, or Docker Compose to start a development cluster"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:22
msgid   "GraalVM installed if you want to run in native mode."
msgstr  ""

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:23 upstream/_guides/kafka.adoc:31
#, no-wrap
msgid   "Architecture"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:30
msgid   "In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events."
msgstr  ""

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:31
#, no-wrap
msgid   "kafka-guide-architecture.png"
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:33
#, no-wrap
msgid   "Solution"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:37
msgid   "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr  "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:39
msgid   "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr  "Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:41
msgid   "The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory]."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:42
#, no-wrap
msgid   "Creating the Maven Project"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:45
msgid   "First, we need a new project. Create a new project with the following command:"
msgstr  "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:55
#, no-wrap
msgid   "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
        "    -DprojectGroupId=org.acme \\\n"
        "    -DprojectArtifactId=kafka-quickstart \\\n"
        "    -DclassName=\"org.acme.kafka.PriceResource\" \\\n"
        "    -Dpath=\"/prices\" \\\n"
        "    -Dextensions=\"resteasy,smallrye-reactive-messaging-kafka\"\n"
        "cd kafka-quickstart\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:58
msgid   "This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:61
msgid   "If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:65
#, no-wrap
msgid   "./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:68
msgid   "This will add the following to your `pom.xml`:"
msgstr  "これにより、 `pom.xml` に以下が追加されます："

#. type: delimited block -
#: upstream/_guides/kafka.adoc:75
#, no-wrap
msgid   "<dependency>\n"
        "    <groupId>io.quarkus</groupId>\n"
        "    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
        "</dependency>\n"
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:77
#, no-wrap
msgid   "Starting Kafka"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:81
msgid   "Then, we need a Kafka cluster.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:85
#, no-wrap
msgid   "version: '2'\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:87
#, no-wrap
msgid   "services:\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:98
#, no-wrap
msgid   "  zookeeper:\n"
        "    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
        "    command: [\n"
        "      \"sh\", \"-c\",\n"
        "      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
        "    ]\n"
        "    ports:\n"
        "      - \"2181:2181\"\n"
        "    environment:\n"
        "      LOG_DIR: /tmp/logs\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:114
#, no-wrap
msgid   "  kafka:\n"
        "    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
        "    command: [\n"
        "      \"sh\", \"-c\",\n"
        "      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
        "    ]\n"
        "    depends_on:\n"
        "      - zookeeper\n"
        "    ports:\n"
        "      - \"9092:9092\"\n"
        "    environment:\n"
        "      LOG_DIR: \"/tmp/logs\"\n"
        "      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
        "      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
        "      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:117
msgid   "Once created, run `docker-compose up`."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:119
msgid   "This is a development cluster, do not use in production."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:120
#, no-wrap
msgid   "The price generator"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:123
msgid   "Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:127 upstream/_guides/kafka.adoc:168
#: upstream/_guides/kafka.adoc:211
#, no-wrap
msgid   "package org.acme.kafka;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:130
#, no-wrap
msgid   "import java.time.Duration;\n"
        "import java.util.Random;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:132 upstream/_guides/kafka.adoc:175
#: upstream/_guides/kafka.adoc:428
#, no-wrap
msgid   "import javax.enterprise.context.ApplicationScoped;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:135
#, no-wrap
msgid   "import io.smallrye.mutiny.Multi;\n"
        "import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:142
#, no-wrap
msgid   "/**\n"
        " * A bean producing random prices every 5 seconds.\n"
        " * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.\n"
        " */\n"
        "@ApplicationScoped\n"
        "public class PriceGenerator {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:144
#, no-wrap
msgid   "    private Random random = new Random();\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:151
#, no-wrap
msgid   "    @Outgoing(\"generated-price\")                        // <1>\n"
        "    public Multi<Integer> generate() {                  // <2>\n"
        "        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
        "                .onOverflow().drop()\n"
        "                .map(tick -> random.nextInt(100));\n"
        "    }\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:153 upstream/_guides/kafka.adoc:194
#: upstream/_guides/kafka.adoc:447 upstream/_guides/kafka.adoc:617
#: upstream/_guides/kafka.adoc:714
#, no-wrap
msgid   "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:155
msgid   "Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:156
msgid   "The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:159
msgid   "The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:160
#, no-wrap
msgid   "The price converter"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:164
msgid   "The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:173
#, no-wrap
msgid   "import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
        "import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
        "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
        "import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:182
#, no-wrap
msgid   "/**\n"
        " * A bean consuming data from the \"prices\" Kafka topic and applying some conversion.\n"
        " * The result is pushed to the \"my-data-stream\" stream which is an in-memory stream.\n"
        " */\n"
        "@ApplicationScoped\n"
        "public class PriceConverter {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:184 upstream/_guides/kafka.adoc:437
#, no-wrap
msgid   "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:192
#, no-wrap
msgid   "    @Incoming(\"prices\")                                     // <1>\n"
        "    @Outgoing(\"my-data-stream\")                             // <2>\n"
        "    @Broadcast                                              // <3>\n"
        "    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // <4>\n"
        "    public double process(int priceInUsd) {\n"
        "        return priceInUsd * CONVERSION_RATE;\n"
        "    }\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:196
msgid   "Indicates that the method consumes the items from the `prices` topic"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:197
msgid   "Indicates that the objects returned by the method are sent to the `my-data-stream` stream"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:198
msgid   "Indicates that the item are dispatched to all _subscribers_"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:199
msgid   "Make sure to acknowledge the incoming message"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:202
msgid   "The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:203
#, no-wrap
msgid   "The price resource"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:207
msgid   "Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:214 upstream/_guides/kafka.adoc:563
#, no-wrap
msgid   "import io.smallrye.reactive.messaging.annotations.Channel;\n"
        "import org.reactivestreams.Publisher;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:221 upstream/_guides/kafka.adoc:570
#, no-wrap
msgid   "import javax.inject.Inject;\n"
        "import javax.ws.rs.GET;\n"
        "import javax.ws.rs.Path;\n"
        "import javax.ws.rs.Produces;\n"
        "import javax.ws.rs.core.MediaType;\n"
        "import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:227
#, no-wrap
msgid   "/**\n"
        " * A simple resource retrieving the in-memory \"my-data-stream\" and sending the items as server-sent events.\n"
        " */\n"
        "@Path(\"/prices\")\n"
        "public class PriceResource {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:230
#, no-wrap
msgid   "    @Inject\n"
        "    @Channel(\"my-data-stream\") Publisher<Double> prices; // <1>\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:239
#, no-wrap
msgid   "    @GET\n"
        "    @Path(\"/stream\")\n"
        "    @Produces(MediaType.SERVER_SENT_EVENTS) // <2>\n"
        "    @SseElementType(\"text/plain\") // <3>\n"
        "    public Publisher<Double> stream() { // <4>\n"
        "        return prices;\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:241
msgid   "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:242
msgid   "Indicates that the content is sent using `Server Sent Events`"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:243
msgid   "Indicates that the data contained within the server sent events is of type `text/plain`"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:244
msgid   "Returns the stream (_Reactive Stream_)"
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:245
#, no-wrap
msgid   "Configuring the Kafka connector"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:249
msgid   "We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:251
msgid   "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:253
msgid   "The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:255
msgid   "`generated-price` -> sink in which we write the prices"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:256
msgid   "`prices` -> source in which we read the prices"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:261
#, no-wrap
msgid   "# Configure the SmallRye Kafka connector\n"
        "kafka.bootstrap.servers=localhost:9092\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:266
#, no-wrap
msgid   "# Configure the Kafka sink (we write to it)\n"
        "mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
        "mp.messaging.outgoing.generated-price.topic=prices\n"
        "mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:270
#, no-wrap
msgid   "# Configure the Kafka source (we read from it)\n"
        "mp.messaging.incoming.prices.connector=smallrye-kafka\n"
        "mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:273
msgid   "More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:275
msgid   "What about `my-data-stream`? This is an in-memory stream, not connected to a message broker."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:276
#, no-wrap
msgid   "The HTML page"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:279
msgid   "Final touch, the HTML page reading the converted prices using SSE."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:281
msgid   "Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:289
#, no-wrap
msgid   "<!DOCTYPE html>\n"
        "<html lang=\"en\">\n"
        "<head>\n"
        "    <meta charset=\"UTF-8\">\n"
        "    <title>Prices</title>\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:297
#, no-wrap
msgid   "    <link rel=\"stylesheet\" type=\"text/css\"\n"
        "          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css\">\n"
        "    <link rel=\"stylesheet\" type=\"text/css\"\n"
        "          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css\">\n"
        "</head>\n"
        "<body>\n"
        "<div class=\"container\">\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:312
#, no-wrap
msgid   "    <h2>Last price</h2>\n"
        "    <div class=\"row\">\n"
        "    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/A</span>&nbsp;&euro;</strong>.</p>\n"
        "    </div>\n"
        "</div>\n"
        "</body>\n"
        "<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
        "<script>\n"
        "    var source = new EventSource(\"/prices/stream\");\n"
        "    source.onmessage = function (event) {\n"
        "        document.getElementById(\"content\").innerHTML = event.data;\n"
        "    };\n"
        "</script>\n"
        "</html>\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:315
msgid   "Nothing spectacular here. On each received price, it updates the page."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:316
#, no-wrap
msgid   "Get it running"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:320
msgid   "If you followed the instructions, you should have Kafka running.  Then, you just need to run the application using:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:324
#, no-wrap
msgid   "./mvnw quarkus:dev\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:327
msgid   "Open `http://localhost:8080/prices.html` in your browser."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:329
msgid   "If you started the Kafka broker with docker compose, stop it using `CTRL+C` followed by `docker-compose down`."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:330
#, no-wrap
msgid   "Running Native"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:333
msgid   "You can build the native executable with:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:337
#, no-wrap
msgid   "./mvnw package -Pnative\n"
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:339
#, no-wrap
msgid   "Imperative usage"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:342
msgid   "Sometimes, you need to have an imperative way of sending messages."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:345
msgid   "For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Output` because your method has parameters."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:347
msgid   "For this, you can use an `Emitter`."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:352
#, no-wrap
msgid   "import org.eclipse.microprofile.reactive.messaging.Channel;\n"
        "import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:358
#, no-wrap
msgid   "import javax.inject.Inject;\n"
        "import javax.ws.rs.POST;\n"
        "import javax.ws.rs.Path;\n"
        "import javax.ws.rs.Consumes;\n"
        "import javax.ws.rs.core.MediaType;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:361
#, no-wrap
msgid   "@Path(\"/prices\")\n"
        "public class PriceResource {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:363
#, no-wrap
msgid   "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:370
#, no-wrap
msgid   "    @POST\n"
        "    @Consumes(MediaType.TEXT_PLAIN)\n"
        "    public void addPrice(Double price) {\n"
        "        priceEmitter.send(price);\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:374
msgid   "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy."
msgstr  ""

#. type: Block title
#: upstream/_guides/kafka.adoc:376
#, no-wrap
msgid   "Deprecation"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:379
msgid   "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:381
msgid   "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:382
msgid   "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:383
msgid   "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:385
msgid   "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:387
#, no-wrap
msgid   "Kafka Health Check"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:391
msgid   "If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka` can add a readiness health check to validate the connection to the broker. This is disabled by default."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:393
msgid   "If enabled, when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:395
msgid   "This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:396
#, no-wrap
msgid   "JSON serialization"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:399
msgid   "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:401
msgid   "Imagine we have a `Fruit` pojo as follows:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:405
#, no-wrap
msgid   "public class Fruit {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:408
#, no-wrap
msgid   "    public String name;\n"
        "    public int price;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:411
#, no-wrap
msgid   "    public Fruit() {\n"
        "    }\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:417
#, no-wrap
msgid   "    public Fruit(String name, int price) {\n"
        "        this.name = name;\n"
        "        this.price = price;\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:420
msgid   "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:426
#, no-wrap
msgid   "import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
        "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
        "import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:435
#, no-wrap
msgid   "/**\n"
        "* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n"
        "* The result is pushed to the \"fruit-out\" stream.\n"
        "*/\n"
        "@ApplicationScoped\n"
        "public class FruitProcessor {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:445
#, no-wrap
msgid   "    @Incoming(\"fruit-in\")\n"
        "    @Outgoing(\"fruit-out\")\n"
        "    @Broadcast\n"
        "    public Fruit process(Fruit fruit) {\n"
        "        fruit.price = fruit.price * CONVERSION_RATE;\n"
        "        return fruit;\n"
        "    }\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:450
msgid   "To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:452
msgid   "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr  ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:453
#, no-wrap
msgid   "Serializing via Jackson"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:456
msgid   "First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed)."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:463
#, no-wrap
msgid   "<dependency>\n"
        "    <groupId>io.quarkus</groupId>\n"
        "    <artifactId>quarkus-jackson</artifactId>\n"
        "</dependency>\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:467
msgid   "There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson, but the corresponding deserializer is generic, so it needs to be subclassed."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:469
msgid   "So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:473
#, no-wrap
msgid   "package com.acme.fruit.jackson;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:475
#, no-wrap
msgid   "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:482
#, no-wrap
msgid   "public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
        "    public FruitDeserializer(){\n"
        "        // pass the class to the parent.\n"
        "        super(Fruit.class);\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:485
msgid   "Finally, configure your streams to use the Jackson serializer and deserializer."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:492
#, no-wrap
msgid   "# Configure the Kafka source (we read from it)\n"
        "mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
        "mp.messaging.incoming.fruit-in.topic=fruit-in\n"
        "mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:497
#, no-wrap
msgid   "# Configure the Kafka sink (we write to it)\n"
        "mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
        "mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
        "mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:500
msgid   "Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo."
msgstr  ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:501
#, no-wrap
msgid   "Serializing via JSON-B"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:504
msgid   "First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed)."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:511
#, no-wrap
msgid   "<dependency>\n"
        "    <groupId>io.quarkus</groupId>\n"
        "    <artifactId>quarkus-jsonb</artifactId>\n"
        "</dependency>\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:515
msgid   "There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B, but the corresponding deserializer is generic, so it needs to be subclassed."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:517
msgid   "So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:521
#, no-wrap
msgid   "package com.acme.fruit.jsonb;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:523
#, no-wrap
msgid   "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:530
#, no-wrap
msgid   "public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
        "    public FruitDeserializer(){\n"
        "        // pass the class to the parent.\n"
        "        super(Fruit.class);\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:534
msgid   "If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:536
msgid   "Finally, configure your streams to use the JSON-B serializer and deserializer."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:543
#, no-wrap
msgid   "# Configure the Kafka source (we read from it)\n"
        "mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
        "mp.messaging.incoming.fruit-in.topic=fruit-in\n"
        "mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:548
#, no-wrap
msgid   "# Configure the Kafka sink (we write to it)\n"
        "mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
        "mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
        "mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:551
msgid   "Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo."
msgstr  ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:552
#, no-wrap
msgid   "Sending JSON Server-Sent Events (SSE)"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:556
msgid   "If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:558
msgid   "The following example shows how to use SSE from a Kafka topic source."
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:573
#, no-wrap
msgid   "@Path(\"/fruits\")\n"
        "public class FruitResource {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:576
#, no-wrap
msgid   "    @Inject\n"
        "    @Channel(\"fruit-out\") Publisher<Fruit> fruits;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:585
#, no-wrap
msgid   "    @GET\n"
        "    @Path(\"/stream\")\n"
        "    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
        "    @SseElementType(MediaType.APPLICATION_JSON)\n"
        "    public Publisher<Fruit> stream() {\n"
        "        return fruits;\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:587
#, no-wrap
msgid   "Blocking processing"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:591
msgid   "You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:593
msgid   "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:597
#, no-wrap
msgid   "package org.acme.panache;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:600
#, no-wrap
msgid   "import io.smallrye.reactive.messaging.annotations.Blocking;\n"
        "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:603
#, no-wrap
msgid   "import javax.enterprise.context.ApplicationScoped;\n"
        "import javax.transaction.Transactional;\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:606
#, no-wrap
msgid   "@ApplicationScoped\n"
        "public class PriceStorage {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:615
#, no-wrap
msgid   "    @Incoming(\"prices\")\n"
        "    @Blocking\n"
        "    @Transactional\n"
        "    public void store(int priceInUsd) {\n"
        "        Price price = new Price();\n"
        "        price.value = priceInUsd;\n"
        "        price.persist();\n"
        "    }\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:620
msgid   "The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:624
msgid   "There are 2 `@Blocking` annotations:"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:626
msgid   "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:627
msgid   "`io.smallrye.common.annotation.Blocking`"
msgstr  ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:632
msgid   "They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:634
#, no-wrap
msgid   "Testing a Kafka application"
msgstr  ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:636
#, no-wrap
msgid   "Testing without a broker"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:640
msgid   "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:642
msgid   "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:644
msgid   "First, add the following dependency to your application:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:652
#, no-wrap
msgid   "<dependency>\n"
        "    <groupId>io.smallrye.reactive</groupId>\n"
        "    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
        "    <scope>test</scope>\n"
        "</dependency>\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:655
msgid   "Then, create a Quarkus Test Resource as follows:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:659
#, no-wrap
msgid   "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:669
#, no-wrap
msgid   "    @Override\n"
        "    public Map<String, String> start() {\n"
        "        Map<String, String> env = new HashMap<>();\n"
        "        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");  // <1>\n"
        "        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"queue\");   // <2>\n"
        "        env.putAll(props1);\n"
        "        env.putAll(props2);\n"
        "        return env;  // <3>\n"
        "    }\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:675
#, no-wrap
msgid   "    @Override\n"
        "    public void stop() {\n"
        "        InMemoryConnector.clear();  // <4>\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:677
msgid   "Switch the incoming channel \"orders\" (expecting messages from Kafka) to in-memory."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:678
msgid   "Switch the outgoing channel \"queue\" (writing messages to Kafka) to in-memory."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:679
msgid   "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:680
msgid   "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:682
msgid   "Create a Quarkus Test using the test resource created above:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:688
#, no-wrap
msgid   "@QuarkusTest\n"
        "@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
        "class BaristaTest {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:691
#, no-wrap
msgid   "    @Inject @Any\n"
        "    InMemoryConnector connector; // <1>\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:696
#, no-wrap
msgid   "    @Test\n"
        "    void testProcessOrder() {\n"
        "        InMemorySource<Order> orders = connector.source(\"orders\"); // <2>\n"
        "        InMemorySink<Beverage> queue = connector.sink(\"queue\");    // <3>\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:701
#, no-wrap
msgid   "        Order order = new Order();\n"
        "        order.setProduct(\"coffee\");\n"
        "        order.setName(\"Coffee lover\");\n"
        "        order.setOrderId(\"1234\");\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:703
#, no-wrap
msgid   "        orders.send(order);  // <4>\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:705
#, no-wrap
msgid   "        await().<List<? extends Message<Beverage>>>until(queue::received, t -> t.size() == 1); // <5>\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:712
#, no-wrap
msgid   "        Beverage queuedBeverage = queue.received().get(0).getPayload();\n"
        "        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
        "        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
        "        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
        "        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
        "    }\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:716
msgid   "Inject the in-memory connector in your test class."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:717
msgid   "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:718
msgid   "Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:719
msgid   "Use the `send` method to send a message to the `orders` channel. So, the application will process this message."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:720
msgid   "Use the `received` method to check the messages produced by the application."
msgstr  ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:721
#, no-wrap
msgid   "Starting Kafka in a test resource"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:725
msgid   "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:729
#, no-wrap
msgid   "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:731
#, no-wrap
msgid   "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:737
#, no-wrap
msgid   "    @Override\n"
        "    public Map<String, String> start() {\n"
        "        kafka.start();\n"
        "        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
        "    }\n"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:743
#, no-wrap
msgid   "    @Override\n"
        "    public void stop() {\n"
        "        kafka.close();\n"
        "    }\n"
        "}\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:745
msgid   "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:746
#, no-wrap
msgid   "Authenticating with OAuth"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:750
msgid   "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:757
#, no-wrap
msgid   "<dependency>\n"
        "    <groupId>io.strimzi</groupId>\n"
        "    <artifactId>kafka-oauth-client</artifactId>\n"
        "</dependency>\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:761
msgid   "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr  ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:771
#, no-wrap
msgid   "mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
        "mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
        "mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
        "  oauth.client.id=\"team-a-client\" \\\n"
        "  oauth.client.secret=\"team-a-client-secret\" \\\n"
        "  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
        "mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:774
msgid   "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:776
msgid   "OAuth authentication works for both JVM and native modes."
msgstr  ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:777
#, no-wrap
msgid   "Going further"
msgstr  "さらに詳しく"

#. type: Plain text
#: upstream/_guides/kafka.adoc:781
msgid   "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes MicroProfile Reactive Messaging to build data streaming applications."
msgstr  ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:782
msgid   "If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr  ""
