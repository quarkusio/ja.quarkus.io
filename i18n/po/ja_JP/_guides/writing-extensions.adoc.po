# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-05 12:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/writing-extensions.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Writing Your Own Extension"
msgstr "Quarkus - 独自の拡張機能の作成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:16
#, fuzzy
msgid ""
"Quarkus extensions add a new developer focused behavior to the core "
"offering, and consist of two distinct parts, buildtime augmentation and "
"runtime container. The augmentation part is responsible for all metadata "
"processing, such as reading annotations, XML descriptors etc. The output of "
"this augmentation phase is recorded bytecode which is responsible for "
"directly instantiating the relevant runtime services."
msgstr ""
"Quarkusの拡張機能は、コアサービスに開発者向けの新しい動作を追加したもので、ビルド時の拡張とランタイムコンテナという2つの異なる部分から構成されています。拡張部分は、アノテーションやXML記述子の読み込みなど、すべてのメタデータ処理を担当します。この拡張フェーズの出力は、関連するランタイムサービスを直接インスタンス化するためのバイトコードとして記録されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:19
#, fuzzy
msgid ""
"This means that metadata is only processed once at build time, which both "
"saves on startup time, and also on memory usage as the classes etc that are "
"used for processing are not loaded (or even present) in the runtime JVM."
msgstr ""
"これは、メタデータがビルド時に一度だけ処理されることを意味し、起動時間の節約と、処理に使用されるクラスなどがランタイムJVMにロードされない（あるいは存在しない）ため、メモリ使用量の節約の両方を実現しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:21
#, fuzzy
msgid ""
"This is an in-depth documentation, see the link:building-my-first-"
"extension[building my first extension] if you need an introduction."
msgstr "これは詳細なドキュメントです。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:22
#, no-wrap, fuzzy
msgid "Extension philosophy"
msgstr "拡張哲学"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:25
#, fuzzy
msgid ""
"This section is a work in progress and gathers the philosophy under which "
"extensions should be designed and written."
msgstr "このセクションは現在進行形の作業であり、拡張機能がどのように設計され、どのように書かれるべきかの哲学を集めたものです。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:26
#, no-wrap, fuzzy
msgid "Why an extension framework"
msgstr "なぜ拡張フレームワークなのか"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:32
#, fuzzy
msgid ""
"Quarkus’s mission is to transform your entire application including the "
"libraries it uses, into an artifact that uses significantly less resources "
"than traditional approaches. These can then be used to build native "
"applications using GraalVM.  To do this you need to analyze and understand "
"the full \"closed world\" of the application.  Without the full and complete "
"context, the best that can be achieved is partial and limited generic "
"support.  By using the Quarkus extension approach, we can bring Java "
"applications in line with memory footprint constrained environments like "
"Kubernetes or cloud platforms."
msgstr ""
"Quarkusの使命は、使用するライブラリを含むアプリケーション全体を、従来のアプローチよりも大幅に少ないリソースしか使用しない人工物に変換することです。これらを使用して、GraalVMを使用してネイティブアプリケーションを構築することができます。これを行うためには、アプリケーションの完全な「クローズドワールド」を分析し、理解する必要があります。完全で完全なコンテキストがなければ、最高のものは部分的で限定的なジェネリックサポートです。Quarkusの拡張アプローチを使用することで、Kubernetesやクラウドプラットフォームのようなメモリフットプリントに制約のある環境にJavaアプリケーションを合わせることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:35
#, fuzzy
msgid ""
"The Quarkus extension framework results in significantly improved resource "
"utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the "
"actions an extension performs:"
msgstr ""
"Quarkus拡張フレームワークは、GraalVMを使用していない場合でも（HotSpotなど）、リソース利用率を大幅に改善します。拡張機能が実行するアクションをリストアップしてみましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:37
#, fuzzy
msgid "Gather build time metadata and generate code"
msgstr "ビルド時のメタデータを収集し、コードを生成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:38
#, fuzzy
msgid ""
"This part has nothing to do with GraalVM, it is how Quarkus starts "
"frameworks “at build time”"
msgstr "この部分はGraalVMとは何の関係もありませんが、Quarkusがフレームワークを\"ビルド時に\"起動する方法です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:39
#, fuzzy
msgid ""
"The extension framework facilitates reading metadata, scanning classes as "
"well as generating classes as needed"
msgstr "拡張フレームワークは、必要に応じてメタデータの読み込み、クラスのスキャン、クラスの生成を容易にします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:40
#, fuzzy
msgid ""
"A small part of the extension work is executed at runtime via the generated "
"classes, while the bulk of the work is done at build time (called deployment "
"time)"
msgstr "拡張作業のごく一部は生成されたクラスを介して実行時に実行され、作業の大部分はビルド時に行われます (デプロイメント時と呼ばれます)"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:41
#, fuzzy
msgid ""
"Enforce opinionated and sensible defaults based on the close world view of "
"the application (e.g. an application with no `@Entity` does not need to "
"start Hibernate ORM)"
msgstr ""
"アプリケーションの近い世界観に基づいて、意見を述べた賢明なデフォルトを強制する（例えば、 `@Entity` "
"のないアプリケーションは、Hibernate ORM を起動する必要はありません）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:42
#, fuzzy
msgid ""
"An extension hosts Substrate VM code substitution so that libraries can run "
"on GraalVM"
msgstr "拡張機能は Substrate VM のコード置換をホストし、ライブラリを GraalVM 上で実行できるようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:43
#, fuzzy
msgid ""
"Most changes are pushed upstream to help the underlying library run on "
"GraalVM"
msgstr "ほとんどの変更は、基礎となるライブラリがGraalVM上で動作するように上流にプッシュされます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:44
#, fuzzy
msgid ""
"Not all changes can be pushed upstream, extensions host Substrate VM "
"substitutions - which is a form of code patching - so that libraries can run"
msgstr ""
"すべての変更を上流にプッシュできるわけではありませんが、拡張機能は Substrate VM "
"置換をホストしており、これはコードパッチの一形態で、ライブラリが実行できるようになっています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:45
#, fuzzy
msgid ""
"Host Substrate VM code substitution to help dead code elimination based on "
"the application needs"
msgstr "ホスト基板VMのコード置換により、アプリケーションのニーズに基づいたデッドコードの排除を支援します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:46
#, fuzzy
msgid ""
"This is application dependant and cannot really be shared in the library "
"itself"
msgstr "これはアプリケーションに依存しており、ライブラリ自体で共有することはできません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:47
#, fuzzy
msgid ""
"For example, Quarkus optimizes the Hibernate code because it knows it only "
"needs a specific connection pool and cache provider"
msgstr ""
"たとえば、Quarkusは、特定の接続プールとキャッシュプロバイダだけが必要であることを知っているため、Hibernateコードを最適化します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:48
#, fuzzy
msgid "Send metadata to GraalVM for example classes in need of reflection"
msgstr "メタデータをGraalVMに送信します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:49
#, fuzzy
msgid ""
"This information is not static per library (e.g. Hibernate) but the "
"framework has the semantic knowledge and knows which classes need to have "
"reflection (for example @Entity classes)"
msgstr ""
"この情報はライブラリ(Hibernateなど)ごとに静的ではありませんが、フレームワークはセマンティックな知識を持っており、どのクラスがリフレクションを必要とするかを知っています(例えば@Entityクラスなど)。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:50
#, no-wrap, fuzzy
msgid "Favor build time work over runtime work"
msgstr "ランタイムワークよりもビルドタイムワークを好む"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:54
#, fuzzy
msgid ""
"As much as possible favor doing work at build time (deployment part of the "
"extension) as opposed to let the framework do work at startup time (runtime)."
"  The more is done there, the smaller Quarkus applications using that "
"extension will be and the faster they will load."
msgstr ""
"可能な限り、フレームワークに起動時（ランタイム）に作業をさせるのではなく、ビルド時（拡張機能のデプロイメント部分）に作業を行うことをお勧めします。そこでの作業が多いほど、その拡張機能を使用しているQuarkusアプリケーションは小さくなり、ロードが速くなります。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:55
#, no-wrap, fuzzy
msgid "How to expose configuration"
msgstr "設定を公開する方法"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:59
#, fuzzy
msgid ""
"Quarkus simplifies the most common usages.  This means that its defaults "
"might be different than the library it integrates."
msgstr "Quarkusは、最も一般的な使用法を簡略化しています。つまり、そのデフォルトは、統合されているライブラリとは異なる場合があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:62
#, fuzzy
msgid ""
"To make the simple experience easiest, unify the configuration in "
"`application.properties` via MicroProfile Config.  Avoid library specific "
"configuration files, or at least make them optional: e.g. `persistence.xml` "
"for Hibernate ORM is optional."
msgstr ""
"シンプルな体験を最も簡単にするために、MicroProfile Configを経由して `application.properties` "
"で設定を統一してください。ライブラリ固有の設定ファイルは避けるか、少なくともオプションにしてください: 例: `persistence.xml` の "
"Hibernate ORM はオプションです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:67
#, fuzzy
msgid ""
"Extensions should see the configuration holistically as a Quarkus "
"application instead of focusing on the library experience.  For example "
"`quarkus.database.url` and friends are shared between extensions as defining "
"a database access is a shared task (instead of a `hibernate.` property for "
"example).  The most useful configuration options should be exposed as "
"`quarkus.[extension].` instead of the natural namespace of the library.  "
"Less common properties can live in the library namespace."
msgstr ""
"拡張機能は、ライブラリエクスペリエンスに焦点を当てるのではなく、Quarkusアプリケーションとして全体的に設定を見るべきです。例えば、データベースアクセスの定義が共有タスクであるように、 "
"`quarkus.database.url` とフレンドは拡張機能間で共有されます（例えば `hibernate.` "
"プロパティの代わりに）。最も便利な設定オプションは、ライブラリの自然な名前空間ではなく、 `quarkus.[extension].` "
"として公開されるべきです。あまり一般的ではないプロパティは、ライブラリの名前空間に置くことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:71
#, fuzzy
msgid ""
"To fully enable the close world assumptions that Quarkus can optimize best, "
"it is better to consider configuration options as build time settled vs "
"overridable at runtime.  Of course properties like host, port, password "
"should be overridable at runtime.  But many properties like enable caching "
"or setting the JDBC driver can safely require a rebuild of the application."
msgstr ""
"Quarkusが最適化できるクローズワールドの仮定を完全に有効にするには、ビルド時に設定された設定オプションと実行時にオーバーライド可能な設定オプションを検討した方が良いでしょう。もちろん、ホスト、ポート、パスワードなどのプロパティは、実行時にオーバーライド可能でなければなりません。しかし、キャッシングを有効にしたり、JDBCドライバを設定したりするような多くのプロパティは、アプリケーションの再構築を安全に要求することができます。"

# 
# 
# 
#. === API
#. TODO: Describe where to put APIs
#. I wonder if that content should be in the technical aspects
#. === Substitution and recorders
#. TODO: Describe where Substitutions and recorders should live
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:83
#, no-wrap, fuzzy
msgid "Expose your components via CDI"
msgstr "CDI経由でコンポーネントを公開"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:88
#, fuzzy
msgid ""
"Since CDI is the central programming model when it comes to component "
"composition, frameworks and extensions should expose their components as "
"beans that are easily consumable by user applications.  For example, "
"Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the "
"connection pool exposes `DataSource` beans etc.  Extensions must register "
"these bean definitions at build time."
msgstr ""
"CDI "
"はコンポーネントの構成に関しては中心的なプログラミングモデルであるため、フレームワークや拡張機能はそのコンポーネントを、ユーザアプリケーションが容易に消費できる豆として公開しなければなりません。例えば、Hibernate "
"ORM は `EntityManagerFactory` と `EntityManager` のビーンを公開し、接続プールは `DataSource` "
"のビーンを公開します。拡張機能は、ビルド時にこれらのビーン定義を登録しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:89
#, no-wrap, fuzzy
msgid "Beans backed by classes"
msgstr "クラスに裏付けられた豆"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:92
#, fuzzy
msgid ""
"An extension can produce an <<cdi-reference."
"adoc#additional_beans,`AdditionalBeanBuildItem`>> to instruct the container "
"to read a bean definition from a class as if it was part of the original "
"application:"
msgstr ""
"拡張機能は link:cdi-reference.html#additional_beans[`AdditionalBeanBuildItem`] "
"コンテナに、元のアプリケーションの一部であるかのようにクラスからビーンの定義を読み込むように指示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:93
#, no-wrap, fuzzy
msgid "Bean Class Registered by `AdditionalBeanBuildItem`"
msgstr "登録されている豆クラス `AdditionalBeanBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:98
#, no-wrap
msgid "@Singleton <1>\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:103
#, no-wrap
msgid "   public String echo(String val) {\n"
"      return val;\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:105
#, fuzzy
msgid ""
"If a bean registered by an `AdditionalBeanBuildItem` does not specify a "
"scope then `@Dependent` is assumed."
msgstr "`AdditionalBeanBuildItem` で登録されたビーンがスコープを指定しない場合は `@Dependent` とする。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:107
#, fuzzy
msgid "All other beans can inject such a bean:"
msgstr "他のすべての豆は、このような豆を注入することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:108
#, no-wrap, fuzzy
msgid "Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`"
msgstr "によって製造された豆を注入する。 `AdditionalBeanBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:113
#, no-wrap
msgid "@Path(\"/hello\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:116
#, no-wrap
msgid "    @Inject\n"
"    Echo echo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:123
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello(String foo) {\n"
"        return echo.echo(foo);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:126
#, fuzzy
msgid ""
"And vice versa - the extension bean can inject application beans and beans "
"provided by other extensions:"
msgstr "また、その逆もまた然り - 拡張機能ビーンは、他の拡張機能によって提供されるアプリケーションビーンやビーンを注入することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:127
#, no-wrap, fuzzy
msgid "Extension Bean Injection Example"
msgstr "拡張豆の注入例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:132
#, no-wrap
msgid "@Singleton\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:135
#, no-wrap
msgid "    @Inject\n"
"    DataSource dataSource;  <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:138
#, no-wrap
msgid "    @Inject\n"
"    Instance<List<String>> listsOfStrings; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:141
#, no-wrap
msgid "    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:143
#, fuzzy
msgid "Inject a bean provided by other extension."
msgstr "他の拡張機能で提供されているビーンをインジェクトします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:144
#, fuzzy
msgid "Inject all beans matching the type `List<String>`."
msgstr "タイプ `List<String>` に一致するすべてのビーンズを注入します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:146
#, no-wrap, fuzzy
msgid "Bean initialization"
msgstr "Beanの初期化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:153
#, fuzzy
msgid ""
"Some components may require additional initialization based on information "
"collected during augmentation.  The most straightforward solution is to "
"obtain a bean instance and call a method directly from a build step.  "
"However, it is _illegal_ to obtain a bean instance during the augmentation "
"phase.  The reason is that the CDI container is not started yet.  It's "
"started during the <<bootstrap-three-phases,Static init bootstrap phase>>."
msgstr ""
"コンポーネントによっては、オーグメンテーション中に収集された情報に基づいて、追加の初期化が必要になる場合があります。最も簡単な解決策は、ビーンのインスタンスを取得し、ビルドステップから直接メソッドを呼び出すことです。しかし、増強フェーズ中にBeanインスタンスを取得することは "
"_違法_ です。理由は、CDIコンテナがまだ起動していないからです。 link:#bootstrap-three-phases[Static "
"initのブートストラップフェーズの] 間に起動されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:155
#, fuzzy
msgid ""
"`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in "
"any bean. `RUN_TIME` config roots should only be injected after the "
"bootstrap though."
msgstr ""
"`BUILD_AND_RUN_TIME_FIXED` と `RUN_TIME` config roots は、どのBeanにも注入することができます。 "
"`RUN_TIME` config roots は、ブートストラップの後にのみ注入すべきです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:161
#, fuzzy
msgid ""
"It is possible to invoke a bean method from a <<bytecode-recording,recorder "
"method>> though.  If you need to access a bean in a `@Record(STATIC_INIT)` "
"build step then is must either depend on the `BeanContainerBuildItem` or "
"wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple -"
" we need to make sure the CDI container is fully initialized and started.  "
"However, it is safe to expect that the CDI container is fully initialized "
"and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a "
"reference to the container via `CDI.current()` or Quarkus-specific `Arc."
"container()`."
msgstr ""
"しかし、 link:#bytecode-recording[レコーダメソッド] からビーンメソッドを呼び出すことは可能です。 "
"`@Record(STATIC_INIT)` ビルドステップでビーンにアクセスする必要がある場合は、 `BeanContainerBuildItem` "
"に依存するか、 `BeanContainerListenerBuildItem` "
"でロジックをラップしなければなりません。理由は簡単で、CDIコンテナが完全に初期化されて起動していることを確認する必要があるからです。しかし、CDI "
"コンテナは `@Record(RUNTIME_INIT)` "
"ビルドステップで完全に初期化されて実行されていると思っておいた方が安全です。コンテナへの参照は、 `CDI.current()` "
"またはQuarkus固有の `Arc.container()` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:163
#, fuzzy
msgid ""
"Don't forget to make sure the bean state guarantees the visibility, e.g. via "
"the `volatile` keyword."
msgstr "`volatile` ビーンの状態が可視性を保証していることを確認することを忘れないでください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:167
#, fuzzy
msgid ""
"There is one significant drawback of this \"late initialization\" approach.  "
"An _uninitialized_ bean may be accessed by other extensions or application "
"components that are instantiated during bootstrap.  We'll cover a more "
"robust solution in the <<synthetic_beans>>."
msgstr ""
"この「遅い初期化」アプローチには、1つの重大な欠点があります。 _初期化されていない_ "
"Beanは、ブートストラップ中にインスタンス化された他の拡張機能やアプリケーションコンポーネントからアクセスされる可能性があります。 link:"
"#synthetic_beans[synthetic_beans]] で、よりロバストな解決策を取り上げます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:168
#, no-wrap, fuzzy
msgid "Default beans"
msgstr "デフォルトの豆"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:173
#, fuzzy
msgid ""
"A very useful pattern of creating such beans but also giving application "
"code the ability to easily override some of the beans with custom "
"implementations, is to use the `@DefaultBean` that Quarkus provides.  This "
"is best explained with an example."
msgstr ""
"このようなビーンを作成しつつ、アプリケーションコードにカスタム実装でビーンの一部を簡単にオーバーライドする機能を与えるという非常に便利なパターンは、Quarkusが提供している "
"`@DefaultBean` を使用することです。これは例を挙げて説明するのが一番です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:175
#, fuzzy
msgid ""
"Let us assume that the Quarkus extension needs to provide a `Tracer` bean "
"which application code is meant to inject into its own beans."
msgstr ""
"ここでは、Quarkus拡張機能が `Tracer` "
"ビーンを提供する必要があると仮定して、アプリケーションコードがそれ自身のビーンに注入することを意味します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:180
#, no-wrap
msgid "@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:185
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:191
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:198
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:201
#, fuzzy
msgid ""
"If for example application code wants to use `Tracer`, but also needs to use "
"a custom `Reporter` bean, such a requirement could easily be done using "
"something like:"
msgstr ""
"例えば、アプリケーションコードが `Tracer` を使用したいが、カスタムの `Reporter` Bean "
"を使用する必要がある場合、そのような要件は、次のようなものを使用して簡単に行うことができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:207
#, no-wrap
msgid "@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:213
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:215
#, no-wrap, fuzzy
msgid ""
"How to Override a Bean Defined by a Library/Quarkus Extension that doesn't "
"use @DefaultBean"
msgstr "DefaultBeanを使用しないライブラリ/Quarkus拡張で定義されたBeanをオーバーライドする方法"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:220
#, fuzzy
msgid ""
"Although `@DefaultBean` is the recommended approach, it is also possible for "
"application code to override beans provided by an extension by marking beans "
"as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a "
"simple example.  Suppose we work on an imaginary \"quarkus-parser\" "
"extension and we have a default bean implementation:"
msgstr ""
"`@DefaultBean` が推奨されていますが、CDI `@Alternative` としてビーンズをマークし、 `@Priority` "
"アノテーションを含めることで、アプリケーションコードが拡張機能によって提供されるビーンズをオーバーライドすることも可能です。簡単な例を示しましょう。架空の\"quarkus-"
"parser\"拡張機能で作業をしていて、デフォルトのビーンの実装を持っているとします。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:225
#, no-wrap
msgid "@Dependent\n"
"class Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:230
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    return expression.split(\"::\");\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:233
#, fuzzy
msgid "And our extension also consumes this parser:"
msgstr "そして、私たちの拡張機能はこのパーサも消費します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:238
#, no-wrap
msgid "@ApplicationScoped\n"
"class ParserService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:241
#, no-wrap
msgid "  @Inject\n"
"  Parser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:244
#, no-wrap
msgid "  //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:247
#, fuzzy
msgid ""
"Now, if a user or even some other extension needs to override the default "
"implementation of the `Parser` the simplest solution is to use CDI "
"`@Alternative` + `@Priority`:"
msgstr ""
"さて、ユーザーや他の拡張機能が `Parser` のデフォルトの実装を上書きする必要がある場合、最も簡単な解決策は CDI `@Alternative` "
"+ `@Priority` を使用することです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:254
#, no-wrap
msgid ""
"@Alternative <1>\n"
"@Priority(1) <2>\n"
"@Singleton\n"
"class MyParser extends Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:259
#, no-wrap
msgid "  String[] parse(String expression) {\n"
"    // my super impl...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:261
#, fuzzy
msgid "`MyParser` is an alternative bean."
msgstr "`MyParser` は代替豆です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:262
#, fuzzy
msgid ""
"Enables the alternative. The priority could be any number to override the "
"default bean but if there are multiple alternatives the highest priority "
"wins."
msgstr ""
"代替案を有効にします。優先度はデフォルトのビーンを上書きするために任意の数値を指定できますが、複数の代替案がある場合は、最も高い優先度のものが優先されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:264
#, fuzzy
msgid ""
"CDI alternatives are only considered during injection and type-safe "
"resolution. For example the default implementation would still receive "
"observer notifications."
msgstr ""
"CDI の代替案は、インジェクションと型安全解決の間のみ考慮されます。例えば、デフォルトの実装では、オブザーバー通知を受け取ることになります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:266
#, no-wrap
msgid "Synthetic beans"
msgstr "合成Bean"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:271
#, fuzzy
msgid ""
"Sometimes it is very useful to be able to register a synthetic bean.  Bean "
"attributes of a synthetic bean are not derived from a java class, method or "
"field.  Instead, the attributes are specified by an extension."
msgstr ""
"合成ビーンを登録できると非常に便利なことがあります。合成ビーンのビーン属性は，javaクラス，メソッド，フィールドから派生したものではありません。その代わりに、属性は拡張子によって指定されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:274
#, fuzzy
msgid ""
"Since the CDI container does not control the instantiation of a synthetic "
"bean the dependency injection and other services (such as interceptors) are "
"not supported.  In other words, it's up to the extension to provide all "
"required services to a synthetic bean instance."
msgstr ""
"CDIコンテナは合成Beanのインスタンス化を制御しないので、依存性注入や他のサービス(インターセプタなど)はサポートされていません。言い換えれば、合成ビーンのインスタンスに必要なすべてのサービスを提供するのは拡張モジュール次第ということです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:277
#, fuzzy
msgid ""
"There are several ways to register a <<cdi-reference."
"adoc#synthetic_beans,synthetic bean>> in Quarkus.  In this chapter, we will "
"cover a use case that can be used to initialize extension beans in a safe "
"manner (compared to <<bean_init>>)."
msgstr ""
"Quarkusで link:cdi-reference.html#synthetic_beans[合成ビーンを] "
"登録する方法はいくつかあります。この章では、安全な方法で拡張ビーンを初期化できるユースケースを取り上げます（ link:"
"#bean_init[[bean_init]] と比較して）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:279
#, fuzzy
msgid "The `SyntheticBeanBuildItem` can be used to register a synthetic bean:"
msgstr "`SyntheticBeanBuildItem` で合成豆を登録することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:281
#, fuzzy
msgid ""
"whose instance can be easily produced through a <<bytecode-"
"recording,recorder>>,"
msgstr "そのインスタンスは、 link:#bytecode-recording[レコーダー] を介して簡単に生成することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:282
#, fuzzy
msgid ""
"to provide a \"context\" bean that holds all the information collected "
"during augmentation so that the real components do not need any \"late "
"initialization\" because they can inject the context bean directly."
msgstr ""
"を提供するために、実際のコンポーネントはコンテキスト・ビーンを直接注入することができるので、\"遅い初期化\"を必要としないように、拡張中に収集されたすべての情報を保持する\"コンテキスト\"ビーンを提供します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:283
#, no-wrap, fuzzy
msgid "Instance Produced Through Recorder"
msgstr "レコーダーを通して生成されたインスタンス"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:293
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo(\"parameters are recorder "
"in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:295
#, fuzzy
msgid ""
"The string value is recorded in the bytecode and used to initialize the "
"instance of `Foo`."
msgstr "文字列の値はバイトコードに記録され、 `Foo` ."

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:296
#, no-wrap, fuzzy
msgid "\"Context\" Holder"
msgstr "\"文脈」ホルダー"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:306
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(TestContext.class)."
"scope(Singleton.class)\n"
"                .runtimeValue(recorder.createContext(\"parameters are "
"recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:308
#, fuzzy
msgid "The \"real\" components can inject the `TestContext` directly."
msgstr "本物の」コンポーネントは、 `TestContext` を直接注入することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:309
#, no-wrap, fuzzy
msgid "Some types of extensions"
msgstr "拡張機能のいくつかのタイプ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:312
#, fuzzy
msgid "There exist multiple stereotypes of extension, let's list a few."
msgstr "拡張子の固定観念は複数存在しますが、いくつか挙げてみましょう。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:313
#, no-wrap, fuzzy
msgid "Bare library running"
msgstr "ベアライブラリの実行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:318
#, fuzzy
msgid ""
"This is the less sophisticated extension.  It consists of a set of patches "
"to make sure a library runs on GraalVM.  If possible, contribute these "
"patches upstream, not in extensions.  Second best is to write Substrate VM "
"substitutions, which are patches applied during native image compilation."
msgstr ""
"これはあまり洗練されていない拡張機能です。これは、ライブラリがGraalVM上で動作するようにするためのパッチのセットで構成されています。可能であれば、これらのパッチは拡張機能の中ではなく、アップストリームで貢献してください。二番目に良いのは、ネイティブイメージのコンパイル時に適用されるパッチである "
"Substrate VM substitutions を書くことです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:319
#, no-wrap, fuzzy
msgid "Get a framework running"
msgstr "実行中のフレームワークを取得する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:322
#, fuzzy
msgid ""
"A framework at runtime typically reads configuration, scan the classpath and "
"classes for metadata (annotations, getters etc), build a metamodel on top of "
"which it runs, find options via the service loader pattern, prepare "
"invocation calls (reflection), proxy interfaces, etc. + These operations "
"should be done at build time and the metamodel be passed to the recorder DSL "
"that will generate classes that will be executed at runtime and boot the "
"framework."
msgstr ""
"実行時のフレームワークは通常、設定を読み込み、クラスパスとクラスをスキャンしてメタデータ(アノテーションやゲッターなど)を探し、その上にメタモデルを構築し、サービスローダパターンを介してオプションを見つけ、呼び出し呼び出し(リフレクション)やプロキシインターフェイスなどを準備します。+ "
"これらの操作はビルド時に行われ、メタモデルは実行時に実行されるクラスを生成するレコーダDSLに渡され、フレームワークを起動します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:323
#, no-wrap, fuzzy
msgid "Get a CDI portable extension running"
msgstr "CDI ポータブル拡張機能を実行する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:328
#, fuzzy
msgid ""
"The CDI portable extension model is very flexible.  Too flexible to benefit "
"from the build time boot promoted by Quarkus.  Most extension we have seen "
"do not make use of these extreme flexibility capabilities.  The way to port "
"a CDI extension to Quarkus is to rewrite it as a Quarkus extension which "
"will define the various beans at build time (deployment time in extension "
"parlance)."
msgstr ""
"CDIポータブル拡張モデルは非常に柔軟性が高い。Quarkusが推進するビルドタイムブートの恩恵を受けるには、あまりにも柔軟性が高すぎます。私たちが見てきたほとんどの拡張機能は、このような極端な柔軟性の機能を利用していません。CDI拡張をQuarkusに移植する方法は、ビルド時（拡張の言い方ではデプロイ時）に様々なビーンを定義するQuarkus拡張として書き換えることです。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:329
#, no-wrap, fuzzy
msgid "Technical aspect"
msgstr "技術的な側面"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:332
#, no-wrap, fuzzy
msgid "Three Phases of Bootstrap and Quarkus Philosophy"
msgstr "BootstrapとQuarkusの3つのフェーズの考え方"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:335
#, fuzzy
msgid "There are three distinct bootstrap phases of a Quarkus app:"
msgstr "Quarkusアプリには、3つの異なるブートストラップフェーズがあります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:336
#, no-wrap, fuzzy
msgid "Augmentation"
msgstr "補強"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:341
#, fuzzy
msgid ""
"This is the first phase, and is done by the <<Build Step Processors>>. These "
"processors have access to Jandex annotation information and can parse any "
"descriptors and read annotations, but should not attempt to load any "
"application classes. The output of these build steps is some recorded "
"bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/"
"gizmo), that is used to actually bootstrap the application at runtime. "
"Depending on the `io.quarkus.deployment.annotations.ExecutionTime` value of "
"the `@io.quarkus.deployment.annotations.Record` annotation associated with "
"the build step, the step may be run in a different JVM based on the "
"following two modes."
msgstr ""
"これは最初のフェーズであり、 link:#Build Step Processors[[Build Step Processors]] "
"によって行われます。これらのプロセッサはJandexのアノテーション情報へのアクセス権を持ち、任意の記述子を解析してアノテーションを読み込むことができますが、アプリケーションクラスをロードしようとはしません。これらのビルドステップの出力は、Gizmo(ext/"
"gizmo)と呼ばれるObjectWeb "
"ASMプロジェクトの拡張機能を使用して記録されたバイトコードで、実行時にアプリケーションを実際にブートストラップするために使用されます。ビルドステップに関連付けられた "
"`@io.quarkus.deployment.annotations.Record` アノテーションの `io.quarkus.deployment."
"annotations.ExecutionTime` の値に応じて、ステップは以下の 2 つのモードに基づいて異なる JVM で実行されます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:342
#, no-wrap, fuzzy
msgid "Static Init"
msgstr "スタティックイニット"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:348
#, fuzzy
msgid ""
"If bytecode is recorded with `@Record(STATIC_INIT)` then it will be executed "
"from a static init method on the main class. For a native executable build, "
"this code is executed in a normal JVM as part of the native build process, "
"and any retained objects that are produced in this stage will be directly "
"serialized into the native executable via an image mapped file.  This means "
"that if a framework can boot in this phase then it will have its booted "
"state directly written to the image, and so the boot code does not need to "
"be executed when the image is started."
msgstr ""
"バイトコードが `@Record(STATIC_INIT)` で記録されている場合は、メインクラスの静的 init "
"メソッドから実行されます。ネイティブ実行形式のビルドでは、このコードはネイティブビルドプロセスの一部として通常のJVMで実行され、この段階で生成された保持オブジェクトはイメージマッピングされたファイルを介してネイティブ実行形式に直接シリアライズされます。これは、もしフレームワークがこのフェーズで起動できるならば、その起動状態がイメージに直接書き込まれ、イメージが起動したときに起動コードが実行される必要がないことを意味します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:350
#, fuzzy
msgid ""
"There are some restrictions on what can be done in this stage as the "
"Substrate VM disallows some objects in the native executable. For example "
"you should not attempt to listen on a port or start threads in this phase. "
"In addition, it is disallowed to read run time configuration during static "
"initialization."
msgstr ""
"この段階でできることにはいくつかの制限がありますが、サブストレートVMはネイティブ実行ファイル内のいくつかのオブジェクトを禁止しています。例えば、この段階ではポートをリッスンしようとしたり、スレッドを開始しようとしたりしてはいけません。さらに、静的な初期化中にランタイム設定を読み込むことも禁止されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:355
#, fuzzy
msgid ""
"In non-native pure JVM mode, there is no real difference between Static and "
"Runtime Init, except that Static Init is always executed first. This mode "
"benefits from the same build phase augmentation as native mode as the "
"descriptor parsing and annotation scanning are done at build time and any "
"associated class/framework dependencies can be removed from the build output "
"jar. In servers like WildFly, deployment related classes such as XML parsers "
"hang around for the life of the application, using up valuable memory. "
"Quarkus aims to eliminate this, so that the only classes loaded at runtime "
"are actually used at runtime."
msgstr ""
"非ネイティブの純粋な JVM モードでは、スタティック Init とランタイム Init の間に実質的な違いはありませんが、スタティック Init "
"が常に最初に実行されます。このモードは、記述子の解析と注釈のスキャンがビルド時に行われ、関連するクラス/"
"フレームワークの依存関係をビルド出力ジャーから削除できるため、ネイティブモードと同じビルドフェーズの拡張の恩恵を受けます。WildFlyのようなサーバーでは、XMLパーサーなどのデプロイメント関連のクラスは、アプリケーションが稼働している間、貴重なメモリを使い果たしてしまいます。Quarkusは、これを排除して、実行時にロードされたクラスだけが実行時に実際に使用されるようにすることを目的としています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:358
#, fuzzy
msgid ""
"As an example, the only reason that a Quarkus application should load an XML "
"parser is if the user is using XML in their application. Any XML parsing of "
"configuration should be done in the Augmentation phase."
msgstr ""
"例として、QuarkusアプリケーションがXMLパーサーをロードする唯一の理由は、ユーザーがアプリケーションでXMLを使用している場合です。設定のXMLパースは、拡張フェーズで行う必要があります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:359
#, no-wrap, fuzzy
msgid "Runtime Init"
msgstr "ランタイムイニット"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:363
#, fuzzy
msgid ""
"If bytecode is recorded with `@Record(RUNTIME_INIT)` then it is executed "
"from the application's main method. This code will be run on native "
"executable boot. In general as little code as possible should be executed in "
"this phase, and should be restricted to code that needs to open ports etc."
msgstr ""
"バイトコードが `@Record(RUNTIME_INIT)` "
"で記録されている場合は、アプリケーションのメインメソッドから実行されます。このコードはネイティブの実行可能なブートで実行されます。一般的に、このフェーズで実行されるコードは可能な限り少なくし、ポートなどを開く必要があるコードに限定してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:365
#, fuzzy
msgid ""
"Pushing as much as possible into the `@Record(STATIC_INIT)` phase allows for "
"two different optimizations:"
msgstr "可能な限り `@Record(STATIC_INIT)` フェーズに押し込むことで、2つの異なる最適化が可能になります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:367
#, fuzzy
msgid ""
"In both native executable and pure JVM mode this allows the app to start as "
"fast as possible since processing was done during build time. This also "
"minimizes the classes/native code needed in the application to pure runtime "
"related behaviors."
msgstr ""
"ネイティブ実行形式と純粋なJVMモードの両方で、これにより、処理はビルド時に行われるため、アプリをできるだけ速く起動することができます。これはまた、アプリケーションで必要とされるクラス/"
"ネイティブコードを、純粋なランタイム関連の動作に最小限に抑えます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:370
#, fuzzy
msgid ""
"Another benefit with native executable mode is that Substrate can more "
"easily eliminate features that are not used. If features are directly "
"initialized via bytecode, Substrate can detect that a method is never called "
"and eliminate that method. If config is read at runtime, Substrate cannot "
"reason about the contents of the config and so needs to keep all features in "
"case they are required."
msgstr ""
"ネイティブ実行モードのもう一つの利点は、Substrate "
"が使用されない機能をより簡単に排除できることです。バイトコードを介して機能が直接初期化されている場合、サブストレートはメソッドが決して呼び出されないことを検出し、そのメソッドを削除することができます。実行時に "
"config が読み込まれる場合、Substrate は config "
"の内容を推論することができないため、必要な場合に備えてすべての機能を保持しておく必要があります。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:372
#, no-wrap, fuzzy
msgid "Maven setup"
msgstr "Mavenのセットアップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:375
#, fuzzy
msgid ""
"Your extension project should be setup as a multi-module project with two "
"submodules:"
msgstr "拡張プロジェクトは、2つのサブモジュールを持つマルチモジュールプロジェクトとして設定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:377
#, fuzzy
msgid ""
"A deployment time submodule that handles the build time processing and "
"bytecode recording."
msgstr "ビルド時の処理とバイトコードの記録を行うデプロイメント時間サブモジュールです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:379
#, fuzzy
msgid ""
"A runtime submodule that contains the runtime behavior that will provide the "
"extension behavior in the native executable or runtime JVM."
msgstr "ネイティブ実行ファイルまたはランタイムJVMで拡張動作を提供するランタイム動作を含むランタイムサブモジュール。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:381
#, fuzzy
msgid ""
"You may want to use the `create-extension` mojo of `io.quarkus:quarkus-maven-"
"plugin` to create these Maven modules - see the next section."
msgstr ""
"これらのMavenモジュールを作成するには、 `io.quarkus:quarkus-maven-plugin` の `create-"
"extension` mojo を使用するとよいでしょう - 次のセクションを参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:386
#, fuzzy
msgid ""
"Your runtime artifact should depend on `io.quarkus:quarkus-core`, and "
"possibly the runtime artifacts of other Quarkus modules if you want to use "
"functionality provided by them.  You will also need to include the `io."
"quarkus:quarkus-bootstrap-maven-plugin` to generate the Quarkus extension "
"descriptor included into the runtime artifact, if you are using the Quarkus "
"parent pom it will automatically inherit the correct configuration.  "
"Furthermore, you'll need to configure the `maven-compiler-plugin` to detect "
"the `quarkus-extension-processor` annotation processor."
msgstr ""
"ランタイムアーティファクトは、 `io.quarkus:quarkus-core` "
"に依存する必要があります。また、他のQuarkusモジュールが提供する機能を使用したい場合は、他のQuarkusモジュールのランタイムアーティファクトに依存することもあります。また、ランタイムアーチファクトに含まれるQuarkus拡張記述子を生成するために "
"`io.quarkus:quarkus-bootstrap-maven-plugin` を含める必要があります。さらに、 `maven-compiler-"
"plugin` を設定して `quarkus-extension-processor` アノテーションプロセッサを検出する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:389
#, fuzzy
msgid ""
"By convention the deployment time artifact has the `-deployment` suffix, and "
"the runtime artifact has no suffix (and is what the end user adds to their "
"project)."
msgstr ""
"慣例では、デプロイメント時間アーティファクトは `-deployment` "
"という接尾辞を持ち、ランタイムアーティファクトは接尾辞を持ちません（エンドユーザーがプロジェクトに追加するものです）。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:399
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-core</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:431
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n"
"            <!-- Executions configuration can be inherited from quarkus-"
"build-parent -->\n"
"            <executions>\n"
"                <execution>\n"
"                    <goals>\n"
"                        <goal>extension-descriptor</goal>\n"
"                    </goals>\n"
"                    <configuration>\n"
"                         <deployment>${project.groupId}:${project."
"artifactId}-deployment:${project.version}</deployment>\n"
"                   </configuration>\n"
"               </execution>\n"
"           </executions>\n"
"        </plugin>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:434
#, fuzzy
msgid "The above `maven-compiler-plugin` configuration requires version 3.5+."
msgstr "上記の `maven-compiler-plugin` の設定には、バージョン 3.5+ が必要です。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:439
#, fuzzy
msgid ""
"Under no circumstances can the runtime module depend on a deployment "
"artifact. This would result in pulling all the deployment time code into "
"runtime scope, which defeats the purpose of having the split."
msgstr ""
"いかなる場合でも、ランタイムモジュールがデプロイメントアーティファクトに依存することはできません。これは、すべてのディプロイメントタイムコードをランタイムスコープに引き込む結果となり、スプリットの目的が達成されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:444
#, fuzzy
msgid ""
"Your deployment time module should depend on `io.quarkus:quarkus-core-"
"deployment`, your runtime artifact, and possibly the deployment artifacts of "
"other Quarkus modules if you want to use functionality provided by them.  "
"You will also need to configure the `maven-compiler-plugin` to detect the "
"`quarkus-extension-processor` annotation processor."
msgstr ""
"デプロイメントタイムモジュールは、 `io.quarkus:quarkus-core-deployment` "
"、ランタイムアーティファクト、および他のQuarkusモジュールが提供する機能を使用する場合は、他のQuarkusモジュールのデプロイメントアーティファクトに依存する必要があります。また、 "
"`quarkus-extension-processor` アノテーションプロセッサを検出するように `maven-compiler-plugin` "
"を設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:453
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-core-deployment</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:470
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:472
#, no-wrap, fuzzy
msgid "Create new extension modules using Maven"
msgstr "Mavenを使って新しい拡張モジュールを作成する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:475
#, fuzzy
msgid ""
"The `create-extension` mojo of `io.quarkus:quarkus-maven-plugin` can be used "
"to generate stubs of Maven modules needed for implementing a new Quarkus "
"extension."
msgstr ""
"`io.quarkus:quarkus-maven-plugin` の `create-extension` mojo は、新しい Quarkus "
"拡張機能の実装に必要な Maven モジュールのスタブを生成するために使用できます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:477
#, fuzzy
msgid ""
"This mojo can be currently used only for adding extensions to an established "
"source tree hosting multiple extensions in one subdirectory, such as https://"
"github.com/quarkusio/quarkus[Quarkus] or https://github.com/apache/camel-"
"quarkus[Camel Quarkus]. Creating extension projects from scratch is not "
"supported yet."
msgstr ""
"このモジョは、現在のところ、 link:https://github.com/quarkusio/quarkus[Quarkus] や link:"
"https://github.com/apache/camel-quarkus[Camel Quarkus] "
"のように、1つのサブディレクトリに複数の拡張機能をホストする確立されたソースツリーに拡張機能を追加するためにのみ使用できます。ゼロから拡張プロジェクトを作成することはまだサポートされていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:479
#, fuzzy
msgid ""
"As and example, let's add a new extension called `my-ext` to the Quarkus "
"source tree:"
msgstr "例として、Quarkusのソースツリーに `my-ext` という新しい拡張機能を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:489
#, no-wrap
msgid ""
"git clone https://github.com/quarkusio/quarkus.git\n"
"cd quarkus\n"
"cd extensions\n"
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N \\\n"
"    -Dquarkus.artifactIdBase=my-ext \\\n"
"    -Dquarkus.artifactIdPrefix=quarkus- \\\n"
"    -Dquarkus.nameBase=\"My Extension\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:492
#, fuzzy
msgid "The above sequence of commands does the following:"
msgstr "上記の一連のコマンドは以下のようなことを行います。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:494
#, fuzzy
msgid "Creates four new Maven modules:"
msgstr "4つの新しいMavenモジュールを作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:495
#, fuzzy
msgid "`quarkus-my-ext-parent` in the `extensions/my-ext` directory"
msgstr "`extensions/my-ext` ディレクトリ内の `quarkus-my-ext-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:496
#, fuzzy
msgid "`quarkus-my-ext` in the `extensions/my-ext/runtime` directory"
msgstr "`extensions/my-ext/runtime` ディレクトリ内の `quarkus-my-ext`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:497
#, fuzzy
msgid ""
"`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; "
"a basic `MyExtProcessor` class is generated in this module."
msgstr ""
"`extensions/my-ext/deployment` ディレクトリの `quarkus-my-ext-deployment` ; 基本的な "
"`MyExtProcessor` クラスはこのモジュールで生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:498
#, fuzzy
msgid ""
"`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/"
"deployment` directory; an empty JAX-RS Resource class and two test classes "
"(for JVM mode and native mode) are generated in this module."
msgstr ""
"`integration-tests/my-ext/deployment` ディレクトリの `quarkus-my-ext-integration-"
"test` ; 空の JAX-RS Resource クラスと 2 つのテストクラス (JVM モードとネイティブモード用) "
"がこのモジュールで生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:499
#, fuzzy
msgid "Links these three modules where necessary:"
msgstr "必要に応じて、これらの3つのモジュールをリンクします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:500
#, fuzzy
msgid ""
"`quarkus-my-ext-parent` is added to the `<modules>` of `quarkus-extensions-"
"parent`"
msgstr ""
"`<modules>` の `quarkus-my-ext-parent` を追加しました。 `quarkus-extensions-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:501
#, fuzzy
msgid ""
"`quarkus-my-ext` is added to the `<dependencyManagement>` of the Quarkus BOM "
"(Bill of Materials) `bom/application/pom.xml`"
msgstr ""
"QuarkusのBOM（部品表）の `<dependencyManagement>` に `quarkus-my-ext` が追加されました。 `bom/"
"application/pom.xml`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:502
#, fuzzy
msgid ""
"`quarkus-my-ext-deployment` is added to the `<dependencyManagement>` of the "
"Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr ""
"QuarkusのBOM（部品表）の `<dependencyManagement>` に `quarkus-my-ext-deployment` "
"が追加されました。 `bom/application/pom.xml`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:503
#, fuzzy
msgid ""
"`quarkus-my-ext-integration-test` is added to the `<modules>` of `quarkus-"
"integration-tests-parent`"
msgstr ""
"`<modules>` の `quarkus-my-ext-integration-test` を追加しました。 `quarkus-"
"integration-tests-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:505
#, fuzzy
msgid ""
"A Maven build performed immediately after generating the modules should fail "
"due to a `fail()` assertion in one of the test classes."
msgstr ""
"モジュールを生成した直後に実行された Maven ビルドは、テストクラスの 1 つに `fail()` アサーションがあるために失敗します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:508
#, fuzzy
msgid ""
"There is one step (specific to the Quarkus source tree) that you should do "
"manually when creating a new extension: create a `quarkus-extension.yaml` "
"file that describe your extension inside the runtime module `src/main/"
"resources/META-INF` folder."
msgstr ""
"それは、ランタイムモジュール `src/main/resources/META-INF` フォルダ内に拡張機能を記述する `quarkus-"
"extension.yaml` ファイルを作成することです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:510
#, fuzzy
msgid ""
"This is the `quarkus-extension.yaml` of the `quarkus-agroal` extension, you "
"can use it as an example:"
msgstr "`quarkus-agroal` の拡張子の `quarkus-extension.yaml` です。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:524
#, no-wrap
msgid ""
"name: \"Agroal - Database connection pool\"\n"
"metadata:\n"
"  keywords:\n"
"  - \"agroal\"\n"
"  - \"database-connection-pool\"\n"
"  - \"datasource\"\n"
"  - \"jdbc\"\n"
"  guide: \"https://quarkus.io/guides/datasource\"\n"
"  categories:\n"
"  - \"data\"\n"
"  status: \"stable\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:527
#, fuzzy
msgid ""
"Note that the parameters of the mojo that will be constant for all the "
"extensions added to this source tree are configured in `extensions/pom.xml` "
"so that they do not need to be passed on the command line each time a new "
"extension is added:"
msgstr ""
"このソースツリーに追加されたすべての拡張機能に対して一定となる mojo のパラメータは `extensions/pom.xml` "
"で設定されているため、新しい拡張機能が追加されるたびにコマンドラインで渡す必要がないことに注意してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:544
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"    <inherited>false</inherited>\n"
"    <!-- Settings for stubbing new extensions via\n"
"           ./mvnw quarkus:create-extension -N -Dquarkus.artifactIdBase=my-"
"ext -Dquarkus.nameBase=\"My Extension\"\n"
"    -->\n"
"    <configuration>\n"
"        <namePrefix xml:space=\"preserve\">Quarkus - </namePrefix>\n"
"        <bomPath>../bom/application/pom.xml</bomPath>\n"
"        <itestParentPath>../integration-tests/pom.xml</itestParentPath>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:549
#, fuzzy
msgid ""
"The `nameBase` parameter of the mojo is optional.  If you do not specify it "
"on the command line, the plugin will derive it from `artifactIdBase` by "
"replacing dashes with spaces and uppercasing each token.  So you may "
"consider omitting explicit `nameBase` in some cases."
msgstr ""
"mojo の `nameBase` "
"パラメータはオプションです。コマンドラインで指定しなかった場合、プラグインはダッシュをスペースに置き換え、各トークンを大文字にすることで "
"`artifactIdBase` からそれを導き出します。そのため、場合によっては明示的な `nameBase` "
"を省略することを検討してもよいでしょう。"

#.  The following link should point to the mojo page once https://github.com/quarkusio/quarkusio.github.io/issues/265 is fixed
#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:552
#, fuzzy
msgid ""
"Please refer to https://github.com/quarkusio/quarkus/blob/{quarkus-version}/"
"devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo."
"java[CreateExtensionMojo JavaDoc] for all the available options of the mojo."
msgstr ""
"モジョで利用可能なすべてのオプションについては、 link:https://github.com/quarkusio/quarkus/blob/"
"{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/"
"CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] を参照してください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:553
#, no-wrap, fuzzy
msgid "Build Step Processors"
msgstr "ビルドステッププロセッサ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:558
#, fuzzy
msgid ""
"Work is done at augmentation time by _build steps_ which produce and consume "
"_build items_.  The build steps found in the deployment modules that "
"correspond to the extensions in the project build are automatically wired "
"together and executed to produce the final build artifact(s)."
msgstr ""
"作業は、 _ビルドアイテムを_ 生成して消費する _ビルドステップ_ "
"によって拡張時に行われます。プロジェクトビルドの拡張機能に対応するデプロイメントモジュールで見つかったビルドステップは、自動的に配線されて実行され、最終的なビルド成果物が生成されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:559
#, no-wrap, fuzzy
msgid "Build steps"
msgstr "ビルドステップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:565
#, fuzzy
msgid ""
"A _build step_ is a method which is annotated with the `@io.quarkus."
"deployment.annotations.BuildStep` annotation.  Each build step may "
"<<consuming-values,consume>> items that are produced by earlier stages, and "
"<<producing-values,produce>> items that can be consumed by later stages. "
"Build steps are normally only run when they produce a build item that is "
"ultimately consumed by another step."
msgstr ""
"_ビルドステップ_ とは、 `@io.quarkus.deployment.annotations.BuildStep` "
"アノテーションが付けられたメソッドのことである。各ビルドステップは、以前のステージで生成されたアイテムを link:#consuming-"
"values[消費し] たり、後のステージで消費可能なアイテムを link:#producing-values[生成し] "
"たりします。ビルドステップは通常、最終的に別のステップで消費されるビルドアイテムを生成する場合にのみ実行されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:568
#, fuzzy
msgid ""
"Build steps are normally placed on plain classes within an extension's "
"deployment module.  The classes are automatically instantiated during the "
"augment process and utilize <<injection,injection>>."
msgstr ""
"ビルドステップは通常、拡張機能のデプロイモジュール内のプレーンクラスに配置されます。クラスは拡張処理の間に自動的にインスタンス化され、 link:"
"#injection[インジェクションを] 利用します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:570
#, no-wrap, fuzzy
msgid "Build items"
msgstr "ビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:576
#, fuzzy
msgid ""
"Build items are concrete, final subclasses of the abstract `io.quarkus."
"builder.item.BuildItem` class.  Each build item represents some unit of "
"information that must be passed from one stage to another.  The base "
"`BuildItem` class may not itself be directly subclassed; rather, there are "
"abstract subclasses for each of the kinds of build item subclasses that "
"_may_ be created: <<simple-build-items,simple>>, <<multi-build-"
"items,multi>>, and <<empty-build-items,empty>>."
msgstr ""
"ビルド項目は、抽象 `io.quarkus.builder.item.BuildItem` "
"クラスの具体的な最終サブクラスです。各ビルド項目は、ある段階から別の段階に渡される必要のある情報の単位を表します。基底 `BuildItem` "
"クラス自体が直接サブクラス化されているわけではなく、作成される _可能性のある_ ビルド・アイテム・サブクラスの種類（ link:#simple-"
"build-items[単純] 、 link:#multi-build-items[複数] 、 link:#empty-build-items[空] "
"）ごとに抽象サブクラスが存在します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:578
#, fuzzy
msgid ""
"Think of build items as a way for different extensions to communicate with "
"one another.  For example, a build item can:"
msgstr "ビルド項目は、異なる拡張機能が互いに通信するための方法と考えてください。たとえば、ビルド項目には次のようなものがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:580
#, fuzzy
msgid "expose the fact that a database configuration exists"
msgstr "データベースの設定が存在することを公開します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:581
#, fuzzy
msgid ""
"consume that database configuration (e.g. a connection pool extension or an "
"ORM extension)"
msgstr "データベース設定を消費する (接続プール拡張やORM拡張など)"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:583
#, fuzzy
msgid ""
"ask an extension to do work for another extension: e.g. an extension wanting "
"to define a new CDI bean and asking the ArC extension to do so"
msgstr "別の拡張機能に作業を依頼する: 例えば、新しい CDI Bean を定義したい拡張機能が ArC 拡張機能にそうするように依頼します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:585
#, fuzzy
msgid "This is a very flexible mechanism."
msgstr "これは非常に柔軟な仕組みです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:588
#, fuzzy
msgid ""
"`BuildItem` instances should be immutable, as the producer/consumer model "
"does not allow for mutation to be correctly ordered. This is not enforced "
"but failure to adhere to this rule can result in race conditions."
msgstr ""
"`BuildItem` インスタンスは不変でなければなりません。プロデューサー/"
"コンシューマーモデルでは突然変異が正しく順序付けられないためです。これは強制されていませんが、このルールを守らないと競合状態になる可能性があります。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:590
#, no-wrap, fuzzy
msgid "Simple build items"
msgstr "シンプルなビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:596
#, fuzzy
msgid ""
"Simple build items are final classes which extend `io.quarkus.builder.item."
"SimpleBuildItem`.  Simple build items may only be produced by one step in a "
"given build; if multiple steps in a build declare that they produce the same "
"simple build item, an error is raised.  Any number of build steps may "
"consume a simple build item.  A build step which consumes a simple build "
"item will always run _after_ the build step which produced that item."
msgstr ""
"シンプルビルド項目は `io.quarkus.builder.item.SimpleBuildItem` "
"を継承する最終クラスです。ビルド中の複数のステップが同じシンプルなビルド項目を生成すると宣言した場合、エラーが発生します。ビルド中の複数のステップが同じ単純なビルド項目を生成することを宣言すると、エラーが発生します。シンプルビルドアイテムを消費するビルドステップは、常にそのアイテムを生成したビルドステップの "
"_後_ に実行されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:597
#, no-wrap, fuzzy
msgid "Example of a single build item"
msgstr "単品のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:606
#, no-wrap
msgid ""
"/**\n"
" * The build item which represents the Jandex index of the application,\n"
" * and would normally be used by many build steps to find usages\n"
" * of annotations.\n"
" */\n"
"public final class ApplicationIndexBuildItem extends SimpleBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:608
#, no-wrap
msgid "    private final Index index;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:612
#, no-wrap
msgid ""
"    public ApplicationIndexBuildItem(Index index) {\n"
"        this.index = index;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:617
#, no-wrap
msgid "    public Index getIndex() {\n"
"        return index;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:621
#, no-wrap, fuzzy
msgid "Multi build items"
msgstr "マルチビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:626
#, fuzzy
msgid ""
"Multiple or \"multi\" build items are final classes which extend `io.quarkus."
"builder.item.MultiBuildItem`.  Any number of multi build items of a given "
"class may be produced by any number of steps, but any steps which consume "
"multi build items will only run _after_ every step which can produce them "
"has run."
msgstr ""
"マルチビルドアイテムまたは「マルチ」ビルドアイテムは、 `io.quarkus.builder.item.MultiBuildItem` ."
"指定されたクラスのマルチビルドアイテムは、いくつでものステップによって生成することができますが、マルチビルドアイテムを消費するステップは、マルチビルドアイテムを生成できるすべてのステップが実行された "
"_後に_ のみ実行されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:627
#, no-wrap, fuzzy
msgid "Example of a multiple build item"
msgstr "複数のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:633
#, no-wrap
msgid ""
"public final class ServiceWriterBuildItem extends MultiBuildItem {\n"
"    private final String serviceName;\n"
"    private final List<String> implementations;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:643
#, no-wrap
msgid ""
"    public ServiceWriterBuildItem(String serviceName, String... "
"implementations) {\n"
"        this.serviceName = serviceName;\n"
"        // Make sure it's immutable\n"
"        this.implementations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                implementations.clone()\n"
"            )\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:647
#, no-wrap
msgid ""
"    public String getServiceName() {\n"
"        return serviceName;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:652
#, no-wrap
msgid ""
"    public List<String> getImplementations() {\n"
"        return implementations;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:654
#, no-wrap, fuzzy
msgid "Example of multiple build item usage"
msgstr "複数のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:669
#, no-wrap
msgid ""
"/**\n"
" * This build step produces a single multi build item that declares two\n"
" * providers of one configuration-related service.\n"
" */\n"
"@BuildStep\n"
"public ServiceWriterBuildItem registerOneService() {\n"
"    return new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyFirstConfigConverterImpl.class.getName(),\n"
"        MySecondConfigConverterImpl.class.getName()\n"
"    );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:688
#, no-wrap
msgid ""
"/**\n"
" * This build step produces several multi build items that declare multiple\n"
" * providers of multiple configuration-related services.\n"
" */\n"
"@BuildStep\n"
"public void registerSeveralServices(\n"
"    BuildProducer<ServiceWriterBuildItem> providerProducer\n"
") {\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyThirdConfigConverterImpl.class.getName(),\n"
"        MyFourthConfigConverterImpl.class.getName()\n"
"    ));\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        ConfigSource.class.getName(),\n"
"        MyConfigSourceImpl.class.getName()\n"
"    ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:699
#, no-wrap
msgid ""
"/**\n"
" * This build step aggregates all the produced service providers\n"
" * and outputs them as resources.\n"
" */\n"
"@BuildStep\n"
"public void produceServiceFiles(\n"
"    List<ServiceWriterBuildItem> items,\n"
"    BuildProducer<GeneratedResourceBuildItem> resourceProducer\n"
") throws IOException {\n"
"    // Aggregate all of the providers\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:710
#, no-wrap
msgid ""
"    Map<String, Set<String>> map = new HashMap<>();\n"
"    for (ServiceWriterBuildItem item : items) {\n"
"        String serviceName = item.getName();\n"
"        for (String implName : item.getImplementations()) {\n"
"            map.computeIfAbsent(\n"
"                serviceName,\n"
"                (k, v) -> new LinkedHashSet<>()\n"
"            ).add(implName);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:731
#, no-wrap
msgid ""
"    // Now produce the resource(s) for the SPI files\n"
"    for (Map.Entry<String, Set<String>> entry : map.entrySet()) {\n"
"        String serviceName = entry.getKey();\n"
"        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n"
"            try (OutputStreamWriter w = new OutputStreamWriter(os, "
"StandardCharsets.UTF_8)) {\n"
"                for (String implName : entry.getValue()) {\n"
"                    w.write(implName);\n"
"                    w.write(System.lineSeparator());\n"
"                }\n"
"            }\n"
"            w.flush();\n"
"            resourceProducer.produce(\n"
"                new GeneratedResourceBuildItem(\n"
"                    \"META-INF/services/\" + serviceName,\n"
"                    os.toByteArray()\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:734
#, no-wrap, fuzzy
msgid "Empty build items"
msgstr "空のビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:739
#, fuzzy
msgid ""
"Empty build items are final (usually empty) classes which extend `io.quarkus."
"builder.item.EmptyBuildItem`.  They represent build items that don't "
"actually carry any data, and allow such items to be produced and consumed "
"without having to instantiate empty classes.  They cannot themselves be "
"instantiated."
msgstr ""
"空のビルド項目は `io.quarkus.builder.item.EmptyBuildItem` を拡張した最終的な (通常は空の) "
"クラスです。これは実際にはデータを持たないビルド項目を表し、空のクラスをインスタンス化することなく、そのような項目を生成したり消費したりすることを可能にします。これらはそれ自体をインスタンス化することはできません。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:740
#, no-wrap, fuzzy
msgid "Example of an empty build item"
msgstr "空のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:746
#, no-wrap
msgid ""
"public final class NativeImageBuildItem extends EmptyBuildItem {\n"
"    // empty\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:751
#, fuzzy
msgid ""
"Empty build items can represent \"barriers\" which can impose ordering "
"between steps.  They can also be used in the same way that popular build "
"systems use \"pseudo-targets\", which is to say that the build item can "
"represent a conceptual goal that does not have a concrete representation."
msgstr ""
"空のビルド項目は、ステップ間の順序付けを強制する「障壁」を表すことができます。また、一般的なビルドシステムが「擬似ターゲット」を使用しているのと同じように使用することもできます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:752
#, no-wrap, fuzzy
msgid "Example of usage of an empty build item in a \"pseudo-target\" style"
msgstr "擬似ターゲット」スタイルでの空のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:767
#, no-wrap
msgid ""
"/**\n"
" * Contrived build step that produces the native image on disk.  The main "
"augmentation\n"
" * step (which is run by Maven or Gradle) would be declared to consume this "
"empty item,\n"
" * causing this step to be run.\n"
" */\n"
"@BuildStep\n"
"@Produce(NativeImageBuildItem.class)\n"
"void produceNativeImage() {\n"
"    // ...\n"
"    // (produce the native image)\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:769
#, no-wrap, fuzzy
msgid "Example of usage of an empty build item in a \"barrier\" style"
msgstr "バリア」スタイルでの空のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:781
#, no-wrap
msgid ""
"/**\n"
" * This would always run after {@link #produceNativeImage()} completes, "
"producing\n"
" * an instance of {@code SomeOtherBuildItem}.\n"
" */\n"
"@BuildStep\n"
"@Consume(NativeImageBuildItem.class)\n"
"SomeOtherBuildItem secondBuildStep() {\n"
"    return new SomeOtherBuildItem(\"foobar\");\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:784
#, no-wrap, fuzzy
msgid "Injection"
msgstr "射出成形"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:787
#, fuzzy
msgid ""
"Classes which contain build steps support the following types of injection:"
msgstr "ビルドステップを含むクラスは、以下のタイプのインジェクションをサポートしています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:789
#, fuzzy
msgid "Constructor parameter injection"
msgstr "コンストラクタのパラメータ注入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:790
#, fuzzy
msgid "Field injection"
msgstr "フィールドインジェクション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:791
#, fuzzy
msgid "Method parameter injection (for build step methods only)"
msgstr "メソッド・パラメータのインジェクション（ビルド・ステップ・メソッドのみ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:794
#, fuzzy
msgid ""
"Build step classes are instantiated and injected for each build step "
"invocation, and are discarded afterwards.  State should only be communicated "
"between build steps by way of build items, even if the steps are on the same "
"class."
msgstr ""
"ビルドステップクラスは、各ビルドステップの呼び出しごとにインスタンス化されて注入され、その後破棄されます。ビルドステップが同じクラス上にある場合でも、ステートはビルドアイテムを介してのみ、ビルドステップ間で通信されるべきです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:797
#, fuzzy
msgid ""
"Final fields are not considered for injection, but can be populated by way "
"of constructor parameter injection if desired.  Static fields are never "
"considered for injection."
msgstr ""
"最終フィールドはインジェクションのために考慮されませんが、必要に応じてコンストラクタのパラメータをインジェクションすることで入力することができます。静的なフィールドはインジェクションのために考慮されることはありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:799
#, fuzzy
msgid "The types of values that can be injected include:"
msgstr "注入できる値の種類には、以下のようなものがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:801
#, fuzzy
msgid "<<build-items,Build items>> produced by previous build steps"
msgstr "前のビルドステップで生成された link:#build-items[アイテムをビルドする]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:802
#, fuzzy
msgid ""
"<<producing-values,Build producers>> to produce items for subsequent build "
"steps"
msgstr "後続のビルドステップのためのアイテムを生産するための link:#producing-values[ビルドプロデューサー]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:803
#, fuzzy
msgid "<<configuration-roots,Configuration root>> types"
msgstr "link:#configuration-roots[設定ルートの] 種類"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:804
#, fuzzy
msgid "Template objects for <<bytecode-recording,bytecode recording>>"
msgstr "link:#bytecode-recording[バイトコード記録] 用テンプレートオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:807
#, fuzzy
msgid ""
"Objects which are injected into a build step method or its class _must not_ "
"be used outside of that method's execution."
msgstr "ビルドステップ・メソッドまたはそのクラスに注入されたオブジェクトは、そのメソッドの実行外で使用してはなり _ませ_ ん。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:810
#, fuzzy
msgid ""
"Injection is resolved at compile time via an annotation processor, and the "
"resulting code does not have permission to inject private fields or invoke "
"private methods."
msgstr ""
"インジェクションはコンパイル時にアノテーション・プロセッサを介して解決され、結果として得られるコードにはプライベート・フィールドを注入したり、プライベート・メソッドを呼び出したりする権限はありません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:812
#, no-wrap, fuzzy
msgid "Producing values"
msgstr "価値観のプロデュース"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:815
#, fuzzy
msgid ""
"A build step may produce values for subsequent steps in several possible "
"ways:"
msgstr "ビルドステップは、いくつかの可能な方法で後続のステップの値を生成することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:817
#, fuzzy
msgid ""
"By returning a <<simple-build-items,simple build item>> or <<multi-build-"
"items,multi build item>> instance"
msgstr ""
"link:#simple-build-items[シンプルなビルドアイテム] または link:#multi-build-"
"items[マルチビルドアイテムの] インスタンスを返すことで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:818
#, fuzzy
msgid "By returning a `List` of a multi build item class"
msgstr "マルチビルドアイテムクラスの `List` を返すことで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:819
#, fuzzy
msgid "By injecting a `BuildProducer` of a simple or multi build item class"
msgstr "シンプルまたはマルチビルドアイテムクラスの `BuildProducer` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:821
#, fuzzy
msgid ""
"By annotating the method with `@io.quarkus.deployment.annotations.Produce`, "
"giving the class name of a <<empty-build-items,empty build item>>"
msgstr ""
"メソッドに `@io.quarkus.deployment.annotations.Produce` をアノテーションすることで、 link:"
"#empty-build-items[空のビルド項目の] クラス名を与えることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:824
#, fuzzy
msgid ""
"If a simple build item is declared on a build step, it _must_ be produced "
"during that build step, otherwise an error will result.  Build producers "
"which are injected into steps _must not_ be used outside of that step."
msgstr ""
"ビルドステップ上で単純なビルド項目が宣言されている場合、そのビルドステップ中に生成する _必要があり_ "
"、そうしないとエラーになります。ステップに注入されたビルドプロデューサは、そのステップの外で使用しては _いけません_ 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:830
#, fuzzy
msgid ""
"Note that a `@BuildStep` method will only be called if it produces something "
"that another consumer or the final output requires. If there is no consumer "
"for a particular item then it will not be produced. What is required will "
"depend on the final target that is being produced.  For example, when "
"running in developer mode the final output will not ask for GraalVM-specific "
"build items such as `ReflectiveClassBuildItem`, so methods that only produce "
"these items will not be invoked."
msgstr ""
"`@BuildStep` "
"メソッドは、他の消費者が必要とするものを生成する場合、または最終的な出力が必要とする場合にのみ呼び出されることに注意してください。特定のアイテムの消費者がいない場合、それは生産されません。何が必要かは、生成される最終ターゲットに依存します。例えば、開発者モードで実行している場合、最終出力は "
"`ReflectiveClassBuildItem` のような GraalVM "
"固有のビルド項目を要求しないため、これらの項目のみを生成するメソッドは呼び出されません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:832
#, no-wrap, fuzzy
msgid "Consuming values"
msgstr "消費する価値観"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:835
#, fuzzy
msgid ""
"A build step may consume values from previous steps in the following ways:"
msgstr "ビルドステップでは、以下の方法で前のステップの値を消費することがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:837
#, fuzzy
msgid "By injecting a <<simple-build-items,simple build item>>"
msgstr "link:#simple-build-items[シンプルなビルド項目を] 注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:838
#, fuzzy
msgid "By injecting an `Optional` of a simple build item class"
msgstr "シンプルなビルド項目クラスの `Optional` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:839
#, fuzzy
msgid ""
"By injecting a `List` of a <<multi-build-items,multi build item>> class"
msgstr "link:#multi-build-items[マルチビルドアイテムクラス] の `List` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:841
#, fuzzy
msgid ""
"By annotating the method with `@io.quarkus.deployment.annotations.Consume`, "
"giving the class name of a <<empty-build-items,empty build item>>"
msgstr ""
"メソッドに `@io.quarkus.deployment.annotations.Consume` をアノテーションすることで、 link:"
"#empty-build-items[空のビルド項目の] クラス名を与えることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:844
#, fuzzy
msgid ""
"Normally it is an error for a step which is included to consume a simple "
"build item that is not produced by any other step.  In this way, it is "
"guaranteed that all of the declared values will be present and non-`null` "
"when a step is run."
msgstr ""
"通常、含まれるステップが他のステップで生成されない単純なビルド項目を消費するのはエラーです。このようにして、ステップが実行されたときに宣言されたすべての値が存在し、 "
"`null` ではないことが保証されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:847
#, fuzzy
msgid ""
"Sometimes a value isn't necessary for the build to complete, but might "
"inform some behavior of the build step if it is present.  In this case, the "
"value can be optionally injected."
msgstr ""
"ビルドを完了させるためには必要のない値ですが、値が存在する場合にはビルドステップの動作に何らかの情報を提供することがあります。この場合、オプションで値を注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:849
#, fuzzy
msgid ""
"Multi build values are always considered _optional_.  If not present, an "
"empty list will be injected."
msgstr "複数のビルド値は常に _オプション_ とみなされます。存在しない場合は、空のリストが注入されます。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:851
#, no-wrap, fuzzy
msgid "Weak value production"
msgstr "弱い価値生産"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:856
#, fuzzy
msgid ""
"Normally a build step is included whenever it produces any build item which "
"is in turn consumed by any other build step.  In this way, only the steps "
"necessary to produce the final artifact(s) are included, and steps which "
"pertain to extensions which are not installed or which only produce build "
"items which are not relevant for the given artifact type are excluded."
msgstr ""
"通常、ビルドステップは、他のビルドステップによって消費されるビルド項目を生成する際には必ず含まれます。このようにして、最終的な成果物を生成するために必要なステップだけが含まれ、インストールされていない拡張機能に関連するステップや、与えられた成果物の種類に関係のないビルド項目を生成するだけのステップは除外される。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:859
#, fuzzy
msgid ""
"For cases where this is not desired behavior, the `@io.quarkus.deployment."
"annotations.Weak` annotation may be used.  This annotation indicates that "
"the build step should not automatically be included solely on the basis of "
"producing the annotated value."
msgstr ""
"これが望ましい動作ではない場合は、 `@io.quarkus.deployment.annotations.Weak` "
"アノテーションを使用することができます。このアノテーションは、アノテーションされた値を生成することだけに基づいて、ビルドステップを自動的に含めるべきではないことを示しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:860
#, no-wrap, fuzzy
msgid "Example of producing a build item weakly"
msgstr "ビルドアイテムを弱く出す例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:876
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the "
"ExecutorClassBuildItem.\n"
" */\n"
"@BuildStep\n"
"void createExecutor(\n"
"        @Weak BuildProducer<GeneratedClassBuildItem> classConsumer,\n"
"        BuildProducer<ExecutorClassBuildItem> executorClassConsumer\n"
") {\n"
"        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);\n"
"        String className = generateClassThatCreatesExecutor(cw); // <1>\n"
"        classConsumer.produce(new GeneratedClassBuildItem(true, className, "
"cw.toByteArray()));\n"
"        executorClassConsumer.produce(new "
"ExecutorClassBuildItem(className));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:878
#, fuzzy
msgid ""
"This method (not provided in this example) would generate the class using "
"the ASM API."
msgstr "このメソッド（この例では提供されていません）は、ASM APIを使用してクラスを生成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:885
#, fuzzy
msgid ""
"Certain types of build items are generally always consumed, such as "
"generated classes or resources.  An extension might produce a build item "
"along with a generated class to facilitate the usage of that build item.  "
"Such a build step would use the `@Weak` annotation on the generated class "
"build item, while normally producing the other build item.  If the other "
"build item is ultimately consumed by something, then the step would run and "
"the class would be generated.  If nothing consumes the other build item, the "
"step would not be included in the build process."
msgstr ""
"一般的に、生成されたクラスやリソースなど、特定のタイプのビルド項目は常に消費されます。拡張モジュールは、そのビルド項目の使用を容易にするために、 "
"生成されたクラスと一緒にビルド項目を生成するかもしれません。そのようなビルドステップでは、生成されたクラスのビルド項目に `@Weak` "
"アノテーションを使用し、通常は他のビルド項目を生成します。他のビルド項目が最終的に何かによって消費される場合は、ステップが実行され、クラスが生成されます。他のビルド項目が何も消費されなければ、そのステップはビルドプロセスには含まれません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:888
#, fuzzy
msgid ""
"In the example above, `GeneratedClassBuildItem` would only be produced if "
"`ExecutorClassBuildItem` is consumed by some other build step."
msgstr ""
"上記の例では、 `GeneratedClassBuildItem` は、 `ExecutorClassBuildItem` "
"が他のビルドステップで消費された場合にのみ生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:891
#, fuzzy
msgid ""
"Note that when using <<bytecode-recording,bytecode recording>>, the "
"implicitly generated class can be declared to be weak by using the "
"`optional` attribute of the `@io.quarkus.deployment.annotations.Record` "
"annotation."
msgstr ""
"link:#bytecode-recording[バイトコード記録を] 使用する場合、 `@io.quarkus.deployment."
"annotations.Record` アノテーションの `optional` "
"属性を使用することで、暗黙的に生成されたクラスを弱いものと宣言することができることに注意してください。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:892
#, no-wrap, fuzzy
msgid ""
"Example of using a bytecode recorder where the generated class is weakly "
"produced"
msgstr "生成されたクラスが弱く生成されるバイトコードレコーダーを使用した例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:904
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorBuildItem.\n"
" */\n"
"@BuildStep\n"
"@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) // <1>\n"
"ExecutorBuildItem createExecutor( // <2>\n"
"        ExecutorTemplate executorTemplate,\n"
"        ThreadPoolConfig threadPoolConfig\n"
") {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:913
#, no-wrap
msgid ""
"    return new ExecutorBuildItem(\n"
"        setupTemplate.setupRunTime(\n"
"            shutdownContextBuildItem,\n"
"            threadPoolConfig,\n"
"            launchModeBuildItem.getLaunchMode()\n"
"        )\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:915
#, fuzzy
msgid "Note the `optional` attribute."
msgstr "`optional` 属性に注意してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:916
#, fuzzy
msgid ""
"This example is using recorder proxies; see the section on <<bytecode-"
"recording,bytecode recording>> for more information."
msgstr ""
"この例では、レコーダーのプロキシを使用しています。詳細については、 link:#bytecode-recording[バイトコード記録の] "
"セクションを参照してください。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:917
#: upstream/_guides/writing-extensions.adoc:2164
#, no-wrap, fuzzy
msgid "Capabilities"
msgstr "機能"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:923
#, fuzzy
msgid ""
"The `@BuildStep` annotation has a `providesCapabilities` property that can "
"be used to provide capability information to other extensions about what is "
"present in the current application. Capabilities are simply strings that are "
"used to describe an extension. Capabilities should generally be named after "
"an extensions root package, for example the transactions extension will "
"provide `io.quarkus.transactions`."
msgstr ""
"`@BuildStep` アノテーションには `providesCapabilities` "
"プロパティがあり、これを使用して、現在のアプリケーションに何が存在するかについてのケイパビリティ情報を他の拡張機能に提供することができます。ケイパビリティとは、拡張機能を説明するために使用される単純な文字列です。 "
"`io.quarkus.transactions` 能力は一般的には拡張機能のルートパッケージにちなんだ名前をつけなければなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:926
#, fuzzy
msgid ""
"To check if a capability is present you can inject the `io.quarkus."
"deployment.Capabilities` object and call `isCapabilityPresent`."
msgstr ""
"ケイパビリティが存在するかどうかを確認するには、 `io.quarkus.deployment.Capabilities` オブジェクトを注入して "
"`isCapabilityPresent` を呼び出すことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:928
#, fuzzy
msgid ""
"Capabilities should be used when checking for the presence of an extension "
"rather than class path based checks."
msgstr "機能は、クラスパスに基づいたチェックではなく、拡張機能の存在をチェックするときに使用しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:929
#, no-wrap, fuzzy
msgid "Application Archives"
msgstr "アプリケーションアーカイブ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:935
#, fuzzy
msgid ""
"The `@BuildStep` annotation can also register marker files that determine "
"which archives on the class path are considered to be 'Application "
"Archives', and will therefore get indexed. This is done via the "
"`applicationArchiveMarkers`. For example the ArC extension registers `META-"
"INF/beans.xml`, which means that all archives on the class path with a "
"`beans.xml` file will be indexed."
msgstr ""
"`@BuildStep` "
"アノテーションは、クラスパス上のどのアーカイブが「アプリケーションアーカイブ」とみなされてインデックス化されるかを決定するマーカーファイルを登録することもできます。これは "
"`applicationArchiveMarkers` を通して行われます。た と えば ArC 拡張は `META-INF/beans.xml` "
"を登録します。これは、クラスパス上の `beans.xml` ファイルを持つすべてのアーカイブがインデックス化されることを意味します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:937
#, fuzzy
msgid ""
"`BuildStep.applicationArchiveMarkers()` is deprecated and will be removed at "
"some point post Quarkus 1.1. Extensions are encouraged to use `io.quarkus."
"deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem` instead."
msgstr ""
"`BuildStep.applicationArchiveMarkers()` は非推奨で、Quarkus 1."
"1以降のある時点で削除される予定です。拡張機能は、代わりに `io.quarkus.deployment.builditem."
"AdditionalApplicationArchiveMarkerBuildItem` を使用することをお勧めします。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:938
#, no-wrap, fuzzy
msgid "Using Thread's Context Class Loader"
msgstr "スレッドのコンテキストクラスローダーの使用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:944
#, fuzzy
msgid ""
"The build step will be run with a TCCL that can load user classes from the "
"deployment in a transformer-safe way.  This class loader only lasts for the "
"life of the augmentation, and is discarded afterwards.  The classes will be "
"loaded again in a different class loader at runtime.  This means that "
"loading a class during augmentation does not stop it from being transformed "
"when running in the development/test mode."
msgstr ""
"ビルドステップは、デプロイメントからユーザークラスをトランスフォーマーセーフな方法でロードできるTCCLを使って実行されます。このクラス・ローダは拡張の期間だけ持続し、その後は破棄されます。クラスは実行時に別のクラス・ローダで再びロードされます。つまり、オーグメンテーション中にクラスをロードしても、開発/"
"テストモードで実行しているときにクラスがトランスフォームされるのを止めることはありません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:945
#, no-wrap, fuzzy
msgid "Adding external JARs to the indexer with IndexDependencyBuildItem"
msgstr "IndexDependencyBuildItemで外部JARをインデクサに追加する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:949
#, fuzzy
msgid ""
"The index of scanned classes will not automatically include your external "
"class dependencies.  To add dependencies, create a `@BuildStep` that "
"produces `IndexDependencyBuildItem` objects, for a `groupId` and "
"`artifactId`."
msgstr ""
"スキャンされたクラスのインデックスには、外部クラスの依存関係は自動的には含まれません。依存関係を追加するには、 `groupId` と "
"`artifactId` に対して `IndexDependencyBuildItem` オブジェクトを生成する `@BuildStep` "
"を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:951
#, fuzzy
msgid ""
"It is important to specify all the required artifacts to be added to the "
"indexer. No artifacts are implicitly added transitively."
msgstr "インデクサーに追加する必要のあるすべてのアーティファクトを指定することが重要です。暗黙的に通過的に追加されるアーティファクトはありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:953
#, fuzzy
msgid ""
"The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK "
"that are used in Jackson JSON transformations, in order for the reflective "
"classes to identified and included at `BUILD_TIME`."
msgstr ""
"`Amazon Alexa` `BUILD_TIME` 拡張機能は、Jackson JSON 変換で使用される Alexa SDK "
"からの依存ライブラリを追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:967
#, no-wrap
msgid ""
"   @BuildStep\n"
"    void addDependencies(BuildProducer<IndexDependencyBuildItem> "
"indexDependency) {\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-runtime\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-model\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-lambda-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-servlet-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-dynamodb-persistence-adapter\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-apache-client\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-model-runtime\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:970
#, fuzzy
msgid ""
"With the artifacts added to the `Jandex` indexer, you can now search the "
"index to identify classes implementing an interface, sub-classes of a "
"specific class, or classes with a target annotation."
msgstr ""
"`Jandex` "
"インデクサに追加された成果物により、インターフェイスを実装しているクラス、特定のクラスのサブクラス、ターゲットアノテーションを持つクラスを識別するためにインデックスを検索することができるようになりました。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:973
#, fuzzy
msgid ""
"For example, the `Jackson` extension uses code like below to search for "
"annotations used in JSON deserialization, and add them to the reflective "
"hierarchy for `BUILD_TIME` analysis."
msgstr ""
"例えば、 `Jackson` 拡張機能では、以下のようなコードを使用して、JSON デシリアライゼーションで使用されるアノテーションを検索し、 "
"`BUILD_TIME` 解析用のリフレクティブ階層に追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:978
#, no-wrap
msgid ""
"    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class."
"getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:980
#, no-wrap
msgid "    IndexView index = combinedIndexBuildItem.getIndex();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:989
#, no-wrap
msgid ""
"    // handle the various @JsonDeserialize cases\n"
"    for (AnnotationInstance deserializeInstance : index."
"getAnnotations(JSON_DESERIALIZE)) {\n"
"        AnnotationTarget annotationTarget = deserializeInstance.target();\n"
"        if (CLASS.equals(annotationTarget.kind())) {\n"
"            DotName dotName = annotationTarget.asClass().name();\n"
"            Type jandexType = Type.create(dotName, Type.Kind.CLASS);\n"
"            reflectiveHierarchyClass.produce(new "
"ReflectiveHierarchyBuildItem(jandexType));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:991
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:994
#, no-wrap
msgid "Configuration"
msgstr "設定"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:999
#, fuzzy
msgid ""
"Configuration in Quarkus is based on SmallRye Config, an implementation of "
"the MicroProfile Config specification.  All of the standard features of MP-"
"Config are supported; in addition, there are several extensions which are "
"made available by the SmallRye Config project as well as by Quarkus itself."
msgstr ""
"Quarkusでの設定は、MicroProfile Config仕様の実装であるSmallRye Configに基づいています。MP-"
"Configの標準機能はすべてサポートされています。さらに、SmallRye "
"ConfigプロジェクトやQuarkus自身が利用できる拡張機能もいくつかあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1001
#, fuzzy
msgid ""
"The value of these properties is configured in a `application.properties` "
"file that follows the MicroProfile config format."
msgstr ""
"これらのプロパティの値は、MicroProfile の設定形式に従う `application.properties` ファイルで設定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1003
#, fuzzy
msgid ""
"Configuration of Quarkus extensions is injection-based, using annotations."
msgstr "Quarkus拡張機能の設定は、アノテーションを使用してインジェクションベースで行われます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1004
#, no-wrap, fuzzy
msgid "Configuration Keys"
msgstr "設定キー"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1007
#, fuzzy
msgid ""
"Leaf configuration keys are mapped to non-`private` fields via the `@io."
"quarkus.runtime.annotations.ConfigItem` annotation."
msgstr ""
"リーフ構成キーは、 `@io.quarkus.runtime.annotations.ConfigItem` アノテーションを介して `private` "
"以外のフィールドにマッピングされます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1010
#, fuzzy
msgid ""
"Though the SmallRye Config project is used for implementation, the standard "
"`@ConfigProperty` annotation does not have the same semantics that are "
"needed to support configuration within extensions."
msgstr ""
"実装には SmallRye Config プロジェクトが使用されていますが、標準の `@ConfigProperty` "
"アノテーションは、拡張機能内での設定をサポートするために必要なセマンティクスを持っていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1013
#, fuzzy
msgid ""
"Configuration keys are normally derived from the field names that they are "
"tied to.  This is done by de-camel-casing the name and then joining the "
"segments with hyphens (`-`).  Some examples:"
msgstr ""
"設定キーは通常、関連付けられたフィールド名から派生します。これは、名前を脱キャメル化し、ハイフンでセグメントを結合することで行われます ( `-` "
")。いくつかの例を示します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1015
#, fuzzy
msgid "`bindAddress` becomes `bind-address`"
msgstr "`bindAddress` になります。 `bind-address`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1016
#, fuzzy
msgid "`keepAliveTime` becomes `keep-alive-time`"
msgstr "`keepAliveTime` になります。 `keep-alive-time`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1017
#, fuzzy
msgid "`requestDNSTimeout` becomes `request-dns-timeout`"
msgstr "`requestDNSTimeout` になります。 `request-dns-timeout`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1019
#, fuzzy
msgid ""
"The name can also be explicitly specified by giving a `name` attribute to "
"the `@ConfigItem` annotation."
msgstr "`@ConfigItem` アノテーションに `name` 属性を与えることで、名前を明示的に指定することもできます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1022
#, fuzzy
msgid ""
"Though it is possible to override the configuration key name using the "
"`name` attribute of `@ConfigItem`, normally this should only be done in "
"cases where (for example) the configuration key name is the same as a Java "
"keyword."
msgstr ""
"`@ConfigItem` の `name` 属性を使って設定キー名を上書きすることは可能ですが、通常は (たとえば) 設定キー名が Java "
"キーワードと同じ場合にのみ行うべきです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1023
#, no-wrap, fuzzy
msgid "Configuration Value types"
msgstr "設定値の種類"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1027
#, fuzzy
msgid ""
"The type of the field with the `@ConfigItem` annotation determines the "
"conversion that is applied to it.  Quarkus extensions may use the full range "
"of configuration types made available by SmallRye Config, which includes:"
msgstr ""
"`@ConfigItem` "
"アノテーションを持つフィールドのタイプによって、そのフィールドに適用される変換が決まります。Quarkus拡張機能では、SmallRye "
"Configで利用可能な設定タイプのすべてを使用することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1029
#, fuzzy
msgid "All primitive types and primitive wrapper types"
msgstr "すべてのプリミティブ型とプリミティブラッパー型"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1030
#, fuzzy
msgid "`String`"
msgstr "`String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1031
#, fuzzy
msgid ""
"Any type which has a constructor accepting a single argument of type "
"`String` or `CharSequence`"
msgstr "コンストラクタが `String` あるいは型の単一の引数を受け取る型。 `CharSequence`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1032
#, fuzzy
msgid ""
"Any type which has a static method named `of` which accepts a single "
"argument of type `String`"
msgstr "`of` という名前の静的メソッドを持ち、型の単一の引数を受け付ける型。 `String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1033
#, fuzzy
msgid ""
"Any type which has a static method named `valueOf` or `parse` which accepts "
"a single argument of type `CharSequence` or `String`"
msgstr ""
"`valueOf` または `parse` という名前の静的メソッドを持ち、 `CharSequence` または の型の単一の引数を受け取る型。 "
"`String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1034
#, fuzzy
msgid "`java.time.Duration`"
msgstr "`java.time.Duration`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1035
#, fuzzy
msgid "`java.util.regex.Pattern`"
msgstr "`java.util.regex.Pattern`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1036
#, fuzzy
msgid "`java.nio.file.Path`"
msgstr "`java.nio.file.Path`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1037
#, fuzzy
msgid "`io.quarkus.runtime.configuration.MemorySize` to represent data sizes"
msgstr "`io.quarkus.runtime.configuration.MemorySize` データサイズを表現するために"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1038
#, fuzzy
msgid ""
"`java.net.InetSocketAddress`, `java.net.InetAddress` and `org.wildfly.common."
"net.CidrAddress`"
msgstr ""
"`java.net.InetSocketAddress` , `java.net.InetAddress` `org.wildfly.common."
"net.CidrAddress`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1039
#, fuzzy
msgid "A `List` or `Optional` of any of the above types"
msgstr "上記のいずれかのタイプの `List` または `Optional`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1040
#, fuzzy
msgid "`OptionalInt`, `OptionalLong`, `OptionalDouble`"
msgstr "`OptionalInt` , `OptionalLong` . `OptionalDouble`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1043
#, fuzzy
msgid ""
"In addition, custom converters may be registered by adding their fully "
"qualified class name in file `META-INF/services/org.eclipse.microprofile."
"config.spi.Converter`."
msgstr ""
"さらに、カスタムコンバータは、ファイル `META-INF/services/org.eclipse.microprofile.config.spi."
"Converter` に完全修飾されたクラス名を追加して登録することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1045
#, fuzzy
msgid ""
"Though these implicit converters use reflection, Quarkus will automatically "
"ensure that they are loaded at the appropriate time."
msgstr "これらの暗黙のコンバータは反射を使用しますが、Quarkusは自動的に適切なタイミングでロードされるようにします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1046
#, no-wrap, fuzzy
msgid "Optional Values"
msgstr "オプション値"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1052
#, fuzzy
msgid ""
"If the configuration type is one of the optional types, then empty values "
"are allowed for the configuration key; otherwise, specification of an empty "
"value will result in a configuration error which prevents the application "
"from starting.  This is especially relevant to configuration properties of "
"inherently emptiable values such as `List`, `Set`, and `String`.  Such value "
"types will never be empty; in the event of an empty value, an empty "
"`Optional` is always used."
msgstr ""
"そうでない場合、空の値を指定すると設定エラーとなり、アプリケーションが起動できなくなります。これは特に、 `List` ・ `Set` ・ "
"`String` のような本質的に空の値を持つ設定プロパティに関係します。このような値型は決して空になることはありません。空の値の場合、常に空の "
"`Optional` が使われます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1053
#, no-wrap, fuzzy
msgid "Configuration Default Values"
msgstr "設定のデフォルト値"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1057
#, fuzzy
msgid ""
"A configuration item can be marked to have a default value.  The default "
"value is used when no matching configuration key is specified in the "
"configuration."
msgstr "構成項目には、デフォルト値を持つようにマークを付けることができます。既定値は、構成に一致する構成キーが指定されていない場合に使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1060
#, fuzzy
msgid ""
"Configuration items with a primitive type (such as `int` or `boolean`) "
"implicitly use a default value of `0` or `false`.  The sole exception to "
"this rule is the `char` type which does not have an implicit default value."
msgstr ""
"プリミティブ型（ `int` や `boolean` など）を持つ設定項目は、暗黙のうちに `0` や `false` "
"のデフォルト値を使用します。このルールの唯一の例外は、暗黙のデフォルト値を持たない `char` タイプです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1064
#, fuzzy
msgid ""
"A property with a default value is not implicitly optional.  If a non-"
"optional configuration item with a default value is explicitly specified to "
"have an empty value, the application will report a configuration error and "
"will not start.  If it is desired for a property to have a default value and "
"also be optional, it must have an `Optional` type as described above."
msgstr ""
"デフォルト値を持つプロパティは、暗黙のうちにオプションではありません。デフォルト値を持つオプションではない設定項目が空の値を持つように明示的に指定されている場合、アプリケーションは設定エラーを報告し、起動しません。プロパティにデフォルト値を持たせてオプションにしたい場合は、上述のように "
"`Optional` 型を持つ必要があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1065
#, no-wrap, fuzzy
msgid "Configuration Groups"
msgstr "設定グループ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1069
#, fuzzy
msgid ""
"Configuration values are always collected into grouping classes which are "
"marked with the `@io.quarkus.runtime.annotations.ConfigGroup` annotation.  "
"These classes contain a field for each key within its group.  In addition, "
"configuration groups can be nested."
msgstr ""
"設定値は常に `@io.quarkus.runtime.annotations.ConfigGroup` "
"アノテーションでマークされたグループ化クラスに集められます。これらのクラスには、グループ内の各キーのフィールドが含まれています。さらに、設定グループは入れ子にすることができます。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1070
#, no-wrap, fuzzy
msgid "Optional Configuration Groups"
msgstr "オプションの設定グループ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1076
#, fuzzy
msgid ""
"A nested configuration group may be wrapped with an `Optional` type.  In "
"this case, the group is not populated unless one or more properties within "
"that group are specified in the configuration.  If the group is populated, "
"then any required properties in the group must also be specified otherwise a "
"configuration error will be reported and the application will not start."
msgstr ""
"入れ子になっている設定グループは `Optional` "
"型で包まれている場合があります。この場合、そのグループ内の1つ以上のプロパティが設定で指定されていない限り、そのグループは生成されません。グループが設定されている場合は、そのグループ内の必須プロパティも指定しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1077
#, no-wrap, fuzzy
msgid "Configuration Maps"
msgstr "設定マップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1082
#, fuzzy
msgid ""
"A `Map` can be used for configuration at any position where a configuration "
"group would be allowed.  The key type of such a map *must* be `String`, and "
"its value may be either a configuration group class or a valid leaf type.  "
"The configuration key segment following the map's key segment will be used "
"as the key for map values."
msgstr ""
"`Map` は、構成グループが許可されている任意の位置で構成に使用できます。このようなマップのキー タイプは `String` である *必要があり* "
"、その値は構成グループ クラスまたは有効なリーフ タイプのいずれかである *必要* "
"があります。マップのキーセグメントに続く設定キーセグメントが、マップ値のキーとして使用されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1084
#, no-wrap, fuzzy
msgid "Configuration Roots"
msgstr "設定のルーツ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1090
#, fuzzy
msgid ""
"Configuration roots are configuration groups that appear in the root of the "
"configuration tree.  A configuration property's full name is determined by "
"joining the string `quarkus.` with the hyphenated name of the fields that "
"form the path from the root to the leaf field.  For example, if I define a "
"configuration root group called `ThreadPool`, with a nested group in a field "
"named `sizing` that in turn contains a field called `minSize`, the final "
"configuration property will be called `quarkus.thread-pool.sizing.min-size`."
msgstr ""
"構成ルートは、構成ツリーのルートに表示される構成グループです。構成プロパティのフルネームは、文字列 `quarkus.` と、ルートからリーフ "
"フィールドへのパスを形成するフィールドのハイフン名を結合することで決定されます。たとえば、 `ThreadPool` "
"という名前のコンフィギュレーション・ルート・グループを定義すると、 `sizing` という名前のフィールドに `minSize` "
"という名前のフィールドを含む入れ子のグループがあり、最終的なコンフィギュレーション・プロパティは `quarkus.thread-pool.sizing."
"min-size` と呼ばれるようになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1094
#, fuzzy
msgid ""
"A configuration root's name can be given with the `name` property, or it can "
"be inferred from the class name.  If the latter, then the configuration key "
"will be the class name, minus any `Config` or `Configuration` suffix, broken "
"up by camel-case, lowercased, and re-joined using hyphens (`-`)."
msgstr ""
"設定ルートの名前は `name` プロパティで指定することもできますし、クラス名から推測することもできます。後者の場合、設定キーはクラス名から "
"`Config` や `Configuration` の接尾辞を除いたものとなり、キャメルケースで区切って小文字にし、ハイフン ( `-` ) "
"で再結合されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1100
#, fuzzy
msgid ""
"A configuration root's class name can contain an extra suffix segment for "
"the case where there are configuration roots for multiple <<Configuration "
"Root Phases>>.  Classes which correspond to the `BUILD_TIME` and "
"`BUILD_AND_RUN_TIME_FIXED` may end with `BuildTimeConfig` or "
"`BuildTimeConfiguration`, classes which correspond to the `RUN_TIME` phase "
"may end with `RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` or "
"`RunTimeConfiguration` while classes which correspond to the `BOOTSTRAP` "
"configuration may end with `BootstrapConfig` or `BootstrapConfiguration`."
msgstr ""
"設定ルートのクラス名には、複数の link:#Configuration Root Phases[[設定ルートフェーズ]] "
"に対応する設定ルートがある場合のために、余分なサフィックスセグメントを含めることができます。 `BUILD_TIME` と "
"`BUILD_AND_RUN_TIME_FIXED` に対応するクラスは `BuildTimeConfig` または "
"`BuildTimeConfiguration` で終わるかもしれません。 `RUN_TIME` フェーズに対応するクラスは "
"`RuntimeConfig` , `RunTimeConfig` , `RuntimeConfiguration` , "
"`RunTimeConfiguration` で終わるかもしれませんが、 `BOOTSTRAP` 設定に対応するクラスは "
"`BootstrapConfig` または `BootstrapConfiguration` で終わるかもしれません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1104
#, fuzzy
msgid ""
"Note: The current implementation is still using injection site to determine "
"the root set, so to avoid migration problems, it is recommended that the "
"injection site (field or parameter) have the same name as the configuration "
"root class until this change is complete."
msgstr ""
"注: "
"現在の実装では、ルートセットを決定するためにインジェクションサイトを使用しているため、移行の問題を避けるために、この変更が完了するまではインジェクションサイト(フィールドまたはパラメータ)に設定ルートクラスと同じ名前を付けることをお勧めします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1105
#, no-wrap, fuzzy
msgid "Configuration Root Phases"
msgstr "設定ルートフェーズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1109
#, fuzzy
msgid ""
"Configuration roots are strictly bound by configuration phase, and "
"attempting to access a configuration root from outside of its corresponding "
"phase will result in an error.  A configuration root dictates when its "
"contained keys are read from configuration, and when they are available to "
"applications.  The phases defined by `io.quarkus.runtime.annotations."
"ConfigPhase` are as follows:"
msgstr ""
"コンフィギュレーション・ルートはコンフィギュレーション・フェイズに厳密に拘束されており、対応するフェイズの外からコンフィギュレーション・ルートにアクセスしようとするとエラーになります。コンフィギュレーションルートは、その中に含まれる鍵がいつコンフィギュレーションから読み出され、それがアプリケーションから利用可能になるかを決定します。 "
"`io.quarkus.runtime.annotations.ConfigPhase` で定義されているフェーズは以下の通りです。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1113
#, no-wrap, fuzzy
msgid "Phase name"
msgstr "フェーズ名"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1114
#, no-wrap, fuzzy
msgid "Read & avail. at build time"
msgstr "ビルド時に読み込んで利用することができます。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1115
#, no-wrap, fuzzy
msgid "Avail. at run time"
msgstr "実行時に利用可能"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1116
#, no-wrap, fuzzy
msgid "Read during static init"
msgstr "静的なinit時に読み込まれる"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1117
#, no-wrap, fuzzy
msgid "Re-read during startup (native executable)"
msgstr "起動時の再読込（ネイティブ実行ファイル"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1119
#, no-wrap, fuzzy
msgid "Notes"
msgstr "注意事項"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1120
#, no-wrap, fuzzy
msgid "BUILD_TIME"
msgstr "BUILD_TIME"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1121
#: upstream/_guides/writing-extensions.adoc:1128
#: upstream/_guides/writing-extensions.adoc:1129
#: upstream/_guides/writing-extensions.adoc:1136
#: upstream/_guides/writing-extensions.adoc:1138
#: upstream/_guides/writing-extensions.adoc:1143
#: upstream/_guides/writing-extensions.adoc:1144
#: upstream/_guides/writing-extensions.adoc:1145
#, no-wrap, fuzzy
msgid "✓"
msgstr "✓"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1122
#: upstream/_guides/writing-extensions.adoc:1123
#: upstream/_guides/writing-extensions.adoc:1124
#: upstream/_guides/writing-extensions.adoc:1130
#: upstream/_guides/writing-extensions.adoc:1131
#: upstream/_guides/writing-extensions.adoc:1135
#: upstream/_guides/writing-extensions.adoc:1137
#: upstream/_guides/writing-extensions.adoc:1142
#, no-wrap, fuzzy
msgid "✗"
msgstr "✗"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1126
#, no-wrap, fuzzy
msgid "Appropriate for things which affect build."
msgstr "造形に影響を与えるものに適しています。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1127
#, no-wrap, fuzzy
msgid "BUILD_AND_RUN_TIME_FIXED"
msgstr "BUILD_AND_RUN_TIME_FIXED"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1133
#, no-wrap, fuzzy
msgid ""
"Appropriate for things which affect build and must be visible for run time "
"code.  Not read from config at run time."
msgstr "ビルドに影響を与え、実行時のコードが見えるようにしなければならないものに適しています。実行時に設定から読み込まない。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1134
#, no-wrap, fuzzy
msgid "BOOTSTRAP"
msgstr "ブーツストラップ"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1140
#, no-wrap, fuzzy
msgid ""
"Used when runtime configuration needs to be obtained from an external system "
"(like `Consul`), but details of that system need to be configurable (for "
"example Consul's URL). The high level way this works is by using the "
"standard Quarkus config sources (such as properties files, system "
"properties, etc.) and producing `ConfigSourceProvider` objects which are "
"subsequently taken into account by Quarkus when creating the final runtime "
"`Config` object."
msgstr ""
"ランタイム設定を外部システム（ `Consul` "
"など）から取得する必要があるが、そのシステムの詳細を設定可能にする必要がある場合に使用します（ConsulのURLなど）。これは、Quarkusの標準的な設定ソース（プロパティファイル、システムプロパティなど）を使用して、 "
"`ConfigSourceProvider` オブジェクトを作成し、最終的なランタイム `Config` "
"オブジェクトを作成する際にQuarkusによって考慮されます。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1141
#, no-wrap, fuzzy
msgid "RUN_TIME"
msgstr "ランタイム"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1147
#, no-wrap, fuzzy
msgid "Not available at build, read at start in all modes."
msgstr "ビルド時には利用できず、すべてのモードで開始時に読み込まれます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1150
#, fuzzy
msgid ""
"For all cases other than the `BUILD_TIME` case, the configuration root class "
"and all of the configuration groups and types contained therein must be "
"located in, or reachable from, the extension's run time artifact.  "
"Configuration roots of phase `BUILD_TIME` may be located in or reachable "
"from either of the extension's run time or deployment artifacts."
msgstr ""
"`BUILD_TIME` "
"以外のすべてのケースでは、設定ルートクラスと、そこに含まれるすべての設定グループと型は、拡張機能のランタイム・アーティファクト内にあるか、拡張機能のランタイム・アーティファクトからアクセス可能でなければなりません。フェーズ "
"`BUILD_TIME` "
"の設定ルートは、拡張機能のランタイム・アーティファクトまたはデプロイメント・アーティファクトのいずれかにあるか、またはそこから到達可能なものでなければなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1152
#, fuzzy
msgid ""
"_Bootstrap_ configuration steps are executed during runtime-init *before* "
"any of other runtime steps. This means that code executed as part of this "
"step cannot access anything that gets initialized in runtime init steps "
"(runtime synthetic CDI beans being one such example)."
msgstr ""
"_Bootstrap_ 設定ステップは、他のランタイム・ステップより *も前に* "
"ランタイム・initの間に実行されます。これは、このステップの一部として実行されるコードは、ランタイムinitステップで初期化されるものにアクセスできないことを意味します（ランタイム合成CDIビーンズはそのような例の一つです）。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1153
#, no-wrap, fuzzy
msgid "Configuration Example"
msgstr "設定例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1160
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.ConfigItem;\n"
"import io.quarkus.runtime.annotations.ConfigGroup;\n"
"import io.quarkus.runtime.annotations.DefaultConverter\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1163
#, no-wrap
msgid "import java.io.File;\n"
"import java.util.logging.Level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1166
#, no-wrap
msgid "@ConfigGroup <1>\n"
"public class FileConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1172
#, no-wrap
msgid ""
"    /**\n"
"     * Enable logging to a file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"true\")\n"
"    boolean enable;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1178
#, no-wrap
msgid ""
"    /**\n"
"     * The log format.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p "
"[%c{1.}] (%t) %s%e%n\")\n"
"    String format;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1184
#, no-wrap
msgid ""
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1190
#, no-wrap
msgid ""
"    /**\n"
"     * The name of the file in which logs will be written.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"application.log\")\n"
"    File path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1192
#: upstream/_guides/writing-extensions.adoc:1397
#: upstream/_guides/writing-extensions.adoc:1904
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1198
#, no-wrap
msgid ""
"/**\n"
" * Logging configuration.\n"
" */\n"
"@ConfigRoot(phase = ConfigPhase.RUN_TIME) <2>\n"
"public class LogConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1200
#, no-wrap
msgid "    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1206
#, no-wrap
msgid ""
"    /**\n"
"     * Configuration properties for the logging file handler.\n"
"     */\n"
"    FileConfig file;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1209
#, no-wrap
msgid "public class LoggingProcessor {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1216
#, no-wrap
msgid ""
"    /**\n"
"     * Logging configuration.\n"
"     */\n"
"    <3>\n"
"    LogConfiguration config;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1220
#, fuzzy
msgid ""
"A configuration property name can be split into segments. For example, a "
"property name like `quarkus.log.file.enable` can be split into the following "
"segments:"
msgstr ""
"構成プロパティ名は、セグメントに分割することができます。例えば、 `quarkus.log.file.enable` "
"のようなプロパティ名は、以下のセグメントに分割することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1222
#, fuzzy
msgid ""
"`quarkus` - a namespace claimed by Quarkus which is a prefix for all "
"`@ConfigRoot` classes,"
msgstr "`quarkus` - Quarkusによって主張された名前空間で、すべての `@ConfigRoot` クラスのプレフィックスです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1223
#, fuzzy
msgid ""
"`log` - a name segment which corresponds to the `LogConfiguration` class "
"annotated with `@ConfigRoot`,"
msgstr "`log` - `@ConfigRoot` でアノテーションされた `LogConfiguration` クラスに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1224
#, fuzzy
msgid ""
"`file` - a name segment which corresponds to the `file` field in this class,"
msgstr "`file` - このクラスの `file` フィールドに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1225
#, fuzzy
msgid ""
"`enabled` - a name segment which corresponds to `enable` field in "
"`FileConfig` class annotated with `@ConfigGroup`."
msgstr ""
"`enabled` - `@ConfigGroup` でアノテーションされた `FileConfig` クラスの `enable` "
"フィールドに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1229
#, fuzzy
msgid ""
"The `FileConfig` class is annotated with `@ConfigGroup` to indicate that "
"this is an aggregate configuration object containing a collection of "
"configurable properties, rather than being a simple configuration key type."
msgstr ""
"`FileConfig` クラスには `@ConfigGroup` "
"というアノテーションが付けられており、これは単純な構成キー型ではなく、構成可能なプロパティのコレクションを含む集約的な構成オブジェクトであることを示しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1234
#, fuzzy
msgid ""
"The `@ConfigRoot` annotation indicates that this object is a configuration "
"root group, in this case one which corresponds to a `log` segment. A class "
"name is used to link configuration root group with the segment from a "
"property name. The `Configuration` part is stripped off from a "
"`LogConfiguration` class name and the remaining `Log` is lowercased to "
"become a `log`. Since all `@ConfigRoot` annotated classes uses `quarkus` as "
"a prefix, this finally becomes `quarkus.log` and represents the properties "
"which names begin with `quarkus.log.*`."
msgstr ""
"`@ConfigRoot` アノテーションは、このオブジェクトが構成ルート・グループであることを示し、この場合は `log` "
"セグメントに対応するものです。クラス名は、プロパティ名からセグメントとコンフィギュレーション・ルート・グループをリンクするために使用されます。 "
"`Configuration` の部分は `LogConfiguration` のクラス名から取り除かれ、残りの `Log` は小文字化されて "
"`log` になります。 `@ConfigRoot` アノテーションされたクラスはすべて `quarkus` "
"をプレフィックスとして使用しているため、最終的に `quarkus.log` となり、 `quarkus.log.*` "
"で始まる名前のプロパティを表します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1236
#, fuzzy
msgid ""
"Here the `LoggingProcessor` injects a `LogConfiguration` instance "
"automatically by detecting the `@ConfigRoot` annotation."
msgstr ""
"ここでは `LoggingProcessor` は `@ConfigRoot` アノテーションを検出して `LogConfiguration` "
"インスタンスを自動的に注入します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1238
#, fuzzy
msgid ""
"A corresponding `application.properties` for the above example could be:"
msgstr "上記の例に対応する `application.properties` は、次のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1244
#, no-wrap
msgid ""
"quarkus.log.file.enable=true\n"
"quarkus.log.file.level=DEBUG\n"
"quarkus.log.file.path=/tmp/debug.log\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1247
#, fuzzy
msgid ""
"Since `format` is not defined in these properties, the default value from "
"`@ConfigItem` will be used instead."
msgstr "これらのプロパティでは `format` が定義されていないので、代わりに `@ConfigItem` のデフォルト値が使用されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1249
#, no-wrap, fuzzy
msgid "Enhanced conversion"
msgstr "強化された変換"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1253
#, fuzzy
msgid ""
"You can use enhanced conversion of a config item by using the `@ConvertWith` "
"annotation which accepts a `Converter` class object.  If the annotation is "
"present on a config item, the implicit or custom built in converter in use "
"will be overridden by the value provided.  To do, see the example below "
"which converts `YES` or `NO` values to `boolean`."
msgstr ""
"`Converter` クラス・オブジェクトを受け付ける `@ConvertWith` "
"アノテーションを使用することで、コンフィグ項目の拡張変換を使用することができます。アノテーションが設定項目に存在する場合、使用中の暗黙の、あるいはカスタムのビルトインコンバータは、提供された値によって上書きされます。これを行うには、 "
"`YES` または `NO` の値を `boolean` に変換する以下の例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1263
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Config item with enhanced converter\n"
"     */\n"
"    @ConvertWith(YesNoConverter.class) // <1>\n"
"    @ConfigItem(defaultValue = \"NO\")\n"
"    Boolean answer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1266
#, no-wrap
msgid ""
"    public static class YesNoConverter implements Converter<Boolean> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1268
#, no-wrap
msgid "        public YesNoConverter() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1274
#, no-wrap
msgid ""
"        @Override\n"
"        public Boolean convert(String s) {\n"
"            if (s == null || s.isEmpty()) {\n"
"                return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1281
#, no-wrap
msgid ""
"            switch (s) {\n"
"                case \"YES\":\n"
"                    return true;\n"
"                case \"NO\":\n"
"                    return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1286
#, no-wrap
msgid ""
"            throw new IllegalArgumentException(\"Unsupported value \" + s + "
"\" given\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1288
#, fuzzy
msgid ""
"Override the default `Boolean` converter and use the provided converter "
"which accepts a `YES` or `NO` config values."
msgstr ""
"デフォルトの `Boolean` コンバータを上書きし、 `YES` または `NO` の設定値を受け付ける提供されたコンバータを使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1291
#, fuzzy
msgid "The corresponding `application.properties` will look like."
msgstr "対応する `application.properties` は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1294
#, no-wrap
msgid "quarkus.some.answer=YES\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1299
#, fuzzy
msgid ""
"Enum values (config items) are translated to skewed-case (hyphenated) by "
"default. The table below illustrates an enum name and their canonical "
"equivalence:"
msgstr ""
"列挙型の値(設定項目)は、デフォルトではスキューテッド・ケース(ハイフン付き)に変換されます。以下の表は、列挙型名とその正準等価性を示しています。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1301
#, no-wrap, fuzzy
msgid "Java enu"
msgstr "ジャワエヌ"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1303
#, no-wrap, fuzzy
msgid "Canonical equivalent"
msgstr "正準等価"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1304
#, no-wrap, fuzzy
msgid "DISCARD"
msgstr "ディカード"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1306
#, no-wrap, fuzzy
msgid "discard"
msgstr "棄てる"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1307
#, no-wrap, fuzzy
msgid "READ_UNCOMMITTED"
msgstr "READ_UNCOMMITTED"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1309
#, no-wrap, fuzzy
msgid "read-uncommitted"
msgstr "よみとりアンコミット"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1310
#, no-wrap, fuzzy
msgid "SIGUSR1"
msgstr "シグナスアールワン"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1312
#, no-wrap, fuzzy
msgid "sigusr1"
msgstr "シグスラーワン"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1313
#, no-wrap, fuzzy
msgid "JavaEnum"
msgstr "ジャワエンナム"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1315
#, no-wrap, fuzzy
msgid "java-enum"
msgstr "ジャワエノナム"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1316
#, no-wrap, fuzzy
msgid "MAKING_LifeDifficult"
msgstr "MAKING_LifeDifficult"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1318
#, no-wrap, fuzzy
msgid "making-life-difficult"
msgstr "困難化"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1319
#, no-wrap, fuzzy
msgid "YeOldeJBoss"
msgstr "ＹｅｏｌｄｅＪBoss"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1321
#, no-wrap, fuzzy
msgid "ye-olde-jboss"
msgstr "ヨールドジェイボス"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1322
#, no-wrap, fuzzy
msgid "camelCaseEnum"
msgstr "ラクダケースエンナム"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1324
#, no-wrap, fuzzy
msgid "camel-case-enum"
msgstr "駱駝ケース列挙"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1327
#, fuzzy
msgid ""
"To use the default behaviour which is based on implicit converter or a "
"custom defined one add `@DefaultConverter` annotation to the configuration "
"item"
msgstr ""
"暗黙のコンバータまたはカスタム定義されたコンバータに基づくデフォルトの動作を使用するには、設定項目に `@DefaultConverter` "
"アノテーションを追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1338
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeLogConfig {\n"
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @DefaultConverter // <1>\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1340
#, fuzzy
msgid ""
"Use the default converter (built in or a custom converter) to convert `Level."
"class` enum."
msgstr "`Level.class` enum を変換するには、デフォルトのコンバータ（内蔵またはカスタムコンバータ）を使用します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1343
#, no-wrap, fuzzy
msgid "Conditional Step Inclusion"
msgstr "条件付きステップインクルージョン"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1349
#, fuzzy
msgid ""
"It is possible to only include a given `@BuildStep` under certain conditions."
"  The `@BuildStep` annotation has two optional parameters: `onlyIf` and "
"`onlyIfNot`.  These parameters can be set to one or more classes which "
"implement `BooleanSupplier`.  The build step will only be included when the "
"method returns `true` (for `onlyIf`) or `false` (for `onlyIfNot`)."
msgstr ""
"特定の条件下では、与えられた `@BuildStep` のみを含めることが可能です。 `@BuildStep` アノテーションには、 `onlyIf` "
"と `onlyIfNot` の 2 つのオプションのパラメータがあります。これらのパラメータは、 `BooleanSupplier` を実装した 1 "
"つ以上のクラスに設定できます。ビルド・ステップは、メソッドが `true` (for `onlyIf` ) または `false` (for "
"`onlyIfNot` ) を返した場合にのみ含まれます。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1352
#, fuzzy
msgid ""
"The condition class can inject <<configuration-roots,configuration roots>> "
"as long as they belong to a build-time phase.  Run time configuration is not "
"available for condition classes."
msgstr ""
"条件クラスは、ビルド時のフェーズに属している限り、 link:#configuration-roots[設定のルートを] "
"注入することができます。ランタイム設定は条件クラスでは利用できません。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1355
#, fuzzy
msgid ""
"The condition class may also inject a value of type `io.quarkus.runtime."
"LaunchMode`.  Constructor parameter and field injection is supported."
msgstr ""
"条件クラスは、型 `io.quarkus.runtime.LaunchMode` "
"の値を注入することもできます。コンストラクタのパラメータとフィールドの注入がサポートされています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:1356
#, no-wrap, fuzzy
msgid "An example of a conditional build step"
msgstr "条件付きビルドステップの例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1363
#, no-wrap
msgid ""
"@BuildStep(onlyIf = IsDevMode.class)\n"
"LogCategoryBuildItem enableDebugLogging() {\n"
"    return new LogCategoryBuildItem(\"org.your.quarkus.extension\", Level."
"DEBUG);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1366
#, no-wrap
msgid ""
"static class IsDevMode implements BooleanSupplier {\n"
"    LaunchMode launchMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1371
#, no-wrap
msgid ""
"    public boolean getAsBoolean() {\n"
"        return launchMode == LaunchMode.DEVELOPMENT;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1374
#, no-wrap, fuzzy
msgid "Bytecode Recording"
msgstr "バイトコード記録"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1378
#, fuzzy
msgid ""
"One of the main outputs of the build process is recorded bytecode. This "
"bytecode actually sets up the runtime environment. For example, in order to "
"start Undertow, the resulting application will have some bytecode that "
"directly registers all Servlet instances and then starts Undertow."
msgstr ""
"ビルドプロセスの主な出力の一つは、記録されたバイトコードです。このバイトコードは実際にランタイム環境を設定します。例えば、Undertowを起動するために、結果として得られるアプリケーションは、すべてのサーブレットインスタンスを直接登録してUndertowを起動するバイトコードを持つことになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1384
#, fuzzy
msgid ""
"As writing bytecode directly is complex, this is instead done via bytecode "
"recorders. At deployment time, invocations are made on recorder objects that "
"contain the actual runtime logic, but instead of these invocations "
"proceeding as normal they are intercepted and recorded (hence the name). "
"This recording is then used to generate bytecode that performs the same "
"sequence of invocations at runtime. This is essentially a form of deferred "
"execution where invocations made at deployment time get deferred until "
"runtime."
msgstr ""
"バイトコードを直接書くのは複雑なので、代わりにバイトコードレコーダを使って行います。デプロイ時には、実際のランタイムロジックを含むレコーダオブジェクト上で呼び出しが行われますが、これらの呼び出しは通常通りに進行するのではなく、傍受されて記録されます（この名前の由来）。この記録は、実行時に同じシーケンスの呼び出しを実行するバイトコードを生成するために使用されます。これは基本的には繰延実行の一形態で、デプロイ時に行われた呼び出しは実行時まで延期されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1386
#, fuzzy
msgid ""
"Let's look at the classic 'Hello World' type example. To do this the Quarkus "
"way we would create a recorder as follows:"
msgstr "古典的な「Hello World」タイプの例を見てみましょう。これをQuarkusの方法で行うには、次のようにレコーダーを作成します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1391
#, no-wrap
msgid "@Recorder\n"
"class HelloRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1395
#, no-wrap
msgid ""
"  public void sayHello(String name) {\n"
"    System.out.println(\"Hello\" + name);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1400
#, fuzzy
msgid "And then create a build step that uses this recorder:"
msgstr "そして、このレコーダーを使用するビルドステップを作成します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1408
#, no-wrap
msgid ""
"@Record(RUNTIME_INIT)\n"
"@BuildStep\n"
"public void helloBuildStep(HelloRecorder recorder) {\n"
"    recorder.sayHello(\"World\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1413
#, fuzzy
msgid ""
"When this build step is run nothing is printed to the console. This is "
"because the `HelloRecorder` that is injected is actually a proxy that "
"records all invocations. Instead if we run the resulting Quarkus program we "
"will see 'Hello World' printed to the console."
msgstr ""
"このビルドステップを実行してもコンソールには何も表示されません。これは、注入された `HelloRecorder` "
"が実際にはすべての呼び出しを記録するプロキシだからです。その代わり、結果のQuarkusプログラムを実行すると、コンソールに「Hello "
"World」が表示されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1418
#, fuzzy
msgid ""
"Methods on a recorder can return a value, which must be proxiable (if you "
"want to return a non-proxiable item wrap it in `io.quarkus.runtime."
"RuntimeValue`). These proxies may not be invoked directly, however they can "
"be passed into other recorder methods. This can be any recorder method, "
"including from other `@BuildStep` methods, so a common pattern is to produce "
"`BuildItem` instances that wrap the results of these recorder invocations."
msgstr ""
"レコーダーのメソッドは値を返すことができますが、その値はプロキシ可能なものでなければなりません (プロキシ不可能な項目を返したい場合は `io."
"quarkus.runtime.RuntimeValue` "
"でラップしてください)。これらのプロキシは直接呼び出すことはできませんが、他のレコーダのメソッドに渡すことができます。これは、他の "
"`@BuildStep` メソッドからも含めて、どのレコーダ・メソッドでもよいので、これらのレコーダ呼び出しの結果をラップした `BuildItem` "
"インスタンスを生成するのが一般的なパターンです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1422
#, fuzzy
msgid ""
"For instance, in order to make arbitrary changes to a Servlet deployment "
"Undertow has a `ServletExtensionBuildItem`, which is a `MultiBuildItem` that "
"wraps a `ServletExtension` instance. I can return a `ServletExtension` from "
"a recorder in another module, and Undertow will consume it and pass it into "
"the recorder method that starts Undertow."
msgstr ""
"例えば、サーブレットのデプロイメントに任意の変更を加えるために、Undertow には `ServletExtensionBuildItem` があり、 "
"`ServletExtension` インスタンスをラップする `MultiBuildItem` があります。別のモジュールのレコーダから "
"`ServletExtension` を返すと、Undertow はそれを消費して Undertow を起動するレコーダメソッドに渡します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1426
#, fuzzy
msgid ""
"At runtime the bytecode will be invoked in the order it is generated. This "
"means that build step dependencies implicitly control the order that "
"generated bytecode is run. In the example above we know that the bytecode "
"that produces a `ServletExtensionBuildItem` will be run before the bytecode "
"that consumes it."
msgstr ""
"実行時には、バイトコードは生成された順番で呼び出されます。つまり、ビルドステップの依存関係は、生成されたバイトコードが実行される順序を暗黙的に制御することを意味します。上の例では、 "
"`ServletExtensionBuildItem` を生成するバイトコードは、それを消費するバイトコードの前に実行されることがわかっています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1428
#, fuzzy
msgid "The following objects can be passed to recorders:"
msgstr "以下のオブジェクトをレコーダに渡すことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1430
#, fuzzy
msgid "Primitives"
msgstr "プリミティブ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1431
#, fuzzy
msgid "String"
msgstr "ひもじ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1432
#, fuzzy
msgid "Class<?> objects"
msgstr "クラス<?"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1433
#, fuzzy
msgid "Objects returned from a previous recorder invocation"
msgstr "前回のレコーダの呼び出しから返されたオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1434
#, fuzzy
msgid ""
"Objects with a no-arg constructor and getter/setters for all properties (or "
"public fields)"
msgstr "すべてのプロパティ (またはパブリックフィールド) のための、引数なしのコンストラクタとゲッター/セッターを持つオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1435
#, fuzzy
msgid ""
"Objects with a constructor annotated with `@RecordableConstructor` with "
"parameter names that match field names"
msgstr ""
"フィールド名と一致するパラメータ名を持つ `@RecordableConstructor` でアノテーションされたコンストラクタを持つオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1436
#, fuzzy
msgid ""
"Any arbitrary object via the `io.quarkus.deployment.recording."
"RecorderContext#registerSubstitution(Class, Class, Class)` mechanism"
msgstr ""
"`io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, "
"Class, Class)` メカニズムを介した任意のオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1437
#, fuzzy
msgid "Arrays, Lists and Maps of the above"
msgstr "上記の配列、リスト、マップ"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1439
#, no-wrap, fuzzy
msgid "RecorderContext"
msgstr "レコーダコンテキスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1445
#, fuzzy
msgid ""
"`io.quarkus.deployment.recording.RecorderContext` provides some convenience "
"methods to enhance bytecode recording, this includes the ability to register "
"creation functions for classes without no-arg constructors, to register an "
"object substitution (basically a transformer from a non-serializable object "
"to a serializable one and vice versa), and to create a class proxy. This "
"interface can be directly injected as a method parameter into any `@Record` "
"method."
msgstr ""
"`io.quarkus.deployment.recording.RecorderContext` "
"はバイトコード記録を強化するための便利なメソッドをいくつか提供しています。これには、no-arg "
"のコンストラクタを使用しないクラスの作成関数の登録、オブジェクト置換の登録（基本的にはシリアライズ可能でないオブジェクトからシリアライズ可能なオブジェクトへの変換、およびその逆）、およびクラスプロキシの作成機能が含まれています。このインターフェイスは、 "
"`@Record` の任意のメソッドにメソッドパラメータとして直接注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1449
#, fuzzy
msgid ""
"Calling `classProxy` with a given class name will create a `Class` that can "
"be passed into recorder methods, and at runtime will be substituted with the "
"class whose name was passed in to `classProxy`. This is basically a "
"convenience to avoid the need to explicitly load classes in the recorders."
msgstr ""
"指定したクラス名で `classProxy` を呼び出すと、レコーダのメソッドに渡すことができる `Class` が作成され、実行時には "
"`classProxy` "
"に渡された名前のクラスで置き換えられます。これは基本的には、レコーダで明示的にクラスをロードする必要がないようにするための便宜的なものです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1450
#, no-wrap, fuzzy
msgid "Printing step execution time"
msgstr "印刷ステップ実行時間"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1455
#, fuzzy
msgid ""
"At times, it can be useful to know how the exact time each startup task "
"(which is the result of each bytecode recording) takes when the application "
"is run.  The simplest way to determine this information is to set the "
"`quarkus.debug.print-startup-times` property to `true` when running the "
"application.  The output will look something like:"
msgstr ""
"時には、アプリケーションの実行時に各起動タスク（各バイトコードの記録の結果である）がどのくらいの正確な時間を要するかを知ることが有用です。この情報を知る最も簡単な方法は、アプリケーションの実行時に "
"`quarkus.debug.print-startup-times` プロパティを `true` に設定することです。出力は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1468
#, no-wrap
msgid ""
"Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: "
"42ms\n"
"Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed "
"in: 4ms\n"
"Build step SyntheticBeansProcessor.initRuntime completed in: 0ms\n"
"Build step ConfigBuildStep.validateConfigProperties completed in: 1ms\n"
"Build step ResteasyStandaloneBuildStep.boot completed in: 95ms\n"
"Build step VertxHttpProcessor.initializeRouter completed in: 1ms\n"
"Build step VertxHttpProcessor.finalizeRouter completed in: 4ms\n"
"Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms\n"
"Build step VertxHttpProcessor.openSocket completed in: 93ms\n"
"Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms\n"
msgstr ""

#. TODO: config integration
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1473
#, no-wrap, fuzzy
msgid "Contexts and Dependency Injection"
msgstr "コンテキストと依存性インジェクション"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1475
#, no-wrap, fuzzy
msgid "Extension Points"
msgstr "拡張ポイント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1480
#, fuzzy
msgid ""
"As a CDI based runtime, Quarkus extensions often make CDI beans available as "
"part of the extension behavior.  However, Quarkus DI solution does not "
"support CDI Portable Extensions.  Instead, Quarkus extensions can make use "
"of various link:cdi-reference[Build Time Extension Points]."
msgstr ""
"CDIベースのランタイムとして、Quarkusの拡張機能では、拡張機能の動作の一部としてCDIビーンズを利用できるようにすることがよくあります。しかし、Quarkus "
"DIソリューションはCDIポータブル拡張をサポートしていません。代わりに、Quarkusの拡張機能は、さまざまな link:cdi-"
"reference[Build Time Extension Pointsを] 利用することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1481
#, no-wrap, fuzzy
msgid "Quarkus DEV Console"
msgstr "Quarkus DEVコンソール"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1484
#, fuzzy
msgid ""
"You can make your extension support the link:dev-console[Quarkus DEV "
"Console] for a greater developer experience."
msgstr ""
"拡張機能を link:dev-console[Quarkus DEV Console] "
"に対応させて、開発者のエクスペリエンスを向上させることができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1485
#, no-wrap, fuzzy
msgid "Extension Health Check"
msgstr "拡張健康診断"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1488
#, fuzzy
msgid ""
"Health checks are provided via the `quarkus-smallrye-health` extension. It "
"provides both liveness and readiness checks capabilities."
msgstr ""
"健康チェックは `quarkus-smallrye-health` "
"の拡張子を介して提供されます。これは、活力と準備状態のチェック機能の両方を提供します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1490
#, fuzzy
msgid ""
"When writing an extension, it's beneficial to provide health checks for the "
"extension, that can be automatically included without the developer needing "
"to write their own."
msgstr "拡張機能を書くときには、開発者が自分で書かなくても自動的に含まれるようにすることができる拡張機能のヘルスチェックを提供することが有益です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1492
#, fuzzy
msgid "In order to provide a health check, you should do the following:"
msgstr "健康診断を行うためには、以下のようにしましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1495
#, fuzzy
msgid ""
"Import the `quarkus-smallrye-health` extension as an **optional** dependency "
"in your runtime module so it will not impact the size of the application if "
"health check is not included."
msgstr ""
"`quarkus-smallrye-health` 拡張モジュールを *オプションの* "
"依存関係としてランタイムモジュールにインポートすることで、ヘルスチェックが含まれていない場合でもアプリケーションのサイズに影響を与えないようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1497
#, fuzzy
msgid ""
"Create your health check following the link:microprofile-health[Quarkus - "
"MicroProfile Health] guide. We advise providing only readiness check for an "
"extension (liveness check is designed to express the fact that an "
"application is up and needs to be lightweight)."
msgstr ""
"link:microprofile-health[Quarkus - MicroProfile Health] "
"ガイドに従って、ヘルスチェックを作成します。拡張機能のレディネスチェックのみを提供することをお勧めします（ライブネスチェックは、アプリケーションが起動していることや軽量化が必要であることを表現するために設計されています）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1498
#, fuzzy
msgid ""
"Import the `quarkus-smallrye-health-spi` library in your deployment module."
msgstr "デプロイメント モジュールに `quarkus-smallrye-health-spi` ライブラリをインポートします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1499
#, fuzzy
msgid ""
"Add a build step in your deployment module that produces a `HealthBuildItem`."
""
msgstr "デプロイメントモジュールにビルドステップを追加して、 `HealthBuildItem` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1500
#, fuzzy
msgid ""
"Add a way to disable the extension health check via a config item `quarkus."
"<extension>.health.enabled` that should be enabled by default."
msgstr ""
"デフォルトで有効になっているはずの設定項目 `quarkus.<extension>.health.enabled` "
"を介して、拡張機能のヘルスチェックを無効にする方法を追加しました。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1502
#, fuzzy
msgid ""
"Following is an example from the Agroal extension that provides a "
"`DataSourceHealthCheck` to validate the readiness of a datasource."
msgstr ""
"以下は、データソースの準備状況を検証するために `DataSourceHealthCheck` を提供する Agroal 拡張モジュールの例です。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1510
#, no-wrap
msgid ""
"@BuildStep\n"
"HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) "
"{\n"
"    return new HealthBuildItem(\"io.quarkus.agroal.runtime.health."
"DataSourceHealthCheck\",\n"
"            agroalBuildTimeConfig.healthEnabled);\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1512
#, no-wrap, fuzzy
msgid "Extension Metrics"
msgstr "拡張メトリクス"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1517
#, fuzzy
msgid ""
"The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` "
"extension provide support for collecting metrics.  As a compatibility note, "
"the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer "
"library primitives, so the `quarkus-micrometer` extension can be enabled "
"without breaking code that relies on the MP Metrics API.  Note that the "
"metrics emitted by Micrometer are different, see the `quarkus-micrometer` "
"extension documentation for more information."
msgstr ""
"`quarkus-micrometer` 拡張モジュールと `quarkus-smallrye-metrics` "
"拡張モジュールは、メトリクスを収集するためのサポートを提供します。互換性についての注意点として、 `quarkus-micrometer` "
"拡張モジュールは MP Metrics API を Micrometer ライブラリのプリミティブに適応させているので、MP Metrics API "
"に依存しているコードを壊すことなく `quarkus-micrometer` 拡張モジュールを有効にすることができます。Micrometer "
"が出力するメトリクスは異なることに注意してください。詳細は `quarkus-micrometer` 拡張モジュールのドキュメントを参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1519
#, fuzzy
msgid ""
"The compatibility layer for MP Metrics APIs will move to a different "
"extension in the future."
msgstr "MP Metrics API の互換性レイヤは、将来的には別の拡張機能に移行する予定です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1521
#, fuzzy
msgid ""
"There are two broad patterns that extensions can use to interact with an "
"optional metrics extension to add their own metrics:"
msgstr ""
"このような場合、「Element Import」（インポート）は、「Element Import」（インポート）と呼ばれ、「Element "
"Import」（インポート）は、「Element Import」（インポート）と呼ばれます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1523
#, fuzzy
msgid ""
"Consumer pattern: An extension declares a `MetricsFactoryConsumerBuildItem` "
"and uses that to provide a bytecode recorder to the metrics extension. When "
"the metrics extension has initialized, it will iterate over registered "
"consumers to initialize them with a `MetricsFactory`. This factory can be "
"used to declare API-agnostic metrics, which can be a good fit for extensions "
"that provide an instrumentable object for gathering statistics (e.g. "
"Hibernate's `Statistics` class)."
msgstr ""
"コンシューマパターン。拡張機能は `MetricsFactoryConsumerBuildItem` "
"を宣言し、それを使ってメトリクス拡張機能にバイトコード・レコーダを提供します。 `MetricsFactory` "
"このように、このクラスでは、「Element Import」という名前のクラスを使用しています。このファクトリは、API "
"にとらわれないメトリクスを宣言するために使用することができ、統計情報を収集するための計測可能なオブジェクトを提供する拡張機能（Hibernate の "
"`Statistics` クラスなど）に適しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1525
#, fuzzy
msgid ""
"Binder pattern: An extension can opt to use completely different gathering "
"implementations depending on the metrics system. An "
"`Optional<MetricsCapabilityBuildItem> metricsCapability` build step "
"parameter can be used to declare or otherwise initialize API-specific "
"metrics based on the active metrics extension (e.g. \"smallrye-metrics\" or "
"\"micrometer\"). This pattern can be combined with the consumer pattern by "
"using `MetricsFactory::metricsSystemSupported()` to test the active metrics "
"extension within the recorder."
msgstr ""
"バインダーパターン。このような場合には、「Element Import」（要素）は、「Element Import」（要素）と呼ばれ、「Element "
"Import」（要素）は、「Element Import」（要素）と呼ばれます。 "
"`Optional<MetricsCapabilityBuildItem> metricsCapability` "
"ビルドステップパラメータを使用して、アクティブなメトリクス拡張に基づく API "
"固有のメトリクスを宣言したり、そうでなければ初期化したりすることができます（例：\"smallrye-"
"metrics\"や\"micrometer\"）。このパターンは、 `MetricsFactory::"
"metricsSystemSupported()` "
"を使用して、レコーダ内でアクティブなメトリクス拡張をテストすることで、コンシューマパターンと組み合わせることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1527
#, fuzzy
msgid ""
"Remember that support for metrics is optional. Extensions can use an "
"`Optional<MetricsCapabilityBuildItem> metricsCapability` parameter in their "
"build step to test for the presence of an enabled metrics extension. "
"Consider using additional configuration to control behavior of metrics. "
"Datasource metrics can be expensive, for example, so additional "
"configuration flags are used enable metrics collection on individual "
"datasources."
msgstr ""
"この図では、「Element Import」（要素）と「Element Import」（要素）の間の関係を説明しています。 "
"`Optional<MetricsCapabilityBuildItem> metricsCapability` この図では、「Element "
"Import」（要素）と「Element Import」（要素）の間の関係を説明します。UML 2.0 "
"コンポジット構造体は、クラス間の相互作用を表すものではありません。例えば、データソース・メトリクスは高価な場合があるため、追加の構成フラグを使用して、個々のデータソースでのメトリクス収集を有効にします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1529
#, fuzzy
msgid ""
"When adding metrics for your extension, you may find yourself in one of the "
"following situations:"
msgstr "拡張機能のメトリクスを追加するとき、以下のいずれかの状況に陥ることがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1531
#, fuzzy
msgid ""
"An underlying library used by the extension is using a specific Metrics API "
"directly (either MP Metrics, Micrometer, or some other)."
msgstr ""
"拡張機能で使用される基礎となるライブラリは、特定のメトリクス API を直接使用しています (MP Metrics, Micrometer, "
"または他のもの)。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1532
#, fuzzy
msgid ""
"An underlying library uses its own mechanism for collecting metrics and "
"makes them available at runtime using its own API, e.g. Hibernate's "
"`Statistics` class, or Vert.x `MetricsOptions`."
msgstr ""
"`Statistics` `MetricsOptions` 基礎となるライブラリは、メトリクスを収集するために独自のメカニズムを使用し、独自の API "
"を使用して実行時に利用できるようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1533
#, fuzzy
msgid ""
"An underlying library does not provide metrics (or there is no library at "
"all) and you want to add instrumentation."
msgstr "このような場合には、「インストルメンテーション」を追加する必要があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1534
#, no-wrap, fuzzy
msgid "Case 1: The library uses a metrics library directly"
msgstr "ケース1：ライブラリはメトリクスライブラリを直接使用する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1537
#, fuzzy
msgid "If the library directly uses a metrics API, there are two options:"
msgstr "ライブラリが直接メトリクス API を使用する場合は、2 つのオプションがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1539
#, fuzzy
msgid ""
"Use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter to "
"test which metrics API is supported (e.g. \"smallrye-metrics\" or "
"\"micrometer\") in your build step, and use that to selectively declare or "
"initialize API-specific beans or build items."
msgstr ""
"`Optional<MetricsCapabilityBuildItem> metricsCapability` "
"パラメータを使用して、ビルドステップでどのメトリクス API がサポートされているか (例: \"smallrye-metrics\" や "
"\"micrometer\" など) をテストし、API 固有のビーンやビルド項目を選択的に宣言または初期化するために使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1541
#, fuzzy
msgid ""
"Create a separate build step that consumes a `MetricsFactory`, and use the "
"`MetricsFactory::metricsSystemSupported()` method within the bytecode "
"recorder to initialize required resources if the desired metrics API is "
"supported (e.g. \"smallrye-metrics\" or \"micrometer\")."
msgstr ""
"`MetricsFactory` を消費する別のビルド・ステップを作成し、バイトコード・レコーダ内で `MetricsFactory::"
"metricsSystemSupported()` メソッドを使用して、必要なメトリクス API "
"がサポートされている場合に必要なリソースを初期化します（例：\"smallrye-metrics\" や \"micrometer\"）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1543
#, fuzzy
msgid ""
"Extensions may need to provide a fallback if there is no active metrics "
"extension or the extension doesn't support the API required by the library."
msgstr ""
"アクティブなメトリクス拡張子がない場合や、拡張子がライブラリが必要とする API "
"をサポートしていない場合、拡張子はフォールバックを提供する必要がある場合があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1544
#, no-wrap, fuzzy
msgid "Case 2: The library provides its own metric API"
msgstr "ケース 2: ライブラリが独自のメトリック API を提供する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1547
#, fuzzy
msgid "There are two examples of a library providing its own metrics API:"
msgstr "独自のメトリクス API を提供するライブラリの例は 2 つあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1549
#, fuzzy
msgid ""
"The extension defines an instrumentable object as Agroal does with `io."
"agroal.api.AgroalDataSourceMetrics`, or"
msgstr ""
"この拡張機能は、Agroal が `io.agroal.api.AgroalDataSourceMetrics` "
"で行っているように、インストルメント可能なオブジェクトを定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1550
#, fuzzy
msgid ""
"The extension provides its own abstraction of metrics, as Jaeger does with "
"`io.jaegertracing.spi.MetricsFactory`."
msgstr ""
"Jaeger が `io.jaegertracing.spi.MetricsFactory` "
"で行っているように、拡張機能は独自のメトリクスの抽象化を提供します。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1551
#, no-wrap, fuzzy
msgid "Observing instrumentable objects"
msgstr "計装可能な物体の観察"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1554
#, fuzzy
msgid ""
"Let's take the instrumentable object (`io.agroal.api."
"AgroalDataSourceMetrics`) case first. In this case, you can do the following:"
""
msgstr ""
"まず、インストルメント可能なオブジェクト ( `io.agroal.api.AgroalDataSourceMetrics` ) "
"の場合を取り上げてみましょう。この場合は以下のようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1556
#, fuzzy
msgid ""
"Define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that "
"uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` "
"consumer. For example, the following creates a "
"`MetricsFactoryConsumerBuildItem` if and only if metrics are enabled both "
"for Agroal generally, and for a datasource specifically:"
msgstr ""
"`MetricsFactoryConsumerBuildItem` `RUNTIME_INIT` または Recorder を使用して "
"コンシューマを定義する を生成する。例えば、以下は、Agroal 一般とデータソースの両方でメトリクスが有効になっている場合にのみ、 を生成します。 "
"`STATIC_INIT` `MetricsFactory` `BuildStep` `MetricsFactoryConsumerBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1565
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void registerMetrics(AgroalMetricsRecorder recorder,\n"
"        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,\n"
"        BuildProducer<MetricsFactoryConsumerBuildItem> datasourceMetrics,\n"
"        List<AggregatedDataSourceBuildTimeConfigBuildItem> "
"aggregatedDataSourceBuildTimeConfigs) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1577
#, no-wrap
msgid ""
"    for (AggregatedDataSourceBuildTimeConfigBuildItem "
"aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) "
"{\n"
"        // Create a MetricsFactory consumer to register metrics for a data "
"source\n"
"        // IFF metrics are enabled globally and for the data source\n"
"        // (they are enabled for each data source by default if they are "
"also enabled globally)\n"
"        if (dataSourcesBuildTimeConfig.metricsEnabled &&\n"
"                aggregatedDataSourceBuildTimeConfig.getJdbcConfig()."
"enableMetrics.orElse(true)) {\n"
"            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(\n"
"                    recorder."
"registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1580
#, fuzzy
msgid ""
"The associated recorder should use the provided `MetricsFactory` to register "
"metrics. For Agroal, this means using the `MetricFactory` API to observe `io."
"agroal.api.AgroalDataSourceMetrics` methods. For example:"
msgstr ""
"関連するレコーダは、提供された `MetricsFactory` を使用してメトリクスを登録する必要があります。Agroal の場合、これは "
"`MetricFactory` API を使用して `io.agroal.api.AgroalDataSourceMetrics` "
"メソッドを観測することを意味します。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1590
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerDataSourceMetrics(String "
"dataSourceName) {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? "
"\"default\" : dataSourceName;\n"
"            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName)."
"getMetrics();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1598
#, no-wrap
msgid ""
"            // When using MP Metrics, the builder uses the VENDOR registry "
"by default.\n"
"            metricsFactory.builder(\"agroal.active.count\")\n"
"                    .description(\n"
"                            \"Number of active connections. These "
"connections are in use and not available to be acquired.\")\n"
"                    .tag(\"datasource\", tagValue)\n"
"                    .buildGauge(metrics::activeCount);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1601
#, fuzzy
msgid ""
"The `MetricsFactory` provides a fluid builder for registration of metrics, "
"with the final step constructing gauges or counters based on a `Supplier` or "
"`ToDoubleFunction`. Timers can either wrap `Callable`, `Runnable`, or "
"`Supplier` implementations, or can use a `TimeRecorder` to accumulate chunks "
"of time. The underlying metrics extension will create appropriate artifacts "
"to observe or measure the defined functions."
msgstr ""
"`MetricsFactory` はメトリクスを登録するための流体ビルダーを提供し、最終的なステップでは `Supplier` または "
"`ToDoubleFunction` に基づいてゲージやカウンターを構築します。タイマーは、 `Callable` 、 `Runnable` 、または "
"`Supplier` の実装をラップしたり、 `TimeRecorder` "
"を使用して時間の塊を蓄積したりすることができます。このように、「Element Import」は、「Element Import」と呼ばれています。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1602
#, no-wrap, fuzzy
msgid "Using a Metrics API-specific implementation"
msgstr "メトリクス API 固有の実装を使用する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1605
#, fuzzy
msgid ""
"Using metrics-API specific implementations may be preferred in some cases. "
"Jaeger, for example, defines its own metrics interface, `io.jaegertracing."
"spi.MetricsFactory`, that it uses to define counters and gauges. A direct "
"mapping from that interface to the metrics system will be the most efficient."
" In this case, it is important to isolate these specialized implementations "
"and to avoid eager classloading to ensure the metrics API remains an "
"optional, compile-time dependency."
msgstr ""
"メトリクス API 固有の実装を使用することが好ましい場合もあります。たとえば、Jaeger "
"は、カウンタとゲージを定義するために使用する独自のメトリクス・インタフェース（ `io.jaegertracing.spi."
"MetricsFactory` ）を定義しています。このような場合には、「Element Import」（要素）は、「Element "
"Import」（要素）と呼ばれ、「Element Import」（要素）は「Element "
"Import」（要素）と呼ばれます。この場合は、これらの特殊な実装を分離し、熱心なクラスローディングを避けて、メトリクス API "
"がコンパイル時の依存関係にあるオプションのままであることを確実にすることが重要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1607
#, fuzzy
msgid ""
"`Optional<MetricsCapabilityBuildItem> metricsCapability` can be used in the "
"build step to selectively control initialization of beans or the production "
"of other build items. The Jaeger extension, for example, can use the "
"following to control initialization of specialized Metrics API adapters:"
msgstr ""
"`Optional<MetricsCapabilityBuildItem> metricsCapability` "
"は、ビーンズの初期化や他のビルド項目の生成を選択的に制御するために、ビルドステップで使用することができます。Jaeger "
"拡張モジュールでは、例えば、以下のようにして、特殊な Metrics API アダプタの初期化を制御することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1615
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig "
"buildTimeConfig, JaegerConfig jaeger,\n"
"        ApplicationConfig appConfig, Optional<MetricsCapabilityBuildItem> "
"metricsCapability) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1618
#, no-wrap
msgid ""
"    // Indicates that this extension would like the SSL support to be "
"enabled\n"
"    extensionSslNativeSupport.produce(new "
"ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1632
#, no-wrap
msgid ""
"    if (buildTimeConfig.enabled) {\n"
"        // To avoid dependency creep, use two separate recorder methods for "
"the two metrics systems\n"
"        if (buildTimeConfig.metricsEnabled && metricsCapability.isPresent()) "
"{\n"
"            if (metricsCapability.get().metricsSupported(MetricsFactory."
"MICROMETER)) {\n"
"                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);\n"
"            } else {\n"
"                jdr.registerTracerWithMpMetrics(jaeger, appConfig);\n"
"            }\n"
"        } else {\n"
"            jdr.registerTracerWithoutMetrics(jaeger, appConfig);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1635
#, fuzzy
msgid ""
"A recorder consuming a `MetricsFactory` can use `MetricsFactory::"
"metricsSystemSupported()` can be used to control initialization of metrics "
"objects during bytecode recording in a similar way."
msgstr ""
"`MetricsFactory` を消費するレコーダは、 `MetricsFactory::metricsSystemSupported()` "
"を使用して、バイトコード記録中のメトリクスオブジェクトの初期化を同様の方法で制御することができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1636
#, no-wrap, fuzzy
msgid "Case 3: It is necessary to collect metrics within the extension code"
msgstr "ケース3：拡張コード内でメトリクスを収集する必要がある"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1639
#, fuzzy
msgid ""
"To define your own metrics from scratch, you have two basic options: Use the "
"generic `MetricFactory` builders, or follow the binder pattern, and create "
"instrumentation specific to the enabled metrics extension."
msgstr "この図では、「Element Import Import」という名前を使用して、「Element Import」という名前を定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1641
#, fuzzy
msgid ""
"To use the extension-agnostic `MetricFactory` API, your processor can define "
"a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a "
"`RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` "
"consumer."
msgstr ""
"拡張子に依存しない `MetricFactory` API を使用するために、プロセッサは `RUNTIME_INIT` または "
"`STATIC_INIT` Recorder を使用して `MetricsFactory` コンシューマを定義する "
"`MetricsFactoryConsumerBuildItem` を生成する `BuildStep` を定義することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1649
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder "
"recorder) {\n"
"    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1652
#, fuzzy
msgid ""
"The associated recorder should use the provided `MetricsFactory` to register "
"metrics, for example"
msgstr "関連するレコーダーは、提供された `MetricsFactory` を使用してメトリクスを登録する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1656
#, no-wrap
msgid "final LongAdder extensionCounter = new LongAdder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1665
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerMetrics() {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            metricsFactory.builder(\"my.extension.counter\")\n"
"                    .buildGauge(extensionCounter::longValue);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1668
#, fuzzy
msgid ""
"Remember that metrics extensions are optional. Keep metrics-related "
"initialization isolated from other setup for your extension, and structure "
"your code to avoid eager imports of metrics APIs. Gathering metrics can also "
"be expensive. Consider using additional extension-specific configuration to "
"control behavior of metrics if the presence/absence of metrics support isn't "
"sufficient."
msgstr ""
"UML 2.0 図では、「Element Import」という名前で、「Element "
"Import」という名前を使用しています。メトリクス関連の初期化は、拡張のための他のセットアップから分離しておき、メトリクス API "
"の熱心なインポートを避けるためにコードを構造化してください。UML 2.0 図では、「UML 2.0」と「UML 2.0」の間には、「UML 2."
"0」と「UML 2.0」があります。UML 2.0 コンポジット構造体は、「UML 2.0 コンポジット構造体」と呼ばれています。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1669
#, no-wrap, fuzzy
msgid "Customizing JSON handling from an extension"
msgstr "拡張機能からJSON処理をカスタマイズする"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1672
#, fuzzy
msgid ""
"Extensions often need to register serializers and/or deserializers for types "
"the extension provides."
msgstr "拡張機能はしばしば、拡張機能が提供する型のシリアライザやデシリアライザを登録する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1675
#, fuzzy
msgid ""
"For this, both Jackson and JSON-B extensions provide a way to register "
"serializer/deserializer from within an extension deployment module."
msgstr ""
"このため、Jackson 拡張モジュールと JSON-B 拡張モジュールの両方で、拡張モジュール内からシリアライザ/"
"デシリアライザを登録する方法を提供しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1677
#, fuzzy
msgid ""
"Keep in mind that not everybody will need JSON, so you need to make it "
"optional."
msgstr "すべての人がJSONを必要とするわけではないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1680
#, fuzzy
msgid ""
"If an extension intends to provide JSON related customization, it is "
"strongly advised to provide customization for both Jackson and JSON-B."
msgstr ""
"拡張機能がJSON関連のカスタマイズを提供しようとする場合は、JacksonとJSON-Bの両方のカスタマイズを提供することを強くお勧めします。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1681
#, no-wrap, fuzzy
msgid "Customizing Jackson"
msgstr "ジャクソンのカスタマイズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1684
#, fuzzy
msgid ""
"First, add an *optional* dependency to `quarkus-jackson` on your extension's "
"runtime module."
msgstr "まず、拡張機能のランタイムモジュールに `quarkus-jackson` に *オプションの* 依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1692
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1695
#, fuzzy
msgid ""
"Then create a serializer or a deserializer (or both) for Jackson, an example "
"of which can be seen in the `mongodb-panache` extension."
msgstr ""
"次に、Jackson 用のシリアライザまたはデシリアライザ (またはその両方) を作成します。 `mongodb-panache` "
"の拡張モジュールで例を見ることができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1710
#, no-wrap
msgid ""
"public class ObjectIdSerializer extends StdSerializer<ObjectId> {\n"
"    public ObjectIdSerializer() {\n"
"        super(ObjectId.class);\n"
"    }\n"
"    @Override\n"
"    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, "
"SerializerProvider serializerProvider)\n"
"            throws IOException {\n"
"        if (objectId != null) {\n"
"            jsonGenerator.writeString(objectId.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1713
#, fuzzy
msgid ""
"Add a dependency to `quarkus-jackson-spi` on your extension's deployment "
"module."
msgstr "`quarkus-jackson-spi` への依存関係をエクステンションのデプロイメントモジュールに追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1720
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1724
#, fuzzy
msgid ""
"Add a build step to your processor to register a Jackson module via the "
"`JacksonModuleBuildItem`.  You need to name your module in a unique way "
"across all Jackson modules."
msgstr ""
"`JacksonModuleBuildItem` を経由して、Jackson "
"モジュールを登録するためのビルドステップをプロセッサに追加してください。モジュールの名前は、すべてのJacksonモジュールに共通するユニークな方法で付ける必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1735
#, no-wrap
msgid ""
"@BuildStep\n"
"JacksonModuleBuildItem registerJacksonSerDeser() {\n"
"    return new JacksonModuleBuildItem.Builder(\"ObjectIdModule\")\n"
"                    .add(io.quarkus.mongodb.panache.jackson."
"ObjectIdSerializer.class.getName(),\n"
"                            io.quarkus.mongodb.panache.jackson."
"ObjectIdDeserializer.class.getName(),\n"
"                            ObjectId.class.getName())\n"
"                    .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1738
#, fuzzy
msgid ""
"The Jackson extension will then use the produced build item to register a "
"module within Jackson automatically."
msgstr "そして、Jackson 拡張モジュールは、生成されたビルドアイテムを使用して、Jackson 内で自動的にモジュールを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1742
#, fuzzy
msgid ""
"If you need more customization capabilities than registering a module, you "
"can produce a CDI bean that implements `io.quarkus.jackson."
"ObjectMapperCustomizer` via an `AdditionalBeanBuildItem`.  More info about "
"customizing Jackson can be found on the JSON guide link:rest-"
"json#configuring-json-support[Configuring JSON support]"
msgstr ""
"モジュールを登録する以上のカスタマイズ機能が必要な場合は、 `io.quarkus.jackson.ObjectMapperCustomizer` "
"を実装した CDI Bean を `AdditionalBeanBuildItem` を介して作成することができます。Jackson "
"のカスタマイズについての詳細は、JSON ガイドの JS link:rest-json#configuring-json-support[ON "
"サポートの設定] を参照してください。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1743
#, no-wrap, fuzzy
msgid "Customizing JSON-B"
msgstr "JSON-Bのカスタマイズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1745
#, fuzzy
msgid ""
"First, add an *optional* dependency to `quarkus-jsonb` on your extension's "
"runtime module."
msgstr "まず、拡張機能のランタイムモジュールに `quarkus-jsonb` に *オプションの* 依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1753
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1756
#, fuzzy
msgid ""
"Then create a serializer and/or a deserializer for JSON-B, an example of "
"which can be seen in the `mongodb-panache` extension."
msgstr ""
"次に、JSON-B用のシリアライザおよび/またはデシリアライザを作成します。 `mongodb-panache` 拡張モジュールに例があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1767
#, no-wrap
msgid ""
"public class ObjectIdSerializer implements JsonbSerializer<ObjectId> {\n"
"    @Override\n"
"    public void serialize(ObjectId obj, JsonGenerator generator, "
"SerializationContext ctx) {\n"
"        if (obj != null) {\n"
"            generator.write(obj.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1770
#, fuzzy
msgid ""
"Add a dependency to `quarkus-jsonb-spi` on your extension's deployment "
"module."
msgstr "`quarkus-jsonb-spi` への依存関係をエクステンションのデプロイメントモジュールに追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1777
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1780
#, fuzzy
msgid ""
"Add a build step to your processor to register the serializer via the "
"`JsonbSerializerBuildItem`."
msgstr "ビルドステップをプロセッサに追加して、 `JsonbSerializerBuildItem` を経由してシリアライザを登録します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1787
#, no-wrap
msgid ""
"@BuildStep\n"
"JsonbSerializerBuildItem registerJsonbSerializer() {\n"
"    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb."
"ObjectIdSerializer.class.getName()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1790
#, fuzzy
msgid ""
"The JSON-B extension will then use the produced build item to register your "
"serializer/deserializer automatically."
msgstr "JSON-B拡張機能は、生成されたビルド項目を使用して、シリアライザ/デシリアライザを自動的に登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1794
#, fuzzy
msgid ""
"If you need more customization capabilities than registering a serializer or "
"a deserializer, you can produce a CDI bean that implements `io.quarkus.jsonb."
"JsonbConfigCustomizer` via an `AdditionalBeanBuildItem`.  More info about "
"customizing JSON-B can be found on the JSON guide link:rest-json#configuring-"
"json-support[Configuring JSON support]"
msgstr ""
"シリアライザやデシリアライザを登録する以上のカスタマイズ機能が必要な場合は、 `io.quarkus.jsonb."
"JsonbConfigCustomizer` を実装した CDI Bean を `AdditionalBeanBuildItem` .JSON-B "
"のカスタマイズについての詳細は、JSON ガイドの link:rest-json#configuring-json-support[JSON "
"サポートの設定] に記載されています。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1795
#, no-wrap, fuzzy
msgid "Testing Extensions"
msgstr "拡張機能のテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1802
#, fuzzy
msgid ""
"Testing of Quarkus extensions should be done with the `io.quarkus.test."
"QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-"
"style tests that test specific functionalities.  It is not intended for "
"testing user applications, as this should be done via `io.quarkus.test.junit."
"QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the "
"application once at the start of the run, while `QuarkusUnitTest` deploys a "
"custom Quarkus application for each test class."
msgstr ""
"Quarkus 拡張モジュールのテストは `io.quarkus.test.QuarkusUnitTest` JUnit 5 "
"拡張モジュールを使用してください。この拡張機能を使用すると、特定の機能をテストする Arquillian "
"スタイルのテストを行うことができます。ユーザーアプリケーションのテストは `io.quarkus.test.junit.QuarkusTest` "
"を経由して行う必要があるため、ユーザーアプリケーションのテストを目的としたものではありません。主な違いは、 `QuarkusTest` "
"は実行開始時にアプリケーションを起動するだけで、 `QuarkusUnitTest` は各テストクラスごとにカスタムの Quarkus "
"アプリケーションを展開するという点です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1805
#, fuzzy
msgid ""
"These tests should be placed in the deployment module, if additional Quarkus "
"modules are required for testing their deployment modules should also be "
"added as test scoped dependencies."
msgstr ""
"これらのテストはデプロイメントモジュールに配置する必要があります。Quarkusモジュールのテストに追加のQuarkusモジュールが必要な場合は、それらのデプロイメントモジュールもテストスコープ付きの依存関係として追加する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1807
#, fuzzy
msgid ""
"Note that `QuarkusUnitTest` is in the `quarkus-junit5-internal` module."
msgstr "`QuarkusUnitTest` は `quarkus-junit5-internal` モジュールの中にあることに注意してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1809
#, fuzzy
msgid "An example test class may look like:"
msgstr "テストクラスの例は次のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1813
#, no-wrap
msgid "package io.quarkus.health.test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1815
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1818
#, no-wrap
msgid "import java.util.ArrayList;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1821
#, no-wrap
msgid "import javax.enterprise.inject.Instance;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1831
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Health;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.asset.EmptyAsset;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1833
#, no-wrap
msgid "import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1835
#, no-wrap
msgid "public class FailingUnitTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1843
#, no-wrap
msgid ""
"    @RegisterExtension                                                       "
"           // <1>\n"
"    static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"            .setArchiveProducer(() ->\n"
"                    ShrinkWrap.create(JavaArchive.class)                     "
"           // <2>\n"
"                            .addClasses(FailingHealthCheck.class)\n"
"                            .addAsManifestResource(EmptyAsset.INSTANCE, "
"\"beans.xml\")\n"
"            );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1847
#, no-wrap
msgid ""
"    @Inject                                                                  "
"           // <3>\n"
"    @Health\n"
"    Instance<HealthCheck> checks;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1852
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthServlet() {\n"
"        RestAssured.when().get(\"/q/health\").then().statusCode(503);        "
"               // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1863
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthBeans() {\n"
"        List<HealthCheck> check = new ArrayList<>();                         "
"           // <5>\n"
"        for (HealthCheck i : checks) {\n"
"            check.add(i);\n"
"        }\n"
"        assertEquals(1, check.size());\n"
"        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call()."
"getState());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1866
#, fuzzy
msgid ""
"The `QuarkusUnitTest` extension must be used with a static field. If used "
"with a non-static field, the test application is not started."
msgstr ""
"`QuarkusUnitTest` "
"拡張子は、静的フィールドと一緒に使用する必要があります。静的でないフィールドで使用した場合、テストアプリケーションは開始されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1867
#, fuzzy
msgid ""
"This producer is used to build the application to be tested. It uses "
"Shrinkwrap to create a JavaArchive to test"
msgstr ""
"このプロデューサーは、テストされるアプリケーションを構築するために使用されます。Shrinkwrap を使用して、テストする JavaArchive "
"を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1868
#, fuzzy
msgid ""
"It is possible to inject beans from our test deployment directly into the "
"test case"
msgstr "テストデプロイメントからテストケースに直接ビーンを注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1869
#, fuzzy
msgid ""
"This method directly invokes the health check Servlet and verifies the "
"response"
msgstr "このメソッドは、ヘルスチェックサーブレットを直接呼び出し、レスポンスを検証します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1870
#, fuzzy
msgid ""
"This method uses the injected health check bean to verify it is returning "
"the expected result"
msgstr "このメソッドは、注入されたヘルスチェック・ビーンを使用して、それが期待された結果を返していることを確認します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1872
#, fuzzy
msgid ""
"If you want to test that an extension properly fails at build time, use the "
"`setExpectedException` method:"
msgstr ""
"ビルド時に拡張機能が適切に失敗するかどうかをテストしたい場合は、 `setExpectedException` メソッドを使用してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1877
#, no-wrap
msgid "package io.quarkus.hibernate.orm;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1885
#, no-wrap
msgid ""
"import io.quarkus.deployment.configuration.ConfigurationError;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1887
#, no-wrap
msgid "public class PersistenceAndQuarkusConfigTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1894
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    static QuarkusUnitTest runner = new QuarkusUnitTest()\n"
"            .setExpectedException(ConfigurationError.class)                  "
"   <1>\n"
"            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n"
"                    .addAsManifestResource(\"META-INF/some-persistence."
"xml\", \"persistence.xml\")\n"
"                    .addAsResource(\"application.properties\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1902
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPersistenceAndConfigTest() {\n"
"        // should not be called, deployment exception should happen first:\n"
"        // it's illegal to have Hibernate configuration properties in both "
"the\n"
"        // application.properties and in the persistence.xml\n"
"        Assertions.fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1907
#, fuzzy
msgid ""
"This tells JUnit that the Quarkus deployment should fail with a specific "
"exception"
msgstr "これは、Quarkus のデプロイが特定の例外で失敗することを JUnit に伝えます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1909
#, no-wrap, fuzzy
msgid "Testing hot reload"
msgstr "ホットリロードのテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1913
#, fuzzy
msgid ""
"It is also possible to write tests that verify an extension works correctly "
"in development mode and can correctly handle updates."
msgstr "開発モードで拡張機能が正しく動作し、アップデートを正しく処理できるかどうかを検証するテストを書くことも可能です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1916
#, fuzzy
msgid ""
"For most extensions this will just work 'out of the box', however it is "
"still a good idea to have a smoke test to verify that this functionality is "
"working as expected. To test this we use `QuarkusDevModeTest`:"
msgstr ""
"ほとんどの拡張機能では、これは「箱から出してすぐに」動作しますが、この機能が期待通りに動作しているかどうかを確認するためにスモークテストを行うことをお勧めします。このテストには "
"`QuarkusDevModeTest` ."

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1921
#, no-wrap
msgid "public class ServletChangeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1932
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    final static QuarkusDevModeTest test = new QuarkusDevModeTest()\n"
"            .setArchiveProducer(new Supplier<JavaArchive>() {\n"
"                @Override\n"
"                public JavaArchive get() {\n"
"                    return ShrinkWrap.create(JavaArchive.class)   <1>\n"
"                            .addClass(DevServlet.class)\n"
"                            .addAsManifestResource(new StringAsset(\"Hello "
"Resource\"), \"resources/file.txt\");\n"
"                }\n"
"            });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1938
#, no-wrap
msgid ""
"    @Test\n"
"    public void testServletChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello World\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1940
#, no-wrap
msgid ""
"        test.modifySourceFile(\"DevServlet.java\", new Function<String, "
"String>() {  <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1946
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return s.replace(\"Hello World\", \"Hello Quarkus\");\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1951
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Quarkus\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1956
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddServlet() throws InterruptedException {\n"
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1958
#, no-wrap
msgid ""
"        test.addSourceFile(NewServlet.class);                                "
"       <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1963
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new Servlet\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1969
#, no-wrap
msgid ""
"    @Test\n"
"    public void testResourceChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Resource\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1971
#, no-wrap
msgid ""
"        test.modifyResourceFile(\"META-INF/resources/file.txt\", new "
"Function<String, String>() { <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1977
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return \"A new resource\";\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1982
#, no-wrap
msgid ""
"        RestAssured.when().get(\"file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new resource\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1985
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddResource() throws InterruptedException {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1988
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1990
#, no-wrap
msgid ""
"        test.addResourceFile(\"META-INF/resources/new.txt\", \"New File\");  "
"<5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1994
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"New File\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1997
#, no-wrap
msgid "    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2001
#, fuzzy
msgid ""
"This starts the deployment, your test can modify it as part of the test "
"suite. Quarkus will be restarted between each test method so every method "
"starts with a clean deployment."
msgstr ""
"これによりデプロイメントが開始され、テストはテストスイートの一部として変更することができます。Quarkusは各テストメソッドの間に再起動されるので、すべてのメソッドはクリーンなデプロイメントから始まります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2004
#, fuzzy
msgid ""
"This method allows you to modify the source of a class file. The old source "
"is passed into the function, and the updated source is returned."
msgstr "このメソッドを使用すると、クラス・ファイルのソースを変更することができます。古いソースが関数に渡され、更新されたソースが返されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2007
#, fuzzy
msgid ""
"This method adds a new class file to the deployment. The source that is used "
"will be the original source that is part of the current project."
msgstr ""
"このメソッドは、新しいクラス ファイルをデプロイメントに追加します。使用されるソースは、現在のプロジェクトの一部であるオリジナルのソースになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2009
#, fuzzy
msgid "This method modifies a static resource"
msgstr "このメソッドは静的リソース"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2011
#, fuzzy
msgid "This method adds a new static resource"
msgstr "このメソッドは新しい静的リソース"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2012
#, no-wrap, fuzzy
msgid "Native Executable Support"
msgstr "ネイティブ実行ファイルのサポート"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2017
#, fuzzy
msgid ""
"There Quarkus provides a lot of build items that control aspects of the "
"native executable build. This allows for extensions to programmatically "
"perform tasks such as registering classes for reflection or adding static "
"resources to the native executable. Some of these build items are listed "
"below:"
msgstr ""
"Quarkusでは、ネイティブ実行ファイルのビルドの側面を制御する多くのビルド項目を提供しています。これにより、リフレクションのためにクラスを登録したり、ネイティブ実行ファイルに静的リソースを追加したりといったタスクを、拡張機能がプログラムで実行できるようになります。これらのビルド項目の一部を以下に示します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2018
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2020
#, fuzzy
msgid "Includes static resources into the native executable."
msgstr "ネイティブ実行ファイルに静的なリソースをインクルードします。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2021
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceDirectoryBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceDirectoryBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2023
#, fuzzy
msgid "Includes directory's static resources into the native executable."
msgstr "ディレクトリの静的リソースをネイティブ実行ファイルに含めます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2024
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeReinitializedClassBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeReinitializedClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2026
#, fuzzy
msgid ""
"A class that will be reinitialized at runtime by Substrate. This will result "
"in the static initializer running twice."
msgstr "実行時に Substrate によって再初期化されるクラス。これにより、静的イニシャライザが2回実行されることになります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2027
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageSystemPropertyBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageSystemPropertyBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2029
#, fuzzy
msgid "A system property that will be set at native executable build time."
msgstr "ネイティブ実行ファイルのビルド時に設定されるシステムプロパティです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2030
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceBundleBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceBundleBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2032
#, fuzzy
msgid "Includes a resource bundle in the native executable."
msgstr "ネイティブ実行ファイルにリソースバンドルを含みます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2033
#, no-wrap, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2035
#, fuzzy
msgid ""
"Registers a class for reflection in Substrate. Constructors are always "
"registered, while methods and fields are optional."
msgstr "Substrateに反映させるためのクラスを登録します。コンストラクタは常に登録され、メソッドとフィールドはオプションです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2036
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeInitializedClassBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeInitializedClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2038
#, fuzzy
msgid ""
"A class that will be initialized at runtime rather than build time. This "
"will cause the build to fail if the class is initialized as part of the "
"native executable build process, so care must be taken."
msgstr ""
"ビルド時ではなく実行時に初期化されるクラス。これは、ネイティブの実行可能なビルドプロセスの一部としてクラスが初期化されるとビルドが失敗する原因となるので、注意が必要です。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2039
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2041
#, fuzzy
msgid ""
"A convenience feature that allows you to control most of the above features "
"from a single build item."
msgstr "1つのビルドアイテムから上記の機能のほとんどをコントロールできる便利な機能です。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2042
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2044
#, fuzzy
msgid "Indicates that all charsets should be enabled in native image."
msgstr "ネイティブ画像ですべての文字セットを有効にすることを示します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2045
#, no-wrap, fuzzy
msgid "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"
msgstr "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2048
#, fuzzy
msgid ""
"A convenient way to tell Quarkus that the extension requires SSL and it "
"should be enabled during native image build.  When using this feature, "
"remember to add your extension to the list of extensions that offer SSL "
"support automatically on the https://github.com/quarkusio/quarkus/blob/"
"master/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgstr ""
"拡張機能がSSLを必要とし、ネイティブイメージのビルド中に有効にする必要があることをQuarkusに伝える便利な方法です。この機能を使用する場合は、 "
"link:https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/"
"native-and-ssl.adoc[ネイティブおよびsslガイド] "
"で自動的にSSLサポートを提供する拡張機能のリストに拡張機能を追加することを忘れないでください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2049
#, no-wrap, fuzzy
msgid "IDE support tips"
msgstr "IDE サポートのヒント"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2051
#, no-wrap, fuzzy
msgid "Writing Quarkus extensions in Eclipse"
msgstr "EclipseでQuarkus拡張機能を書く"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2054
#, fuzzy
msgid ""
"The only particular aspect of writing Quarkus extensions in Eclipse is that "
"APT (Annotation Processing Tool) is required as part of extension builds, "
"which means you need to:"
msgstr ""
"EclipseでQuarkus拡張機能を書く際の唯一の特別な点は、拡張機能のビルドの一部としてAPT（Annotation Processing "
"Tool）が必要であることです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2056
#, fuzzy
msgid "Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt"
msgstr ""
"https://marketplace.eclipse.org/content/m2e-apt から `m2e-apt` をインストールします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2057
#, fuzzy
msgid ""
"Define this property in your `pom.xml`: `<m2e.apt.activation>jdt_apt</m2e."
"apt.activation>`, although if you rely on `io.quarkus:quarkus-build-parent` "
"you will get it for free."
msgstr ""
"あなたの `pom.xml` : `<m2e.apt.activation>jdt_apt</m2e.apt.activation>` 、あなたが "
"`io.quarkus:quarkus-build-parent` に依存している場合、あなたは無料でそれを取得しますが、このプロパティを定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2058
#, fuzzy
msgid ""
"If you have the `io.quarkus:quarkus-extension-processor` project open at the "
"same time in your IDE (for example, if you have the Quarkus sources checked "
"out and open in your IDE) you will need to close that project. Otherwise, "
"Eclipse will not invoke the APT plugin that it contains."
msgstr ""
"IDEで `io.quarkus:quarkus-extension-processor` "
"プロジェクトを同時に開いている場合（例えば、QuarkusソースをチェックアウトしてIDEで開いている場合など）、そのプロジェクトを閉じる必要があります。そうしないと、Eclipseはそのプロジェクトに含まれるAPTプラグインを起動しません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2059
#, fuzzy
msgid ""
"If you just closed the extension processor project, be sure to do `Maven > "
"Update Project` on the other projects in order for Eclipse to pick up the "
"extension processor from the Maven repository."
msgstr ""
"拡張プロセッサプロジェクトを閉じたばかりの場合は、EclipseがMavenリポジトリから拡張プロセッサをピックアップするために、他のプロジェクトで "
"`Maven > Update Project` を実行するようにしてください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2060
#, no-wrap, fuzzy
msgid "Troubleshooting / Debugging Tips"
msgstr "トラブルシューティング / デバッグのヒント"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2062
#, no-wrap, fuzzy
msgid "Dump the Generated Classes to the File System"
msgstr "生成されたクラスをファイルシステムにダンプする"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2067
#, fuzzy
msgid ""
"During the augmentation phase Quarkus extensions generate new and modify "
"existing classes for various purposes.  Sometimes you need to inspect the "
"generated bytecode to debug or understand an issue.  There are three system "
"properties that allow you to dump the classes to the filesystem:"
msgstr ""
"拡張フェーズでは、Quarkusの拡張機能は、さまざまな目的のために既存のクラスを新規に生成したり変更したりします。デバッグや問題の理解のために、生成されたバイトコードを検査する必要がある場合もあります。クラスをファイルシステムにダンプするための3つのシステムプロパティがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2069
#, fuzzy
msgid ""
"`quarkus.debug.generated-classes-dir` - to dump the generated classes, such "
"as bean metadata"
msgstr "`quarkus.debug.generated-classes-dir` - ビーンのメタデータのような生成されたクラスをダンプします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2070
#, fuzzy
msgid ""
"`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e."
"g. Panache entities"
msgstr ""
"`quarkus.debug.transformed-classes-dir` - 変換されたクラス、例えば Panache "
"エンティティをダンプします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2071
#, fuzzy
msgid ""
"`quarkus.debug.generated-sources-dir` - to dump the ZIG files; ZIG file is a "
"textual representation of the generated code that is referenced in the stack "
"traces"
msgstr ""
"`quarkus.debug.generated-sources-dir` - ZIG ファイルをダンプします。ZIG "
"ファイルは、スタックトレースで参照される生成コードのテキスト表現です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2073
#, fuzzy
msgid ""
"These properties are especially useful in the development mode or when "
"running the tests where the generated/transformed classes are only held in "
"memory in a class loader."
msgstr "これらのプロパティは、開発モードや、生成/変換されたクラスがクラス・ローダのメモリにしか保持されないテストを実行するときに特に便利です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2075
#, fuzzy
msgid ""
"For example, you can specify the `quarkus.debug.generated-classes-dir` "
"system property to have these classes written out to disk for inspection in "
"the development mode:"
msgstr ""
"例えば、 `quarkus.debug.generated-classes-dir` system "
"プロパティを指定して、開発モードで検査のためにこれらのクラスをディスクに書き出すようにすることができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2079
#, no-wrap
msgid "./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2082
#, fuzzy
msgid ""
"The property value could be either an absolute path, such as `/home/foo/"
"dump` on a Linux machine, or a path relative to the user working directory, "
"i.e. `dump` corresponds to the `{user.dir}/target/dump` in the dev mode and "
"`{user.dir}/dump` when running the tests."
msgstr ""
"`dump` `{user.dir}/target/dump` `{user.dir}/dump` プロパティ値は、Linux マシンの `/home/"
"foo/dump` のような絶対パスか、ユーザの作業ディレクトリからの相対パスのどちらかになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2084
#, fuzzy
msgid ""
"You should see a line in the log for each class written to the directory:"
msgstr "ディレクトリに書き込まれた各クラスのログに一行が表示されるはずです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2088
#, no-wrap
msgid ""
"INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/"
"dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean."
"class\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2091
#, fuzzy
msgid "The property is also honored when running tests:"
msgstr "このプロパティは、テストを実行する際にも優先されます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2095
#, no-wrap
msgid ""
"./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-"
"generated-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2098
#, fuzzy
msgid ""
"Analogously, you can use the `quarkus.debug.transformed-classes-dir` and "
"`quarkus.debug.transformed-classes-dir` properties to dump the relevant "
"output."
msgstr ""
"同様に、 `quarkus.debug.transformed-classes-dir` と `quarkus.debug.transformed-"
"classes-dir` プロパティを使用して、関連する出力をダンプすることができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2100
#, no-wrap, fuzzy
msgid "Multi-module Maven Projects and the Development Mode"
msgstr "マルチモジュールMavenプロジェクトと開発モード"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2105
#, fuzzy
msgid ""
"It's not uncommon to develop an extension in a multi-module Maven project "
"that also contains an \"example\" module.  However, if you want to run the "
"example in the development mode then the `-DnoDeps` system property must be "
"used in order to exclude the local project dependencies.  Otherwise, Quarkus "
"attempts to monitor the extension classes and this may result in weird class "
"loading issues."
msgstr ""
"マルチモジュールのMavenプロジェクトで拡張機能を開発する場合、\"example\"モジュールも含まれていることは珍しくありません。しかし、開発モードで例を実行したい場合は、ローカルプロジェクトの依存関係を除外するために、 "
"`-DnoDeps` "
"システムプロパティを使用する必要があります。そうしないと、Quarkusは拡張クラスを監視しようとするため、奇妙なクラスロードの問題が発生する可能性があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2109
#, no-wrap
msgid "./mvnw compile quarkus:dev -DnoDeps\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2111
#, no-wrap, fuzzy
msgid "Indexer does not include your external dependency"
msgstr "インデクサには、あなたの外部依存関係が含まれていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2114
#, fuzzy
msgid ""
"Remember to add `IndexDependencyBuildItem` artifacts to your `@BuildStep`."
msgstr "`IndexDependencyBuildItem` の成果物を `@BuildStep` に追加することを忘れないでください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2115
#, no-wrap, fuzzy
msgid "Sample Test Extension"
msgstr "サンプルテスト拡張"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2118
#, fuzzy
msgid ""
"We have an extension that is used to test for regressions in the extension "
"processing. It is located in {quarkus-tree-url}/core/test-extension "
"directory. In this section we touch on some of the tasks an extension author "
"will typically need to perform using the test-extension code to illustrate "
"how the task could be done."
msgstr ""
"拡張機能の処理でリグレッションのテストを行うための拡張機能を用意しています。これは {quarkus-tree-url}/core/test-"
"extension "
"ディレクトリにあります。このセクションでは、拡張機能の作者がテスト拡張コードを使って実行する必要があるタスクのいくつかに触れ、どのようにタスクが実行できるかを説明します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2119
#, no-wrap, fuzzy
msgid "Features and Capabilities"
msgstr "特徴と機能"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2121
#, no-wrap
msgid "Features"
msgstr "特徴"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2125
#, fuzzy
msgid ""
"A _feature_ represents a functionality provided by an extension.  The name "
"of the feature gets displayed in the log during application bootstrap."
msgstr "_機能は_ 、拡張機能によって提供される機能を表します。機能の名前は、アプリケーションの起動時にログに表示されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2126
#, no-wrap, fuzzy
msgid "Example Startup Lines"
msgstr "スタートアップラインの例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2131
#, no-wrap
msgid ""
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT "
"started in 0.061s.\n"
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, "
"test-extension] <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2133
#, fuzzy
msgid "A list of features installed in the runtime image"
msgstr "ランタイムイメージにインストールされている機能のリスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2135
#, fuzzy
msgid ""
"A feature can be registered in a <<Build Step Processors>> method that "
"produces a `FeatureBuildItem`:"
msgstr "機能を登録できるのは、 link:#Build Step Processors[] `FeatureBuildItem` ."

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2136
#, no-wrap, fuzzy
msgid "TestProcessor#feature()"
msgstr "TestProcessor#feature()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2143
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(\"test-extension\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2148
#, fuzzy
msgid ""
"The name of the feature should only contain lowercase characters, words are "
"separated by dash; e.g. `security-jpa`.  An extension should provide at most "
"one feature and the name must be unique.  If multiple extensions register a "
"feature of the same name the build fails."
msgstr ""
"`security-jpa` "
"機能の名前は小文字のみで、単語はダッシュで区切ってください。1つの拡張モジュールが提供する機能は最大でも1つでなければならず、その名前は一意でなければなりません。複数の拡張モジュールが同じ名前の機能を登録した場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2152
#, fuzzy
msgid ""
"The feature name should also map to a label in the extension's `devtools/"
"common/src/main/filtered/extensions.json` entry so that the feature name "
"displayed by the startup line matches a label that one can used to select "
"the extension when creating a project using the Quarkus maven plugin as "
"shown in this example taken from the link:rest-json[Writing JSON REST "
"Services] guide where the `resteasy-jackson` feature is referenced:"
msgstr ""
"機能名は、 `resteasy-jackson` 機能が参照されている link:rest-json[Writing JSON REST "
"Services] ガイドの例に示されているように、起動時に表示される機能名が、Quarkus "
"mavenプラグインを使用してプロジェクトを作成する際に拡張機能を選択するために使用できるラベルと一致するように、拡張機能の `devtools/"
"common/src/main/filtered/extensions.json` エントリ内のラベルにもマッピングする必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2162
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy,resteasy-jackson\"\n"
"cd rest-json\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2169
#, fuzzy
msgid ""
"A _capability_ represents a technical capability that can be queried by "
"other extensions.  An extension may provide multiple capabilities and "
"multiple extensions can provide the same capability.  By default, "
"capabilities are not displayed to users."
msgstr ""
"_ケイパビリティ_ "
"は、他のエクステンションから問い合わせ可能な技術的なケイパビリティを表します。1つのエクステンションが複数のケイパビリティを提供し、複数のエクステンションが同じケイパビリティを提供することができます。デフォルトでは、ケイパビリティはユーザーに表示されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2171
#, fuzzy
msgid ""
"Capabilities can be registered in a <<Build Step Processors>> method that "
"produces a `CapabilityBuildItem`:"
msgstr ""
"能力は、 `CapabilityBuildItem` を生成する link:#Build Step Processors[[Build Step "
"Processors]] メソッドに登録することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2172
#, no-wrap, fuzzy
msgid "TestProcessor#capability()"
msgstr "TestProcessor#capability()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2180
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void capabilities(BuildProducer<CapabilityBuildItem> capabilityProducer) "
"{\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-"
"transactions\"));\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-"
"metrics\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2183
#, fuzzy
msgid ""
"Extensions can consume registered capabilities using the `Capabilities` "
"build item:"
msgstr "拡張機能は、 `Capabilities` ビルド項目を使用して登録された機能を消費することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2184
#, no-wrap, fuzzy
msgid "TestProcessor#doSomeCoolStuff()"
msgstr "TestProcessor#doSomeCoolStuff()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2193
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void doSomeCoolStuff(Capabilities capabilities) {\n"
"        if (capabilities.isPresent(Capability.TRANSACTIONS)) {\n"
"          // do something only if JTA transactions are in...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2197
#, fuzzy
msgid ""
"Capabilities should follow the naming conventions of Java packages; e.g. `io."
"quarkus.security.jpa`.  Capabilities provided by core extensions should be "
"listed in the `io.quarkus.deployment.Capability` enum and their name should "
"always start with the `io.quarkus` prefix."
msgstr ""
"`io.quarkus.security.jpa` 機能はJavaパッケージの命名規則に従うべきです。コア拡張機能によって提供される機能は `io."
"quarkus.deployment.Capability` enum にリストされ、その名前は常に `io.quarkus` で始まるべきです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2198
#, no-wrap, fuzzy
msgid "Bean Defining Annotations"
msgstr "Bean定義アノテーション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2200
#, fuzzy
msgid ""
"The CDI layer processes CDI beans that are either explicitly registered or "
"that it discovers based on bean defining annotations as defined in http://"
"docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[2.5.1. "
"Bean defining annotations]. You can expand this set of annotations to "
"include annotations your extension processes using a "
"`BeanDefiningAnnotationBuildItem` as shown in this "
"`TestProcessor#registerBeanDefinningAnnotations` example:"
msgstr ""
"CDI レイヤは、明示的に登録された CDI ビーン、または link:http://docs.jboss.org/cdi/spec/2.0/cdi-"
"spec.html#bean_defining_annotations[2.5.1] で定義されているビーン定義アノテーションに基づいて検出された "
"CDI ビーンを処理する。 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#bean_defining_annotations[ビーン] 定義アノテーション。このアノテーションのセットを拡張して、この "
"`TestProcessor#registerBeanDefinningAnnotations` の例に示すように、 "
"`BeanDefiningAnnotationBuildItem` を使用して拡張機能が処理するアノテーションを含めることができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2201
#, no-wrap, fuzzy
msgid "Register a Bean Defining Annotation"
msgstr "Bean定義アノテーションの登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2207
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.jboss.jandex.DotName;\n"
"import io.quarkus.extest.runtime.TestAnnotation;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2211
#, no-wrap
msgid ""
"public final class TestProcessor {\n"
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation."
"class.getName());\n"
"    static DotName TEST_ANNOTATION_SCOPE = DotName."
"createSimple(ApplicationScoped.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2213
#: upstream/_guides/writing-extensions.adoc:2239
#, no-wrap
msgid "...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2221
#, no-wrap
msgid ""
"    @BuildStep\n"
"    BeanDefiningAnnotationBuildItem registerX() {\n"
"        <1>\n"
"        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, "
"TEST_ANNOTATION_SCOPE);\n"
"    }\n"
"...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2231
#, no-wrap
msgid ""
"/**\n"
" * Marker annotation for test configuration target beans\n"
" */\n"
"@Target({ TYPE })\n"
"@Retention(RUNTIME)\n"
"@Documented\n"
"@Inherited\n"
"public @interface TestAnnotation {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2237
#, no-wrap
msgid ""
"/**\n"
" * A sample bean\n"
" */\n"
"@TestAnnotation <2>\n"
"public class ConfiguredBean implements IConfigConsumer {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2241
#, fuzzy
msgid ""
"Register the annotation class and CDI default scope using the Jandex "
"`DotName` class."
msgstr "Jandex `DotName` クラスを使用して、アノテーションクラスと CDI デフォルトスコープを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2242
#, fuzzy
msgid ""
"`ConfiguredBean` will be processed by the CDI layer the same as a bean "
"annotated with the CDI standard @ApplicationScoped."
msgstr ""
"`ConfiguredBean` は CDI 標準の @ApplicationScoped でアノテーションされたビーンと同じように CDI "
"レイヤーによって処理されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2243
#, no-wrap, fuzzy
msgid "Parsing Config to Objects"
msgstr "コンフィグをオブジェクトに解析する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2245
#, fuzzy
msgid ""
"One of the main things an extension is likely to do is completely separate "
"the configuration phase of behavior from the runtime phase. Frameworks often "
"do parsing/load of configuration on startup that can be done during build "
"time to both reduce the runtime dependencies on frameworks like xml parsers "
"as well as reducing the startup time the parsing incurs."
msgstr ""
"拡張機能が行う可能性の高い主なことの一つは、動作の設定フェーズをランタイムフェーズから完全に分離することです。フレームワークはしばしば起動時に設定のパース/"
"ロードを行いますが、これはビルド時に行うことができ、xml パーサのようなフレームワークへのランタイム依存を減らし、パースにかかる起動時間を短縮します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2247
#, fuzzy
msgid ""
"An example of parsing a XML config file using JAXB is shown in the "
"`TestProcessor#parseServiceXmlConfig` method:"
msgstr ""
"JAXBを使用してXML設定ファイルを解析する例は、 `TestProcessor#parseServiceXmlConfig` "
"メソッドに示されています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2247
#, no-wrap, fuzzy
msgid "Parsing an XML Configuration into Runtime XmlConfig Instance"
msgstr "XML 設定のランタイム XmlConfig インスタンスへのパース"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2264
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) "
"throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\"); "
"<1>\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <2>\n"
"...\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2267
#, fuzzy
msgid "Look for a config.xml classpath resource"
msgstr "config.xml のクラスパスリソースを探す"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2268
#, fuzzy
msgid "If found, parse using JAXB context for `XmlConfig.class`"
msgstr "見つかった場合は、JAXB コンテキストを使用してパースします。 `XmlConfig.class`"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2272
#, fuzzy
msgid ""
"If there was no /config.xml resource available in the build environment, "
"then a null `RuntimeServiceBuildItem` would be returned and no subsequent "
"logic based on a `RuntimeServiceBuildItem` being produced would execute."
msgstr ""
"ビルド環境で利用可能な /config.xml リソースがない場合は、null `RuntimeServiceBuildItem` が返され、生成された "
"`RuntimeServiceBuildItem` に基づく後続のロジックは実行されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2275
#, fuzzy
msgid ""
"Typically one is loading a configuration to create some runtime component/"
"service as `parseServiceXmlConfig` is doing. We will come back to the rest "
"of the behavior in `parseServiceXmlConfig` in the following <<Manage Non-CDI "
"Service>> section."
msgstr ""
"通常、 `parseServiceXmlConfig` が行っているように、ランタイムコンポーネント/サービスを作成するために設定をロードしています。 "
"`parseServiceXmlConfig` の動作の残りの部分については、次の link:#Manage Non-CDI Service[[非 "
"CDI サービスの管理]] セクションで説明します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2277
#, fuzzy
msgid ""
"If for some reason you need to parse the config and use it in other build "
"steps in an extension processor, you would need to create an "
"`XmlConfigBuildItem` to pass the parsed XmlConfig instance around."
msgstr ""
"何らかの理由でコンフィグを解析して拡張プロセッサの他のビルドステップで使用する必要がある場合は、 `XmlConfigBuildItem` "
"を作成して解析した XmlConfig インスタンスを渡す必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2281
#, fuzzy
msgid ""
"If you look at the XmlConfig code you will see that it does carry around the "
"JAXB annotations. If you don't want these in the runtime image, you could "
"clone the XmlConfig instance into some POJO object graph and then replace "
"XmlConfig with the POJO class. We will do this in <<Replacing Classes in the "
"Native Image>>."
msgstr ""
"XmlConfig のコードを見ると、JAXB "
"のアノテーションを持ち歩いていることがわかります。ランタイムイメージにこれらのアノテーションを入れたくない場合は、XmlConfig のインスタンスを "
"POJO オブジェクトグラフにクローンして、XmlConfig を POJO クラスに置き換えることができます。これについては link:"
"#Replacing Classes in the Native Image[[ネイティブイメージでクラスを置き換える]] で説明します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2283
#, no-wrap, fuzzy
msgid "Scanning Deployments Using Jandex"
msgstr "Jandexを使用したスキャニング導入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2285
#, fuzzy
msgid ""
"If your extension defines annotations or interfaces that mark beans needing "
"to be processed, you can locate these beans using the Jandex API, a Java "
"annotation indexer and offline reflection library. The following "
"`TestProcessor#scanForBeans` method shows how to find the beans annotated "
"with our `@TestAnnotation` that also implement the `IConfigConsumer` "
"interface:"
msgstr ""
"拡張機能で処理が必要なビーンズをマークするアノテーションやインターフェイスを定義している場合は、Java "
"アノテーションインデクサとオフラインリフレクションライブラリである Jandex API を使用して、これらのビーンズを見つけることができます。次の "
"`TestProcessor#scanForBeans` メソッドは、 `IConfigConsumer` インターフェイスも実装している "
"`@TestAnnotation` でアノテーションされたビーンを見つける方法を示しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2286
#, no-wrap, fuzzy
msgid "Example Jandex Usage"
msgstr "ジャンデックスの使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2291
#, no-wrap
msgid ""
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation."
"class.getName());\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2314
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem "
"beanArchiveIndex, <1>\n"
"            BuildProducer<TestBeanBuildItem> testBeanProducer) {\n"
"        IndexView indexView = beanArchiveIndex.getIndex(); <2>\n"
"        Collection<AnnotationInstance> testBeans = indexView."
"getAnnotations(TEST_ANNOTATION); <3>\n"
"        for (AnnotationInstance ann : testBeans) {\n"
"            ClassInfo beanClassInfo = ann.target().asClass();\n"
"            try {\n"
"                boolean isConfigConsumer = beanClassInfo.interfaceNames()\n"
"                        .stream()\n"
"                        .anyMatch(dotName -> dotName.equals(DotName."
"createSimple(IConfigConsumer.class.getName()))); <4>\n"
"                if (isConfigConsumer) {\n"
"                    Class<IConfigConsumer> beanClass = "
"(Class<IConfigConsumer>) Class.forName(beanClassInfo.name().toString(), "
"false, Thread.currentThread().getContextClassLoader());\n"
"                    testBeanProducer.produce(new "
"TestBeanBuildItem(beanClass)); <5>\n"
"                    log.infof(\"Configured bean: %s\", beanClass);\n"
"                }\n"
"            } catch (ClassNotFoundException e) {\n"
"                log.warn(\"Failed to load bean class\", e);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2316
#, fuzzy
msgid ""
"Depend on a `BeanArchiveIndexBuildItem` to have the build step be run after "
"the deployment has been indexed."
msgstr ""
"デプロイメントがインデックス化された後にビルドステップが実行されるようにするには、 `BeanArchiveIndexBuildItem` "
"に依存します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2317
#, fuzzy
msgid "Retrieve the index."
msgstr "インデックスを取得します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2318
#, fuzzy
msgid "Find all beans annotated with `@TestAnnotation`."
msgstr "`@TestAnnotation` で注釈されたすべての豆を検索する ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2319
#, fuzzy
msgid ""
"Determine which of these beans also has the `IConfigConsumer` interface."
msgstr "これらのビーンズのうち、どのビーンズが `IConfigConsumer` インターフェイスも持っているかを決定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2320
#, fuzzy
msgid ""
"Save the bean class in a `TestBeanBuildItem` for use in a latter "
"RUNTIME_INIT build step that will interact with the bean instances."
msgstr ""
"ビーンクラスを `TestBeanBuildItem` に保存して、後の RUNTIME_INIT "
"ビルドステップでビーンインスタンスと対話するために使用します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2321
#, no-wrap, fuzzy
msgid "Interacting With Extension Beans"
msgstr "エクステンションビーンズとの相互作用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2323
#, fuzzy
msgid ""
"You can use the `io.quarkus.arc.runtime.BeanContainer` interface to interact "
"with your extension beans. The following `configureBeans` methods illustrate "
"interacting with the beans scanned for in the previous section:"
msgstr ""
"`io.quarkus.arc.runtime.BeanContainer` インターフェイスを使用して、拡張ビーンと対話することができます。以下の "
"`configureBeans` メソッドは、前のセクションでスキャンしたビーンとの対話を説明しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2324
#, no-wrap, fuzzy
msgid "Using CDI BeanContainer Interface"
msgstr "CDI BeanContainerインタフェースの使用"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2333
#, no-wrap
msgid ""
"// TestProcessor#configureBeans\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    void configureBeans(TestRecorder recorder, List<TestBeanBuildItem> "
"testBeans, <1>\n"
"            BeanContainerBuildItem beanContainer, <2>\n"
"            TestRunTimeConfig runTimeConfig) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2339
#, no-wrap
msgid ""
"        for (TestBeanBuildItem testBeanBuildItem : testBeans) {\n"
"            Class<IConfigConsumer> beanClass = testBeanBuildItem."
"getConfigConsumer();\n"
"            recorder.configureBeans(beanContainer.getValue(), beanClass, "
"buildAndRunTimeConfig, runTimeConfig); <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2349
#, no-wrap
msgid ""
"// TestRecorder#configureBeans\n"
"    public void configureBeans(BeanContainer beanContainer, "
"Class<IConfigConsumer> beanClass,\n"
"            TestBuildAndRunTimeConfig buildTimeConfig,\n"
"            TestRunTimeConfig runTimeConfig) {\n"
"        log.info(\"Begin BeanContainerListener callback\\n\");\n"
"        IConfigConsumer instance = beanContainer.instance(beanClass); <4>\n"
"        instance.loadConfig(buildTimeConfig, runTimeConfig); <5>\n"
"        log.infof(\"configureBeans, instance=%s\\n\", instance);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2351
#, fuzzy
msgid ""
"Consume the `TestBeanBuildItem`s produced from the scanning build step."
msgstr "スキャンビルドステップで生成された `TestBeanBuildItem` を消費する。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2352
#, fuzzy
msgid ""
"Consume the `BeanContainerBuildItem` to order this build step to run after "
"the CDI bean container has been created."
msgstr ""
"CDI Beanコンテナが作成された後にこのビルドステップを実行するために、 `BeanContainerBuildItem` を消費します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2353
#, fuzzy
msgid "Call the runtime recorder to record the bean interactions."
msgstr "ランタイムレコーダを呼び出して、ビーンのインタラクションを記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2354
#, fuzzy
msgid "Runtime recorder retrieves the bean using its type."
msgstr "ランタイムレコーダは、その型を使用してビーンを取得します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2355
#, fuzzy
msgid ""
"Runtime recorder invokes the `IConfigConsumer#loadConfig(...)` method "
"passing in the configuration objects with runtime information."
msgstr ""
"ランタイム・レコーダは `IConfigConsumer#loadConfig(…)` "
"メソッドを呼び出し、ランタイム情報を含む設定オブジェクトを渡します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2356
#, no-wrap, fuzzy
msgid "Manage Non-CDI Service"
msgstr "非CDIサービスの管理"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2358
#, fuzzy
msgid ""
"A common purpose for an extension is to integrate a non-CDI aware service "
"into the CDI based Quarkus runtime. Step 1 of this task is to load any "
"configuration needed in a STATIC_INIT build step as we did in <<Parsing "
"Config to Objects>>. Now we need to create an instance of the service using "
"the configuration. Let's return to the `TestProcessor#parseServiceXmlConfig` "
"method to see how this can be done."
msgstr ""
"拡張機能の一般的な目的は、CDIを認識しないサービスをCDIベースのQuarkusランタイムに統合することです。このタスクのステップ1では、 link:"
"#Parsing Config to Objects[[Parsing Config to Objects]] "
"で行ったように、STATIC_INITビルドステップで必要な設定をロードします。次に、設定を使用してサービスのインスタンスを作成する必要があります。 "
"`TestProcessor#parseServiceXmlConfig` メソッドに戻って、これがどのようにできるか見てみましょう。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2359
#, no-wrap, fuzzy
msgid "Creating a Non-CDI Service"
msgstr "非CDIサービスの作成"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2379
#, no-wrap
msgid ""
"// TestProcessor#parseServiceXmlConfig\n"
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) "
"throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\");\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);\n"
"            log.info(\"Loaded XmlConfig, creating service\");\n"
"            RuntimeValue<RuntimeXmlConfigService> service = recorder."
"initRuntimeService(config); //<1>\n"
"            serviceBuildItem = new RuntimeServiceBuildItem(service); //<3>\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2385
#, no-wrap
msgid ""
"// TestRecorder#initRuntimeService\n"
"    public RuntimeValue<RuntimeXmlConfigService> "
"initRuntimeService(XmlConfig config) {\n"
"        RuntimeXmlConfigService service = new "
"RuntimeXmlConfigService(config); //<2>\n"
"        return new RuntimeValue<>(service);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2389
#, no-wrap
msgid ""
"// RuntimeServiceBuildItem\n"
"    final public class RuntimeServiceBuildItem extends SimpleBuildItem {\n"
"    private RuntimeValue<RuntimeXmlConfigService> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2393
#, no-wrap
msgid ""
"    public RuntimeServiceBuildItem(RuntimeValue<RuntimeXmlConfigService> "
"service) {\n"
"        this.service = service;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2398
#, no-wrap
msgid ""
"    public RuntimeValue<RuntimeXmlConfigService> getService() {\n"
"        return service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2400
#, fuzzy
msgid "Call into the runtime recorder to record the creation of the service."
msgstr "ランタイムレコーダーに呼び出して、サービスの作成を記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2401
#, fuzzy
msgid ""
"Using the parsed `XmlConfig` instance, create an instance of "
"`RuntimeXmlConfigService` and wrap it in a `RuntimeValue`. Use a "
"`RuntimeValue` wrapper for non-interface objects that are non-proxiable."
msgstr ""
"解析された `XmlConfig` インスタンスを使用して、 `RuntimeXmlConfigService` のインスタンスを作成し、それを "
"`RuntimeValue` でラップします。 `RuntimeValue` ラッパーは、プロキシ不可能な非インターフェイス・オブジェクトに使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2402
#, fuzzy
msgid ""
"Wrap the return service value in a `RuntimeServiceBuildItem` for use in a "
"RUNTIME_INIT build step that will start the service."
msgstr ""
"サービスを開始する RUNTIME_INIT ビルドステップで使用するために、サービスの戻り値を `RuntimeServiceBuildItem` "
"でラップします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2403
#, no-wrap, fuzzy
msgid "Starting a Service"
msgstr "サービスの開始"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2405
#, fuzzy
msgid ""
"Now that you have recorded the creation of a service during the build phase, "
"you need to record how to start the service at runtime during booting. You "
"do this with a RUNTIME_INIT build step as shown in the "
"`TestProcessor#startRuntimeService` method."
msgstr ""
"ビルドフェーズでのサービスの作成を記録したので、ブート時にランタイムでサービスを起動する方法を記録する必要があります。これを行うには、 "
"`TestProcessor#startRuntimeService` メソッドに示されているように、RUNTIME_INIT "
"ビルドステップを使用します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2406
#, no-wrap, fuzzy
msgid "Starting/Stopping a Non-CDI Service"
msgstr "非CDIサービスの開始/停止"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2422
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, "
"ShutdownContextBuildItem shutdownContextBuildItem , // <1>\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException { //"
" <2>\n"
"        if (serviceBuildItem != null) {\n"
"            log.info(\"Registering service start\");\n"
"            recorder.startRuntimeService(shutdownContextBuildItem, "
"serviceBuildItem.getService()); // <3>\n"
"        } else {\n"
"            log.info(\"No RuntimeServiceBuildItem seen, check config.xml\");\n"
"        }\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2430
#, no-wrap
msgid ""
"// TestRecorder#startRuntimeService\n"
"    public void startRuntimeService(ShutdownContext shutdownContext, "
"RuntimeValue<RuntimeXmlConfigService> runtimeValue)\n"
"            throws IOException {\n"
"        RuntimeXmlConfigService service = runtimeValue.getValue();\n"
"        service.startService(); //<5>\n"
"        shutdownContext.addShutdownTask(service::stopService); //<6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2432
#, fuzzy
msgid ""
"We consume a ShutdownContextBuildItem to register the service shutdown."
msgstr "ShutdownContextBuildItemを消費してサービスのシャットダウンを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2433
#, fuzzy
msgid ""
"We consume the previously initialized service captured in "
"`RuntimeServiceBuildItem`."
msgstr "`RuntimeServiceBuildItem` で取得した初期化済みのサービスを消費します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2434
#, fuzzy
msgid "Call the runtime recorder to record the service start invocation."
msgstr "ランタイムレコーダーを呼び出して、サービス開始時の呼び出しを記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2435
#, fuzzy
msgid ""
"Produce a `ServiceStartBuildItem` to indicate the startup of a service. See "
"<<Startup and Shutdown Events>> for details."
msgstr ""
"サービスの起動を示す `ServiceStartBuildItem` を生成します。詳細は link:#Startup and Shutdown "
"Events[[起動・シャットダウンイベント]] を参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2436
#, fuzzy
msgid ""
"Runtime recorder retrieves the service instance reference and calls its "
"`startService` method."
msgstr "ランタイム レコーダはサービス インスタンス参照を取得し、その `startService` メソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2437
#, fuzzy
msgid ""
"Runtime recorder registers an invocation of the service instance "
"`stopService` method with the Quarkus `ShutdownContext`."
msgstr ""
"ランタイムレコーダーは、サービスインスタンス `stopService` メソッドの呼び出しをQuarkus `ShutdownContext` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2440
#, fuzzy
msgid ""
"The code for the `RuntimeXmlConfigService` can be viewed here: {quarkus-blob-"
"url}/core/test-extension/runtime/src/main/java/io/quarkus/extest/runtime/"
"RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"
msgstr ""
"`RuntimeXmlConfigService` のコードはこちらで確認できます。{quarkus-blob-url}/core/test-"
"extension/runtime/src/main/java/io/quarkus/extest/runtime/"
"RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2442
#, fuzzy
msgid ""
"The testcase for validating that the `RuntimeXmlConfigService` has started "
"can be found in the `testRuntimeXmlConfigService` test of "
"`ConfiguredBeanTest` and `NativeImageIT`."
msgstr ""
"`RuntimeXmlConfigService` が起動したことを検証するためのテストケースは、 `ConfiguredBeanTest` と "
"`NativeImageIT` の `testRuntimeXmlConfigService` テストにあります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2443
#, no-wrap, fuzzy
msgid "Startup and Shutdown Events"
msgstr "スタートアップとシャットダウンのイベント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2446
#, fuzzy
msgid ""
"The Quarkus container supports startup and shutdown lifecycle events to "
"notify components of the container startup and shutdown. There are CDI "
"events fired that components can observe are illustrated in this example:"
msgstr ""
"Quarkusコンテナは、コンテナの起動とシャットダウンをコンポーネントに通知するための起動とシャットダウンのライフサイクルイベントをサポートしています。この例では、コンポーネントが観察できるCDIイベントが発生しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2447
#, no-wrap, fuzzy
msgid "Observing Container Startup"
msgstr "コンテナ起動の観察"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2452
#, no-wrap
msgid ""
"import io.quarkus.runtime.ShutdownEvent;\n"
"import io.quarkus.runtime.StartupEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2461
#, no-wrap
msgid ""
"public class SomeBean {\n"
"    /**\n"
"     * Called when the runtime has started\n"
"     * @param event\n"
"     */\n"
"    void onStart(@Observes StartupEvent event) { // <1>\n"
"        System.out.printf(\"onStart, event=%s%n\", event);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2470
#, no-wrap
msgid ""
"    /**\n"
"     * Called when the runtime is shutting down\n"
"     * @param event\n"
"    */\n"
"    void onStop(@Observes ShutdownEvent event) { // <2>\n"
"        System.out.printf(\"onStop, event=%s%n\", event);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2472
#, fuzzy
msgid "Observe a `StartupEvent` to be notified the runtime has started."
msgstr "ランタイムが開始されたことを通知するために `StartupEvent` を監視します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2473
#, fuzzy
msgid ""
"Observe a `ShutdownEvent` to be notified when the runtime is going to "
"shutdown."
msgstr "ランタイムがシャットダウンしようとしているときに通知されるように `ShutdownEvent` を監視します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2477
#, fuzzy
msgid ""
"What is the relevance of startup and shutdown events for extension authors? "
"We have already seen the use of a `ShutdownContext` to register a callback "
"to perform shutdown tasks in the <<Starting a Service>> section. These "
"shutdown tasks would be called after a `ShutdownEvent` had been sent."
msgstr ""
"拡張機能の作者にとって、起動イベントとシャットダウンイベントの関連性とは何でしょうか？ link:#Starting a "
"Service[サービスの開始]] セクションで、シャットダウンタスクを実行するためのコールバックを登録するために `ShutdownContext` "
"を使用することをすでに見てきました。これらのシャットダウンタスクは `ShutdownEvent` が送信された後に呼び出されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2483
#, fuzzy
msgid ""
"A `StartupEvent` is fired after all `io.quarkus.deployment.builditem."
"ServiceStartBuildItem` producers have been consumed.  The implication of "
"this is that if an extension has services that application components would "
"expect to have been started when they observe a `StartupEvent`, the build "
"steps that invoke the runtime code to start those services needs to produce "
"a `ServiceStartBuildItem` to ensure that the runtime code is run before the "
"`StartupEvent` is sent. Recall that we saw the production of a "
"`ServiceStartBuildItem` in the previous section, and it is repeated here for "
"clarity:"
msgstr ""
"`StartupEvent` は、すべての `io.quarkus.deployment.builditem."
"ServiceStartBuildItem` "
"プロデューサが消費された後に発射されます。このことの意味するところは、拡張機能にアプリケーションコンポーネントが `StartupEvent` "
"を観測したときに開始されたと予想されるサービスがある場合、それらのサービスを開始するためにランタイムコードを呼び出すビルドステップで "
"`ServiceStartBuildItem` を生成して、 `StartupEvent` "
"が送信される前にランタイムコードが実行されるようにする必要があるということです。 `ServiceStartBuildItem` "
"の生成については前のセクションで見たことを思い出してください。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2484
#, no-wrap, fuzzy
msgid "Example of Producing a ServiceStartBuildItem"
msgstr "ServiceStartBuildItemの生成例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2495
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, "
"ShutdownContextBuildItem shutdownContextBuildItem,\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException {\n"
"...\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2497
#, fuzzy
msgid ""
"Produce a `ServiceStartBuildItem` to indicate that this is a service "
"starting step that needs to run before the `StartupEvent` is sent."
msgstr ""
"`StartupEvent` を送信する前に実行する必要があるサービス開始ステップであることを示すために `ServiceStartBuildItem` "
"を作成します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2498
#, no-wrap, fuzzy
msgid "Register Resources for Use in Native Image"
msgstr "ネイティブイメージで使用するためのリソースを登録する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2500
#, fuzzy
msgid ""
"Not all configuration or resources can be consumed at build time. If you "
"have classpath resources that the runtime needs to access, you need to "
"inform the build phase that these resources need to be copied into the "
"native image. This is done by producing one or more "
"`NativeImageResourceBuildItem` or `NativeImageResourceBundleBuildItem` in "
"the case of resource bundles. Examples of this are shown in this sample "
"`registerNativeImageResources` build step:"
msgstr ""
"ビルド時にすべてのコンフィギュレーションやリソースを消費できるわけではありません。ランタイムがアクセスする必要のあるクラスパスリソースがある場合、そのリソースをネイティブイメージにコピーする必要があることをビルドフェーズで伝える必要があります。これは、リソースバンドルの場合は1つまたは複数の "
"`NativeImageResourceBuildItem` または `NativeImageResourceBundleBuildItem` "
"を生成することによって行われます。この例を `registerNativeImageResources` ビルドステップのサンプルに示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2501
#, no-wrap, fuzzy
msgid "Registering Resources and ResourceBundles"
msgstr "リソースとリソースバンドルの登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2509
#, no-wrap
msgid ""
"public final class MyExtProcessor {\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBuildItem> resource;\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBundleBuildItem> resourceBundle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2513
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources() {\n"
"        resource.produce(new NativeImageResourceBuildItem(\"/security/"
"runtime.keys\")); //<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2516
#, no-wrap
msgid ""
"        resource.produce(new NativeImageResourceBuildItem(\n"
"                \"META-INF/my-descriptor.xml\")); //<2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2520
#, no-wrap
msgid ""
"        resourceBundle.produce(new NativeImageResourceBuildItem(\"javax.xml."
"bind.Messages\")); //<3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2522
#, fuzzy
msgid ""
"Indicate that the /security/runtime.keys classpath resource should be copied "
"into native image."
msgstr "クラスパスリソース/security/runtime.keysをネイティブイメージにコピーする必要があることを示しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2523
#, fuzzy
msgid ""
"Indicate that the `META-INF/my-descriptor.xml` resource should be copied "
"into native image"
msgstr "`META-INF/my-descriptor.xml` リソースをネイティブイメージにコピーすることを示す"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2524
#, fuzzy
msgid ""
"Indicate that the \"javax.xml.bind.Messages\" resource bundle should be "
"copied into native image."
msgstr "javax.xml.bind.Messages\"リソースバンドルをネイティブイメージにコピーすることを示します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2525
#, no-wrap, fuzzy
msgid "Service files"
msgstr "サービスファイル"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2529
#, fuzzy
msgid ""
"If you are using `META-INF/services` files you need to register the files as "
"resources so that your native image can find them, but you also need to "
"register each listed class for reflection so they can be instantiated or "
"inspected at run-time:"
msgstr ""
"`META-INF/services` "
"ファイルを使用している場合は、ネイティブイメージがファイルを見つけられるようにリソースとして登録する必要がありますが、リストされている各クラスを反映させるために登録する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2533
#: upstream/_guides/writing-extensions.adoc:2563
#: upstream/_guides/writing-extensions.adoc:2592
#, no-wrap
msgid "public final class MyExtProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2537
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void "
"registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> "
"services) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService."
"class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2542
#, no-wrap
msgid ""
"        // find out all the implementation classes listed in the service "
"files\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread()."
"getContextClassLoader(),\n"
"                                          service);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2550
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be "
"instantiated\n"
"        // in native-image at run-time\n"
"        services.produce(\n"
"            new ServiceProviderBuildItem(io.quarkus.SomeService.class."
"getName(),\n"
"                                         implementations.toArray(new "
"String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2556
#, fuzzy
msgid ""
"`ServiceProviderBuildItem` takes a list of service implementation classes as "
"parameters: if you are not reading them from the service file, make sure "
"that they correspond to the service file contents because the service file "
"will still be read and used at run-time. This is not a substitute for "
"writing a service file."
msgstr ""
"`ServiceProviderBuildItem` "
"は、サービス実装クラスのリストをパラメータとして受け取ります。サービスファイルからそれらを読み込まない場合は、サービスファイルの内容と一致していることを確認してください。これはサービスファイルを書く代わりにはなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2559
#, fuzzy
msgid ""
"This only registers the implementation classes for instantiation via "
"reflection (you will not be able to inspect its fields and methods). If you "
"need to do that, you can do it this way:"
msgstr ""
"これは反射を介してインスタンス化のための実装クラスを登録するだけです(そのフィールドやメソッドを検査することはできません)。その必要がある場合は、このようにします。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2568
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void "
"registerNativeImageResources(BuildProducer<NativeImageResourceBuildItem> "
"resource,\n"
"                                     BuildProducer<ReflectiveClassBuildItem> "
"reflectionClasses) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService."
"class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2571
#, no-wrap
msgid ""
"        // register the service file so it is visible in native-image\n"
"        resource.produce(new NativeImageResourceBuildItem(service));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2581
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be "
"inspected/instantiated\n"
"        // in native-image at run-time\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread()."
"getContextClassLoader(),\n"
"                                          service);\n"
"        reflectionClasses.produce(\n"
"            new ReflectiveClassBuildItem(true, true, implementations."
"toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2585
#, fuzzy
msgid ""
"While this is the easiest way to get your services running natively, it's "
"less efficient than scanning the implementation classes at build time and "
"generating code that registers them at static-init time instead of relying "
"on reflection."
msgstr ""
"これはサービスをネイティブに動作させる最も簡単な方法ですが、ビルド時に実装クラスをスキャンして、 "
"リフレクションに頼るのではなくスタティックイット時にそれらを登録するコードを生成するよりも効率的ではありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2588
#, fuzzy
msgid ""
"You can achieve that by adapting the previous build step to use a static-"
"init recorder instead of registering classes for reflection:"
msgstr ""
"反映のためにクラスを登録するのではなく、スタティックイニットレコーダーを使用するように前のビルドステップを適応させることで、これを実現することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2598
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(ExecutionTime.STATIC_INIT)\n"
"    void registerNativeImageResources(RecorderContext recorderContext,\n"
"                                     SomeServiceRecorder recorder) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService."
"class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2607
#, no-wrap
msgid ""
"        // read the implementation classes\n"
"        Collection<Class<? extends io.quarkus.SomeService>> "
"implementationClasses = new LinkedHashSet<>();\n"
"        Set<String> implementations = ServiceUtil.classNamesNamedIn(Thread."
"currentThread().getContextClassLoader(),\n"
"                                                                    "
"service);\n"
"        for(String implementation : implementations) {\n"
"            implementationClasses.add((Class<? extends io.quarkus."
"SomeService>)\n"
"                recorderContext.classProxy(implementation));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2612
#, no-wrap
msgid ""
"        // produce a static-initializer with those classes\n"
"        recorder.configure(implementationClasses);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2615
#, no-wrap
msgid "@Recorder\n"
"public class SomeServiceRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2620
#, no-wrap
msgid ""
"    public void configure(List<Class<? extends io.quarkus.SomeService>> "
"implementations) {\n"
"        // configure our service statically\n"
"        SomeServiceProvider serviceProvider = SomeServiceProvider."
"instance();\n"
"        SomeServiceBuilder builder = serviceProvider."
"getSomeServiceBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2630
#, no-wrap
msgid ""
"        List<io.quarkus.SomeService> services = new "
"ArrayList<>(implementations.size());\n"
"        // instantiate the service implementations\n"
"        for (Class<? extends io.quarkus.SomeService> implementationClass : "
"implementations) {\n"
"            try {\n"
"                services.add(implementationClass.getConstructor()."
"newInstance());\n"
"            } catch (Exception e) {\n"
"                throw new IllegalArgumentException(\"Unable to instantiate "
"service \" + implementationClass, e);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2634
#, no-wrap
msgid ""
"        // build our service\n"
"        builder.withSomeServices(implementations.toArray(new io.quarkus."
"SomeService[0]));\n"
"        ServiceManager serviceManager = builder.build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2639
#, no-wrap
msgid ""
"        // register it\n"
"        serviceProvider.registerServiceManager(serviceManager, Thread."
"currentThread().getContextClassLoader());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2642
#, no-wrap, fuzzy
msgid "Object Substitution"
msgstr "オブジェクトの置換"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2644
#, fuzzy
msgid ""
"Objects created during the build phase that are passed into the runtime need "
"to have a default constructor in order for them to be created and configured "
"at startup of the runtime from the build time state. If an object does not "
"have a default constructor you will see an error similar to the following "
"during generation of the augmented artifacts:"
msgstr ""
"ビルドフェーズで作成されたオブジェクトでランタイムに渡されるものは、ランタイムの起動時にビルド時の状態から作成され設定されるため、デフォルトのコンストラクタを持っている必要があります。オブジェクトがデフォルト・コンストラクタを持たない場合、拡張成果物の生成時に以下のようなエラーが表示されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2645
#, no-wrap, fuzzy
msgid "DSAPublicKey Serialization Error"
msgstr "DSAPublicKey シリアル化エラー"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2654
#, no-wrap
msgid ""
"\t[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build "
"threw an exception: java.lang.RuntimeException: Unable to serialize objects "
"of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has "
"no default constructor\n"
"\tat io.quarkus.builder.Execution.run(Execution.java:123)\n"
"\tat io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder."
"java:136)\n"
"\tat io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)\n"
"\tat io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)\n"
"\t... 36 more\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2657
#, fuzzy
msgid ""
"There is a `io.quarkus.runtime.ObjectSubstitution` interface that can be "
"implemented to tell Quarkus how to handle such classes. An example "
"implementation for the `DSAPublicKey` is shown here:"
msgstr ""
"このようなクラスをどのように扱うかをQuarkusに伝えるために実装できる `io.quarkus.runtime."
"ObjectSubstitution` インターフェイスがあります。 `DSAPublicKey` の実装例をここに示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2658
#, no-wrap, fuzzy
msgid "DSAPublicKeyObjectSubstitution Example"
msgstr "DSAPublicKeyObjectSubstitution の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2662
#, no-wrap
msgid "package io.quarkus.extest.runtime.subst;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2669
#, no-wrap
msgid ""
"import java.security.KeyFactory;\n"
"import java.security.NoSuchAlgorithmException;\n"
"import java.security.interfaces.DSAPublicKey;\n"
"import java.security.spec.InvalidKeySpecException;\n"
"import java.security.spec.X509EncodedKeySpec;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2671
#, no-wrap
msgid "import io.quarkus.runtime.ObjectSubstitution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2682
#, no-wrap
msgid ""
"public class DSAPublicKeyObjectSubstitution implements "
"ObjectSubstitution<DSAPublicKey, KeyProxy> {\n"
"    private static final Logger log = Logger."
"getLogger(\"DSAPublicKeyObjectSubstitution\");\n"
"    @Override\n"
"    public KeyProxy serialize(DSAPublicKey obj) { //<1>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.serialize\");\n"
"        byte[] encoded = obj.getEncoded();\n"
"        KeyProxy proxy = new KeyProxy();\n"
"        proxy.setContent(encoded);\n"
"        return proxy;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2692
#, no-wrap
msgid ""
"    @Override\n"
"    public DSAPublicKey deserialize(KeyProxy obj) { //<2>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.deserialize\");\n"
"        byte[] encoded = obj.getContent();\n"
"        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);\n"
"        DSAPublicKey dsaPublicKey = null;\n"
"        try {\n"
"            KeyFactory kf = KeyFactory.getInstance(\"DSA\");\n"
"            dsaPublicKey = (DSAPublicKey) kf."
"generatePublic(publicKeySpec);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2699
#, no-wrap
msgid ""
"        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return dsaPublicKey;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2701
#, fuzzy
msgid ""
"The serialize method takes the object without a default constructor and "
"creates a `KeyProxy` that contains the information necessary to recreate the "
"`DSAPublicKey`."
msgstr ""
"`DSAPublicKey` serialize メソッドは、デフォルトのコンストラクタを持たないオブジェクトを受け取り、 `KeyProxy` "
"を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2702
#, fuzzy
msgid ""
"The deserialize method uses the `KeyProxy` to recreate the `DSAPublicKey` "
"from its encoded form using the key factory."
msgstr ""
"deserialize メソッドは、 `KeyProxy` を使用して、キーファクトリーを使用してエンコードされた形式から `DSAPublicKey` "
"を再作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2704
#, fuzzy
msgid ""
"An extension registers this substitution by producing an "
"`ObjectSubstitutionBuildItem` as shown in this "
"`TestProcessor#loadDSAPublicKey` fragment:"
msgstr ""
"拡張機能は、この `TestProcessor#loadDSAPublicKey` フラグメントに示すように "
"`ObjectSubstitutionBuildItem` を生成することで、この置換を登録します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2705
#, no-wrap, fuzzy
msgid "Registering an Object Substitution"
msgstr "オブジェクト置換の登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2718
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,\n"
"            BuildProducer<ObjectSubstitutionBuildItem> substitutions) throws "
"IOException, GeneralSecurityException {\n"
"...\n"
"        // Register how to serialize DSAPublicKey\n"
"        ObjectSubstitutionBuildItem.Holder<DSAPublicKey, KeyProxy> holder = "
"new ObjectSubstitutionBuildItem.Holder(\n"
"                DSAPublicKey.class, KeyProxy.class, "
"DSAPublicKeyObjectSubstitution.class);\n"
"        ObjectSubstitutionBuildItem keysub = new "
"ObjectSubstitutionBuildItem(holder);\n"
"        substitutions.produce(keysub);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2722
#, no-wrap
msgid ""
"        log.info(\"loadDSAPublicKey run\");\n"
"        return new PublicKeyBuildItem(publicKey);\n"
"    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2724
#, no-wrap, fuzzy
msgid "Replacing Classes in the Native Image"
msgstr "ネイティブイメージでクラスを置き換える"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2726
#, fuzzy
msgid ""
"The Graal SDK supports substitutions of classes in the native image. An "
"example of how one could replace the `XmlConfig/XmlData` classes with "
"versions that have no JAXB annotation dependencies is shown in these example "
"classes:"
msgstr ""
"Graal SDK は、ネイティブイメージ内のクラスの置換をサポートしています。 `XmlConfig/XmlData` のクラスを、JAXB "
"アノテーションに依存しないバージョンのクラスに置き換える方法の例を以下に示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2727
#, no-wrap, fuzzy
msgid "Substitution of XmlConfig/XmlData Classes Example"
msgstr "XmlConfig/XmlDataクラスの置換例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2735
#, no-wrap
msgid ""
"package io.quarkus.extest.runtime.graal;\n"
"import java.util.Date;\n"
"import com.oracle.svm.core.annotate.Substitute;\n"
"import com.oracle.svm.core.annotate.TargetClass;\n"
"import io.quarkus.extest.runtime.config.XmlData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2739
#, no-wrap
msgid ""
"@TargetClass(XmlConfig.class)\n"
"@Substitute\n"
"public final class Target_XmlConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2746
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String address;\n"
"    @Substitute\n"
"    private int port;\n"
"    @Substitute\n"
"    private ArrayList<XData> dataList;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2751
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getAddress() {\n"
"        return address;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2756
#, no-wrap
msgid "    @Substitute\n"
"    public int getPort() {\n"
"        return port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2761
#, no-wrap
msgid ""
"    @Substitute\n"
"    public ArrayList<XData> getDataList() {\n"
"        return dataList;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2772
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlConfig{\" +\n"
"                \"address='\" + address + '\\'' +\n"
"                \", port=\" + port +\n"
"                \", dataList=\" + dataList +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2776
#, no-wrap
msgid ""
"@TargetClass(XmlData.class)\n"
"@Substitute\n"
"public final class Target_XmlData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2783
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String name;\n"
"    @Substitute\n"
"    private String model;\n"
"    @Substitute\n"
"    private Date date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2788
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2793
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2798
#, no-wrap
msgid ""
"    @Substitute\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2809
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlData{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", model='\" + model + '\\'' +\n"
"                \", date='\" + date + '\\'' +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:2811
#, no-wrap, fuzzy
msgid "Configuration reference documentation"
msgstr "設定参照ドキュメント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2815
#, fuzzy
msgid ""
"The configuration is an important part of each extension and therefore needs "
"to be properly documented.  Each configuration property should have a proper "
"Javadoc comment."
msgstr ""
"設定は各拡張機能の重要な部分なので、適切に文書化する必要があります。それぞれの設定プロパティには、適切な Javadoc コメントが必要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2818
#, fuzzy
msgid ""
"While it is handy to have the documentation available when coding, this "
"configuration documentation must also be available in the extension guides.  "
"The Quarkus build automatically generates the configuration documentation "
"for you based on the Javadoc comments but you need to explicitly include it "
"in your guide."
msgstr ""
"コーディング時にドキュメントを利用できるようにしておくと便利ですが、この設定ドキュメントは拡張ガイドでも利用できるようにしておく必要があります。Quarkusのビルドでは、Javadocのコメントに基づいて設定ドキュメントが自動的に生成されますが、ガイドに明示的に含める必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2820
#, fuzzy
msgid ""
"In this section, we will explain everything you need to know about the "
"configuration reference documentation."
msgstr "このセクションでは、設定参照ドキュメントについて知っておくべきことをすべて説明します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2821
#, no-wrap, fuzzy
msgid "Writing the documentation"
msgstr "ドキュメントの書き方"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2824
#, fuzzy
msgid ""
"For each configuration property, you need to write some Javadoc explaining "
"its purpose."
msgstr "それぞれの設定プロパティに対して、その目的を説明するJavadocを書く必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2828
#, fuzzy
msgid ""
"Always make the first sentence meaningful and self-contained as it is "
"included in the summary table."
msgstr "必ず最初の一文に意味を持たせ、まとめ表に記載するように自己完結させましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2831
#, fuzzy
msgid ""
"You can either use standard Javadoc comments or Asciidoc directly as a "
"Javadoc comment."
msgstr "標準のJavadocコメントかAsciidocを直接Javadocコメントとして使うことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2835
#, fuzzy
msgid ""
"We assume you are familiar with writing Javadoc comments so let's focus on "
"our Asciidoc support.  While standard Javadoc comments are perfectly fine "
"for simple documentation (recommended even), if you want to include tips, "
"source code extracts, lists... Asciidoc comes in handy."
msgstr ""
"ここでは、Javadocのコメントを書くことに慣れていることを前提としているので、Asciidocのサポートに焦点を当ててみましょう。標準的なJavadocのコメントは単純な文書化には完全に適していますが（推奨されています）、もしあなたがTipsやソースコードの抜粋、リストなどを含めたい場合は、Asciidocが便利です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2837
#, fuzzy
msgid "Here is a typical configuration property commented with Asciidoc:"
msgstr "以下は、Asciidocでコメントされた典型的な設定プロパティです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2854
#, no-wrap
msgid ""
"/**\n"
" * Class name of the Hibernate ORM dialect. The complete list of bundled "
"dialects is available in the\n"
" * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/"
"dialect/package-summary.html[Hibernate ORM JavaDoc].\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Not all the dialects are supported in GraalVM native executables: we "
"currently provide driver extensions for PostgreSQL,\n"
" * MariaDB, Microsoft SQL Server and H2.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"@ConfigItem\n"
"public Optional<String> dialect;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2858
#, fuzzy
msgid ""
"This is the simple case: you just have to write Asciidoc and mark the "
"comment with the `@asciidoclet` tag.  This tag has two purposes: it is used "
"as a marker for our generation tool but it is also used by the `javadoc` "
"process for proper Javadoc generation."
msgstr ""
"これは簡単なケースです: Asciidoc を書いて、コメントに `@asciidoclet` "
"タグを付ければいいだけです。このタグには2つの目的があります: 生成ツールのマーカーとして使用されますが、 `javadoc` のプロセスで適切な "
"Javadoc 生成のためにも使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2860
#, fuzzy
msgid "Now let's consider a more complicated example:"
msgstr "では、もう少し複雑な例を考えてみましょう。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2898
#, no-wrap
msgid ""
"// @formatter:off\n"
"/**\n"
" * Name of the file containing the SQL statements to execute when Hibernate "
"ORM starts.\n"
" * Its default value differs depending on the Quarkus launch mode:\n"
" *\n"
" * * In dev and test modes, it defaults to `import.sql`.\n"
" *   Simply add an `import.sql` file in the root of your resources directory\n"
" *   and it will be picked up without having to set this property.\n"
" *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.\n"
" * * In production mode, it defaults to `no-file`.\n"
" *   It means Hibernate ORM won't try to execute any SQL import file by "
"default.\n"
" *   Pass an explicit value to force Hibernate ORM to execute the SQL import "
"file.\n"
" *\n"
" * If you need different SQL statements between dev mode, test "
"(`@QuarkusTest`) and in production, use Quarkus\n"
" * https://quarkus.io/guides/config#configuration-profiles[configuration "
"profiles facility].\n"
" *\n"
" * [source,property]\n"
" * .application.properties\n"
" * ----\n"
" * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql\n"
" * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql\n"
" * %prod.quarkus.hibernate-orm.sql-load-script = no-file\n"
" * ----\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Quarkus supports `.sql` file with SQL statements or comments spread over "
"multiple lines.\n"
" * Each SQL statement must be terminated by a semicolon.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"// @formatter:on\n"
"@ConfigItem\n"
"public Optional<String> sqlLoadScript;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2901
#, fuzzy
msgid "A few comments on this one:"
msgstr "これについてのコメントをいくつか。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2907
#, fuzzy
msgid ""
"Every time you will need the indentation to be respected in the Javadoc "
"comment (think list items spread on multiple lines or indented source code), "
"you will need to disable temporarily the automatic Eclipse formatter (this, "
"even if you don't use Eclipse as the formatter is included in our build).  "
"To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the "
"fact that they are separate comments and there is a space after the `//` "
"marker. This is required."
msgstr ""
"Javadocのコメントでインデントを尊重する必要がある場合（複数行にまたがるリスト項目やインデントされたソースコードを考えてみてください）には、Eclipseの自動フォーマッタを一時的に無効にする必要があります（これは、私たちのビルドにはフォーマッタが含まれているので、Eclipseを使用していない場合でも同様です）。これを行うには、 "
"`// @formatter:off` / `// @formatter:on` マーカーを使用してください。これらは別々のコメントであり、 `//` "
"マーカーの後にスペースがあることに注意してください。これは必須です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2908
#, fuzzy
msgid ""
"As you can see, you can use the full power of Asciidoctor (except for the "
"limitation below)"
msgstr "見ての通り、アッシドクトールのフルパワーが使えます（以下の制限を除く）。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2913
#, fuzzy
msgid ""
"You cannot use open blocks (`--`) in your Asciidoctor documentation.  All "
"the other types of blocks (source, admonitions...) are supported."
msgstr ""
"Asciidoctor のドキュメントでは、オープンブロック ( `--` ) を使用することはできません。他のすべてのタイプのブロック "
"(ソース、アドミッション...) がサポートされています。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2920
#, fuzzy
msgid ""
"By default, the doc generator will use the hyphenated field name as the key "
"of a `java.util.Map` configuration item.  To override this default and have "
"a user friendly key (independent of implementation details), you may use the "
"`io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the "
"following example,"
msgstr ""
"デフォルトでは、doc ジェネレータは `java.util.Map` "
"設定項目のキーとしてハイフンで囲まれたフィールド名を使用します。このデフォルトを上書きして（実装の詳細とは無関係に）ユーザーフレンドリーなキーを持つためには、 "
"`io.quarkus.runtime.annotations.ConfigDocMapKey` "
"アノテーションを使用することができます。以下の例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2931
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Namespace configuration.\n"
"     */\n"
"    @ConfigItem(name = ConfigItem.PARENT)\n"
"    @ConfigDocMapKey(\"cache-name\") <1>\n"
"    Map<String, CaffeineNamespaceConfig> namespace;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2934
#, fuzzy
msgid ""
"This will generate a configuration map key named `quarkus.some.\"cache-"
"name\"` instead of `quarkus.some.\"namespace\"`."
msgstr ""
"これにより、 `quarkus.some.\"namespace\"` の代わりに `quarkus.some.\"cache-name\"` "
"という名前の構成マップキーが生成されます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2936
#, no-wrap, fuzzy
msgid "Writing section documentation"
msgstr "セクションのドキュメントを書く"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2940
#, fuzzy
msgid ""
"If you wish to generate configuration section of a given `@ConfigGroup`, "
"Quarkus has got you covered with the `@ConfigDocSection` annotation.  See "
"the code example below:"
msgstr ""
"指定された `@ConfigGroup` の設定セクションを生成したい場合は、 `@ConfigDocSection` "
"アノテーションで対応できます。以下のコード例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2949
#, no-wrap
msgid ""
"/**\n"
"* Config group related configuration.\n"
"* Amazing introduction here\n"
"*/\n"
"@ConfigItem\n"
"@ConfigDocSection <1>\n"
"public ConfigGroupConfig configGroup;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2954
#, fuzzy
msgid ""
"This will add a section documentation for the `configGroup` config item in "
"the generated documentation.  Section's title and introduction will be "
"derived from the javadoc of the configuration item. The first sentence from "
"the javadoc is considered as the section title and the remaining sentences "
"used as section introduction.  You can also use the `@asciidoclet` tag as "
"shown above."
msgstr ""
"これは、生成されたドキュメントの中に `configGroup` "
"設定項目のためのセクションドキュメントを追加します。セクションのタイトルと導入は、設定項目の javadoc から派生します。javadoc "
"の最初の文がセクションのタイトルとみなされ、残りの文がセクションの紹介文として使用されます。上記のように `@asciidoclet` "
"タグを使用することもできます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2955
#, no-wrap, fuzzy
msgid "Generating the documentation"
msgstr "ドキュメントの生成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2958
#, fuzzy
msgid "Generating the documentation is easy:"
msgstr "ドキュメントの生成は簡単です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2960
#, fuzzy
msgid "Running `./mvnw clean install -DskipTests -DskipITs` will do."
msgstr "`./mvnw clean install -DskipTests -DskipITs` を実行すればOKです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2961
#, fuzzy
msgid ""
"You can either do it globally or in a specific extension directory (e.g. "
"`extensions/mailer`)."
msgstr "グローバルに行うことも、特定の拡張機能ディレクトリ ( `extensions/mailer` など) で行うこともできます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2963
#, fuzzy
msgid ""
"The documentation is generated in the global `target/asciidoc/generated/"
"config/` located at the root of the project."
msgstr ""
"ドキュメントはプロジェクトのルートにあるグローバル `target/asciidoc/generated/config/` で生成されます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2964
#, no-wrap, fuzzy
msgid "Including the documentation in the extension guide"
msgstr "拡張ガイドにドキュメントを含める"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2967
#, fuzzy
msgid ""
"Now that you have generated the configuration reference documentation for "
"your extension, you need to include it in your guide (and review it)."
msgstr ""
"これで、あなたの拡張機能の設定参照ドキュメントが生成されたので、それをガイドに含める必要があります (そして、それをレビューする必要があります)。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2969
#, fuzzy
msgid "This is simple, include the generated documentation in your guide:"
msgstr "これは簡単で、生成されたドキュメントをガイドに含めます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2973
#, no-wrap
msgid ""
"\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, "
"leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2976
#, fuzzy
msgid ""
"If you are interested in including the generated documentation for the "
"config group, you can use the include statement below"
msgstr "設定グループのために生成されたドキュメントを含めたい場合は、以下のinclude文を使用することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2979
#, no-wrap
msgid ""
"\\include::{generated-dir}/config/hyphenated-config-group-class-name-with-"
"runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts="
"optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2982
#, fuzzy
msgid ""
"For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` "
"configuration group will be generated in a file named `quarkus-vertx-http-"
"config-group-form-auth-config.adoc`."
msgstr ""
"例えば、 `io.quarkus.vertx.http.runtime.FormAuthConfig` 設定グループは `quarkus-vertx-"
"http-config-group-form-auth-config.adoc` という名前のファイルに生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2985
#, fuzzy
msgid "A few recommendations:"
msgstr "お勧めをいくつか。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2987
#, fuzzy
msgid ""
"`opts=optional` is mandatory as we don't want the build to fail if only part "
"of the configuration documentation has been generated"
msgstr "`opts=optional` は、設定ドキュメントの一部しか生成されていない場合にビルドを失敗させたくないので必須です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2990
#, fuzzy
msgid ""
"The documentation is generated with a title level of 2 (i.e. `==`).  You "
"usually need to adjust it.  It can be done with `leveloffset=+N`."
msgstr ""
"ドキュメントはタイトルレベルが2(例: `==` )で生成されます。通常はこれを調整する必要があります。これは `leveloffset=+N` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2993
#, fuzzy
msgid ""
"It is not recommended to include the whole configuration documentation in "
"the middle of your guide as it's heavy.  If you have an `application."
"properties` extract with your configuration, just do as follows."
msgstr ""
"ガイドの途中に設定ドキュメント全体を入れるのは重いのでお勧めできません。 `application.properties` "
"のエキスが設定と一緒に入っている場合は、以下のようにすればいいだけです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2995
#, fuzzy
msgid "First, include a tip just below your `application.properties` extract:"
msgstr "まず、 `application.properties` のエキスのすぐ下にチップを入れます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3000
#, no-wrap
msgid ""
"[TIP]\n"
"For more information about the extension configuration please refer to the "
"<<configuration-reference, Configuration Reference>>.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3003
#, fuzzy
msgid ""
"Then, at the end of your documentation, include the extensive documentation:"
msgstr "そして、文書の最後には、広範な文書を含めてください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3007
#, no-wrap
msgid "[[configuration-reference]]\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3007
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3010
msgid ""
"\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, "
"leveloffset=+1]"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3013
#, fuzzy
msgid "Finally, generate the documentation and check it out."
msgstr "最後にドキュメントを生成して確認します。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3014
#, no-wrap, fuzzy
msgid "Continuous testing of your extension"
msgstr "拡張機能の継続的なテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3019
#, fuzzy
msgid ""
"In order to make it easy for extension authors to test their extensions "
"daily against the latest snapshot of Quarkus, Quarkus has introduced the "
"notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/"
"quarkus-ecosystem-ci/blob/master/README.adoc[README] has all the details on "
"how to set up a GitHub Actions job to take advantage of this capability, "
"while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides "
"an overview of what the process looks like."
msgstr ""
"拡張機能の作者が、Quarkusの最新のスナップショットに対して自分の拡張機能を毎日簡単にテストできるようにするために、QuarkusはエコシステムCIという概念を導入しました。Ecosystem "
"CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README."
"adoc[README] には、この機能を利用するためのGitHub Actionsジョブの設定方法の詳細がすべて記載されています。"
