# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-05 12:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/writing-extensions.adoc:6
#, no-wrap
msgid "Quarkus - Writing Your Own Extension"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:16
msgid "Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:19
msgid "This means that metadata is only processed once at build time, which both saves on startup time, and also on memory usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:21
msgid "This is an in-depth documentation, see the link:building-my-first-extension[building my first extension] if you need an introduction."
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:22
#, no-wrap
msgid "Extension philosophy"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:25
msgid "This section is a work in progress and gathers the philosophy under which extensions should be designed and written."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:26
#, no-wrap
msgid "Why an extension framework"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:32
msgid "Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact that uses significantly less resources than traditional approaches. These can then be used to build native applications using GraalVM.  To do this you need to analyze and understand the full \"closed world\" of the application.  Without the full and complete context, the best that can be achieved is partial and limited generic support.  By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:35
msgid "The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the actions an extension performs:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:37
msgid "Gather build time metadata and generate code"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:38
msgid "This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:39
msgid "The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:40
msgid "A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:41
msgid "Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no `@Entity` does not need to start Hibernate ORM)"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:42
msgid "An extension hosts Substrate VM code substitution so that libraries can run on GraalVM"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:43
msgid "Most changes are pushed upstream to help the underlying library run on GraalVM"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:44
msgid "Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:45
msgid "Host Substrate VM code substitution to help dead code elimination based on the application needs"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:46
msgid "This is application dependant and cannot really be shared in the library itself"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:47
msgid "For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:48
msgid "Send metadata to GraalVM for example classes in need of reflection"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:49
msgid "This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:50
#, no-wrap
msgid "Favor build time work over runtime work"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:54
msgid "As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).  The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:55
#, no-wrap
msgid "How to expose configuration"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:59
msgid "Quarkus simplifies the most common usages.  This means that its defaults might be different than the library it integrates."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:62
msgid "To make the simple experience easiest, unify the configuration in `application.properties` via MicroProfile Config.  Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:67
msgid "Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.  For example `quarkus.database.url` and friends are shared between extensions as defining a database access is a shared task (instead of a `hibernate.` property for example).  The most useful configuration options should be exposed as `quarkus.[extension].` instead of the natural namespace of the library.  Less common properties can live in the library namespace."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:71
msgid "To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.  Of course properties like host, port, password should be overridable at runtime.  But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application."
msgstr ""

#
#
#
#. === API
#. TODO: Describe where to put APIs
#. I wonder if that content should be in the technical aspects
#. === Substitution and recorders
#. TODO: Describe where Substitutions and recorders should live
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:83
#, no-wrap
msgid "Expose your components via CDI"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:88
msgid "Since CDI is the central programming model when it comes to component composition, frameworks and extensions should expose their components as beans that are easily consumable by user applications.  For example, Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the connection pool exposes `DataSource` beans etc.  Extensions must register these bean definitions at build time."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:89
#, no-wrap
msgid "Beans backed by classes"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:92
msgid "An extension can produce an <<cdi-reference.adoc#additional_beans,`AdditionalBeanBuildItem`>> to instruct the container to read a bean definition from a class as if it was part of the original application:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:93
#, no-wrap
msgid "Bean Class Registered by `AdditionalBeanBuildItem`"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:98
#, no-wrap
msgid ""
"@Singleton <1>\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:103
#, no-wrap
msgid ""
"   public String echo(String val) {\n"
"      return val;\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:105
msgid "If a bean registered by an `AdditionalBeanBuildItem` does not specify a scope then `@Dependent` is assumed."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:107
msgid "All other beans can inject such a bean:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:108
#, no-wrap
msgid "Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:113
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:116
#, no-wrap
msgid ""
"    @Inject\n"
"    Echo echo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:123
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello(String foo) {\n"
"        return echo.echo(foo);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:126
msgid "And vice versa - the extension bean can inject application beans and beans provided by other extensions:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:127
#, no-wrap
msgid "Extension Bean Injection Example"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:132
#, no-wrap
msgid ""
"@Singleton\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:135
#, no-wrap
msgid ""
"    @Inject\n"
"    DataSource dataSource;  <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:138
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<List<String>> listsOfStrings; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:141
#, no-wrap
msgid ""
"    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:143
msgid "Inject a bean provided by other extension."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:144
msgid "Inject all beans matching the type `List<String>`."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:146
#, no-wrap
msgid "Bean initialization"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:153
msgid "Some components may require additional initialization based on information collected during augmentation.  The most straightforward solution is to obtain a bean instance and call a method directly from a build step.  However, it is _illegal_ to obtain a bean instance during the augmentation phase.  The reason is that the CDI container is not started yet.  It's started during the <<bootstrap-three-phases,Static init bootstrap phase>>."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:155
msgid "`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in any bean. `RUN_TIME` config roots should only be injected after the bootstrap though."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:161
msgid "It is possible to invoke a bean method from a <<bytecode-recording,recorder method>> though.  If you need to access a bean in a `@Record(STATIC_INIT)` build step then is must either depend on the `BeanContainerBuildItem` or wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple - we need to make sure the CDI container is fully initialized and started.  However, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:163
msgid "Don't forget to make sure the bean state guarantees the visibility, e.g. via the `volatile` keyword."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:167
msgid "There is one significant drawback of this \"late initialization\" approach.  An _uninitialized_ bean may be accessed by other extensions or application components that are instantiated during bootstrap.  We'll cover a more robust solution in the <<synthetic_beans>>."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:168
#, no-wrap
msgid "Default beans"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:173
msgid "A very useful pattern of creating such beans but also giving application code the ability to easily override some of the beans with custom implementations, is to use the `@DefaultBean` that Quarkus provides.  This is best explained with an example."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:175
msgid "Let us assume that the Quarkus extension needs to provide a `Tracer` bean which application code is meant to inject into its own beans."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:180
#, no-wrap
msgid ""
"@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:185
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:191
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:198
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:201
msgid "If for example application code wants to use `Tracer`, but also needs to use a custom `Reporter` bean, such a requirement could easily be done using something like:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:207
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:213
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:215
#, no-wrap
msgid "How to Override a Bean Defined by a Library/Quarkus Extension that doesn't use @DefaultBean"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:220
msgid "Although `@DefaultBean` is the recommended approach, it is also possible for application code to override beans provided by an extension by marking beans as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a simple example.  Suppose we work on an imaginary \"quarkus-parser\" extension and we have a default bean implementation:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:225
#, no-wrap
msgid ""
"@Dependent\n"
"class Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:230
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    return expression.split(\"::\");\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:233
msgid "And our extension also consumes this parser:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:238
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class ParserService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:241
#, no-wrap
msgid ""
"  @Inject\n"
"  Parser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:244
#, no-wrap
msgid ""
"  //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:247
msgid "Now, if a user or even some other extension needs to override the default implementation of the `Parser` the simplest solution is to use CDI `@Alternative` + `@Priority`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:254
#, no-wrap
msgid ""
"@Alternative <1>\n"
"@Priority(1) <2>\n"
"@Singleton\n"
"class MyParser extends Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:259
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    // my super impl...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:261
msgid "`MyParser` is an alternative bean."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:262
msgid "Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:264
msgid "CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:266
#, no-wrap
msgid "Synthetic beans"
msgstr "合成Bean"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:271
msgid "Sometimes it is very useful to be able to register a synthetic bean.  Bean attributes of a synthetic bean are not derived from a java class, method or field.  Instead, the attributes are specified by an extension."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:274
msgid "Since the CDI container does not control the instantiation of a synthetic bean the dependency injection and other services (such as interceptors) are not supported.  In other words, it's up to the extension to provide all required services to a synthetic bean instance."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:277
msgid "There are several ways to register a <<cdi-reference.adoc#synthetic_beans,synthetic bean>> in Quarkus.  In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to <<bean_init>>)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:279
msgid "The `SyntheticBeanBuildItem` can be used to register a synthetic bean:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:281
msgid "whose instance can be easily produced through a <<bytecode-recording,recorder>>,"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:282
msgid "to provide a \"context\" bean that holds all the information collected during augmentation so that the real components do not need any \"late initialization\" because they can inject the context bean directly."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:283
#, no-wrap
msgid "Instance Produced Through Recorder"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:293
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo(\"parameters are recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:295
msgid "The string value is recorded in the bytecode and used to initialize the instance of `Foo`."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:296
#, no-wrap
msgid "\"Context\" Holder"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:306
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(TestContext.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createContext(\"parameters are recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:308
msgid "The \"real\" components can inject the `TestContext` directly."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:309
#, no-wrap
msgid "Some types of extensions"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:312
msgid "There exist multiple stereotypes of extension, let's list a few."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:313
#, no-wrap
msgid "Bare library running"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:318
msgid "This is the less sophisticated extension.  It consists of a set of patches to make sure a library runs on GraalVM.  If possible, contribute these patches upstream, not in extensions.  Second best is to write Substrate VM substitutions, which are patches applied during native image compilation."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:319
#, no-wrap
msgid "Get a framework running"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:322
msgid "A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc. + These operations should be done at build time and the metamodel be passed to the recorder DSL that will generate classes that will be executed at runtime and boot the framework."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:323
#, no-wrap
msgid "Get a CDI portable extension running"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:328
msgid "The CDI portable extension model is very flexible.  Too flexible to benefit from the build time boot promoted by Quarkus.  Most extension we have seen do not make use of these extreme flexibility capabilities.  The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parlance)."
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:329
#, no-wrap
msgid "Technical aspect"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:332
#, no-wrap
msgid "Three Phases of Bootstrap and Quarkus Philosophy"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:335
msgid "There are three distinct bootstrap phases of a Quarkus app:"
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:336
#, no-wrap
msgid "Augmentation"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:341
msgid "This is the first phase, and is done by the <<Build Step Processors>>. These processors have access to Jandex annotation information and can parse any descriptors and read annotations, but should not attempt to load any application classes. The output of these build steps is some recorded bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/gizmo), that is used to actually bootstrap the application at runtime. Depending on the `io.quarkus.deployment.annotations.ExecutionTime` value of the `@io.quarkus.deployment.annotations.Record` annotation associated with the build step, the step may be run in a different JVM based on the following two modes."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:342
#, no-wrap
msgid "Static Init"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:348
msgid "If bytecode is recorded with `@Record(STATIC_INIT)` then it will be executed from a static init method on the main class. For a native executable build, this code is executed in a normal JVM as part of the native build process, and any retained objects that are produced in this stage will be directly serialized into the native executable via an image mapped file.  This means that if a framework can boot in this phase then it will have its booted state directly written to the image, and so the boot code does not need to be executed when the image is started."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:350
msgid "There are some restrictions on what can be done in this stage as the Substrate VM disallows some objects in the native executable. For example you should not attempt to listen on a port or start threads in this phase. In addition, it is disallowed to read run time configuration during static initialization."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:355
msgid "In non-native pure JVM mode, there is no real difference between Static and Runtime Init, except that Static Init is always executed first. This mode benefits from the same build phase augmentation as native mode as the descriptor parsing and annotation scanning are done at build time and any associated class/framework dependencies can be removed from the build output jar. In servers like WildFly, deployment related classes such as XML parsers hang around for the life of the application, using up valuable memory. Quarkus aims to eliminate this, so that the only classes loaded at runtime are actually used at runtime."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:358
msgid "As an example, the only reason that a Quarkus application should load an XML parser is if the user is using XML in their application. Any XML parsing of configuration should be done in the Augmentation phase."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:359
#, no-wrap
msgid "Runtime Init"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:363
msgid "If bytecode is recorded with `@Record(RUNTIME_INIT)` then it is executed from the application's main method. This code will be run on native executable boot. In general as little code as possible should be executed in this phase, and should be restricted to code that needs to open ports etc."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:365
msgid "Pushing as much as possible into the `@Record(STATIC_INIT)` phase allows for two different optimizations:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:367
msgid "In both native executable and pure JVM mode this allows the app to start as fast as possible since processing was done during build time. This also minimizes the classes/native code needed in the application to pure runtime related behaviors."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:370
msgid "Another benefit with native executable mode is that Substrate can more easily eliminate features that are not used. If features are directly initialized via bytecode, Substrate can detect that a method is never called and eliminate that method. If config is read at runtime, Substrate cannot reason about the contents of the config and so needs to keep all features in case they are required."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:372
#, no-wrap
msgid "Maven setup"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:375
msgid "Your extension project should be setup as a multi-module project with two submodules:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:377
msgid "A deployment time submodule that handles the build time processing and bytecode recording."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:379
msgid "A runtime submodule that contains the runtime behavior that will provide the extension behavior in the native executable or runtime JVM."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:381
msgid "You may want to use the `create-extension` mojo of `io.quarkus:quarkus-maven-plugin` to create these Maven modules - see the next section."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:386
msgid "Your runtime artifact should depend on `io.quarkus:quarkus-core`, and possibly the runtime artifacts of other Quarkus modules if you want to use functionality provided by them.  You will also need to include the `io.quarkus:quarkus-bootstrap-maven-plugin` to generate the Quarkus extension descriptor included into the runtime artifact, if you are using the Quarkus parent pom it will automatically inherit the correct configuration.  Furthermore, you'll need to configure the `maven-compiler-plugin` to detect the `quarkus-extension-processor` annotation processor."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:389
msgid "By convention the deployment time artifact has the `-deployment` suffix, and the runtime artifact has no suffix (and is what the end user adds to their project)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:399
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-core</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:431
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n"
"            <!-- Executions configuration can be inherited from quarkus-build-parent -->\n"
"            <executions>\n"
"                <execution>\n"
"                    <goals>\n"
"                        <goal>extension-descriptor</goal>\n"
"                    </goals>\n"
"                    <configuration>\n"
"                         <deployment>${project.groupId}:${project.artifactId}-deployment:${project.version}</deployment>\n"
"                   </configuration>\n"
"               </execution>\n"
"           </executions>\n"
"        </plugin>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:434
msgid "The above `maven-compiler-plugin` configuration requires version 3.5+."
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:439
msgid "Under no circumstances can the runtime module depend on a deployment artifact. This would result in pulling all the deployment time code into runtime scope, which defeats the purpose of having the split."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:444
msgid "Your deployment time module should depend on `io.quarkus:quarkus-core-deployment`, your runtime artifact, and possibly the deployment artifacts of other Quarkus modules if you want to use functionality provided by them.  You will also need to configure the `maven-compiler-plugin` to detect the `quarkus-extension-processor` annotation processor."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:453
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-core-deployment</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:470
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:472
#, no-wrap
msgid "Create new extension modules using Maven"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:475
msgid "The `create-extension` mojo of `io.quarkus:quarkus-maven-plugin` can be used to generate stubs of Maven modules needed for implementing a new Quarkus extension."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:477
msgid "This mojo can be currently used only for adding extensions to an established source tree hosting multiple extensions in one subdirectory, such as https://github.com/quarkusio/quarkus[Quarkus] or https://github.com/apache/camel-quarkus[Camel Quarkus]. Creating extension projects from scratch is not supported yet."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:479
msgid "As and example, let's add a new extension called `my-ext` to the Quarkus source tree:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:489
#, no-wrap
msgid ""
"git clone https://github.com/quarkusio/quarkus.git\n"
"cd quarkus\n"
"cd extensions\n"
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N \\\n"
"    -Dquarkus.artifactIdBase=my-ext \\\n"
"    -Dquarkus.artifactIdPrefix=quarkus- \\\n"
"    -Dquarkus.nameBase=\"My Extension\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:492
msgid "The above sequence of commands does the following:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:494
msgid "Creates four new Maven modules:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:495
msgid "`quarkus-my-ext-parent` in the `extensions/my-ext` directory"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:496
msgid "`quarkus-my-ext` in the `extensions/my-ext/runtime` directory"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:497
msgid "`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; a basic `MyExtProcessor` class is generated in this module."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:498
msgid "`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/deployment` directory; an empty JAX-RS Resource class and two test classes (for JVM mode and native mode) are generated in this module."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:499
msgid "Links these three modules where necessary:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:500
msgid "`quarkus-my-ext-parent` is added to the `<modules>` of `quarkus-extensions-parent`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:501
msgid "`quarkus-my-ext` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:502
msgid "`quarkus-my-ext-deployment` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:503
msgid "`quarkus-my-ext-integration-test` is added to the `<modules>` of `quarkus-integration-tests-parent`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:505
msgid "A Maven build performed immediately after generating the modules should fail due to a `fail()` assertion in one of the test classes."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:508
msgid "There is one step (specific to the Quarkus source tree) that you should do manually when creating a new extension: create a `quarkus-extension.yaml` file that describe your extension inside the runtime module `src/main/resources/META-INF` folder."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:510
msgid "This is the `quarkus-extension.yaml` of the `quarkus-agroal` extension, you can use it as an example:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:524
#, no-wrap
msgid ""
"name: \"Agroal - Database connection pool\"\n"
"metadata:\n"
"  keywords:\n"
"  - \"agroal\"\n"
"  - \"database-connection-pool\"\n"
"  - \"datasource\"\n"
"  - \"jdbc\"\n"
"  guide: \"https://quarkus.io/guides/datasource\"\n"
"  categories:\n"
"  - \"data\"\n"
"  status: \"stable\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:527
msgid "Note that the parameters of the mojo that will be constant for all the extensions added to this source tree are configured in `extensions/pom.xml` so that they do not need to be passed on the command line each time a new extension is added:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:544
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"    <inherited>false</inherited>\n"
"    <!-- Settings for stubbing new extensions via\n"
"           ./mvnw quarkus:create-extension -N -Dquarkus.artifactIdBase=my-ext -Dquarkus.nameBase=\"My Extension\"\n"
"    -->\n"
"    <configuration>\n"
"        <namePrefix xml:space=\"preserve\">Quarkus - </namePrefix>\n"
"        <bomPath>../bom/application/pom.xml</bomPath>\n"
"        <itestParentPath>../integration-tests/pom.xml</itestParentPath>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:549
msgid "The `nameBase` parameter of the mojo is optional.  If you do not specify it on the command line, the plugin will derive it from `artifactIdBase` by replacing dashes with spaces and uppercasing each token.  So you may consider omitting explicit `nameBase` in some cases."
msgstr ""

#.  The following link should point to the mojo page once https://github.com/quarkusio/quarkusio.github.io/issues/265 is fixed
#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:552
msgid "Please refer to https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] for all the available options of the mojo."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:553
#, no-wrap
msgid "Build Step Processors"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:558
msgid "Work is done at augmentation time by _build steps_ which produce and consume _build items_.  The build steps found in the deployment modules that correspond to the extensions in the project build are automatically wired together and executed to produce the final build artifact(s)."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:559
#, no-wrap
msgid "Build steps"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:565
msgid "A _build step_ is a method which is annotated with the `@io.quarkus.deployment.annotations.BuildStep` annotation.  Each build step may <<consuming-values,consume>> items that are produced by earlier stages, and <<producing-values,produce>> items that can be consumed by later stages. Build steps are normally only run when they produce a build item that is ultimately consumed by another step."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:568
msgid "Build steps are normally placed on plain classes within an extension's deployment module.  The classes are automatically instantiated during the augment process and utilize <<injection,injection>>."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:570
#, no-wrap
msgid "Build items"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:576
msgid "Build items are concrete, final subclasses of the abstract `io.quarkus.builder.item.BuildItem` class.  Each build item represents some unit of information that must be passed from one stage to another.  The base `BuildItem` class may not itself be directly subclassed; rather, there are abstract subclasses for each of the kinds of build item subclasses that _may_ be created: <<simple-build-items,simple>>, <<multi-build-items,multi>>, and <<empty-build-items,empty>>."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:578
msgid "Think of build items as a way for different extensions to communicate with one another.  For example, a build item can:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:580
msgid "expose the fact that a database configuration exists"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:581
msgid "consume that database configuration (e.g. a connection pool extension or an ORM extension)"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:583
msgid "ask an extension to do work for another extension: e.g. an extension wanting to define a new CDI bean and asking the ArC extension to do so"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:585
msgid "This is a very flexible mechanism."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:588
msgid "`BuildItem` instances should be immutable, as the producer/consumer model does not allow for mutation to be correctly ordered. This is not enforced but failure to adhere to this rule can result in race conditions."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:590
#, no-wrap
msgid "Simple build items"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:596
msgid "Simple build items are final classes which extend `io.quarkus.builder.item.SimpleBuildItem`.  Simple build items may only be produced by one step in a given build; if multiple steps in a build declare that they produce the same simple build item, an error is raised.  Any number of build steps may consume a simple build item.  A build step which consumes a simple build item will always run _after_ the build step which produced that item."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:597
#, no-wrap
msgid "Example of a single build item"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:606
#, no-wrap
msgid ""
"/**\n"
" * The build item which represents the Jandex index of the application,\n"
" * and would normally be used by many build steps to find usages\n"
" * of annotations.\n"
" */\n"
"public final class ApplicationIndexBuildItem extends SimpleBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:608
#, no-wrap
msgid "    private final Index index;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:612
#, no-wrap
msgid ""
"    public ApplicationIndexBuildItem(Index index) {\n"
"        this.index = index;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:617
#, no-wrap
msgid ""
"    public Index getIndex() {\n"
"        return index;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:621
#, no-wrap
msgid "Multi build items"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:626
msgid "Multiple or \"multi\" build items are final classes which extend `io.quarkus.builder.item.MultiBuildItem`.  Any number of multi build items of a given class may be produced by any number of steps, but any steps which consume multi build items will only run _after_ every step which can produce them has run."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:627
#, no-wrap
msgid "Example of a multiple build item"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:633
#, no-wrap
msgid ""
"public final class ServiceWriterBuildItem extends MultiBuildItem {\n"
"    private final String serviceName;\n"
"    private final List<String> implementations;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:643
#, no-wrap
msgid ""
"    public ServiceWriterBuildItem(String serviceName, String... implementations) {\n"
"        this.serviceName = serviceName;\n"
"        // Make sure it's immutable\n"
"        this.implementations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                implementations.clone()\n"
"            )\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:647
#, no-wrap
msgid ""
"    public String getServiceName() {\n"
"        return serviceName;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:652
#, no-wrap
msgid ""
"    public List<String> getImplementations() {\n"
"        return implementations;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:654
#, no-wrap
msgid "Example of multiple build item usage"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:669
#, no-wrap
msgid ""
"/**\n"
" * This build step produces a single multi build item that declares two\n"
" * providers of one configuration-related service.\n"
" */\n"
"@BuildStep\n"
"public ServiceWriterBuildItem registerOneService() {\n"
"    return new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyFirstConfigConverterImpl.class.getName(),\n"
"        MySecondConfigConverterImpl.class.getName()\n"
"    );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:688
#, no-wrap
msgid ""
"/**\n"
" * This build step produces several multi build items that declare multiple\n"
" * providers of multiple configuration-related services.\n"
" */\n"
"@BuildStep\n"
"public void registerSeveralServices(\n"
"    BuildProducer<ServiceWriterBuildItem> providerProducer\n"
") {\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyThirdConfigConverterImpl.class.getName(),\n"
"        MyFourthConfigConverterImpl.class.getName()\n"
"    ));\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        ConfigSource.class.getName(),\n"
"        MyConfigSourceImpl.class.getName()\n"
"    ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:699
#, no-wrap
msgid ""
"/**\n"
" * This build step aggregates all the produced service providers\n"
" * and outputs them as resources.\n"
" */\n"
"@BuildStep\n"
"public void produceServiceFiles(\n"
"    List<ServiceWriterBuildItem> items,\n"
"    BuildProducer<GeneratedResourceBuildItem> resourceProducer\n"
") throws IOException {\n"
"    // Aggregate all of the providers\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:710
#, no-wrap
msgid ""
"    Map<String, Set<String>> map = new HashMap<>();\n"
"    for (ServiceWriterBuildItem item : items) {\n"
"        String serviceName = item.getName();\n"
"        for (String implName : item.getImplementations()) {\n"
"            map.computeIfAbsent(\n"
"                serviceName,\n"
"                (k, v) -> new LinkedHashSet<>()\n"
"            ).add(implName);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:731
#, no-wrap
msgid ""
"    // Now produce the resource(s) for the SPI files\n"
"    for (Map.Entry<String, Set<String>> entry : map.entrySet()) {\n"
"        String serviceName = entry.getKey();\n"
"        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n"
"            try (OutputStreamWriter w = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {\n"
"                for (String implName : entry.getValue()) {\n"
"                    w.write(implName);\n"
"                    w.write(System.lineSeparator());\n"
"                }\n"
"            }\n"
"            w.flush();\n"
"            resourceProducer.produce(\n"
"                new GeneratedResourceBuildItem(\n"
"                    \"META-INF/services/\" + serviceName,\n"
"                    os.toByteArray()\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:734
#, no-wrap
msgid "Empty build items"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:739
msgid "Empty build items are final (usually empty) classes which extend `io.quarkus.builder.item.EmptyBuildItem`.  They represent build items that don't actually carry any data, and allow such items to be produced and consumed without having to instantiate empty classes.  They cannot themselves be instantiated."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:740
#, no-wrap
msgid "Example of an empty build item"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:746
#, no-wrap
msgid ""
"public final class NativeImageBuildItem extends EmptyBuildItem {\n"
"    // empty\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:751
msgid "Empty build items can represent \"barriers\" which can impose ordering between steps.  They can also be used in the same way that popular build systems use \"pseudo-targets\", which is to say that the build item can represent a conceptual goal that does not have a concrete representation."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:752
#, no-wrap
msgid "Example of usage of an empty build item in a \"pseudo-target\" style"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:767
#, no-wrap
msgid ""
"/**\n"
" * Contrived build step that produces the native image on disk.  The main augmentation\n"
" * step (which is run by Maven or Gradle) would be declared to consume this empty item,\n"
" * causing this step to be run.\n"
" */\n"
"@BuildStep\n"
"@Produce(NativeImageBuildItem.class)\n"
"void produceNativeImage() {\n"
"    // ...\n"
"    // (produce the native image)\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:769
#, no-wrap
msgid "Example of usage of an empty build item in a \"barrier\" style"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:781
#, no-wrap
msgid ""
"/**\n"
" * This would always run after {@link #produceNativeImage()} completes, producing\n"
" * an instance of {@code SomeOtherBuildItem}.\n"
" */\n"
"@BuildStep\n"
"@Consume(NativeImageBuildItem.class)\n"
"SomeOtherBuildItem secondBuildStep() {\n"
"    return new SomeOtherBuildItem(\"foobar\");\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:784
#, no-wrap
msgid "Injection"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:787
msgid "Classes which contain build steps support the following types of injection:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:789
msgid "Constructor parameter injection"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:790
msgid "Field injection"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:791
msgid "Method parameter injection (for build step methods only)"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:794
msgid "Build step classes are instantiated and injected for each build step invocation, and are discarded afterwards.  State should only be communicated between build steps by way of build items, even if the steps are on the same class."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:797
msgid "Final fields are not considered for injection, but can be populated by way of constructor parameter injection if desired.  Static fields are never considered for injection."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:799
msgid "The types of values that can be injected include:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:801
msgid "<<build-items,Build items>> produced by previous build steps"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:802
msgid "<<producing-values,Build producers>> to produce items for subsequent build steps"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:803
msgid "<<configuration-roots,Configuration root>> types"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:804
msgid "Template objects for <<bytecode-recording,bytecode recording>>"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:807
msgid "Objects which are injected into a build step method or its class _must not_ be used outside of that method's execution."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:810
msgid "Injection is resolved at compile time via an annotation processor, and the resulting code does not have permission to inject private fields or invoke private methods."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:812
#, no-wrap
msgid "Producing values"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:815
msgid "A build step may produce values for subsequent steps in several possible ways:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:817
msgid "By returning a <<simple-build-items,simple build item>> or <<multi-build-items,multi build item>> instance"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:818
msgid "By returning a `List` of a multi build item class"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:819
msgid "By injecting a `BuildProducer` of a simple or multi build item class"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:821
msgid "By annotating the method with `@io.quarkus.deployment.annotations.Produce`, giving the class name of a <<empty-build-items,empty build item>>"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:824
msgid "If a simple build item is declared on a build step, it _must_ be produced during that build step, otherwise an error will result.  Build producers which are injected into steps _must not_ be used outside of that step."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:830
msgid "Note that a `@BuildStep` method will only be called if it produces something that another consumer or the final output requires. If there is no consumer for a particular item then it will not be produced. What is required will depend on the final target that is being produced.  For example, when running in developer mode the final output will not ask for GraalVM-specific build items such as `ReflectiveClassBuildItem`, so methods that only produce these items will not be invoked."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:832
#, no-wrap
msgid "Consuming values"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:835
msgid "A build step may consume values from previous steps in the following ways:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:837
msgid "By injecting a <<simple-build-items,simple build item>>"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:838
msgid "By injecting an `Optional` of a simple build item class"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:839
msgid "By injecting a `List` of a <<multi-build-items,multi build item>> class"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:841
msgid "By annotating the method with `@io.quarkus.deployment.annotations.Consume`, giving the class name of a <<empty-build-items,empty build item>>"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:844
msgid "Normally it is an error for a step which is included to consume a simple build item that is not produced by any other step.  In this way, it is guaranteed that all of the declared values will be present and non-`null` when a step is run."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:847
msgid "Sometimes a value isn't necessary for the build to complete, but might inform some behavior of the build step if it is present.  In this case, the value can be optionally injected."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:849
msgid "Multi build values are always considered _optional_.  If not present, an empty list will be injected."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:851
#, no-wrap
msgid "Weak value production"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:856
msgid "Normally a build step is included whenever it produces any build item which is in turn consumed by any other build step.  In this way, only the steps necessary to produce the final artifact(s) are included, and steps which pertain to extensions which are not installed or which only produce build items which are not relevant for the given artifact type are excluded."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:859
msgid "For cases where this is not desired behavior, the `@io.quarkus.deployment.annotations.Weak` annotation may be used.  This annotation indicates that the build step should not automatically be included solely on the basis of producing the annotated value."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:860
#, no-wrap
msgid "Example of producing a build item weakly"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:876
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorClassBuildItem.\n"
" */\n"
"@BuildStep\n"
"void createExecutor(\n"
"        @Weak BuildProducer<GeneratedClassBuildItem> classConsumer,\n"
"        BuildProducer<ExecutorClassBuildItem> executorClassConsumer\n"
") {\n"
"        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);\n"
"        String className = generateClassThatCreatesExecutor(cw); // <1>\n"
"        classConsumer.produce(new GeneratedClassBuildItem(true, className, cw.toByteArray()));\n"
"        executorClassConsumer.produce(new ExecutorClassBuildItem(className));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:878
msgid "This method (not provided in this example) would generate the class using the ASM API."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:885
msgid "Certain types of build items are generally always consumed, such as generated classes or resources.  An extension might produce a build item along with a generated class to facilitate the usage of that build item.  Such a build step would use the `@Weak` annotation on the generated class build item, while normally producing the other build item.  If the other build item is ultimately consumed by something, then the step would run and the class would be generated.  If nothing consumes the other build item, the step would not be included in the build process."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:888
msgid "In the example above, `GeneratedClassBuildItem` would only be produced if `ExecutorClassBuildItem` is consumed by some other build step."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:891
msgid "Note that when using <<bytecode-recording,bytecode recording>>, the implicitly generated class can be declared to be weak by using the `optional` attribute of the `@io.quarkus.deployment.annotations.Record` annotation."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:892
#, no-wrap
msgid "Example of using a bytecode recorder where the generated class is weakly produced"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:904
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorBuildItem.\n"
" */\n"
"@BuildStep\n"
"@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) // <1>\n"
"ExecutorBuildItem createExecutor( // <2>\n"
"        ExecutorTemplate executorTemplate,\n"
"        ThreadPoolConfig threadPoolConfig\n"
") {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:913
#, no-wrap
msgid ""
"    return new ExecutorBuildItem(\n"
"        setupTemplate.setupRunTime(\n"
"            shutdownContextBuildItem,\n"
"            threadPoolConfig,\n"
"            launchModeBuildItem.getLaunchMode()\n"
"        )\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:915
msgid "Note the `optional` attribute."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:916
msgid "This example is using recorder proxies; see the section on <<bytecode-recording,bytecode recording>> for more information."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:917
#: upstream/_guides/writing-extensions.adoc:2164
#, no-wrap
msgid "Capabilities"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:923
msgid "The `@BuildStep` annotation has a `providesCapabilities` property that can be used to provide capability information to other extensions about what is present in the current application. Capabilities are simply strings that are used to describe an extension. Capabilities should generally be named after an extensions root package, for example the transactions extension will provide `io.quarkus.transactions`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:926
msgid "To check if a capability is present you can inject the `io.quarkus.deployment.Capabilities` object and call `isCapabilityPresent`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:928
msgid "Capabilities should be used when checking for the presence of an extension rather than class path based checks."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:929
#, no-wrap
msgid "Application Archives"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:935
msgid "The `@BuildStep` annotation can also register marker files that determine which archives on the class path are considered to be 'Application Archives', and will therefore get indexed. This is done via the `applicationArchiveMarkers`. For example the ArC extension registers `META-INF/beans.xml`, which means that all archives on the class path with a `beans.xml` file will be indexed."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:937
msgid "`BuildStep.applicationArchiveMarkers()` is deprecated and will be removed at some point post Quarkus 1.1. Extensions are encouraged to use `io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem` instead."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:938
#, no-wrap
msgid "Using Thread's Context Class Loader"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:944
msgid "The build step will be run with a TCCL that can load user classes from the deployment in a transformer-safe way.  This class loader only lasts for the life of the augmentation, and is discarded afterwards.  The classes will be loaded again in a different class loader at runtime.  This means that loading a class during augmentation does not stop it from being transformed when running in the development/test mode."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:945
#, no-wrap
msgid "Adding external JARs to the indexer with IndexDependencyBuildItem"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:949
msgid "The index of scanned classes will not automatically include your external class dependencies.  To add dependencies, create a `@BuildStep` that produces `IndexDependencyBuildItem` objects, for a `groupId` and `artifactId`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:951
msgid "It is important to specify all the required artifacts to be added to the indexer. No artifacts are implicitly added transitively."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:953
msgid "The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK that are used in Jackson JSON transformations, in order for the reflective classes to identified and included at `BUILD_TIME`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:967
#, no-wrap
msgid ""
"   @BuildStep\n"
"    void addDependencies(BuildProducer<IndexDependencyBuildItem> indexDependency) {\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-runtime\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-model\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-lambda-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-servlet-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-dynamodb-persistence-adapter\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-apache-client\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-model-runtime\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:970
msgid "With the artifacts added to the `Jandex` indexer, you can now search the index to identify classes implementing an interface, sub-classes of a specific class, or classes with a target annotation."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:973
msgid "For example, the `Jackson` extension uses code like below to search for annotations used in JSON deserialization, and add them to the reflective hierarchy for `BUILD_TIME` analysis."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:978
#, no-wrap
msgid "    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:980
#, no-wrap
msgid "    IndexView index = combinedIndexBuildItem.getIndex();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:989
#, no-wrap
msgid ""
"    // handle the various @JsonDeserialize cases\n"
"    for (AnnotationInstance deserializeInstance : index.getAnnotations(JSON_DESERIALIZE)) {\n"
"        AnnotationTarget annotationTarget = deserializeInstance.target();\n"
"        if (CLASS.equals(annotationTarget.kind())) {\n"
"            DotName dotName = annotationTarget.asClass().name();\n"
"            Type jandexType = Type.create(dotName, Type.Kind.CLASS);\n"
"            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:991
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:994
#, no-wrap
msgid "Configuration"
msgstr "設定"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:999
msgid "Configuration in Quarkus is based on SmallRye Config, an implementation of the MicroProfile Config specification.  All of the standard features of MP-Config are supported; in addition, there are several extensions which are made available by the SmallRye Config project as well as by Quarkus itself."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1001
msgid "The value of these properties is configured in a `application.properties` file that follows the MicroProfile config format."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1003
msgid "Configuration of Quarkus extensions is injection-based, using annotations."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1004
#, no-wrap
msgid "Configuration Keys"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1007
msgid "Leaf configuration keys are mapped to non-`private` fields via the `@io.quarkus.runtime.annotations.ConfigItem` annotation."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1010
msgid "Though the SmallRye Config project is used for implementation, the standard `@ConfigProperty` annotation does not have the same semantics that are needed to support configuration within extensions."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1013
msgid "Configuration keys are normally derived from the field names that they are tied to.  This is done by de-camel-casing the name and then joining the segments with hyphens (`-`).  Some examples:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1015
msgid "`bindAddress` becomes `bind-address`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1016
msgid "`keepAliveTime` becomes `keep-alive-time`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1017
msgid "`requestDNSTimeout` becomes `request-dns-timeout`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1019
msgid "The name can also be explicitly specified by giving a `name` attribute to the `@ConfigItem` annotation."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1022
msgid "Though it is possible to override the configuration key name using the `name` attribute of `@ConfigItem`, normally this should only be done in cases where (for example) the configuration key name is the same as a Java keyword."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1023
#, no-wrap
msgid "Configuration Value types"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1027
msgid "The type of the field with the `@ConfigItem` annotation determines the conversion that is applied to it.  Quarkus extensions may use the full range of configuration types made available by SmallRye Config, which includes:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1029
msgid "All primitive types and primitive wrapper types"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1030
msgid "`String`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1031
msgid "Any type which has a constructor accepting a single argument of type `String` or `CharSequence`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1032
msgid "Any type which has a static method named `of` which accepts a single argument of type `String`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1033
msgid "Any type which has a static method named `valueOf` or `parse` which accepts a single argument of type `CharSequence` or `String`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1034
msgid "`java.time.Duration`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1035
msgid "`java.util.regex.Pattern`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1036
msgid "`java.nio.file.Path`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1037
msgid "`io.quarkus.runtime.configuration.MemorySize` to represent data sizes"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1038
msgid "`java.net.InetSocketAddress`, `java.net.InetAddress` and `org.wildfly.common.net.CidrAddress`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1039
msgid "A `List` or `Optional` of any of the above types"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1040
msgid "`OptionalInt`, `OptionalLong`, `OptionalDouble`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1043
msgid "In addition, custom converters may be registered by adding their fully qualified class name in file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1045
msgid "Though these implicit converters use reflection, Quarkus will automatically ensure that they are loaded at the appropriate time."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1046
#, no-wrap
msgid "Optional Values"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1052
msgid "If the configuration type is one of the optional types, then empty values are allowed for the configuration key; otherwise, specification of an empty value will result in a configuration error which prevents the application from starting.  This is especially relevant to configuration properties of inherently emptiable values such as `List`, `Set`, and `String`.  Such value types will never be empty; in the event of an empty value, an empty `Optional` is always used."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1053
#, no-wrap
msgid "Configuration Default Values"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1057
msgid "A configuration item can be marked to have a default value.  The default value is used when no matching configuration key is specified in the configuration."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1060
msgid "Configuration items with a primitive type (such as `int` or `boolean`) implicitly use a default value of `0` or `false`.  The sole exception to this rule is the `char` type which does not have an implicit default value."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1064
msgid "A property with a default value is not implicitly optional.  If a non-optional configuration item with a default value is explicitly specified to have an empty value, the application will report a configuration error and will not start.  If it is desired for a property to have a default value and also be optional, it must have an `Optional` type as described above."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1065
#, no-wrap
msgid "Configuration Groups"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1069
msgid "Configuration values are always collected into grouping classes which are marked with the `@io.quarkus.runtime.annotations.ConfigGroup` annotation.  These classes contain a field for each key within its group.  In addition, configuration groups can be nested."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1070
#, no-wrap
msgid "Optional Configuration Groups"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1076
msgid "A nested configuration group may be wrapped with an `Optional` type.  In this case, the group is not populated unless one or more properties within that group are specified in the configuration.  If the group is populated, then any required properties in the group must also be specified otherwise a configuration error will be reported and the application will not start."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1077
#, no-wrap
msgid "Configuration Maps"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1082
msgid "A `Map` can be used for configuration at any position where a configuration group would be allowed.  The key type of such a map *must* be `String`, and its value may be either a configuration group class or a valid leaf type.  The configuration key segment following the map's key segment will be used as the key for map values."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1084
#, no-wrap
msgid "Configuration Roots"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1090
msgid "Configuration roots are configuration groups that appear in the root of the configuration tree.  A configuration property's full name is determined by joining the string `quarkus.` with the hyphenated name of the fields that form the path from the root to the leaf field.  For example, if I define a configuration root group called `ThreadPool`, with a nested group in a field named `sizing` that in turn contains a field called `minSize`, the final configuration property will be called `quarkus.thread-pool.sizing.min-size`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1094
msgid "A configuration root's name can be given with the `name` property, or it can be inferred from the class name.  If the latter, then the configuration key will be the class name, minus any `Config` or `Configuration` suffix, broken up by camel-case, lowercased, and re-joined using hyphens (`-`)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1100
msgid "A configuration root's class name can contain an extra suffix segment for the case where there are configuration roots for multiple <<Configuration Root Phases>>.  Classes which correspond to the `BUILD_TIME` and `BUILD_AND_RUN_TIME_FIXED` may end with `BuildTimeConfig` or `BuildTimeConfiguration`, classes which correspond to the `RUN_TIME` phase may end with `RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` or `RunTimeConfiguration` while classes which correspond to the `BOOTSTRAP` configuration may end with `BootstrapConfig` or `BootstrapConfiguration`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1104
msgid "Note: The current implementation is still using injection site to determine the root set, so to avoid migration problems, it is recommended that the injection site (field or parameter) have the same name as the configuration root class until this change is complete."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1105
#, no-wrap
msgid "Configuration Root Phases"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1109
msgid "Configuration roots are strictly bound by configuration phase, and attempting to access a configuration root from outside of its corresponding phase will result in an error.  A configuration root dictates when its contained keys are read from configuration, and when they are available to applications.  The phases defined by `io.quarkus.runtime.annotations.ConfigPhase` are as follows:"
msgstr ""

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1147
#, no-wrap
msgid ""
"| Phase name\n"
"| Read & avail. at build time\n"
"| Avail. at run time\n"
"| Read during static init\n"
"| Re-read during startup (native executable)\n"
"| Notes\n"
"\n"
"| BUILD_TIME\n"
"| ✓\n"
"| ✗\n"
"| ✗\n"
"| ✗\n"
"| Appropriate for things which affect build.\n"
"\n"
"| BUILD_AND_RUN_TIME_FIXED\n"
"| ✓\n"
"| ✓\n"
"| ✗\n"
"| ✗\n"
"| Appropriate for things which affect build and must be visible for run time code.  Not read from config at run time.\n"
"\n"
"| BOOTSTRAP\n"
"| ✗\n"
"| ✓\n"
"| ✗\n"
"| ✓\n"
"| Used when runtime configuration needs to be obtained from an external system (like `Consul`), but details of that system need to be configurable (for example Consul's URL). The high level way this works is by using the standard Quarkus config sources (such as properties files, system properties, etc.) and producing `ConfigSourceProvider` objects which are subsequently taken into account by Quarkus when creating the final runtime `Config` object.\n"
"\n"
"| RUN_TIME\n"
"| ✗\n"
"| ✓\n"
"| ✓\n"
"| ✓\n"
"| Not available at build, read at start in all modes.\n"
"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1150
msgid "For all cases other than the `BUILD_TIME` case, the configuration root class and all of the configuration groups and types contained therein must be located in, or reachable from, the extension's run time artifact.  Configuration roots of phase `BUILD_TIME` may be located in or reachable from either of the extension's run time or deployment artifacts."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1152
msgid "_Bootstrap_ configuration steps are executed during runtime-init *before* any of other runtime steps. This means that code executed as part of this step cannot access anything that gets initialized in runtime init steps (runtime synthetic CDI beans being one such example)."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1153
#, no-wrap
msgid "Configuration Example"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1160
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.ConfigItem;\n"
"import io.quarkus.runtime.annotations.ConfigGroup;\n"
"import io.quarkus.runtime.annotations.DefaultConverter\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1163
#, no-wrap
msgid ""
"import java.io.File;\n"
"import java.util.logging.Level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1166
#, no-wrap
msgid ""
"@ConfigGroup <1>\n"
"public class FileConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1172
#, no-wrap
msgid ""
"    /**\n"
"     * Enable logging to a file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"true\")\n"
"    boolean enable;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1178
#, no-wrap
msgid ""
"    /**\n"
"     * The log format.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{1.}] (%t) %s%e%n\")\n"
"    String format;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1184
#, no-wrap
msgid ""
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1190
#, no-wrap
msgid ""
"    /**\n"
"     * The name of the file in which logs will be written.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"application.log\")\n"
"    File path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1192
#: upstream/_guides/writing-extensions.adoc:1397
#: upstream/_guides/writing-extensions.adoc:1904
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1198
#, no-wrap
msgid ""
"/**\n"
" * Logging configuration.\n"
" */\n"
"@ConfigRoot(phase = ConfigPhase.RUN_TIME) <2>\n"
"public class LogConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1200
#, no-wrap
msgid "    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1206
#, no-wrap
msgid ""
"    /**\n"
"     * Configuration properties for the logging file handler.\n"
"     */\n"
"    FileConfig file;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1209
#, no-wrap
msgid ""
"public class LoggingProcessor {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1216
#, no-wrap
msgid ""
"    /**\n"
"     * Logging configuration.\n"
"     */\n"
"    <3>\n"
"    LogConfiguration config;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1220
msgid "A configuration property name can be split into segments. For example, a property name like `quarkus.log.file.enable` can be split into the following segments:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1222
msgid "`quarkus` - a namespace claimed by Quarkus which is a prefix for all `@ConfigRoot` classes,"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1223
msgid "`log` - a name segment which corresponds to the `LogConfiguration` class annotated with `@ConfigRoot`,"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1224
msgid "`file` - a name segment which corresponds to the `file` field in this class,"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1225
msgid "`enabled` - a name segment which corresponds to `enable` field in `FileConfig` class annotated with `@ConfigGroup`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1229
msgid "The `FileConfig` class is annotated with `@ConfigGroup` to indicate that this is an aggregate configuration object containing a collection of configurable properties, rather than being a simple configuration key type."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1234
msgid "The `@ConfigRoot` annotation indicates that this object is a configuration root group, in this case one which corresponds to a `log` segment. A class name is used to link configuration root group with the segment from a property name. The `Configuration` part is stripped off from a `LogConfiguration` class name and the remaining `Log` is lowercased to become a `log`. Since all `@ConfigRoot` annotated classes uses `quarkus` as a prefix, this finally becomes `quarkus.log` and represents the properties which names begin with `quarkus.log.*`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1236
msgid "Here the `LoggingProcessor` injects a `LogConfiguration` instance automatically by detecting the `@ConfigRoot` annotation."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1238
msgid "A corresponding `application.properties` for the above example could be:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1244
#, no-wrap
msgid ""
"quarkus.log.file.enable=true\n"
"quarkus.log.file.level=DEBUG\n"
"quarkus.log.file.path=/tmp/debug.log\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1247
msgid "Since `format` is not defined in these properties, the default value from `@ConfigItem` will be used instead."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1249
#, no-wrap
msgid "Enhanced conversion"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1253
msgid "You can use enhanced conversion of a config item by using the `@ConvertWith` annotation which accepts a `Converter` class object.  If the annotation is present on a config item, the implicit or custom built in converter in use will be overridden by the value provided.  To do, see the example below which converts `YES` or `NO` values to `boolean`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1263
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Config item with enhanced converter\n"
"     */\n"
"    @ConvertWith(YesNoConverter.class) // <1>\n"
"    @ConfigItem(defaultValue = \"NO\")\n"
"    Boolean answer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1266
#, no-wrap
msgid "    public static class YesNoConverter implements Converter<Boolean> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1268
#, no-wrap
msgid "        public YesNoConverter() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1274
#, no-wrap
msgid ""
"        @Override\n"
"        public Boolean convert(String s) {\n"
"            if (s == null || s.isEmpty()) {\n"
"                return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1281
#, no-wrap
msgid ""
"            switch (s) {\n"
"                case \"YES\":\n"
"                    return true;\n"
"                case \"NO\":\n"
"                    return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1286
#, no-wrap
msgid ""
"            throw new IllegalArgumentException(\"Unsupported value \" + s + \" given\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1288
msgid "Override the default `Boolean` converter and use the provided converter which accepts a `YES` or `NO` config values."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1291
msgid "The corresponding `application.properties` will look like."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1294
#, no-wrap
msgid "quarkus.some.answer=YES\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1299
msgid "Enum values (config items) are translated to skewed-case (hyphenated) by default. The table below illustrates an enum name and their canonical equivalence:"
msgstr ""

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1324
#, no-wrap
msgid ""
"|Java enum| Canonical equivalent\n"
"\n"
"|DISCARD\n"
"|discard\n"
"\n"
"|READ_UNCOMMITTED\n"
"|read-uncommitted\n"
"\n"
"|SIGUSR1\n"
"|sigusr1\n"
"\n"
"|JavaEnum\n"
"|java-enum\n"
"\n"
"|MAKING_LifeDifficult\n"
"|making-life-difficult\n"
"\n"
"|YeOldeJBoss\n"
"|ye-olde-jboss\n"
"\n"
"|camelCaseEnum\n"
"|camel-case-enum\n"
"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1327
msgid "To use the default behaviour which is based on implicit converter or a custom defined one add `@DefaultConverter` annotation to the configuration item"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1338
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeLogConfig {\n"
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @DefaultConverter // <1>\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1340
msgid "Use the default converter (built in or a custom converter) to convert `Level.class` enum."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1343
#, no-wrap
msgid "Conditional Step Inclusion"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1349
msgid "It is possible to only include a given `@BuildStep` under certain conditions.  The `@BuildStep` annotation has two optional parameters: `onlyIf` and `onlyIfNot`.  These parameters can be set to one or more classes which implement `BooleanSupplier`.  The build step will only be included when the method returns `true` (for `onlyIf`) or `false` (for `onlyIfNot`)."
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1352
msgid "The condition class can inject <<configuration-roots,configuration roots>> as long as they belong to a build-time phase.  Run time configuration is not available for condition classes."
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1355
msgid "The condition class may also inject a value of type `io.quarkus.runtime.LaunchMode`.  Constructor parameter and field injection is supported."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:1356
#, no-wrap
msgid "An example of a conditional build step"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1363
#, no-wrap
msgid ""
"@BuildStep(onlyIf = IsDevMode.class)\n"
"LogCategoryBuildItem enableDebugLogging() {\n"
"    return new LogCategoryBuildItem(\"org.your.quarkus.extension\", Level.DEBUG);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1366
#, no-wrap
msgid ""
"static class IsDevMode implements BooleanSupplier {\n"
"    LaunchMode launchMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1371
#, no-wrap
msgid ""
"    public boolean getAsBoolean() {\n"
"        return launchMode == LaunchMode.DEVELOPMENT;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1374
#, no-wrap
msgid "Bytecode Recording"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1378
msgid "One of the main outputs of the build process is recorded bytecode. This bytecode actually sets up the runtime environment. For example, in order to start Undertow, the resulting application will have some bytecode that directly registers all Servlet instances and then starts Undertow."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1384
msgid "As writing bytecode directly is complex, this is instead done via bytecode recorders. At deployment time, invocations are made on recorder objects that contain the actual runtime logic, but instead of these invocations proceeding as normal they are intercepted and recorded (hence the name). This recording is then used to generate bytecode that performs the same sequence of invocations at runtime. This is essentially a form of deferred execution where invocations made at deployment time get deferred until runtime."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1386
msgid "Let's look at the classic 'Hello World' type example. To do this the Quarkus way we would create a recorder as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1391
#, no-wrap
msgid ""
"@Recorder\n"
"class HelloRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1395
#, no-wrap
msgid ""
"  public void sayHello(String name) {\n"
"    System.out.println(\"Hello\" + name);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1400
msgid "And then create a build step that uses this recorder:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1408
#, no-wrap
msgid ""
"@Record(RUNTIME_INIT)\n"
"@BuildStep\n"
"public void helloBuildStep(HelloRecorder recorder) {\n"
"    recorder.sayHello(\"World\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1413
msgid "When this build step is run nothing is printed to the console. This is because the `HelloRecorder` that is injected is actually a proxy that records all invocations. Instead if we run the resulting Quarkus program we will see 'Hello World' printed to the console."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1418
msgid "Methods on a recorder can return a value, which must be proxiable (if you want to return a non-proxiable item wrap it in `io.quarkus.runtime.RuntimeValue`). These proxies may not be invoked directly, however they can be passed into other recorder methods. This can be any recorder method, including from other `@BuildStep` methods, so a common pattern is to produce `BuildItem` instances that wrap the results of these recorder invocations."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1422
msgid "For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a `ServletExtensionBuildItem`, which is a `MultiBuildItem` that wraps a `ServletExtension` instance. I can return a `ServletExtension` from a recorder in another module, and Undertow will consume it and pass it into the recorder method that starts Undertow."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1426
msgid "At runtime the bytecode will be invoked in the order it is generated. This means that build step dependencies implicitly control the order that generated bytecode is run. In the example above we know that the bytecode that produces a `ServletExtensionBuildItem` will be run before the bytecode that consumes it."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1428
msgid "The following objects can be passed to recorders:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1430
msgid "Primitives"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1431
msgid "String"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1432
msgid "Class<?> objects"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1433
msgid "Objects returned from a previous recorder invocation"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1434
msgid "Objects with a no-arg constructor and getter/setters for all properties (or public fields)"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1435
msgid "Objects with a constructor annotated with `@RecordableConstructor` with parameter names that match field names"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1436
msgid "Any arbitrary object via the `io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` mechanism"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1437
msgid "Arrays, Lists and Maps of the above"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1439
#, no-wrap
msgid "RecorderContext"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1445
msgid "`io.quarkus.deployment.recording.RecorderContext` provides some convenience methods to enhance bytecode recording, this includes the ability to register creation functions for classes without no-arg constructors, to register an object substitution (basically a transformer from a non-serializable object to a serializable one and vice versa), and to create a class proxy. This interface can be directly injected as a method parameter into any `@Record` method."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1449
msgid "Calling `classProxy` with a given class name will create a `Class` that can be passed into recorder methods, and at runtime will be substituted with the class whose name was passed in to `classProxy`. This is basically a convenience to avoid the need to explicitly load classes in the recorders."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1450
#, no-wrap
msgid "Printing step execution time"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1455
msgid "At times, it can be useful to know how the exact time each startup task (which is the result of each bytecode recording) takes when the application is run.  The simplest way to determine this information is to set the `quarkus.debug.print-startup-times` property to `true` when running the application.  The output will look something like:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1468
#, no-wrap
msgid ""
"Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: 42ms\n"
"Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed in: 4ms\n"
"Build step SyntheticBeansProcessor.initRuntime completed in: 0ms\n"
"Build step ConfigBuildStep.validateConfigProperties completed in: 1ms\n"
"Build step ResteasyStandaloneBuildStep.boot completed in: 95ms\n"
"Build step VertxHttpProcessor.initializeRouter completed in: 1ms\n"
"Build step VertxHttpProcessor.finalizeRouter completed in: 4ms\n"
"Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms\n"
"Build step VertxHttpProcessor.openSocket completed in: 93ms\n"
"Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms\n"
msgstr ""

#. TODO: config integration
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1473
#, no-wrap
msgid "Contexts and Dependency Injection"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1475
#, no-wrap
msgid "Extension Points"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1480
msgid "As a CDI based runtime, Quarkus extensions often make CDI beans available as part of the extension behavior.  However, Quarkus DI solution does not support CDI Portable Extensions.  Instead, Quarkus extensions can make use of various link:cdi-reference[Build Time Extension Points]."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1481
#, no-wrap
msgid "Quarkus DEV Console"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1484
msgid "You can make your extension support the link:dev-console[Quarkus DEV Console] for a greater developer experience."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1485
#, no-wrap
msgid "Extension Health Check"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1488
msgid "Health checks are provided via the `quarkus-smallrye-health` extension. It provides both liveness and readiness checks capabilities."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1490
msgid "When writing an extension, it's beneficial to provide health checks for the extension, that can be automatically included without the developer needing to write their own."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1492
msgid "In order to provide a health check, you should do the following:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1495
msgid "Import the `quarkus-smallrye-health` extension as an **optional** dependency in your runtime module so it will not impact the size of the application if health check is not included."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1497
msgid "Create your health check following the link:microprofile-health[Quarkus - MicroProfile Health] guide. We advise providing only readiness check for an extension (liveness check is designed to express the fact that an application is up and needs to be lightweight)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1498
msgid "Import the `quarkus-smallrye-health-spi` library in your deployment module."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1499
msgid "Add a build step in your deployment module that produces a `HealthBuildItem`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1500
msgid "Add a way to disable the extension health check via a config item `quarkus.<extension>.health.enabled` that should be enabled by default."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1502
msgid "Following is an example from the Agroal extension that provides a `DataSourceHealthCheck` to validate the readiness of a datasource."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1510
#, no-wrap
msgid ""
"@BuildStep\n"
"HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {\n"
"    return new HealthBuildItem(\"io.quarkus.agroal.runtime.health.DataSourceHealthCheck\",\n"
"            agroalBuildTimeConfig.healthEnabled);\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1512
#, no-wrap
msgid "Extension Metrics"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1517
msgid "The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` extension provide support for collecting metrics.  As a compatibility note, the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer library primitives, so the `quarkus-micrometer` extension can be enabled without breaking code that relies on the MP Metrics API.  Note that the metrics emitted by Micrometer are different, see the `quarkus-micrometer` extension documentation for more information."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1519
msgid "The compatibility layer for MP Metrics APIs will move to a different extension in the future."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1521
msgid "There are two broad patterns that extensions can use to interact with an optional metrics extension to add their own metrics:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1523
msgid "Consumer pattern: An extension declares a `MetricsFactoryConsumerBuildItem` and uses that to provide a bytecode recorder to the metrics extension. When the metrics extension has initialized, it will iterate over registered consumers to initialize them with a `MetricsFactory`. This factory can be used to declare API-agnostic metrics, which can be a good fit for extensions that provide an instrumentable object for gathering statistics (e.g. Hibernate's `Statistics` class)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1525
msgid "Binder pattern: An extension can opt to use completely different gathering implementations depending on the metrics system. An `Optional<MetricsCapabilityBuildItem> metricsCapability` build step parameter can be used to declare or otherwise initialize API-specific metrics based on the active metrics extension (e.g. \"smallrye-metrics\" or \"micrometer\"). This pattern can be combined with the consumer pattern by using `MetricsFactory::metricsSystemSupported()` to test the active metrics extension within the recorder."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1527
msgid "Remember that support for metrics is optional. Extensions can use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter in their build step to test for the presence of an enabled metrics extension. Consider using additional configuration to control behavior of metrics. Datasource metrics can be expensive, for example, so additional configuration flags are used enable metrics collection on individual datasources."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1529
msgid "When adding metrics for your extension, you may find yourself in one of the following situations:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1531
msgid "An underlying library used by the extension is using a specific Metrics API directly (either MP Metrics, Micrometer, or some other)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1532
msgid "An underlying library uses its own mechanism for collecting metrics and makes them available at runtime using its own API, e.g. Hibernate's `Statistics` class, or Vert.x `MetricsOptions`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1533
msgid "An underlying library does not provide metrics (or there is no library at all) and you want to add instrumentation."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1534
#, no-wrap
msgid "Case 1: The library uses a metrics library directly"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1537
msgid "If the library directly uses a metrics API, there are two options:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1539
msgid "Use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter to test which metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\") in your build step, and use that to selectively declare or initialize API-specific beans or build items."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1541
msgid "Create a separate build step that consumes a `MetricsFactory`, and use the `MetricsFactory::metricsSystemSupported()` method within the bytecode recorder to initialize required resources if the desired metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\")."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1543
msgid "Extensions may need to provide a fallback if there is no active metrics extension or the extension doesn't support the API required by the library."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1544
#, no-wrap
msgid "Case 2: The library provides its own metric API"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1547
msgid "There are two examples of a library providing its own metrics API:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1549
msgid "The extension defines an instrumentable object as Agroal does with `io.agroal.api.AgroalDataSourceMetrics`, or"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1550
msgid "The extension provides its own abstraction of metrics, as Jaeger does with `io.jaegertracing.spi.MetricsFactory`."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1551
#, no-wrap
msgid "Observing instrumentable objects"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1554
msgid "Let's take the instrumentable object (`io.agroal.api.AgroalDataSourceMetrics`) case first. In this case, you can do the following:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1556
msgid "Define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer. For example, the following creates a `MetricsFactoryConsumerBuildItem` if and only if metrics are enabled both for Agroal generally, and for a datasource specifically:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1565
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void registerMetrics(AgroalMetricsRecorder recorder,\n"
"        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,\n"
"        BuildProducer<MetricsFactoryConsumerBuildItem> datasourceMetrics,\n"
"        List<AggregatedDataSourceBuildTimeConfigBuildItem> aggregatedDataSourceBuildTimeConfigs) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1577
#, no-wrap
msgid ""
"    for (AggregatedDataSourceBuildTimeConfigBuildItem aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) {\n"
"        // Create a MetricsFactory consumer to register metrics for a data source\n"
"        // IFF metrics are enabled globally and for the data source\n"
"        // (they are enabled for each data source by default if they are also enabled globally)\n"
"        if (dataSourcesBuildTimeConfig.metricsEnabled &&\n"
"                aggregatedDataSourceBuildTimeConfig.getJdbcConfig().enableMetrics.orElse(true)) {\n"
"            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(\n"
"                    recorder.registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1580
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics. For Agroal, this means using the `MetricFactory` API to observe `io.agroal.api.AgroalDataSourceMetrics` methods. For example:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1590
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerDataSourceMetrics(String dataSourceName) {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? \"default\" : dataSourceName;\n"
"            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName).getMetrics();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1598
#, no-wrap
msgid ""
"            // When using MP Metrics, the builder uses the VENDOR registry by default.\n"
"            metricsFactory.builder(\"agroal.active.count\")\n"
"                    .description(\n"
"                            \"Number of active connections. These connections are in use and not available to be acquired.\")\n"
"                    .tag(\"datasource\", tagValue)\n"
"                    .buildGauge(metrics::activeCount);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1601
msgid "The `MetricsFactory` provides a fluid builder for registration of metrics, with the final step constructing gauges or counters based on a `Supplier` or `ToDoubleFunction`. Timers can either wrap `Callable`, `Runnable`, or `Supplier` implementations, or can use a `TimeRecorder` to accumulate chunks of time. The underlying metrics extension will create appropriate artifacts to observe or measure the defined functions."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1602
#, no-wrap
msgid "Using a Metrics API-specific implementation"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1605
msgid "Using metrics-API specific implementations may be preferred in some cases. Jaeger, for example, defines its own metrics interface, `io.jaegertracing.spi.MetricsFactory`, that it uses to define counters and gauges. A direct mapping from that interface to the metrics system will be the most efficient. In this case, it is important to isolate these specialized implementations and to avoid eager classloading to ensure the metrics API remains an optional, compile-time dependency."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1607
msgid "`Optional<MetricsCapabilityBuildItem> metricsCapability` can be used in the build step to selectively control initialization of beans or the production of other build items. The Jaeger extension, for example, can use the following to control initialization of specialized Metrics API adapters:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1615
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig buildTimeConfig, JaegerConfig jaeger,\n"
"        ApplicationConfig appConfig, Optional<MetricsCapabilityBuildItem> metricsCapability) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1618
#, no-wrap
msgid ""
"    // Indicates that this extension would like the SSL support to be enabled\n"
"    extensionSslNativeSupport.produce(new ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1632
#, no-wrap
msgid ""
"    if (buildTimeConfig.enabled) {\n"
"        // To avoid dependency creep, use two separate recorder methods for the two metrics systems\n"
"        if (buildTimeConfig.metricsEnabled && metricsCapability.isPresent()) {\n"
"            if (metricsCapability.get().metricsSupported(MetricsFactory.MICROMETER)) {\n"
"                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);\n"
"            } else {\n"
"                jdr.registerTracerWithMpMetrics(jaeger, appConfig);\n"
"            }\n"
"        } else {\n"
"            jdr.registerTracerWithoutMetrics(jaeger, appConfig);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1635
msgid "A recorder consuming a `MetricsFactory` can use `MetricsFactory::metricsSystemSupported()` can be used to control initialization of metrics objects during bytecode recording in a similar way."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1636
#, no-wrap
msgid "Case 3: It is necessary to collect metrics within the extension code"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1639
msgid "To define your own metrics from scratch, you have two basic options: Use the generic `MetricFactory` builders, or follow the binder pattern, and create instrumentation specific to the enabled metrics extension."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1641
msgid "To use the extension-agnostic `MetricFactory` API, your processor can define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1649
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder recorder) {\n"
"    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1652
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics, for example"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1656
#, no-wrap
msgid "final LongAdder extensionCounter = new LongAdder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1665
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerMetrics() {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            metricsFactory.builder(\"my.extension.counter\")\n"
"                    .buildGauge(extensionCounter::longValue);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1668
msgid "Remember that metrics extensions are optional. Keep metrics-related initialization isolated from other setup for your extension, and structure your code to avoid eager imports of metrics APIs. Gathering metrics can also be expensive. Consider using additional extension-specific configuration to control behavior of metrics if the presence/absence of metrics support isn't sufficient."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1669
#, no-wrap
msgid "Customizing JSON handling from an extension"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1672
msgid "Extensions often need to register serializers and/or deserializers for types the extension provides."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1675
msgid "For this, both Jackson and JSON-B extensions provide a way to register serializer/deserializer from within an extension deployment module."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1677
msgid "Keep in mind that not everybody will need JSON, so you need to make it optional."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1680
msgid "If an extension intends to provide JSON related customization, it is strongly advised to provide customization for both Jackson and JSON-B."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1681
#, no-wrap
msgid "Customizing Jackson"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1684
msgid "First, add an *optional* dependency to `quarkus-jackson` on your extension's runtime module."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1692
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1695
msgid "Then create a serializer or a deserializer (or both) for Jackson, an example of which can be seen in the `mongodb-panache` extension."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1710
#, no-wrap
msgid ""
"public class ObjectIdSerializer extends StdSerializer<ObjectId> {\n"
"    public ObjectIdSerializer() {\n"
"        super(ObjectId.class);\n"
"    }\n"
"    @Override\n"
"    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)\n"
"            throws IOException {\n"
"        if (objectId != null) {\n"
"            jsonGenerator.writeString(objectId.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1713
msgid "Add a dependency to `quarkus-jackson-spi` on your extension's deployment module."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1720
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1724
msgid "Add a build step to your processor to register a Jackson module via the `JacksonModuleBuildItem`.  You need to name your module in a unique way across all Jackson modules."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1735
#, no-wrap
msgid ""
"@BuildStep\n"
"JacksonModuleBuildItem registerJacksonSerDeser() {\n"
"    return new JacksonModuleBuildItem.Builder(\"ObjectIdModule\")\n"
"                    .add(io.quarkus.mongodb.panache.jackson.ObjectIdSerializer.class.getName(),\n"
"                            io.quarkus.mongodb.panache.jackson.ObjectIdDeserializer.class.getName(),\n"
"                            ObjectId.class.getName())\n"
"                    .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1738
msgid "The Jackson extension will then use the produced build item to register a module within Jackson automatically."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1742
msgid "If you need more customization capabilities than registering a module, you can produce a CDI bean that implements `io.quarkus.jackson.ObjectMapperCustomizer` via an `AdditionalBeanBuildItem`.  More info about customizing Jackson can be found on the JSON guide link:rest-json#configuring-json-support[Configuring JSON support]"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1743
#, no-wrap
msgid "Customizing JSON-B"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1745
msgid "First, add an *optional* dependency to `quarkus-jsonb` on your extension's runtime module."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1753
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1756
msgid "Then create a serializer and/or a deserializer for JSON-B, an example of which can be seen in the `mongodb-panache` extension."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1767
#, no-wrap
msgid ""
"public class ObjectIdSerializer implements JsonbSerializer<ObjectId> {\n"
"    @Override\n"
"    public void serialize(ObjectId obj, JsonGenerator generator, SerializationContext ctx) {\n"
"        if (obj != null) {\n"
"            generator.write(obj.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1770
msgid "Add a dependency to `quarkus-jsonb-spi` on your extension's deployment module."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1777
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1780
msgid "Add a build step to your processor to register the serializer via the `JsonbSerializerBuildItem`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1787
#, no-wrap
msgid ""
"@BuildStep\n"
"JsonbSerializerBuildItem registerJsonbSerializer() {\n"
"    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb.ObjectIdSerializer.class.getName()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1790
msgid "The JSON-B extension will then use the produced build item to register your serializer/deserializer automatically."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1794
msgid "If you need more customization capabilities than registering a serializer or a deserializer, you can produce a CDI bean that implements `io.quarkus.jsonb.JsonbConfigCustomizer` via an `AdditionalBeanBuildItem`.  More info about customizing JSON-B can be found on the JSON guide link:rest-json#configuring-json-support[Configuring JSON support]"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1795
#, no-wrap
msgid "Testing Extensions"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1802
msgid "Testing of Quarkus extensions should be done with the `io.quarkus.test.QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-style tests that test specific functionalities.  It is not intended for testing user applications, as this should be done via `io.quarkus.test.junit.QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the application once at the start of the run, while `QuarkusUnitTest` deploys a custom Quarkus application for each test class."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1805
msgid "These tests should be placed in the deployment module, if additional Quarkus modules are required for testing their deployment modules should also be added as test scoped dependencies."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1807
msgid "Note that `QuarkusUnitTest` is in the `quarkus-junit5-internal` module."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1809
msgid "An example test class may look like:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1813
#, no-wrap
msgid "package io.quarkus.health.test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1815
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1818
#, no-wrap
msgid ""
"import java.util.ArrayList;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1821
#, no-wrap
msgid ""
"import javax.enterprise.inject.Instance;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1831
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Health;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.asset.EmptyAsset;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1833
#, no-wrap
msgid "import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1835
#, no-wrap
msgid "public class FailingUnitTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1843
#, no-wrap
msgid ""
"    @RegisterExtension                                                                  // <1>\n"
"    static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"            .setArchiveProducer(() ->\n"
"                    ShrinkWrap.create(JavaArchive.class)                                // <2>\n"
"                            .addClasses(FailingHealthCheck.class)\n"
"                            .addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\")\n"
"            );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1847
#, no-wrap
msgid ""
"    @Inject                                                                             // <3>\n"
"    @Health\n"
"    Instance<HealthCheck> checks;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1852
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthServlet() {\n"
"        RestAssured.when().get(\"/q/health\").then().statusCode(503);                       // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1863
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthBeans() {\n"
"        List<HealthCheck> check = new ArrayList<>();                                    // <5>\n"
"        for (HealthCheck i : checks) {\n"
"            check.add(i);\n"
"        }\n"
"        assertEquals(1, check.size());\n"
"        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call().getState());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1866
msgid "The `QuarkusUnitTest` extension must be used with a static field. If used with a non-static field, the test application is not started."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1867
msgid "This producer is used to build the application to be tested. It uses Shrinkwrap to create a JavaArchive to test"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1868
msgid "It is possible to inject beans from our test deployment directly into the test case"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1869
msgid "This method directly invokes the health check Servlet and verifies the response"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1870
msgid "This method uses the injected health check bean to verify it is returning the expected result"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1872
msgid "If you want to test that an extension properly fails at build time, use the `setExpectedException` method:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1877
#, no-wrap
msgid "package io.quarkus.hibernate.orm;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1885
#, no-wrap
msgid ""
"import io.quarkus.deployment.configuration.ConfigurationError;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1887
#, no-wrap
msgid "public class PersistenceAndQuarkusConfigTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1894
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    static QuarkusUnitTest runner = new QuarkusUnitTest()\n"
"            .setExpectedException(ConfigurationError.class)                     <1>\n"
"            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n"
"                    .addAsManifestResource(\"META-INF/some-persistence.xml\", \"persistence.xml\")\n"
"                    .addAsResource(\"application.properties\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1902
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPersistenceAndConfigTest() {\n"
"        // should not be called, deployment exception should happen first:\n"
"        // it's illegal to have Hibernate configuration properties in both the\n"
"        // application.properties and in the persistence.xml\n"
"        Assertions.fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1907
msgid "This tells JUnit that the Quarkus deployment should fail with a specific exception"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1909
#, no-wrap
msgid "Testing hot reload"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1913
msgid "It is also possible to write tests that verify an extension works correctly in development mode and can correctly handle updates."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1916
msgid "For most extensions this will just work 'out of the box', however it is still a good idea to have a smoke test to verify that this functionality is working as expected. To test this we use `QuarkusDevModeTest`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1921
#, no-wrap
msgid "public class ServletChangeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1932
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    final static QuarkusDevModeTest test = new QuarkusDevModeTest()\n"
"            .setArchiveProducer(new Supplier<JavaArchive>() {\n"
"                @Override\n"
"                public JavaArchive get() {\n"
"                    return ShrinkWrap.create(JavaArchive.class)   <1>\n"
"                            .addClass(DevServlet.class)\n"
"                            .addAsManifestResource(new StringAsset(\"Hello Resource\"), \"resources/file.txt\");\n"
"                }\n"
"            });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1938
#, no-wrap
msgid ""
"    @Test\n"
"    public void testServletChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello World\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1940
#, no-wrap
msgid "        test.modifySourceFile(\"DevServlet.java\", new Function<String, String>() {  <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1946
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return s.replace(\"Hello World\", \"Hello Quarkus\");\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1951
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Quarkus\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1956
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddServlet() throws InterruptedException {\n"
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1958
#, no-wrap
msgid "        test.addSourceFile(NewServlet.class);                                       <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1963
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new Servlet\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1969
#, no-wrap
msgid ""
"    @Test\n"
"    public void testResourceChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Resource\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1971
#, no-wrap
msgid "        test.modifyResourceFile(\"META-INF/resources/file.txt\", new Function<String, String>() { <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1977
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return \"A new resource\";\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1982
#, no-wrap
msgid ""
"        RestAssured.when().get(\"file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new resource\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1985
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddResource() throws InterruptedException {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1988
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1990
#, no-wrap
msgid "        test.addResourceFile(\"META-INF/resources/new.txt\", \"New File\");  <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1994
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"New File\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1997
#, no-wrap
msgid ""
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2001
msgid "This starts the deployment, your test can modify it as part of the test suite. Quarkus will be restarted between each test method so every method starts with a clean deployment."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2004
msgid "This method allows you to modify the source of a class file. The old source is passed into the function, and the updated source is returned."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2007
msgid "This method adds a new class file to the deployment. The source that is used will be the original source that is part of the current project."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2009
msgid "This method modifies a static resource"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2011
msgid "This method adds a new static resource"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2012
#, no-wrap
msgid "Native Executable Support"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2017
msgid "There Quarkus provides a lot of build items that control aspects of the native executable build. This allows for extensions to programmatically perform tasks such as registering classes for reflection or adding static resources to the native executable. Some of these build items are listed below:"
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2018
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2020
msgid "Includes static resources into the native executable."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2021
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2023
msgid "Includes directory's static resources into the native executable."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2024
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2026
msgid "A class that will be reinitialized at runtime by Substrate. This will result in the static initializer running twice."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2027
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2029
msgid "A system property that will be set at native executable build time."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2030
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2032
msgid "Includes a resource bundle in the native executable."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2033
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2035
msgid "Registers a class for reflection in Substrate. Constructors are always registered, while methods and fields are optional."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2036
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2038
msgid "A class that will be initialized at runtime rather than build time. This will cause the build to fail if the class is initialized as part of the native executable build process, so care must be taken."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2039
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2041
msgid "A convenience feature that allows you to control most of the above features from a single build item."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2042
#, no-wrap
msgid "`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2044
msgid "Indicates that all charsets should be enabled in native image."
msgstr ""

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2045
#, no-wrap
msgid "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2048
msgid "A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build.  When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2049
#, no-wrap
msgid "IDE support tips"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2051
#, no-wrap
msgid "Writing Quarkus extensions in Eclipse"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2054
msgid "The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2056
msgid "Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2057
msgid "Define this property in your `pom.xml`: `<m2e.apt.activation>jdt_apt</m2e.apt.activation>`, although if you rely on `io.quarkus:quarkus-build-parent` you will get it for free."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2058
msgid "If you have the `io.quarkus:quarkus-extension-processor` project open at the same time in your IDE (for example, if you have the Quarkus sources checked out and open in your IDE) you will need to close that project. Otherwise, Eclipse will not invoke the APT plugin that it contains."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2059
msgid "If you just closed the extension processor project, be sure to do `Maven > Update Project` on the other projects in order for Eclipse to pick up the extension processor from the Maven repository."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2060
#, no-wrap
msgid "Troubleshooting / Debugging Tips"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2062
#, no-wrap
msgid "Dump the Generated Classes to the File System"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2067
msgid "During the augmentation phase Quarkus extensions generate new and modify existing classes for various purposes.  Sometimes you need to inspect the generated bytecode to debug or understand an issue.  There are three system properties that allow you to dump the classes to the filesystem:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2069
msgid "`quarkus.debug.generated-classes-dir` - to dump the generated classes, such as bean metadata"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2070
msgid "`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e.g. Panache entities"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2071
msgid "`quarkus.debug.generated-sources-dir` - to dump the ZIG files; ZIG file is a textual representation of the generated code that is referenced in the stack traces"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2073
msgid "These properties are especially useful in the development mode or when running the tests where the generated/transformed classes are only held in memory in a class loader."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2075
msgid "For example, you can specify the `quarkus.debug.generated-classes-dir` system property to have these classes written out to disk for inspection in the development mode:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2079
#, no-wrap
msgid "./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2082
msgid "The property value could be either an absolute path, such as `/home/foo/dump` on a Linux machine, or a path relative to the user working directory, i.e. `dump` corresponds to the `{user.dir}/target/dump` in the dev mode and `{user.dir}/dump` when running the tests."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2084
msgid "You should see a line in the log for each class written to the directory:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2088
#, no-wrap
msgid "INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean.class\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2091
msgid "The property is also honored when running tests:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2095
#, no-wrap
msgid "./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-generated-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2098
msgid "Analogously, you can use the `quarkus.debug.transformed-classes-dir` and `quarkus.debug.transformed-classes-dir` properties to dump the relevant output."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2100
#, no-wrap
msgid "Multi-module Maven Projects and the Development Mode"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2105
msgid "It's not uncommon to develop an extension in a multi-module Maven project that also contains an \"example\" module.  However, if you want to run the example in the development mode then the `-DnoDeps` system property must be used in order to exclude the local project dependencies.  Otherwise, Quarkus attempts to monitor the extension classes and this may result in weird class loading issues."
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2109
#, no-wrap
msgid "./mvnw compile quarkus:dev -DnoDeps\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2111
#, no-wrap
msgid "Indexer does not include your external dependency"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2114
msgid "Remember to add `IndexDependencyBuildItem` artifacts to your `@BuildStep`."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2115
#, no-wrap
msgid "Sample Test Extension"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2118
msgid "We have an extension that is used to test for regressions in the extension processing. It is located in {quarkus-tree-url}/core/test-extension directory. In this section we touch on some of the tasks an extension author will typically need to perform using the test-extension code to illustrate how the task could be done."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2119
#, no-wrap
msgid "Features and Capabilities"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2121
#, no-wrap
msgid "Features"
msgstr "特徴"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2125
msgid "A _feature_ represents a functionality provided by an extension.  The name of the feature gets displayed in the log during application bootstrap."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2126
#, no-wrap
msgid "Example Startup Lines"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2131
#, no-wrap
msgid ""
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.061s.\n"
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, test-extension] <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2133
msgid "A list of features installed in the runtime image"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2135
msgid "A feature can be registered in a <<Build Step Processors>> method that produces a `FeatureBuildItem`:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2136
#, no-wrap
msgid "TestProcessor#feature()"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2143
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(\"test-extension\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2148
msgid "The name of the feature should only contain lowercase characters, words are separated by dash; e.g. `security-jpa`.  An extension should provide at most one feature and the name must be unique.  If multiple extensions register a feature of the same name the build fails."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2152
msgid "The feature name should also map to a label in the extension's `devtools/common/src/main/filtered/extensions.json` entry so that the feature name displayed by the startup line matches a label that one can used to select the extension when creating a project using the Quarkus maven plugin as shown in this example taken from the link:rest-json[Writing JSON REST Services] guide where the `resteasy-jackson` feature is referenced:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2162
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy,resteasy-jackson\"\n"
"cd rest-json\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2169
msgid "A _capability_ represents a technical capability that can be queried by other extensions.  An extension may provide multiple capabilities and multiple extensions can provide the same capability.  By default, capabilities are not displayed to users."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2171
msgid "Capabilities can be registered in a <<Build Step Processors>> method that produces a `CapabilityBuildItem`:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2172
#, no-wrap
msgid "TestProcessor#capability()"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2180
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void capabilities(BuildProducer<CapabilityBuildItem> capabilityProducer) {\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-transactions\"));\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-metrics\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2183
msgid "Extensions can consume registered capabilities using the `Capabilities` build item:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2184
#, no-wrap
msgid "TestProcessor#doSomeCoolStuff()"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2193
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void doSomeCoolStuff(Capabilities capabilities) {\n"
"        if (capabilities.isPresent(Capability.TRANSACTIONS)) {\n"
"          // do something only if JTA transactions are in...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2197
msgid "Capabilities should follow the naming conventions of Java packages; e.g. `io.quarkus.security.jpa`.  Capabilities provided by core extensions should be listed in the `io.quarkus.deployment.Capability` enum and their name should always start with the `io.quarkus` prefix."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2198
#, no-wrap
msgid "Bean Defining Annotations"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2200
msgid "The CDI layer processes CDI beans that are either explicitly registered or that it discovers based on bean defining annotations as defined in http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[2.5.1. Bean defining annotations]. You can expand this set of annotations to include annotations your extension processes using a `BeanDefiningAnnotationBuildItem` as shown in this `TestProcessor#registerBeanDefinningAnnotations` example:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2201
#, no-wrap
msgid "Register a Bean Defining Annotation"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2207
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.jboss.jandex.DotName;\n"
"import io.quarkus.extest.runtime.TestAnnotation;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2211
#, no-wrap
msgid ""
"public final class TestProcessor {\n"
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());\n"
"    static DotName TEST_ANNOTATION_SCOPE = DotName.createSimple(ApplicationScoped.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2213
#: upstream/_guides/writing-extensions.adoc:2239
#, no-wrap
msgid "...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2221
#, no-wrap
msgid ""
"    @BuildStep\n"
"    BeanDefiningAnnotationBuildItem registerX() {\n"
"        <1>\n"
"        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, TEST_ANNOTATION_SCOPE);\n"
"    }\n"
"...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2231
#, no-wrap
msgid ""
"/**\n"
" * Marker annotation for test configuration target beans\n"
" */\n"
"@Target({ TYPE })\n"
"@Retention(RUNTIME)\n"
"@Documented\n"
"@Inherited\n"
"public @interface TestAnnotation {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2237
#, no-wrap
msgid ""
"/**\n"
" * A sample bean\n"
" */\n"
"@TestAnnotation <2>\n"
"public class ConfiguredBean implements IConfigConsumer {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2241
msgid "Register the annotation class and CDI default scope using the Jandex `DotName` class."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2242
msgid "`ConfiguredBean` will be processed by the CDI layer the same as a bean annotated with the CDI standard @ApplicationScoped."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2243
#, no-wrap
msgid "Parsing Config to Objects"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2245
msgid "One of the main things an extension is likely to do is completely separate the configuration phase of behavior from the runtime phase. Frameworks often do parsing/load of configuration on startup that can be done during build time to both reduce the runtime dependencies on frameworks like xml parsers as well as reducing the startup time the parsing incurs."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2247
msgid "An example of parsing a XML config file using JAXB is shown in the `TestProcessor#parseServiceXmlConfig` method:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2247
#, no-wrap
msgid "Parsing an XML Configuration into Runtime XmlConfig Instance"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2264
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\"); <1>\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <2>\n"
"...\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2267
msgid "Look for a config.xml classpath resource"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2268
msgid "If found, parse using JAXB context for `XmlConfig.class`"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2272
msgid "If there was no /config.xml resource available in the build environment, then a null `RuntimeServiceBuildItem` would be returned and no subsequent logic based on a `RuntimeServiceBuildItem` being produced would execute."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2275
msgid "Typically one is loading a configuration to create some runtime component/service as `parseServiceXmlConfig` is doing. We will come back to the rest of the behavior in `parseServiceXmlConfig` in the following <<Manage Non-CDI Service>> section."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2277
msgid "If for some reason you need to parse the config and use it in other build steps in an extension processor, you would need to create an `XmlConfigBuildItem` to pass the parsed XmlConfig instance around."
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2281
msgid "If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don't want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class. We will do this in <<Replacing Classes in the Native Image>>."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2283
#, no-wrap
msgid "Scanning Deployments Using Jandex"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2285
msgid "If your extension defines annotations or interfaces that mark beans needing to be processed, you can locate these beans using the Jandex API, a Java annotation indexer and offline reflection library. The following `TestProcessor#scanForBeans` method shows how to find the beans annotated with our `@TestAnnotation` that also implement the `IConfigConsumer` interface:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2286
#, no-wrap
msgid "Example Jandex Usage"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2291
#, no-wrap
msgid ""
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2314
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem beanArchiveIndex, <1>\n"
"            BuildProducer<TestBeanBuildItem> testBeanProducer) {\n"
"        IndexView indexView = beanArchiveIndex.getIndex(); <2>\n"
"        Collection<AnnotationInstance> testBeans = indexView.getAnnotations(TEST_ANNOTATION); <3>\n"
"        for (AnnotationInstance ann : testBeans) {\n"
"            ClassInfo beanClassInfo = ann.target().asClass();\n"
"            try {\n"
"                boolean isConfigConsumer = beanClassInfo.interfaceNames()\n"
"                        .stream()\n"
"                        .anyMatch(dotName -> dotName.equals(DotName.createSimple(IConfigConsumer.class.getName()))); <4>\n"
"                if (isConfigConsumer) {\n"
"                    Class<IConfigConsumer> beanClass = (Class<IConfigConsumer>) Class.forName(beanClassInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());\n"
"                    testBeanProducer.produce(new TestBeanBuildItem(beanClass)); <5>\n"
"                    log.infof(\"Configured bean: %s\", beanClass);\n"
"                }\n"
"            } catch (ClassNotFoundException e) {\n"
"                log.warn(\"Failed to load bean class\", e);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2316
msgid "Depend on a `BeanArchiveIndexBuildItem` to have the build step be run after the deployment has been indexed."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2317
msgid "Retrieve the index."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2318
msgid "Find all beans annotated with `@TestAnnotation`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2319
msgid "Determine which of these beans also has the `IConfigConsumer` interface."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2320
msgid "Save the bean class in a `TestBeanBuildItem` for use in a latter RUNTIME_INIT build step that will interact with the bean instances."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2321
#, no-wrap
msgid "Interacting With Extension Beans"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2323
msgid "You can use the `io.quarkus.arc.runtime.BeanContainer` interface to interact with your extension beans. The following `configureBeans` methods illustrate interacting with the beans scanned for in the previous section:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2324
#, no-wrap
msgid "Using CDI BeanContainer Interface"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2333
#, no-wrap
msgid ""
"// TestProcessor#configureBeans\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    void configureBeans(TestRecorder recorder, List<TestBeanBuildItem> testBeans, <1>\n"
"            BeanContainerBuildItem beanContainer, <2>\n"
"            TestRunTimeConfig runTimeConfig) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2339
#, no-wrap
msgid ""
"        for (TestBeanBuildItem testBeanBuildItem : testBeans) {\n"
"            Class<IConfigConsumer> beanClass = testBeanBuildItem.getConfigConsumer();\n"
"            recorder.configureBeans(beanContainer.getValue(), beanClass, buildAndRunTimeConfig, runTimeConfig); <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2349
#, no-wrap
msgid ""
"// TestRecorder#configureBeans\n"
"    public void configureBeans(BeanContainer beanContainer, Class<IConfigConsumer> beanClass,\n"
"            TestBuildAndRunTimeConfig buildTimeConfig,\n"
"            TestRunTimeConfig runTimeConfig) {\n"
"        log.info(\"Begin BeanContainerListener callback\\n\");\n"
"        IConfigConsumer instance = beanContainer.instance(beanClass); <4>\n"
"        instance.loadConfig(buildTimeConfig, runTimeConfig); <5>\n"
"        log.infof(\"configureBeans, instance=%s\\n\", instance);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2351
msgid "Consume the `TestBeanBuildItem`s produced from the scanning build step."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2352
msgid "Consume the `BeanContainerBuildItem` to order this build step to run after the CDI bean container has been created."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2353
msgid "Call the runtime recorder to record the bean interactions."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2354
msgid "Runtime recorder retrieves the bean using its type."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2355
msgid "Runtime recorder invokes the `IConfigConsumer#loadConfig(...)` method passing in the configuration objects with runtime information."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2356
#, no-wrap
msgid "Manage Non-CDI Service"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2358
msgid "A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime. Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in <<Parsing Config to Objects>>. Now we need to create an instance of the service using the configuration. Let's return to the `TestProcessor#parseServiceXmlConfig` method to see how this can be done."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2359
#, no-wrap
msgid "Creating a Non-CDI Service"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2379
#, no-wrap
msgid ""
"// TestProcessor#parseServiceXmlConfig\n"
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\");\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);\n"
"            log.info(\"Loaded XmlConfig, creating service\");\n"
"            RuntimeValue<RuntimeXmlConfigService> service = recorder.initRuntimeService(config); //<1>\n"
"            serviceBuildItem = new RuntimeServiceBuildItem(service); //<3>\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2385
#, no-wrap
msgid ""
"// TestRecorder#initRuntimeService\n"
"    public RuntimeValue<RuntimeXmlConfigService> initRuntimeService(XmlConfig config) {\n"
"        RuntimeXmlConfigService service = new RuntimeXmlConfigService(config); //<2>\n"
"        return new RuntimeValue<>(service);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2389
#, no-wrap
msgid ""
"// RuntimeServiceBuildItem\n"
"    final public class RuntimeServiceBuildItem extends SimpleBuildItem {\n"
"    private RuntimeValue<RuntimeXmlConfigService> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2393
#, no-wrap
msgid ""
"    public RuntimeServiceBuildItem(RuntimeValue<RuntimeXmlConfigService> service) {\n"
"        this.service = service;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2398
#, no-wrap
msgid ""
"    public RuntimeValue<RuntimeXmlConfigService> getService() {\n"
"        return service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2400
msgid "Call into the runtime recorder to record the creation of the service."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2401
msgid "Using the parsed `XmlConfig` instance, create an instance of `RuntimeXmlConfigService` and wrap it in a `RuntimeValue`. Use a `RuntimeValue` wrapper for non-interface objects that are non-proxiable."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2402
msgid "Wrap the return service value in a `RuntimeServiceBuildItem` for use in a RUNTIME_INIT build step that will start the service."
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2403
#, no-wrap
msgid "Starting a Service"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2405
msgid "Now that you have recorded the creation of a service during the build phase, you need to record how to start the service at runtime during booting. You do this with a RUNTIME_INIT build step as shown in the `TestProcessor#startRuntimeService` method."
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2406
#, no-wrap
msgid "Starting/Stopping a Non-CDI Service"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2422
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem , // <1>\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException { // <2>\n"
"        if (serviceBuildItem != null) {\n"
"            log.info(\"Registering service start\");\n"
"            recorder.startRuntimeService(shutdownContextBuildItem, serviceBuildItem.getService()); // <3>\n"
"        } else {\n"
"            log.info(\"No RuntimeServiceBuildItem seen, check config.xml\");\n"
"        }\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2430
#, no-wrap
msgid ""
"// TestRecorder#startRuntimeService\n"
"    public void startRuntimeService(ShutdownContext shutdownContext, RuntimeValue<RuntimeXmlConfigService> runtimeValue)\n"
"            throws IOException {\n"
"        RuntimeXmlConfigService service = runtimeValue.getValue();\n"
"        service.startService(); //<5>\n"
"        shutdownContext.addShutdownTask(service::stopService); //<6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2432
msgid "We consume a ShutdownContextBuildItem to register the service shutdown."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2433
msgid "We consume the previously initialized service captured in `RuntimeServiceBuildItem`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2434
msgid "Call the runtime recorder to record the service start invocation."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2435
msgid "Produce a `ServiceStartBuildItem` to indicate the startup of a service. See <<Startup and Shutdown Events>> for details."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2436
msgid "Runtime recorder retrieves the service instance reference and calls its `startService` method."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2437
msgid "Runtime recorder registers an invocation of the service instance `stopService` method with the Quarkus `ShutdownContext`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2440
msgid "The code for the `RuntimeXmlConfigService` can be viewed here: {quarkus-blob-url}/core/test-extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2442
msgid "The testcase for validating that the `RuntimeXmlConfigService` has started can be found in the `testRuntimeXmlConfigService` test of `ConfiguredBeanTest` and `NativeImageIT`."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2443
#, no-wrap
msgid "Startup and Shutdown Events"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2446
msgid "The Quarkus container supports startup and shutdown lifecycle events to notify components of the container startup and shutdown. There are CDI events fired that components can observe are illustrated in this example:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2447
#, no-wrap
msgid "Observing Container Startup"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2452
#, no-wrap
msgid ""
"import io.quarkus.runtime.ShutdownEvent;\n"
"import io.quarkus.runtime.StartupEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2461
#, no-wrap
msgid ""
"public class SomeBean {\n"
"    /**\n"
"     * Called when the runtime has started\n"
"     * @param event\n"
"     */\n"
"    void onStart(@Observes StartupEvent event) { // <1>\n"
"        System.out.printf(\"onStart, event=%s%n\", event);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2470
#, no-wrap
msgid ""
"    /**\n"
"     * Called when the runtime is shutting down\n"
"     * @param event\n"
"    */\n"
"    void onStop(@Observes ShutdownEvent event) { // <2>\n"
"        System.out.printf(\"onStop, event=%s%n\", event);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2472
msgid "Observe a `StartupEvent` to be notified the runtime has started."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2473
msgid "Observe a `ShutdownEvent` to be notified when the runtime is going to shutdown."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2477
msgid "What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a `ShutdownContext` to register a callback to perform shutdown tasks in the <<Starting a Service>> section. These shutdown tasks would be called after a `ShutdownEvent` had been sent."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2483
msgid "A `StartupEvent` is fired after all `io.quarkus.deployment.builditem.ServiceStartBuildItem` producers have been consumed.  The implication of this is that if an extension has services that application components would expect to have been started when they observe a `StartupEvent`, the build steps that invoke the runtime code to start those services needs to produce a `ServiceStartBuildItem` to ensure that the runtime code is run before the `StartupEvent` is sent. Recall that we saw the production of a `ServiceStartBuildItem` in the previous section, and it is repeated here for clarity:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2484
#, no-wrap
msgid "Example of Producing a ServiceStartBuildItem"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2495
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem,\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException {\n"
"...\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2497
msgid "Produce a `ServiceStartBuildItem` to indicate that this is a service starting step that needs to run before the `StartupEvent` is sent."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2498
#, no-wrap
msgid "Register Resources for Use in Native Image"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2500
msgid "Not all configuration or resources can be consumed at build time. If you have classpath resources that the runtime needs to access, you need to inform the build phase that these resources need to be copied into the native image. This is done by producing one or more `NativeImageResourceBuildItem` or `NativeImageResourceBundleBuildItem` in the case of resource bundles. Examples of this are shown in this sample `registerNativeImageResources` build step:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2501
#, no-wrap
msgid "Registering Resources and ResourceBundles"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2509
#, no-wrap
msgid ""
"public final class MyExtProcessor {\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBuildItem> resource;\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBundleBuildItem> resourceBundle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2513
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources() {\n"
"        resource.produce(new NativeImageResourceBuildItem(\"/security/runtime.keys\")); //<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2516
#, no-wrap
msgid ""
"        resource.produce(new NativeImageResourceBuildItem(\n"
"                \"META-INF/my-descriptor.xml\")); //<2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2520
#, no-wrap
msgid ""
"        resourceBundle.produce(new NativeImageResourceBuildItem(\"javax.xml.bind.Messages\")); //<3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2522
msgid "Indicate that the /security/runtime.keys classpath resource should be copied into native image."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2523
msgid "Indicate that the `META-INF/my-descriptor.xml` resource should be copied into native image"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2524
msgid "Indicate that the \"javax.xml.bind.Messages\" resource bundle should be copied into native image."
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2525
#, no-wrap
msgid "Service files"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2529
msgid "If you are using `META-INF/services` files you need to register the files as resources so that your native image can find them, but you also need to register each listed class for reflection so they can be instantiated or inspected at run-time:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2533
#: upstream/_guides/writing-extensions.adoc:2563
#: upstream/_guides/writing-extensions.adoc:2592
#, no-wrap
msgid "public final class MyExtProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2537
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> services) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2542
#, no-wrap
msgid ""
"        // find out all the implementation classes listed in the service files\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                          service);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2550
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be instantiated\n"
"        // in native-image at run-time\n"
"        services.produce(\n"
"            new ServiceProviderBuildItem(io.quarkus.SomeService.class.getName(),\n"
"                                         implementations.toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2556
msgid "`ServiceProviderBuildItem` takes a list of service implementation classes as parameters: if you are not reading them from the service file, make sure that they correspond to the service file contents because the service file will still be read and used at run-time. This is not a substitute for writing a service file."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2559
msgid "This only registers the implementation classes for instantiation via reflection (you will not be able to inspect its fields and methods). If you need to do that, you can do it this way:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2568
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources(BuildProducer<NativeImageResourceBuildItem> resource,\n"
"                                     BuildProducer<ReflectiveClassBuildItem> reflectionClasses) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2571
#, no-wrap
msgid ""
"        // register the service file so it is visible in native-image\n"
"        resource.produce(new NativeImageResourceBuildItem(service));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2581
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be inspected/instantiated\n"
"        // in native-image at run-time\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                          service);\n"
"        reflectionClasses.produce(\n"
"            new ReflectiveClassBuildItem(true, true, implementations.toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2585
msgid "While this is the easiest way to get your services running natively, it's less efficient than scanning the implementation classes at build time and generating code that registers them at static-init time instead of relying on reflection."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2588
msgid "You can achieve that by adapting the previous build step to use a static-init recorder instead of registering classes for reflection:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2598
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(ExecutionTime.STATIC_INIT)\n"
"    void registerNativeImageResources(RecorderContext recorderContext,\n"
"                                     SomeServiceRecorder recorder) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2607
#, no-wrap
msgid ""
"        // read the implementation classes\n"
"        Collection<Class<? extends io.quarkus.SomeService>> implementationClasses = new LinkedHashSet<>();\n"
"        Set<String> implementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                                                    service);\n"
"        for(String implementation : implementations) {\n"
"            implementationClasses.add((Class<? extends io.quarkus.SomeService>)\n"
"                recorderContext.classProxy(implementation));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2612
#, no-wrap
msgid ""
"        // produce a static-initializer with those classes\n"
"        recorder.configure(implementationClasses);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2615
#, no-wrap
msgid ""
"@Recorder\n"
"public class SomeServiceRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2620
#, no-wrap
msgid ""
"    public void configure(List<Class<? extends io.quarkus.SomeService>> implementations) {\n"
"        // configure our service statically\n"
"        SomeServiceProvider serviceProvider = SomeServiceProvider.instance();\n"
"        SomeServiceBuilder builder = serviceProvider.getSomeServiceBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2630
#, no-wrap
msgid ""
"        List<io.quarkus.SomeService> services = new ArrayList<>(implementations.size());\n"
"        // instantiate the service implementations\n"
"        for (Class<? extends io.quarkus.SomeService> implementationClass : implementations) {\n"
"            try {\n"
"                services.add(implementationClass.getConstructor().newInstance());\n"
"            } catch (Exception e) {\n"
"                throw new IllegalArgumentException(\"Unable to instantiate service \" + implementationClass, e);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2634
#, no-wrap
msgid ""
"        // build our service\n"
"        builder.withSomeServices(implementations.toArray(new io.quarkus.SomeService[0]));\n"
"        ServiceManager serviceManager = builder.build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2639
#, no-wrap
msgid ""
"        // register it\n"
"        serviceProvider.registerServiceManager(serviceManager, Thread.currentThread().getContextClassLoader());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2642
#, no-wrap
msgid "Object Substitution"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2644
msgid "Objects created during the build phase that are passed into the runtime need to have a default constructor in order for them to be created and configured at startup of the runtime from the build time state. If an object does not have a default constructor you will see an error similar to the following during generation of the augmented artifacts:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2645
#, no-wrap
msgid "DSAPublicKey Serialization Error"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2654
#, no-wrap
msgid ""
"\t[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build threw an exception: java.lang.RuntimeException: Unable to serialize objects of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has no default constructor\n"
"\tat io.quarkus.builder.Execution.run(Execution.java:123)\n"
"\tat io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder.java:136)\n"
"\tat io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)\n"
"\tat io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)\n"
"\t... 36 more\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2657
msgid "There is a `io.quarkus.runtime.ObjectSubstitution` interface that can be implemented to tell Quarkus how to handle such classes. An example implementation for the `DSAPublicKey` is shown here:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2658
#, no-wrap
msgid "DSAPublicKeyObjectSubstitution Example"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2662
#, no-wrap
msgid "package io.quarkus.extest.runtime.subst;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2669
#, no-wrap
msgid ""
"import java.security.KeyFactory;\n"
"import java.security.NoSuchAlgorithmException;\n"
"import java.security.interfaces.DSAPublicKey;\n"
"import java.security.spec.InvalidKeySpecException;\n"
"import java.security.spec.X509EncodedKeySpec;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2671
#, no-wrap
msgid "import io.quarkus.runtime.ObjectSubstitution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2682
#, no-wrap
msgid ""
"public class DSAPublicKeyObjectSubstitution implements ObjectSubstitution<DSAPublicKey, KeyProxy> {\n"
"    private static final Logger log = Logger.getLogger(\"DSAPublicKeyObjectSubstitution\");\n"
"    @Override\n"
"    public KeyProxy serialize(DSAPublicKey obj) { //<1>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.serialize\");\n"
"        byte[] encoded = obj.getEncoded();\n"
"        KeyProxy proxy = new KeyProxy();\n"
"        proxy.setContent(encoded);\n"
"        return proxy;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2692
#, no-wrap
msgid ""
"    @Override\n"
"    public DSAPublicKey deserialize(KeyProxy obj) { //<2>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.deserialize\");\n"
"        byte[] encoded = obj.getContent();\n"
"        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);\n"
"        DSAPublicKey dsaPublicKey = null;\n"
"        try {\n"
"            KeyFactory kf = KeyFactory.getInstance(\"DSA\");\n"
"            dsaPublicKey = (DSAPublicKey) kf.generatePublic(publicKeySpec);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2699
#, no-wrap
msgid ""
"        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return dsaPublicKey;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2701
msgid "The serialize method takes the object without a default constructor and creates a `KeyProxy` that contains the information necessary to recreate the `DSAPublicKey`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2702
msgid "The deserialize method uses the `KeyProxy` to recreate the `DSAPublicKey` from its encoded form using the key factory."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2704
msgid "An extension registers this substitution by producing an `ObjectSubstitutionBuildItem` as shown in this `TestProcessor#loadDSAPublicKey` fragment:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2705
#, no-wrap
msgid "Registering an Object Substitution"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2718
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,\n"
"            BuildProducer<ObjectSubstitutionBuildItem> substitutions) throws IOException, GeneralSecurityException {\n"
"...\n"
"        // Register how to serialize DSAPublicKey\n"
"        ObjectSubstitutionBuildItem.Holder<DSAPublicKey, KeyProxy> holder = new ObjectSubstitutionBuildItem.Holder(\n"
"                DSAPublicKey.class, KeyProxy.class, DSAPublicKeyObjectSubstitution.class);\n"
"        ObjectSubstitutionBuildItem keysub = new ObjectSubstitutionBuildItem(holder);\n"
"        substitutions.produce(keysub);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2722
#, no-wrap
msgid ""
"        log.info(\"loadDSAPublicKey run\");\n"
"        return new PublicKeyBuildItem(publicKey);\n"
"    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2724
#, no-wrap
msgid "Replacing Classes in the Native Image"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2726
msgid "The Graal SDK supports substitutions of classes in the native image. An example of how one could replace the `XmlConfig/XmlData` classes with versions that have no JAXB annotation dependencies is shown in these example classes:"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2727
#, no-wrap
msgid "Substitution of XmlConfig/XmlData Classes Example"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2735
#, no-wrap
msgid ""
"package io.quarkus.extest.runtime.graal;\n"
"import java.util.Date;\n"
"import com.oracle.svm.core.annotate.Substitute;\n"
"import com.oracle.svm.core.annotate.TargetClass;\n"
"import io.quarkus.extest.runtime.config.XmlData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2739
#, no-wrap
msgid ""
"@TargetClass(XmlConfig.class)\n"
"@Substitute\n"
"public final class Target_XmlConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2746
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String address;\n"
"    @Substitute\n"
"    private int port;\n"
"    @Substitute\n"
"    private ArrayList<XData> dataList;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2751
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getAddress() {\n"
"        return address;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2756
#, no-wrap
msgid ""
"    @Substitute\n"
"    public int getPort() {\n"
"        return port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2761
#, no-wrap
msgid ""
"    @Substitute\n"
"    public ArrayList<XData> getDataList() {\n"
"        return dataList;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2772
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlConfig{\" +\n"
"                \"address='\" + address + '\\'' +\n"
"                \", port=\" + port +\n"
"                \", dataList=\" + dataList +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2776
#, no-wrap
msgid ""
"@TargetClass(XmlData.class)\n"
"@Substitute\n"
"public final class Target_XmlData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2783
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String name;\n"
"    @Substitute\n"
"    private String model;\n"
"    @Substitute\n"
"    private Date date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2788
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2793
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2798
#, no-wrap
msgid ""
"    @Substitute\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2809
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlData{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", model='\" + model + '\\'' +\n"
"                \", date='\" + date + '\\'' +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:2811
#, no-wrap
msgid "Configuration reference documentation"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2815
msgid "The configuration is an important part of each extension and therefore needs to be properly documented.  Each configuration property should have a proper Javadoc comment."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2818
msgid "While it is handy to have the documentation available when coding, this configuration documentation must also be available in the extension guides.  The Quarkus build automatically generates the configuration documentation for you based on the Javadoc comments but you need to explicitly include it in your guide."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2820
msgid "In this section, we will explain everything you need to know about the configuration reference documentation."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2821
#, no-wrap
msgid "Writing the documentation"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2824
msgid "For each configuration property, you need to write some Javadoc explaining its purpose."
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2828
msgid "Always make the first sentence meaningful and self-contained as it is included in the summary table."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2831
msgid "You can either use standard Javadoc comments or Asciidoc directly as a Javadoc comment."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2835
msgid "We assume you are familiar with writing Javadoc comments so let's focus on our Asciidoc support.  While standard Javadoc comments are perfectly fine for simple documentation (recommended even), if you want to include tips, source code extracts, lists... Asciidoc comes in handy."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2837
msgid "Here is a typical configuration property commented with Asciidoc:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2854
#, no-wrap
msgid ""
"/**\n"
" * Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the\n"
" * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Not all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,\n"
" * MariaDB, Microsoft SQL Server and H2.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"@ConfigItem\n"
"public Optional<String> dialect;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2858
msgid "This is the simple case: you just have to write Asciidoc and mark the comment with the `@asciidoclet` tag.  This tag has two purposes: it is used as a marker for our generation tool but it is also used by the `javadoc` process for proper Javadoc generation."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2860
msgid "Now let's consider a more complicated example:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2898
#, no-wrap
msgid ""
"// @formatter:off\n"
"/**\n"
" * Name of the file containing the SQL statements to execute when Hibernate ORM starts.\n"
" * Its default value differs depending on the Quarkus launch mode:\n"
" *\n"
" * * In dev and test modes, it defaults to `import.sql`.\n"
" *   Simply add an `import.sql` file in the root of your resources directory\n"
" *   and it will be picked up without having to set this property.\n"
" *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.\n"
" * * In production mode, it defaults to `no-file`.\n"
" *   It means Hibernate ORM won't try to execute any SQL import file by default.\n"
" *   Pass an explicit value to force Hibernate ORM to execute the SQL import file.\n"
" *\n"
" * If you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus\n"
" * https://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].\n"
" *\n"
" * [source,property]\n"
" * .application.properties\n"
" * ----\n"
" * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql\n"
" * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql\n"
" * %prod.quarkus.hibernate-orm.sql-load-script = no-file\n"
" * ----\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Quarkus supports `.sql` file with SQL statements or comments spread over multiple lines.\n"
" * Each SQL statement must be terminated by a semicolon.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"// @formatter:on\n"
"@ConfigItem\n"
"public Optional<String> sqlLoadScript;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2901
msgid "A few comments on this one:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2907
msgid "Every time you will need the indentation to be respected in the Javadoc comment (think list items spread on multiple lines or indented source code), you will need to disable temporarily the automatic Eclipse formatter (this, even if you don't use Eclipse as the formatter is included in our build).  To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the fact that they are separate comments and there is a space after the `//` marker. This is required."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2908
msgid "As you can see, you can use the full power of Asciidoctor (except for the limitation below)"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2913
msgid "You cannot use open blocks (`--`) in your Asciidoctor documentation.  All the other types of blocks (source, admonitions...) are supported."
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2920
msgid "By default, the doc generator will use the hyphenated field name as the key of a `java.util.Map` configuration item.  To override this default and have a user friendly key (independent of implementation details), you may use the `io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the following example,"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2931
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Namespace configuration.\n"
"     */\n"
"    @ConfigItem(name = ConfigItem.PARENT)\n"
"    @ConfigDocMapKey(\"cache-name\") <1>\n"
"    Map<String, CaffeineNamespaceConfig> namespace;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2934
msgid "This will generate a configuration map key named `quarkus.some.\"cache-name\"` instead of `quarkus.some.\"namespace\"`."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2936
#, no-wrap
msgid "Writing section documentation"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2940
msgid "If you wish to generate configuration section of a given `@ConfigGroup`, Quarkus has got you covered with the `@ConfigDocSection` annotation.  See the code example below:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2949
#, no-wrap
msgid ""
"/**\n"
"* Config group related configuration.\n"
"* Amazing introduction here\n"
"*/\n"
"@ConfigItem\n"
"@ConfigDocSection <1>\n"
"public ConfigGroupConfig configGroup;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2954
msgid "This will add a section documentation for the `configGroup` config item in the generated documentation.  Section's title and introduction will be derived from the javadoc of the configuration item. The first sentence from the javadoc is considered as the section title and the remaining sentences used as section introduction.  You can also use the `@asciidoclet` tag as shown above."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2955
#, no-wrap
msgid "Generating the documentation"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2958
msgid "Generating the documentation is easy:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2960
msgid "Running `./mvnw clean install -DskipTests -DskipITs` will do."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2961
msgid "You can either do it globally or in a specific extension directory (e.g. `extensions/mailer`)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2963
msgid "The documentation is generated in the global `target/asciidoc/generated/config/` located at the root of the project."
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2964
#, no-wrap
msgid "Including the documentation in the extension guide"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2967
msgid "Now that you have generated the configuration reference documentation for your extension, you need to include it in your guide (and review it)."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2969
msgid "This is simple, include the generated documentation in your guide:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2973
#, no-wrap
msgid "\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2976
msgid "If you are interested in including the generated documentation for the config group, you can use the include statement below"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2979
#, no-wrap
msgid "\\include::{generated-dir}/config/hyphenated-config-group-class-name-with-runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts=optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2982
msgid "For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` configuration group will be generated in a file named `quarkus-vertx-http-config-group-form-auth-config.adoc`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2985
msgid "A few recommendations:"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2987
msgid "`opts=optional` is mandatory as we don't want the build to fail if only part of the configuration documentation has been generated"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2990
msgid "The documentation is generated with a title level of 2 (i.e. `==`).  You usually need to adjust it.  It can be done with `leveloffset=+N`."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2993
msgid "It is not recommended to include the whole configuration documentation in the middle of your guide as it's heavy.  If you have an `application.properties` extract with your configuration, just do as follows."
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2995
msgid "First, include a tip just below your `application.properties` extract:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3000
#, no-wrap
msgid ""
"[TIP]\n"
"For more information about the extension configuration please refer to the <<configuration-reference, Configuration Reference>>.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3003
msgid "Then, at the end of your documentation, include the extensive documentation:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3007
#, no-wrap
msgid "[[configuration-reference]]\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3007
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3010
msgid "\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3013
msgid "Finally, generate the documentation and check it out."
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3014
#, no-wrap
msgid "Continuous testing of your extension"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3019
msgid "In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview of what the process looks like."
msgstr ""
