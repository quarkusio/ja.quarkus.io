# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-29 14:09+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:1
#, no-wrap
msgid "---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:8
#, no-wrap
msgid ""
"layout: post\n"
"title: 'Combining Apache Kafka and the Rest client'\n"
"date: 2020-09-08\n"
"tags: reactive kafka rest mutiny http\n"
"synopsis: How to combine reactive messaging, Kafka and the Rest client\n"
"author: cescoffier\n"
"---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:13
msgid ""
"Another week, another interesting question.  This week, someone asks me "
"about combining Kafka and the Rest Client.  That is a recurring subject, and "
"most of the time, the goal is to achieve the following process:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:15
msgid "image:/assets/images/posts/kafka-rest-client/kafka-rest-architecture.png[]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:21
msgid ""
"In other words, we want to call a remote service for each Kafka message we "
"receive.  Therefore, we have a first topic (\"in\") containing the data we "
"are consuming, for instance, \"transactions\".  Then, we have the central "
"piece of the architecture: the processing component.  It consumes the "
"incoming transactions, and for each of them, calls a remote service.  It "
"also writes the response (produced by the remote service) to another Kafka "
"topic \"out\"."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:24
msgid ""
"Implementing this with Quarkus is straightforward, and that's what we will "
"cover in this post.  Thanks to Reactive Messaging and the Rest Client, this "
"should not take more than 20 lines of code!"
msgstr ""

#. type: Title ==
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:25
#, no-wrap
msgid "The Remote Service"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:29
msgid ""
"Let's start with the remote service.  Quarkus offers multiple ways to invoke "
"a remote HTTP service, but let's use the Rest Client as it provides an "
"excellent way to interact with HTTP services without having to handle the "
"low-level details of HTTP."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:31
msgid ""
"You can use any HTTP API, but to simplify, let's consider a straightforward "
"remote service, something like:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:38
#, no-wrap
msgid ""
"@RegisterRestClient(configKey = \"transaction-service\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public interface TransactionService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:42
#, no-wrap
msgid ""
"    @Path(\"/transactions\")\n"
"    @POST \n"
"    TransactionResult postSync(Transaction transaction);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:46
#, no-wrap
msgid ""
"    @Path(\"/transactions\")\n"
"    @POST \n"
"    Uni<TransactionResult> postAsync(Transaction transaction);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:48 upstream/_posts/2020-09-08-kafka-rest-client.adoc:92 upstream/_posts/2020-09-08-kafka-rest-client.adoc:116 upstream/_posts/2020-09-08-kafka-rest-client.adoc:147
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:56
msgid ""
"This service contains two methods calling the same HTTP endpoint.  The first "
"one is synchronous, and so blocks the caller thread until the response is "
"received.  The second is asynchronous, and the returned `Uni` gets the "
"response when received.  In this case, the caller thread is not blocked and "
"can do something else.  We are going to see how to use these methods later, "
"but first, a bit of configuration.  In the `application.properties` add:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:61
#, no-wrap
msgid ""
"# Configure the transaction-service (rest client)\n"
"transaction-service/mp-rest/url=http://localhost:8080\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:65
msgid ""
"Of course, update the URL.  The "
"https://quarkus.io/guides/rest-client[https://quarkus.io/guides/rest-client] "
"guide gives more details about the usage and configuration of the Rest "
"Client."
msgstr ""

#. type: Title ==
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:66
#, no-wrap
msgid "Invoking the service for each incoming transaction"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:73
msgid ""
"Ok, we can call our service, but remember, we want to invoke it for every "
"incoming transaction, and these transactions come from a Kafka topic.  With "
"Reactive Messaging, there is no need to handle Kafka right now.  We can "
"focus on the logic.  Let's say we have a *channel* (a stream of data), in "
"which to transit our transactions.  We call this first channel `in`."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:77
msgid ""
"We also want to write the responses from the remote service into another "
"Kafka topic.  Again, no need to handle Kafka right now.  Let's say we write "
"the responses into a channel named `out`."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:79
msgid "So, we have the following (incomplete) code:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:84 upstream/_posts/2020-09-08-kafka-rest-client.adoc:102 upstream/_posts/2020-09-08-kafka-rest-client.adoc:134
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class TransactionProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:90
#, no-wrap
msgid ""
"    @Incoming(\"in\") // The first channel - we read from it\n"
"    @Outgoing(\"out\") // The second channel - we write to it\n"
"    public TransactionResult sendToTransactionService(Transaction "
"transaction) {\n"
"       // Need to call our service here\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:97
msgid ""
"`@Incoming` configures the read channel.  `@Outgoing` configures the written "
"channel.  But, something is missing... we need to call our remote service:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:104 upstream/_posts/2020-09-08-kafka-rest-client.adoc:136
#, no-wrap
msgid ""
"    private static final Logger LOGGER = "
"Logger.getLogger(\"TransactionProcessor\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:106 upstream/_posts/2020-09-08-kafka-rest-client.adoc:138
#, no-wrap
msgid "    @Inject @RestClient TransactionService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:114
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out\")\n"
"    @Blocking\n"
"    public TransactionResult sendToTransactionService(Transaction "
"transaction) {\n"
"        LOGGER.infof(\"Sending %s transaction service\", transaction);\n"
"        return service.postSync(transaction);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:120
msgid "First, we inject the Rest Client.  Then, we just invoke it in our method."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:125
msgid ""
"You may wonder about `@Blocking`.  With reactive messaging, you need to "
"indicate when you are using blocking code, as by default, it uses an event "
"loop architecture.  While convenient, you should not abuse `@Blocking`, as "
"it relies on a thread pool limiting your concurrency.  But, it keeps your "
"logic synchronous."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:127
msgid "### Using Asynchronous operations"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:129
msgid ""
"We can get rid of `@Blocking` annotation by using the second method provided "
"by the `TransactionService`: `postAsync:`"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:145
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out\")\n"
"    public Uni<TransactionResult> sendToTransactionService(Transaction "
"transaction) {\n"
"        LOGGER.infof(\"Sending %s transaction service\", transaction);\n"
"        return service.postAsync(transaction);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:152
msgid ""
"Using the *async* variant of the `post` method allows us to remove "
"`@Blocking`.  We return the `Uni` directly.  When that `Uni` receives the "
"remote service's response, it writes the value to the `out` channel."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:154
msgid "### Mapping channel to Kafka"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:160
msgid ""
"So far, so good.  It's time to connect our code with Kafka.  With Reactive "
"Messaging, we map channels to _connectors_, here Kafka.  So, we just need to "
"configure the application to indicate that the `in` and `out` channels are "
"Kafka topics.  Once again, edit the `application.properties` file, and add:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:167
msgid ""
"``` mp.messaging.incoming.in.connector=smallrye-kafka "
"mp.messaging.incoming.in.topic=transactions "
"mp.messaging.incoming.in.value.deserializer=org.acme.model.TransactionDeserializer "
"mp.messaging.incoming.in.auto.offset.reset=earliest "
"mp.messaging.incoming.in.enable.auto.commit=false"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:172
msgid ""
"mp.messaging.outgoing.out.connector=smallrye-kafka "
"mp.messaging.outgoing.out.topic=output "
"mp.messaging.outgoing.out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer "
"```"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:177
msgid ""
"The first block is about the `in` channel.  It's connected to the "
"`transactions` Kafka topic.  The data is deserialized with a "
"https://github.com/cescoffier/quarkus-kafka-rest-client-demo/blob/master/src/main/java/org/acme/model/TransactionDeserializer.java[custom "
"deserializer].  The last other properties disable the auto-commit (Reactive "
"Messaging is handling commits for you) and read the data since the last "
"committed offset."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:181
msgid ""
"The second block configures the `out` channel.  We connect it with the "
"`output` Kafka topic and configure the value serializer.  For this simple "
"example, we write the data as JSON."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:183
msgid ""
"So, when a transaction is written to the Kafka `transaction` topic, it gets "
"received by our processing component, sent to the remote service, and the "
"result is written to the `output` Kafka topic:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:190
#, no-wrap
msgid ""
"2020-08-27 10:04:44,141 INFO  [TransactionProcessor] "
"(vert.x-eventloop-thread-0) Sending Transaction{name='MacroHard', amount=20} "
"transaction service\n"
"2020-08-27 10:04:44,196 INFO  [TransactionResource] (executor-thread-2) "
"Handling transaction MacroHard / 20\n"
"2020-08-27 10:04:44,240 INFO  [TransactionProcessor] "
"(vert.x-eventloop-thread-0) Sending Transaction{name='BlueHat', amount=10} "
"transaction service\n"
"2020-08-27 10:04:44,245 INFO  [TransactionResource] (executor-thread-2) "
"Handling transaction BlueHat / 10\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:193
msgid ""
"If you look inside the `output` topic, you will see the `TransactionResult` "
"flowing:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:195
msgid "image:/assets/images/posts/kafka-rest-client/output.png[]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:197
msgid "### We are done!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:199
msgid ""
"With a few lines of code and a bit of configuration, we can read data from a "
"Kafka topic, call a remote service, and write the result to another Kafka "
"topic. Plain simple."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:202
msgid ""
"Want to try by yourself? Check out the code in this "
"https://github.com/cescoffier/quarkus-kafka-rest-client-demo[GitHub "
"repository] and follow the instructions from the readme."
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:204
msgid ""
"Reactive Messaging and the Rest client contain other gems, check the related "
"guides and documentation to learn more about them:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:206
msgid "https://quarkus.io/guides/rest-client[Using the Rest Client]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:207
msgid "https://quarkus.io/guides/kafka[Interacting with Kafka]"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-08-kafka-rest-client.adoc:207
msgid ""
"https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.2/kafka/kafka.html[The "
"Kafka Connector documentation]"
msgstr ""
