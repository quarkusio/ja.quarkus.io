# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid   ""
msgstr  "Project-Id-Version: PACKAGE VERSION\n"
        "POT-Creation-Date: 2021-02-04 15:40+0000\n"
        "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
        "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
        "Language-Team: LANGUAGE <LL@li.org>\n"
        "Language: \n"
        "MIME-Version: 1.0\n"
        "Content-Type: text/plain; charset=UTF-8\n"
        "Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:1
#, no-wrap
msgid   "---\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:8
#, no-wrap
msgid   "layout: post\n"
        "title: 'How to handle failures with Mutiny'\n"
        "date: 2020-08-24\n"
        "tags: reactive mutiny\n"
        "synopsis: Failures are an inherent part of any software. This post explains how you handle them with Mutiny\n"
        "author: cescoffier\n"
        "---\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:11
msgid   "In the past week, I got several questions about failure handling with Mutiny. So, maybe it deserves a bit more explanation."
msgstr  ""

#. type: Title ==
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:12
#, no-wrap
msgid   "Failures are events"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:15
msgid   "First, Mutiny is an event-driven reactive programming library. With Mutiny, you handle events. An upstream `Uni` or `Multi` propagates these events and gives you the possibility to process them. These events can be *item*, *completion*, *cancellation*, and... *failure*:"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:24
#, no-wrap
msgid   "Multi.createFrom().range(0, 10)\n"
        "    .onItem().invoke(i -> System.out.println(\"Received item \" + i))\n"
        "    .onCompletion().invoke(() -> System.out.println(\"We are done!\"))\n"
        "    .onCancellation().invoke(() -> System.out.println(\n"
        "        \"The downstream does not want our items anymore!\")\n"
        "    )\n"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:28
#, no-wrap
msgid   "    .onFailure().invoke(t -> System.out.println(\n"
        "        \"Oh no! We received a failure: \" + t.getMessage())\n"
        "    )\n"
msgstr  ""

#. type: Title ==
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:30
#, no-wrap
msgid   "What can you do when you receive a failure?"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:33
msgid   "In addition to calling an action, as shown in the previous snippet, there are multiple things you can do when you receive a failure."
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:35
msgid   "The most common thing to do is to recover. You can recover by passing a specific item or with another `Uni`:"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:41
#, no-wrap
msgid   "upstream\n"
        "    .onFailure().recoverWithItem(failure -> \"hello (fallback)\")\n"
        "    .subscribe().with(i -> System.out.println(\"Received: \" + i));\n"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:45
#, no-wrap
msgid   "upstream\n"
        "    .onFailure().recoverWithUni(failure -> getAnotherUni(failure))\n"
        "    .subscribe().with(i -> System.out.println(\"Received: \" + i));\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:48
msgid   "On Multi, you can also recover by providing another `Multi` or completing the stream:"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:53
#, no-wrap
msgid   "upstream\n"
        "  .onFailure().recoverWithCompletion();\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:56
msgid   "If you have faith in your system, you can also *retry*. Note that you need to make sure you can retry the operation safely first!"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:63
#, no-wrap
msgid   "upstream\n"
        "      .onFailure().retry()\n"
        "        .withBackOff(Duration.ofSeconds(1), Duration.ofSeconds(10)).atMost(10)\n"
        "      .subscribe().with(i -> System.out.println(\"Received: \" + i));\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:66
msgid   "You can also transform the failure. For example, you can map a low-level failure into something more business-friendly. It propagates that second failure downstream, hiding the low-level failure:"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:71
#, no-wrap
msgid   "Uni.createFrom().failure(new IOException(\"boom\"))\n"
        "      .onFailure().transform(t -> new BusinessException(t))\n"
msgstr  ""

#. type: Title ==
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:73
#, no-wrap
msgid   "Failures are terminal"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:76
msgid   "Failures are terminal events. If your upstream propagates a failure, it means it can't operate normally. For Uni, that's not a problem, as you can only have an item or a failure. But for multi, it's a bit more complicated."
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:78
msgid   "Even if you recover, by handling the failure, you won't get the rest of the stream. Your upstream is ...Â *kaputt*."
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:80
msgid   "Let's take the following code:"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:94
#, no-wrap
msgid   "List<String> list = Multi.createFrom().range(0, 10)\n"
        "      .onItem().invoke(v -> {\n"
        "              if (v == 7) {\n"
        "                throw new IllegalArgumentException(\"We don't like seven!\");\n"
        "              }\n"
        "      })\n"
        "      .onFailure().recoverWithItem(7)\n"
        "      .map(integer -> integer.toString())\n"
        "      .onItem().invoke(s -> System.out.println(s))\n"
        "      .collectItems().asList()\n"
        "      .await().indefinitely();\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:97
msgid   "It produces [1, 2, 3, 4, 5, 6, 7] and not the rest of the stream. When the `onItem().invoke()` stage is called with `7`, it produces a failure. That stops the stream. It does not process more items from upstream."
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:99
msgid   "So what can we do? Isolate!"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:101
msgid   "When a *stage* sends a failure, it sends a failure terminating the stream and cancels its subscription to the upstream (informing that it does not need more items as it's not operating correctly). So, if we need to continue processing the other items from upstream; we just need to isolate that failure and be sure we do not cancel our subscription to the upstream."
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:103
msgid   "The most common approach to achieve this is the following:"
msgstr  ""

#. type: delimited block -
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:121
#, no-wrap
msgid   "List<String> list = Multi.createFrom().range(0, 10)\n"
        "    .onItem().transformToUniAndConcatenate(i ->\n"
        "            // Isolate the failure in this block\n"
        "            Uni.createFrom().item(i)\n"
        "                    .onItem().invoke(v -> {\n"
        "                        if (v == 7) {\n"
        "                            throw new IllegalArgumentException(\"We don't like seven!\");\n"
        "                        }\n"
        "                    })\n"
        "                    .onFailure().recoverWithItem(7)\n"
        "    )\n"
        "    .map(integer -> integer.toString())\n"
        "    .onItem().invoke(s -> System.out.println(s))\n"
        "    .collectItems().asList()\n"
        "    .await().indefinitely();\n"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:124
msgid   "Basically, we isolate the potentially failing operation. If it fails, we recover. But the cancellation only cancels that item, not the full stream, meaning we will receive the next one item and so on. This code produces the expected list."
msgstr  ""

#. type: Title ==
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:125
#, no-wrap
msgid   "Summary"
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:128
msgid   "Here you go, you can now handle failure and continue the streams gracefully."
msgstr  ""

#. type: Plain text
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:130
msgid   "If you want to know more about Mutiny, check the following video:"
msgstr  ""

#. type: delimited block +
#: upstream/_posts/2020-08-24-mutiny-failure-handling.adoc:133
#, no-wrap
msgid   "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/kWlrGtwvOxg\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n"
msgstr  ""
