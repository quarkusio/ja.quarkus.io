# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-26 18:44+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/topic/architecture.adoc:2
#, no-wrap
msgid "{project-name} - Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:5
msgid "image::images/architecture-phases.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:9
msgid ""
"{project-name} has an architecture that does as much processing as possible "
"at build time. Annotations and other descriptors are processed as early as "
"possible, and then {project-name} will generate bytecode based on this "
"information. This results in lower memory usage and faster startup speeds at "
"runtime."
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:10
#, no-wrap
msgid "Application Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:14
msgid ""
"This means that a {project-name} based application will go through a few "
"different distinct phases, each of which can potentially be executed in a "
"different JVM. These phases are:"
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:15
#, no-wrap
msgid "Augmentation"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:22
msgid ""
"This involves processing all the metadata that is present in the application "
"and its libraries, such as annotations, descriptors etc, and processing this "
"information to create bytecode that is executable at runtime. This generated "
"bytecode will directly start the runtime services that were represented by "
"the metadata. For example if your application contains a `@WebServlet` "
"annotation this phase will output the bytecode required to start Undertow "
"and register this Servlet.  The end result of this phase is a runnable "
"application that should be equivalent to manually wiring up the runtime "
"services you require, without any of the deployment time code present."
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:23
#, no-wrap
msgid "JVM Startup"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:29
msgid ""
"When running as a normal JVM application the bytecode generated in the "
"augmentation phase will be executed to start the runtime services needed by "
"the application. In production mode this will generally be in a different "
"JVM instance, which means that none of the classes needed by the "
"augmentation phase will be loaded at runtime, resulting in a smaller memory "
"footprint and faster startup time. In development mode this will be the same "
"JVM, allowing for the application to be quickly restarted when changes are "
"made."
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:30
#, no-wrap
msgid "Native Image Build"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:38
msgid ""
"When building a native image with SubstrateVM any code that is part of a "
"static initializer is run as part of the native image build process, and the "
"results are directly stored in memory. {project-name} takes advantage of "
"this by generating some of the startup code in static initializer blocks, so "
"they are run as part of the image build process rather than on image "
"startup. This has multiple advantages, as the image build is a standard JVM "
"it is still possible to use JVM features such as reflection and dynamic "
"proxy generation that do not work out of the box on Substrate. As most of "
"the startup is done in this phase the native image will start even faster, "
"as it effectively contains a serialized image of an already started "
"application."
msgstr ""

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:39
#, no-wrap
msgid "Native Image Start"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:42
msgid ""
"As most of the work has been done in the image build the actual native image "
"startup will generally only contain tasks that can't be done in advance, "
"such as opening sockets and connecting to databases."
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:43
#, no-wrap
msgid "Extension Architecture"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:50
msgid ""
"As a result of this architecture every extension will provide two artifacts, "
"one that handles build time processing (the `-deployment` artifacts), and "
"another `-runtime` artifact that contains the classes needed at "
"runtime. Only the runtime artifact will end up in the final application. The "
"end result of the deployment process is some generated bytecode that can "
"directly start any runtime services required by the application (but don't "
"worry, you don't have to know anything about bytecode to write a "
"{project-name} extension)."
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:56
msgid ""
"{project-name} uses a novel technique for writing bytecode that we are "
"calling _Bytecode Recording_. Basically at augment time extensions can "
"inject instances of classes that contain the runtime logic to start "
"services, and invoke these instances as if they were directly starting the "
"service. These injected instances are actually proxies, that override all "
"the public methods and record exactly which invocations have been made, what "
"the parameters are, and the order they were made in. They then generate "
"bytecode to perform this exact same sequence of invocations when the "
"application starts up."
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:60
msgid ""
"This means that from the point of view of an extension developer it looks "
"like they are making invocations that directly start the application, when "
"in fact they are recording bytecode that will be used to start the "
"application later."
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:62
msgid ""
"The `-deployment` artifacts work by defining `@BuildStep` methods, that "
"produce and consume `BuildItem` instances, and can also record bytecode if "
"required."
msgstr ""
