# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-11-27 00:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr "cescoffier"

#. type: YAML Front Matter: date
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "2022-11-22"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "How to implement a more reliable job queue with Redis, including fault tolerance, de-duplication, and poison pill."
msgstr ""

#. type: YAML Front Matter: tags
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "redis"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "Redis Job Queue - Reloaded"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:12
msgid "In https://quarkus.io/blog/redis-job-queue/[How to implement a job queue with Redis], we explained how to implement a job queue mechanism with Redis and the new Redis API from Quarkus.  The approach explored in that blog post had a significant flaw: if the execution of a job failed, the request was lost and will never be re-attempted."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:14
msgid "In this post, we explain how to improve the reliability of the job queue to handle failures, enable retry and use a _dead-letter queue_ to avoid poison pills."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:16
msgid "## Recap & Problem"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:18
msgid "In the https://quarkus.io/blog/redis-job-queue/[previous blog post], we implemented the following system."
msgstr ""

#. type: Target for macro image
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:19
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/application.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:24
msgid "An application receives _fight requests_ and writes these requests into a Redis list.  Several simulators processed this list.  The outcomes of the _fights_ were communicated using Redis Pub/Sub."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:27
msgid "The architecture works and ensures that a fight can only be executed once, thanks to the `brpop` command used by the simulator code.  This command pops the item from the queue in an atomic manner and ensure that the other simulators can't process it too."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:31
msgid "However, this architecture has a drawback.  If the processing of the popped fight request fails, the request is lost.  No other simulator would be able to process it, and if the simulator that failed restarts, it will not reprocess the same request."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:33
msgid "## Introducing more queues"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:37
msgid "An approach to handle that problem is to introduce more queues.  In addition to the main queue (the Redis list from the image above), we introduce one queue per simulator.  Thus, each simulator has its private queue."
msgstr ""

#. type: Target for macro image
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:38
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/reloaded.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:41
msgid "These private queues form a safety net."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:43
msgid "So, the simulator does use not only the _main queue_ but also its private queue:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:48
#, no-wrap
msgid ""
"this.queues = ds.list(FightRequest.class);\n"
"this.queueName = \"queue-\" + name; // the name of the private queue\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:54
msgid "When a simulator pops a request from the main queue, it does not process it immediately; it writes it to its private queue.  To achieve this, we cannot use `brpop` and then write to the other queue, as if something wrong happens in between, we would have the same problem.  Instead, we use `blmove,` which pops an element from a list and pushes it into another in an atomic fashion.  Thus, we ensure that multiple simulators cannot consume the same request and that the request cannot be lost."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:56
msgid "So, we use the following code to move the request from the main queue to the private queue:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:65
#, no-wrap
msgid ""
"// pop the item at the right side of the 'fight-requests' queue\n"
"// and writes it to the left side of 'queueName'.\n"
"// it returns the moved item or `null` in the entry queue, 'fight-requests',\n"
"// does not have any item, even after the 1-second delay\n"
"var moved = queues.blmove(\"fight-requests\", queueName,  \n"
"        Position.RIGHT, Position.LEFT, Duration.ofSeconds(1));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:68
msgid "Now, the simulator does not simulate the requests from the main queue but needs to process the ones added to its private queue."
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:79
#, no-wrap
msgid ""
"public void processRequestFromPrivateQueue() {  \n"
"    var request = queues.lindex(queueName, -1);  \n"
"    while (request != null) {  \n"
"        runSimulation(request);  \n"
"        queues.lrem(queueName, 1, request);    \n"
"        request = queues.lindex(\"queue-\" + name, -1);  \n"
"    }  \n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:85
msgid "This code is slightly different from the code from the previous blog.  This time, we do not pop.  We get the last item from the queue (index `-1` is the last one), process it, and then remove it from the queue.  We do this until the queue is empty."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:87
msgid "Let's put everything together:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:88
msgid "when the simulator starts, it should process the items from its private queue. So, if it crashes, it will retry to process the item."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:89
msgid "once the private queue is empty, it gets new requests from the main queue. It will not process them directly but re-trigger the processing of the private queue until the queue is empty."
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:108
#, no-wrap
msgid ""
"@Override  \n"
"public void run() {  \n"
"  // First, check if we are recovering, and drain the requests from the \n"
"  // simulator's queue  \n"
"  processRequestFromPrivateQueue();  \n"
"  while (! stopped) {  \n"
"    // Simulator's queue drained - poll the main queue  \n"
"    var moved = queues.blmove(\"fight-requests\", queueName,  \n"
"        Position.RIGHT, Position.LEFT, Duration.ofSeconds(1)\n"
"    );  \n"
"    if (moved != null) {  \n"
"      // If an element has been moved, process it  \n"
"      processRequestFromPrivateQueue();  \n"
"    }  \n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:111
msgid "## New architecture, new problems"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:115
msgid "That approach fixes the initial problem.  If the processing fails, we retry it (as the request is not removed from the private queue).  That will handle transient failures pretty well."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:117
msgid "However, it also has its own set of drawbacks:"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:119
msgid "_Duplicates_: if the processing succeeds, but the `lrem` fails for any reason (like a network failure), the request will be processed another time as it was not removed from the queue."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:120
msgid "_Poison pill_: if a request cannot be processed successfully, it will retry to process it forever."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:122
msgid "### De-duplication"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:125
msgid "Handling _duplicates_ require having a way to identify the requests uniquely and deduplicate manually.  In other words, if all our requests have a unique id, we can check if that id has already been processed (for example, by storing the processed ids in another list or a hash). If the item has already been processed, ignore it (remove it from the queue) and process it to the next one:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:138
#, no-wrap
msgid ""
"public void processRequestFromPrivateQueue() {  \n"
"    var request = queues.lindex(queueName, -1);  \n"
"    while (request != null) {  \n"
"        if (! isDuplicate(request)) {\n"
"            runSimulation(request);  \n"
"        }\n"
"        queues.lrem(queueName, 1, request);    \n"
" .      request = queues.lindex(\"queue-\" + name, -1);  \n"
"    }  \n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:141
msgid "### Avoiding swallowing the poison pill"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:146
msgid "Handling _poison pills_ is more complex.  A _poison pill_ is a request that will always make the processing fails.  It can be because of a bug in the processing code or something unexpected; it will always fail.  Retrying, in this case, will not help; we are not facing a transient issue."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:150
msgid "So, what can we do? We need to track the number of processing attempts for that request, and if it exceeds a specific number, let's face it: we won't be able to handle the request.  We generally want to send the request to a dead-letter queue (DLQ), i.e., a specific queue storing the unprocessable items:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:167
#, no-wrap
msgid ""
"public void processRequestFromPrivateQueue() {  \n"
"    var request = queues.lindex(queueName, -1);  \n"
"    while (request != null) {  \n"
"        if (counter.incr(counterName) > MAX_ATTEMPT) {  \n"
"            // Give up - it's a poison pill\n"
"            queues.lpush(DLQ, request); // Add to DLQ\n"
"        } else {  \n"
"            runSimulation(request);  \n"
"        }  \n"
"        request = queues.lindex(\"queue-\" + name, -1);  \n"
"        queues.lrem(queueName, 1, request);  \n"
"        counter.set(counterName, 0); // Reset  \n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:170
msgid "The counter is a specific Redis integer value that we increment and reset once we succeed or give up."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:174
msgid "The items from the DLQ are not lost; they are saved for future processing.  These items could be re-added to the main queue (to verify if it was not a transient issue or the bug was fixed).  Another approach requires that a human administrator looks at these requests before re-injecting them into the system; maybe it was just a formatting issue..."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:176
msgid "## Summary"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:181
msgid "This post explores how to improve the job queue we implemented in https://quarkus.io/blog/redis-job-queue/[How to implement a job queue with Redis].  This initial implementation, while simple, would lose requests if the processing fails.  This post proposes another, more complex, architecture to handle that case but also handle duplicates and poison pills.  But, nothing comes for free, and the resulting code is slightly more complex."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:184
msgid "Remember: Redis is a fantastic toolbox.  But, it's a toolbox; you build what you need with it, as it is rarely available out of the box.  That being said, the richness of the Redis commands lets you do many things... (spoiler: we will see some of these things in future posts)."
msgstr ""
