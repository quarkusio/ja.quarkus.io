# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-02-09 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:1
#, no-wrap
msgid "julgus"
msgstr ""

#. type: YAML Front Matter: date
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:1
#, no-wrap
msgid "2023-02-10"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:1
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:11
#, no-wrap
msgid "Writing Hibernate queries using the Criteria API can be anything but intuitive and comes at the expense of wordiness. In this article, you will learn how the JPAStreamer Quarkus extension facilitates type-safe Hibernate queries without unnecessary complexity."
msgstr ""

#. type: YAML Front Matter: tags
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:1
#, no-wrap
msgid "extension, announcement, hibernate, jpa"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:1
#, no-wrap
msgid "Express Hibernate Queries as Type-Safe Java Streams"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:13
msgid "As much as the JPA Criteria builder is expressive, JPA queries are often equally verbose, and the API itself can be unintuitive to use, especially for newcomers. In the Quarkus ecosystem, Panache is a partial remedy for these problems when using Hibernate ORM. Still, I find myself juggling the Panache’s helper methods, preconfigured Enums and raw Strings when composing anything but the simplest of queries. You could claim I am just inexperienced and impatient or instead acknowledge that the perfect API is frictionless to use for everyone. Thus, the user experience of writing JPA queries can be further improved in that direction."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:15
msgid "One of the remaining shortcomings is that raw Strings are inherently not type-safe, meaning my IDE rejects me the helping hand of code completion and wish me good luck at best. On the upside, Quarkus facilitates application relaunches in a split second to issue quick verdicts on my code. And nothing beats the heart-felt joy and genuine surprise when I have composed a working query on the fifth, rather than the tenth, attempt..."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:17
msgid "With this in mind, we built the open source library JPAStreamer to make the process of writing Hibernate queries more intuitive and less time-consuming, while leaving your existing codebase intact. It achieves this goal by allowing queries to be expressed as standard Java Streams. Upon execution, JPAStreamer translates the Stream pipeline to a HQL query for efficient execution and thereby avoids materialising anything but the relevant results."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:19
msgid "Let me take an example - in some random database exists a table called person represented in a Hibernate application by the following standard `@Entity`:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:25
#, no-wrap
msgid ""
"@Entity\n"
"@Table(name = \"person\")\n"
"public class Person {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:30
#, no-wrap
msgid ""
"    @Id\n"
"    @GeneratedValue(strategy = GenerationType.IDENTITY)\n"
"    @Column(name = \"person_id\", nullable = false, updatable = false)\n"
"    private Integer actorId;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:33
#, no-wrap
msgid ""
"    @Column(name = \"first_name\", nullable = false, columnDefinition = \"varchar(45)\")\n"
"    private String firstName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:36
#, no-wrap
msgid ""
"    @Column(name = \"last_name\", nullable = false, columnDefinition = \"varchar(45)\")\n"
"    private String lastName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:39
#, no-wrap
msgid ""
"    @Column(name = \"created_at\", nullable = false, updatable = false)\n"
"    private LocalDateTime createdAt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:42
#, no-wrap
msgid ""
"    // Getters for all fields will follow from here\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:45
msgid "To fetch the `Person` with an `Id` of 1 using JPAStreamer and Hibernate ORM, all you need is the following:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:50
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PersonRepository {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:53
#, no-wrap
msgid ""
"   @PersistenceContext\n"
"   EntityManagerFactory entityManagerFactory;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:55
#, no-wrap
msgid "   private final JPAStreamer jpaStreamer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:59
#, no-wrap
msgid ""
"   public PersonRepository (EntityManagerFactory entityManagerFactory) {\n"
"       jpaStreamer = JPAStreamer.of(entityManagerFactory); <1>\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:66
#, no-wrap
msgid ""
"   @Override\n"
"   public Optional<Person> getPersonById(int id) {\n"
"      return this.jpaStreamer.from(Person.class) <2>\n"
"           .filter(Person$.personId.equal(id)) <3>\n"
"           .findAny();\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:68
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:70
msgid "Initialize JPAStreamer in one line, the underlying JPA provider handles the DB configuration."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:71
msgid "The Stream source is set to be the Person table."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:72
msgid "The filter operation is treated as a SQL WHERE clause and the condition is expressed type-safely with JPAStreamer predicates (more on this to follow)."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:74
msgid "Despite it looking as if JPAStreamer operates on all `Person` objects, the pipeline is optimized to a single query, in this case:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:86
#, no-wrap
msgid ""
"select\n"
"    person0_.person_id as person_id1_0_,\n"
"    person0_.first_name as first_na2_0_,\n"
"    person0_.last_name as last_nam3_0_,\n"
"    person0_.created_at as created_4_0_,\n"
"from\n"
"    person person0_\n"
"where\n"
"    person0_.person_id=1\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:88
msgid "Thus, only the `Person` matching the search criteria is ever materialized."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:90
msgid "Next, we can look at a more complex example in which I am searching for persons with a first name ending with an “A” and a last name that starts with “B”. The matches are sorted primarily by the first name and secondly by last name. I further decide to apply an offset of 5, excluding the first five results, and to limit the total results to 10. Here is the Stream pipeline to achieve this task:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:99
#, no-wrap
msgid ""
"List<Person> list = jpaStreamer.stream(Person.class)\n"
"    .filter(Person$.firstName.endsWith(\"A\").and(Person$.lastName.startsWith(\"B\"))) <1>\n"
"    .sorted(Person$.firstName.comparator().thenComparing(Person$.lastName.comparator())) <2>\n"
"    .skip(5) <3>\n"
"    .limit(10) <4>\n"
"    .collect(Collectors.toList())\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:101
msgid "Filters can be combined with the and/or operators"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:102
msgid "Easily filter on one or more properties"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:103
msgid "Skip the first 5 Persons"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:104
msgid "Return at most 10 Persons"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:106
msgid "In the context of queries, the Stream operators filter, sort, limit, and skip all have a natural mapping that makes the resulting query expressive and intuitive to read while remaining compact."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:108
msgid "The Stream above is translated by JPAStreamer to the following HQL statement:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:125
#, no-wrap
msgid ""
"select\n"
"   person0_.person_id as person_id1_0_,\n"
"   person0_.first_name as first_na2_0_,\n"
"   person0_.last_name as last_nam3_0_,\n"
"   person0_.created_at as created_4_0_,\n"
"from\n"
"   person person0_\n"
"where\n"
"   person0_.person_id=1\n"
"where\n"
"    (person0_.first_name like ?) \n"
"    and (person0_.last_name like ?)\n"
"order by\n"
"    person0_.first_name asc,\n"
"    person0_.last_name asc limit ?, ?\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:127
#, no-wrap
msgid "How JPAStreamer works"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:129
msgid "Okay, it looks simple. But how does it work? JPAstreamer uses an annotation processor to form a meta-model at compile time. It inspects any classes marked with the standard JPA annotation `@Entity`, and for every entity `Foo.class`, a corresponding `Foo$.class` is created. The generated classes represent entity attributes as Fields used to form predicates on the form `User$.firstName.startsWith(\"A\")` that can be interpreted by JPAStreamer's query optimizer."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:131
msgid "It is worth repeating that JPAStreamer does not alter or disturb the existing codebase but merely extends the API to handle Java Stream queries."
msgstr ""

#. type: Title ==
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:132
#, no-wrap
msgid "Installing the JPAstreamer Extension"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:134
msgid "JPAStreamer is installed as any other Quarkus extension, using a Maven dependency:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:142
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkiverse.jpastreamer</groupId>\n"
"    <artifactId>quarkus-jpastreamer</artifactId>\n"
"    <version>1.0.0</version>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:145
msgid "After the dependency is added, rebuild your Quarkus application to trigger JPAStreamer’s annotation processor. The installation is complete once the generated fields reside in `/target/generated-sources`; you’ll recognise them by the trailing $ in the classnames, e.g. `Person$.class`."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:147
msgid "JPAStreamer requires an underlying JPA provider, such as Hibernate ORM. For this reason, JPAStreamer needs no additional configuration as the database integration is taken care of by the JPA provider."
msgstr ""

#. type: Title ==
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:148
#, no-wrap
msgid "JPAStreamer and Panache"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:150
msgid "Any Panache fan will note that JPAStreamer shares some of its objectives with Panache, in simplifying many common queries. Still, JPAStreamer distinguishes itself by instilling more confidence in the queries with its type-safe Stream interface. Luckily however, no one if forced to take a pick as Panache and JPAStreamer work seamlessly alongside each other."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:152
msgid "link:https//github.com/speedment/jpa-streamer-demo/tree/master/quarkus-hibernate-panache[Here] is an example Quarkus application that uses both JPAStreamer and Panache."
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:154
msgid "At the time of writing, JPAStreamer does not have support for Panache’s Active Record Pattern, as it relies on standard JPA Entities to generate its meta model. This will likely change in the near future."
msgstr ""

#. type: Title ==
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:155
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:157
msgid "JPA in general, and Hibernate ORM in particular, has greatly simplified application database access, but its API sometimes forces unnecessary complexity. With JPAstreamer, you can utilize JPA while keeping your codebase clean and maintainable."
msgstr ""

#. type: Title ===
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:158
#, no-wrap
msgid "Resources "
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:161
#, no-wrap
msgid "**GitHub:** link:https://github.com/quarkiverse/quarkus-jpastreamer[github.com/quarkiverse/quarkus-jpastreamer]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:162
#, no-wrap
msgid "**Homepage:** link:https://jpastreamer.org[jpastreamer.org]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:163
#, no-wrap
msgid "**JPAStreamer Quarkus Demo:** link:https//github.com/speedment/jpa-streamer-demo/tree/master/quarkus-hibernate-panache[github.com/speedment/jpa-streamer-demo/tree/master/quarkus-hibernate-panache]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:164
#, no-wrap
msgid "**Documentation:** link:https://speedment.github.io/jpa-streamer[speedment.github.io/jpa-streamer]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-02-10-jpastreamer-extension.adoc:164
#, no-wrap
msgid "**Gitter Support Chat:** link:https://gitter.im/jpa-streamer[gitter.im/jpa-streamer]\n"
msgstr ""
