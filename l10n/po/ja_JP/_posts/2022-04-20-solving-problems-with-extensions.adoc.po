# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-04-19 13:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, no-wrap
msgid "---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:8
#, no-wrap
msgid ""
"layout: post\n"
"title: 'Solving problems with Quarkus extensions (1/n)'\n"
"date: 2022-04-20\n"
"tags: extensions development-tips\n"
"synopsis: 'The unique build infrastructure of Quarkus allows you to solve complex issues in a very simple way by developing custom extensions.'\n"
"author: gsmet\n"
"---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:11
msgid "This is the first post of what I hope will be a series of several articles showing how you can solve complex problems by leveraging the unique Quarkus build infrastructure and extension framework."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:14
msgid "First things first, bootstraping a Quarkus extension is easy: in one command, you can get it scaffolded and get started on the actual implementation.  But that's not the subject of this post!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:17
msgid "An extension, apart from providing some runtime code to your application, also allows to tweak the build of your application and do all sorts of things at the build level.  This is what we will focus on in this series."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:19
#, no-wrap
msgid "**Problem of the day:** to ensure binary compatibility, the Hub4j GitHub API introduces some bridge methods that confuse Mockito and more specifically ByteBuddy and ultimately make our tests unreliable. How can we solve that?\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:20
#, no-wrap
msgid "Some context"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:25
msgid "You might have heard about https://github.com/quarkiverse/quarkus-github-app[my Quarkus GitHub App extension] that allows you to develop GitHub Apps based on Quarkus at light speed with very little boilerplate (shameless ad: it is awesome!)."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:30
msgid "My dear colleague https://github.com/yrodiere[Yoann Rodi√®re] (he is awesome too!) wrote some test infrastructure for it based on https://site.mockito.org[Mockito] (which uses https://bytebuddy.net/[ByteBuddy] under the hood).  That was all good until we started noticing confusing and non reproducible failures in our tests with Mockito sometimes not actually calling the method we would expect."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:32
msgid "The source of the problem is that, to ensure binary compatibility, the https://github.com/hub4j/github-api[Hub4j GitHub API] we use in Quarkus GitHub App introduces bridge methods in the bytecode."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:34
msgid "For instance, let's take this method of the `GitHub` class of the GitHub API:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:42
#, no-wrap
msgid ""
"    @WithBridgeMethods(value = GHUser.class)\n"
"    public GHMyself getMyself() throws IOException {\n"
"        client.requireCredential();\n"
"        return setMyself();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:46
msgid "Historically, it used to return a `GHUser` but, in newer versions, it returns a `GHMyself`, which broke the binary compatibility."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:51
msgid "To restore it and with the help of the `@WithBridgeMethods` annotation, the GitHub API build will create two methods in the bytecode: one returning `GHMyself` and one returning `GHUser`.  This is very useful if you have compiled your application with an old version of the GitHub API and you just want to use the new version without recompiling your application.  Typically, in the case of Jenkins, you can switch to a new version of the GitHub API without having to recompile all the Jenkins plugins using GitHub API."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:53
msgid "At the bytecode level, you end up with something equivalent to the following:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:60
#, no-wrap
msgid ""
"    public GHMyself getMyself() throws IOException {\n"
"        client.requireCredential();\n"
"        return setMyself();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:64
#, no-wrap
msgid ""
"    public GHUser getMyself() throws IOException {\n"
"        return getMyself(); <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:66
msgid "`invokevirtual` of `getMyself()` that returns `GHMyself`"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:68
msgid "And if your existing compiled code calls `GHUser getMyself()`, it will still work after the change of return type."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:72
msgid "This bridge methods approach solves a real problem and it's not that big of a deal as it's fully transparent for the developer...  except when you start using Mockito due to https://github.com/raphw/byte-buddy/issues/1162[a ByteBuddy issue]: ByteBuddy can get confused if there are several methods with the same signature but different return types."
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:77
msgid "ByteBuddy is an amazing library and this blog post should not be seen as a critique of ByteBuddy.  This is an extreme corner case that doesn't happen with standard bytecode."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:80
msgid "This issue was causing our tests to be unreliable because sometimes ByteBuddy was choosing the wrong method to apply Mockito magic."
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:81
#, no-wrap
msgid "How can we work around this?"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:86
msgid "In the case of Quarkus GitHub App, we don't really care about binary compatibility: when upgrading to a new version of the GitHub API, users will rebuild their application."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:89
msgid "So given these bridge methods are problematic, one solution would be to get rid of them."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:91
msgid "Obviously, we could fork the GitHub API and avoid generating the bridge methods."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:94
msgid "But forking and maintaining a fork forever is definitely not something we should consider if we can avoid it.  Especially since we want to continue benefiting from all the future improvements of the GitHub API."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:96
msgid "So could we somehow keep the library standard but have Quarkus adjust the bytecode when building the application?"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:99
msgid "If you are in a rush, the short answer is yes.  Now let's go for the (not so) long answer."
msgstr ""

#. type: Title ===
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:100
#, no-wrap
msgid "Let's identify the methods"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:105
msgid "In Quarkus, we can index the annotations with Jandex so, in a perfect world, we would index the GitHub API jar with Jandex (which we already do for other purposes)  and interrogate Jandex to get all the methods annotated with `@WithBridgeMethods`:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:110
#, no-wrap
msgid ""
"Collection<AnnotationInstance> withBridgeMethodsAnnotations =\n"
"    index.getAnnotations(DotName.createSimple(WithBridgeMethods.class.getName));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:113
msgid "Unfortunately, `@WithBridgeMethods` has a `CLASS` retention policy"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:115
msgid "which makes perfect sense for its usage - and Jandex only considers annotations with a `RUNTIME` retention policy."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:118
msgid "This limitation will be alleviated in Jandex 3 but, for the time being, we cannot use Jandex."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:121
msgid "Unfortunately, until then, we don't have many options here: we have to list the methods manually."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:123
msgid "For more flexibility, we introduced a `BuildItem`:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:127
#, no-wrap
msgid "public final class GitHubApiClassWithBridgeMethodsBuildItem extends MultiBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:130
#, no-wrap
msgid ""
"    private final String className;\n"
"    private final Set<String> methodNames;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:135
#, no-wrap
msgid ""
"    GitHubApiClassWithBridgeMethodsBuildItem(String className, String... methodsWithBridges) {\n"
"        this.className = className;\n"
"        this.methodNames = new HashSet<>(Arrays.asList(methodsWithBridges));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:139
#, no-wrap
msgid ""
"    public String getClassName() {\n"
"        return className;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:144
#, no-wrap
msgid ""
"    public Set<String> getMethodsWithBridges() {\n"
"        return methodNames;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:147
msgid "And we will produce a `GitHubApiClassWithBridgeMethodsBuildItem` for each class:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:151
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:156
#, no-wrap
msgid "// ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:154
#, no-wrap
msgid ""
"classesWithBridgeMethods.produce(new GitHubApiClassWithBridgeMethodsBuildItem(\n"
"        \"org.kohsuke.github.GHPullRequestCommitDetail$Commit\", \"getAuthor\", \"getCommitter\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:160
msgid "Once this is done, we are able to consume the `GitHubApiClassWithBridgeMethodsBuildItem` from any Quarkus `@BuildStep` so this list is generally available to the Quarkus build."
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:164
msgid "I won't go into detail on the Quarkus build process but the principle of it is extremely simple:"
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:166
msgid "It is composed of build steps (methods annotated with `@BuildStep`)."
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:167
msgid "A build step can consume build items."
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:168
msgid "A build step produces build items."
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:169
msgid "Then it is just a matter of resolving the dependencies of the build steps to get to the final result: your application."
msgstr ""

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:171
msgid "You can learn more about it in the link:/guides/writing-extensions#build-step-processors[Writing extensions guide]."
msgstr ""

#. type: Title ===
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:173
#, no-wrap
msgid "Removing the methods"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:176
msgid "Now that we have the list of methods handy, the next step is to remove them."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:179
msgid "To manipulate bytecode during the build, Quarkus offers the `BytecodeTransformerBuildItem`.  Adjusting the bytecode of a class is just a matter of producing one for the given class."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:182
msgid "For instance, to remove the bridge methods from our GitHub API methods, we add the following build step to our extension:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:189
#, no-wrap
msgid ""
"@BuildStep\n"
"void removeCompatibilityBridgeMethodsFromGitHubApi(\n"
"        BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers, <1>\n"
"        List<GitHubApiClassWithBridgeMethodsBuildItem> gitHubApiClassesWithBridgeMethods) { <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:199
#, no-wrap
msgid ""
"    for (GitHubApiClassWithBridgeMethodsBuildItem gitHubApiClassWithBridgeMethods : gitHubApiClassesWithBridgeMethods) {\n"
"        bytecodeTransformers.produce(new BytecodeTransformerBuildItem.Builder()\n"
"                .setClassToTransform(gitHubApiClassWithBridgeMethods.getClassName())\n"
"                .setVisitorFunction((ignored, visitor) -> new RemoveBridgeMethodsClassVisitor(visitor,\n"
"                        gitHubApiClassWithBridgeMethods.getClassName(),\n"
"                        gitHubApiClassWithBridgeMethods.getMethodsWithBridges()))\n"
"                .build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:201
msgid "We are going to produce ``BytecodeTransformerBuildItem``s."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:202
msgid "We consume the previously produced ``GitHubApiClassWithBridgeMethodsBuildItem``s."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:204
msgid "`RemoveBridgeMethodsClassVisitor` is a classic https://asm.ow2.io[ASM] `ClassVisitor` that will modify the bytecode:"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:208
#, no-wrap
msgid "class RemoveBridgeMethodsClassVisitor extends ClassVisitor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:211
#, no-wrap
msgid ""
"    private final String className;\n"
"    private final Set<String> methodsWithBridges;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:214
#, no-wrap
msgid ""
"    public RemoveBridgeMethodsClassVisitor(ClassVisitor visitor, String className, Set<String> methodsWithBridges) {\n"
"        super(Gizmo.ASM_API_VERSION, visitor);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:218
#, no-wrap
msgid ""
"        this.className = className;\n"
"        this.methodsWithBridges = methodsWithBridges;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:223
#, no-wrap
msgid ""
"    @Override\n"
"    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n"
"        if (methodsWithBridges.contains(name) && ((access & Opcodes.ACC_BRIDGE) != 0)\n"
"                && ((access & Opcodes.ACC_SYNTHETIC) != 0)) { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:226
#, no-wrap
msgid ""
"            return null; <2>\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:230
#, no-wrap
msgid ""
"        return super.visitMethod(access, name, descriptor, signature, exceptions); <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:232
msgid "If the method name matches and the method is a bridge and synthetic method..."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:233
msgid "... we remove it from the bytecode by returning `null`."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:234
msgid "If not, we just delegate to the superclass method that will incorporate the method in the bytecode."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:236
msgid "And that's it!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:240
msgid "During the build process, Quarkus will create a class file containing the modified bytecode and will use it instead of the class coming from the GitHub API jar.  Thus the bridge methods we wanted to remove will never be visible to ByteBuddy."
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:241
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:245
msgid "At conferences, we often say that Quarkus is doing things differently from other frameworks and that the magic relies in its innovative build process."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:247
msgid "This build process is the key to the low memory footprint and fast startup times of Quarkus."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:249
#, no-wrap
msgid "**But it is also a very powerful tool to customize the build of your applications.**\n"
msgstr ""
