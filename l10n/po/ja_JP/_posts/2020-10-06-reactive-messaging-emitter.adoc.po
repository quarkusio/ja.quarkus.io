# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-04-29 21:23+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr ""

#. type: YAML Front Matter: date
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:1
#, no-wrap
msgid "2020-10-06"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:1
#, no-wrap
msgid "post"
msgstr ""

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:1
#, no-wrap
msgid "Emitting messages with Reactive Messaging Emitters"
msgstr ""

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:1
#, no-wrap
msgid "reactive mutiny messaging kafka"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:1
#, no-wrap
msgid "Emitter - Bridging the imperative and the reactive worlds"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:11
#, fuzzy
msgid "In a https://quarkus.io/blog/kafka-avro/[previous blog post] about Kafka and Avro, we used an _emitter_ to send Kafka messages."
msgstr "link:https://quarkus.io/blog/kafka-avro/[以前の]KafkaとAvroに関する link:https://quarkus.io/blog/kafka-avro/[ブログ記事]では、Kafkaメッセージを送信するために _エミッター_を使用しました。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:13
#, fuzzy
msgid "image:/assets/images/posts/reactive-messaging-emitter/architecture.png[width=70%]"
msgstr "image:/assets/images/posts/reactive-messaging-emitter/architecture.png[alt=architecture]"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:15
#, fuzzy
msgid "In this post, we are going look at this emitter construct a little bit more closely."
msgstr "今回の記事では、このエミッター構造をもう少し詳しく見てみましょう。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:17
#, fuzzy
msgid "## Injecting an Emitter"
msgstr "エミッターへの注入"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:20
#, fuzzy
msgid "Injecting an emitter is straightforward.  You indicate the targeted channel, i.e., where do you send your messages:"
msgstr "エミッタを注入する方法は簡単です。対象となるチャンネル、つまり、どこにメッセージを送るかを指定します。"

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:24
#, no-wrap
msgid "@Inject @Channel(\"movies\") Emitter<Movie> emitter;\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:28
#, fuzzy
msgid "Remember that reactive messaging uses _channels_ as a primary abstraction.  They can be in-memory channels or mapped to a remote broker."
msgstr "リアクティブ・メッセージングでは、主に _チャンネル_を抽象化して使用することを覚えておいてください。チャネルは、インメモリ・チャネルでも、リモート・ブローカーにマッピングされたものでも構いません。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:33
#, fuzzy
msgid "In the previous code snippet, we inject an `Emitter<Movie>`.  It means you will send messages containing movies as payload.  So, the specified type is the payload type.  That lets you send: payloads directly (wrapped automatically in a message) or more detailed messages containing a movie as payload:"
msgstr "先ほどのコードでは、 `Emitter<Movie>` を注入しています。これは、ムービーを含むメッセージをペイロードとして送信することを意味します。つまり、指定されたタイプはペイロードタイプとなります。これにより、次のものを送ることができます：ペイロードを直接（メッセージの中に自動的にラップする）、またはペイロードとしてムービーを含むより詳細なメッセージ。"

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:37
#, no-wrap
msgid "Movie movie = ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:40
#, no-wrap
msgid ""
"// Send payloads directly\n"
"emitter.send(movie);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:43
#, no-wrap
msgid ""
"// Send messages\n"
"emitter.send(Message.of(movie));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:46
#, fuzzy
msgid "## Sending payloads"
msgstr "ペイロードの送信"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:50
#, fuzzy
msgid "Sending payload is the simplest way to send data.  You just pass the payload to the `send` method like an instance of `Movie`.  Under the hood, it just creates a simple `Message` wrapping the payload."
msgstr "ペイロードの送信は、データを送信する最も簡単な方法です。 `Movie` のインスタンスのように、ペイロードを `send` メソッドに渡すだけです。フードの下では、ペイロードをラップしたシンプルな `Message` が作成されるだけです。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:52
#, fuzzy
msgid "When used with payload, the `send` method returns a `CompletionStage` indicating if the message processing succeeded or failed:"
msgstr "ペイロードと一緒に使用すると、 `send` メソッドは、メッセージ処理が成功したか失敗したかを示す `CompletionStage` を返します。"

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:63
#, no-wrap
msgid ""
"emitter.send(movie)\n"
"    .whenComplete((success, failure) -> {\n"
"        if (failure != null) {\n"
"            System.out.println(\"D'oh! \" + failure.getMessage());\n"
"        } else {\n"
"            System.out.println(\"Message processed successfully\");\n"
"        }\n"
"    });\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:71
#, fuzzy
msgid "Processing, and will see later event the emission, happens asynchronously.  So, the returned `CompletionStage` lets you know when the message is processed.  The `CompletionStage` is completed successfully when the message is acknowledged.  Most of the time, it means that the processing has been completed smoothly, or the message has been sent to a broker successfully.  If something wrong happens, the `CompletionStage` is completed exceptionally.  The passed exception gives you an idea of the reason."
msgstr "処理は非同期的に行われますが、これは後述するイベント「エミッション」で確認できます。そのため、返された `CompletionStage` は、メッセージがいつ処理されたかを知ることができます。メッセージが確認されると `CompletionStage` は正常に終了します。ほとんどの場合、それは処理がスムーズに完了したこと、またはメッセージが正常にブローカーに送信されたことを意味します。何か問題が起こった場合、 `CompletionStage` は例外的に完了します。渡された例外を見れば、その理由がわかります。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:73
#, fuzzy
msgid "## Sending messages"
msgstr "メッセージの送信"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:79
#, fuzzy
msgid "While sending payloads is more straightforward, sometimes you want to attach metadata to the message, like configuring how it should be written in Kafka, tracing information, etc.  The emitter also allows sending messages, and so attach the metadata you want.  In the following example, we configure the outbound Kafka record.  We set the key, the topic, and so on.  That way, you can dispatch messages to different topics and even decide dynamically:"
msgstr "ペイロードの送信はより簡単ですが、Kafkaにどのように書き込むかの設定や、トレース情報など、メッセージにメタデータを添付したい場合があります。エミッターではメッセージの送信も可能なので、必要なメタデータを添付することができます。以下の例では、アウトバウンドのKafkaレコードを設定しています。キーやトピックなどを設定します。このようにして、異なるトピックにメッセージをディスパッチしたり、動的に決めることもできます。"

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:87
#, no-wrap
msgid ""
"OutgoingKafkaRecordMetadata<?> metadata = OutgoingKafkaRecordMetadata.builder()\n"
"        .withTopic(\"movies\")\n"
"        .withKey(movie.getYear())\n"
"        .build();\n"
"emitter.send(Message.of(movie).addMetadata(metadata));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:90
#, fuzzy
msgid "## Emissions are asynchronous"
msgstr "エミッションは非同期"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:97
#, fuzzy
msgid "Emitters form a bridge between the imperative and the reactive worlds.  When you emit a message, this message is not processed immediately.  The downstream component consuming the message are part of a _Reactive Streams_.  Passing the message immediately would violate the Reactive Streams protocol.  We must be sure that the downstream components are ready to accept this message.  As a result, the emitter is not pushing the message directly, but enqueue it in a buffer used to handle the downstream capacity (requests in Reactive Streams lingo)."
msgstr "エミッターは、命令型の世界と反応型の世界の橋渡しをします。メッセージをエミットしても、このメッセージはすぐには処理されません。メッセージを消費する下流のコンポーネントは、 _Reactive Streams_の一部です。メッセージをすぐに渡してしまうと、Reactive Streamsのプロトコルに違反してしまいます。下流のコンポーネントがこのメッセージを受け入れる準備ができていることを確認する必要があります。そのため、エミッターはメッセージを直接プッシュするのではなく、下流の容量（Reactive Streamsの用語ではリクエスト）を処理するために使用されるバッファにエンキューしています。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:99
#, fuzzy
msgid "image:/assets/images/posts/reactive-messaging-emitter/buffer.png[width=90%]"
msgstr "image:/assets/images/posts/reactive-messaging-emitter/buffer.png[alt=buffer]"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:101
#, fuzzy
msgid "The downstream component receives the messages according to the requests it makes, ensuring its capacity is never exceeded."
msgstr "下流のコンポーネントは、要求に応じてメッセージを受信し、その容量を超えることはありません。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:103
#, fuzzy
msgid "## Overflow management"
msgstr "オーバーフロー管理"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:111
#, fuzzy
msgid "But with buffer comes... overflow.  If you emit too many messages and the downstream cannot keep up, the messages are stored in the buffer until it reaches its maximum capacity.  Then, you cannot emit anymore, and attempting to emit will throw exceptions.  But what can we do in this case? When injecting the emitter, you can configure an Overflow strategy.  For example, you can set the buffer size, use an unbounded buffer, drop the messages, fail, or just ignore the back pressure and let the downstream handle it.  By default, it uses a buffer, but depending on your use case, you may want to configure it differently:"
msgstr "しかし、バッファには...オーバーフローがつきものです。メッセージを発信しすぎてダウンストリームが追いつかなくなると、メッセージはバッファが最大容量に達するまで保存されます。そうなると、それ以上は発信できなくなり、発信しようとすると例外が発生します。しかし、このような場合、どうすればよいのでしょうか？エミッタを注入する際に、Overflow戦略を設定することができます。例えば、バッファサイズを設定したり、束縛されていないバッファを使用したり、メッセージをドロップしたり、失敗したり、あるいはバックプレッシャーを無視してダウンストリームに処理させたりすることができます。デフォルトではバッファを使用しますが、ユースケースによっては別の設定をしたい場合もあります。"

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:118
#, no-wrap
msgid ""
"@Inject \n"
"@Channel(\"movies\") \n"
"@OnOverflow(value = OnOverflow.Strategy.BUFFER, bufferSize = 1000) \n"
"Emitter<Movie> emitter1;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:123
#, no-wrap
msgid ""
"@Inject \n"
"@Channel(\"movies\") \n"
"@OnOverflow(value = OnOverflow.Strategy.NONE) \n"
"Emitter<Movie> emitter2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:128
#, no-wrap
msgid ""
"@Inject \n"
"@Channel(\"movies\") \n"
"@OnOverflow(value = OnOverflow.Strategy.UNBOUNDED_BUFFER) \n"
"Emitter<Movie> emitter3;\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:131
msgid "## Conclusion"
msgstr "## まとめ"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:134
#, fuzzy
msgid "This post is a brief introduction to the `Emitter` construct from Reactive Messaging.  More information is available on the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.2/emitter/emitter.html[SmallRye Reactive Messaging documentation]."
msgstr "この投稿は、Reactive Messagingの `Emitter` 構成について簡単に紹介しています。詳しい情報は link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.2/emitter/emitter.html[SmallRye Reactive Messaging]のドキュメントに掲載されています。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:138
#, fuzzy
msgid "In the next Quarkus version (1.9), this feature will be improved with two very nice enhancements.  First, it will offer a Mutiny variant, easing the integration with Mutiny APIs.  Then, it would be possible for the Kafka case to directly emit key/value pairs without needing to use metadata."
msgstr "次のQuarkusバージョン（1.9）では、この機能が2つの素晴らしい機能強化によって改善されます。まず、Mutinyのバリアントを提供し、Mutiny APIとの統合を容易にします。そして、Kafkaのケースでは、メタデータを使用しなくても、キーと値のペアを直接エミットすることが可能になります。"

#. type: Plain text
#: upstream/_posts/2020-10-06-reactive-messaging-emitter.adoc:139
#, fuzzy
msgid "Stay tuned! Will will cover these in a follow-up post!"
msgstr "期待していてください。次の記事でご紹介します。"

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"

#, fuzzy
#~ msgid ""
#~ "layout: post\n"
#~ "title: 'Emitter - Bridging the imperative and the reactive worlds'\n"
#~ "date: 2020-10-06\n"
#~ "tags: reactive mutiny messaging kafka\n"
#~ "synopsis: Emitting messages with Reactive Messaging Emitters\n"
#~ "author: cescoffier\n"
#~ "---\n"
#~ msgstr ""
#~ "layout: post\n"
#~ "title: エミッター - 命令型の世界と反応型の世界の架け橋」。\n"
#~ "date: 2020-10-06\n"
#~ "tags: reactive mutiny messaging kafka\n"
#~ "synopsis: リアクティブ・メッセージング・エミッターによるメッセージの発信\n"
#~ "author: cescoffier\n"
#~ "---\n"
