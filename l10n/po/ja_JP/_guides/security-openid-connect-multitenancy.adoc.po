msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit\n"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Using OpenID Connect (OIDC) multitenancy"
msgstr "OpenID Connect (OIDC)のマルチテナンシーの使用"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"This guide demonstrates how your OpenID Connect (OIDC) application can support multitenancy to serve multiple tenants from a single application.\n"
"These tenants can be distinct realms or security domains within the same OIDC provider or even distinct OIDC providers."
msgstr "このガイドでは、OpenID Connect（OIDC）アプリケーションがマルチテナントをサポートし、1つのアプリケーションから複数のテナントにサービスを提供する方法を示します。これらのテナントは、同じOIDCプロバイダー内の異なるレルムまたはセキュリティドメインであることも、異なるOIDCプロバイダーであることもできます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Each customer functions as a distinct tenant when serving multiple customers from the same application, such as in a SaaS environment.\n"
"By enabling multitenancy support to your applications, you can support distinct authentication policies for each tenant, even authenticating against different OIDC providers, such as Keycloak and Google."
msgstr "SaaS環境のように、同じアプリケーションから複数の顧客にサービスを提供する場合、各顧客は個別のテナントとして機能します。アプリケーションでマルチテナントのサポートを有効にすることで、テナントごとに異なる認証ポリシーをサポートすることができます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "To authorize a tenant by using Bearer Token Authorization, see the xref:security-oidc-bearer-token-authentication.adoc[OpenID Connect (OIDC) Bearer token authentication] guide."
msgstr "ベアラートークン認証を使用してテナントを認可するには、 xref:security-oidc-bearer-token-authentication.adoc[OpenID Connect（OIDC）ベアラートークン認証] ガイドを参照してください。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "To authenticate and authorize a tenant by using the OIDC authorization code flow, read the xref:security-oidc-code-flow-authentication.adoc[OpenID Connect authorization code flow mechanism for protecting web applications] guide."
msgstr "OIDC認可コードフローを使用してテナントを認証および認可するには、 xref:security-oidc-code-flow-authentication.adoc[Webアプリケーションを保護するためのOpenID Connect認可コードフローメカニズムガイド] をお読みください。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Also, see the xref:security-oidc-configuration-properties-reference.adoc[OpenID Connect (OIDC) configuration properties] reference guide."
msgstr "また、 xref:security-oidc-configuration-properties-reference.adoc[OpenID Connect (OIDC)設定プロパティリファレンスガイドも] 参照してください。"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "https://stedolan.github.io/jq/[jq tool]"
msgstr "https://stedolan.github.io/jq/[jq tool]"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "In this example, we build a very simple application that supports two resource methods:"
msgstr "この例では、2つのリソースメソッドをサポートする非常に単純なアプリケーションを構築します："

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "`/{tenant}`"
msgstr "`/{tenant}`"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "This resource returns information obtained from the ID token issued by the OIDC provider about the authenticated user and the current tenant."
msgstr "このリソースは、OIDCプロバイダが発行したIDトークンから取得した、認証されたユーザーと現在のテナントに関する情報を返します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "`/{tenant}/bearer`"
msgstr "`/{tenant}/bearer`"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "This resource returns information obtained from the Access Token issued by the OIDC provider about the authenticated user and the current tenant."
msgstr "このリソースは、OIDCプロバイダが発行したAccess Tokenから取得した、認証されたユーザーと現在のテナントに関する情報を返します。"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "For a thorough understanding, we recommend you build the application by following the upcoming step-by-step instructions."
msgstr "よく理解するために、次のステップバイステップの指示に従ってアプリケーションを構築することをお勧めします。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Alternatively, if you prefer to start with the completed example, clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "完成した例から始めたい場合は、Gitリポジトリをクローンしてください： `git clone {quickstarts-clone-url}` または {quickstarts-archive-url}[archive] をダウンロードしてください。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The solution is located in the `security-openid-connect-multi-tenancy-quickstart` link:{quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart[directory]."
msgstr "ソリューションは `security-openid-connect-multi-tenancy-quickstart` link:{quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart[ディレクトリに] あります。"

#: _guides/security-openid-connect-multitenancy.adoc
msgid "Creating the Maven project"
msgstr "Mavenプロジェクトの作成"

#: _guides/security-openid-connect-multitenancy.adoc
msgid ""
"First, we need a new project.\n"
"Create a new project with the following command:"
msgstr "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "If you already have your Quarkus project configured, add the `oidc` extension to your project by running the following command in your project base directory:"
msgstr "Quarkusプロジェクトがすでに設定されている場合は、プロジェクトのベースディレクトリで次のコマンドを実行して、 `oidc` エクステンションをプロジェクトに追加します："

#: _guides/security-openid-connect-multitenancy.adoc
msgid "This adds the following to your build file:"
msgstr "これにより、 `pom.xml` ファイルに以下が追加されます:"

#. type: Block title
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "Writing the application"
msgstr "アプリケーションの記述"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Start by implementing the `/{tenant}` endpoint.\n"
"As you can see from the source code below, it is just a regular Jakarta REST resource:"
msgstr "まず、 `/{tenant}` エンドポイントを実装します。以下のソースコードからわかるように、これは通常の Jakarta REST リソースです："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "To resolve the tenant from incoming requests and map it to a specific `quarkus-oidc` tenant configuration in `application.properties`, create an implementation for the `io.quarkus.oidc.TenantConfigResolver` interface, which can dynamically resolve tenant configurations:"
msgstr "受信リクエストからテナントを解決し、 `application.properties` の特定の `quarkus-oidc` テナント設定にマッピングするには、テナント設定を動的に解決できる `io.quarkus.oidc.TenantConfigResolver` インターフェイスの実装を作成します："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"In the preceding implementation, tenants are resolved from the request path.\n"
"If no tenant can be inferred, `null` is returned to indicate that the default tenant configuration should be used."
msgstr "前述の実装では、テナントはリクエストパスから解決されます。テナントが推測できない場合は、 `null` が返され、デフォルトのテナント設定を使用する必要があることを示します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"The `tenant-a` application type is `hybrid`; it can accept HTTP bearer tokens if provided.\n"
"Otherwise, it initiates an authorization code flow when authentication is required."
msgstr "`tenant-a` アプリケーション・タイプは `hybrid` です。そうでない場合は、認証が必要なときに認可コードフローを開始します。"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "Configuring the application"
msgstr "アプリケーションの設定"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"The first configuration is the default tenant configuration that should be used when the tenant cannot be inferred from the request.\n"
"Be aware that a `%prod` profile prefix is used with `quarkus.oidc.auth-server-url` to support testing a multitenant application with Dev Services For Keycloak.\n"
"This configuration uses a Keycloak instance to authenticate users."
msgstr "最初の構成は、リクエストからテナントを推測できない場合に使用するデフォルトのテナント構成です。Dev Services For Keycloakを使用したマルチテナント・アプリケーションのテストをサポートするために、 `quarkus.oidc.auth-server-url` で `%prod` プロファイル接頭辞が使用されることに注意してください。この構成では、Keycloakインスタンスを使用してユーザーを認証します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The second configuration, provided by `TenantConfigResolver`, is used when an incoming request is mapped to the `tenant-a` tenant."
msgstr "`TenantConfigResolver` が提供する2つ目の設定は、送られてくるリクエストが `tenant-a` テナントに設定マッピングされるときに使用されます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Both configurations map to the same Keycloak server instance while using distinct `realms`."
msgstr "どちらの設定マッピングも、同じKeycloakサーバーインスタンスにマッピングされ、 `realms` 。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Alternatively, you can configure the tenant `tenant-a` directly in `application.properties`:"
msgstr "または、 `application.properties` で直接テナント `tenant-a` を設定することもできます："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "In that case, also use a custom `TenantConfigResolver` to resolve it:"
msgstr "その場合は、カスタム `TenantConfigResolver` ："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"You can define multiple tenants in your configuration file.\n"
"To map them correctly when resolving a tenant from your `TenantResolver` implementation, ensure each has a unique alias."
msgstr "構成ファイルで複数のテナントを定義できます。 `TenantResolver` の実装からテナントを解決するときに正しくマッピングするために、それぞれに一意のエイリアスがあることを確認してください。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "However, using a static tenant resolution, which involves configuring tenants in `application.properties` and resolving them with `TenantResolver`, does not work for testing endpoints with Dev Services for Keycloak because it does not know how the requests are be mapped to individual tenants, and cannot dynamically provide tenant-specific `quarkus.oidc.<tenant-id>.auth-server-url` values. Therefore, using `%prod` prefixes with tenant-specific URLs within `application.properties` does not work in both test and development modes."
msgstr "しかし、 `application.properties` でテナントを設定し、 `TenantResolver` で解決する静的なテナント解決を使用することは、Dev Services for Keycloakを使用したエンドポイントのテストでは機能しません。これは、リクエストが個々のテナントにどのようにマッピングされるかがわからず、テナント固有の `quarkus.oidc.<tenant-id>.auth-server-url` 値を動的に提供できないためです。したがって、 `application.properties` 内のテナント固有の URL で `%prod` プレフィックスを使用しても、テストモードと開発モードの両方で機能しません。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"When a current tenant represents an OIDC `web-app` application, the current `io.vertx.ext.web.RoutingContext` contains a `tenant-id` attribute by the time the custom tenant resolver has been called for all the requests completing the code authentication flow and the already authenticated requests, when either a tenant-specific state or session cookie already exists.\n"
"Therefore, when working with multiple OIDC providers, you only need a path-specific check to resolve a tenant id if the `RoutingContext` does not have the `tenant-id` attribute set, for example:"
msgstr "現在のテナントがOIDC `web-app` アプリケーションを表している場合、現在の `io.vertx.ext.web.RoutingContext` には、コード認証フローを完了したすべてのリクエストと、すでに認証されたリクエストに対してカスタムテナントリゾルバが呼び出されるまでに `tenant-id` 属性が設定されています。そのため、複数のOIDCプロバイダを使用する場合、 `RoutingContext` に `tenant-id` 属性が設定されていない場合など、テナントIDを解決するために必要なのはパス固有のチェックだけです："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "This is how Quarkus OIDC resolves static custom tenants if no custom `TenantResolver` is registered."
msgstr "カスタム `TenantResolver` が登録されていない場合、Quarkus OIDCが静的カスタムテナントを解決する方法です。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "A similar technique can be used with `TenantConfigResolver`, where a `tenant-id` provided in the context can return `OidcTenantConfig` already prepared with the previous request."
msgstr "同じようなテクニックは、 `TenantConfigResolver` で使うことができま す。 `tenant-id` コンテキストで提供された `OidcTenantConfig` は、前のリクエストですでに用意されていたものを返すことができます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"If you also use xref:hibernate-orm.adoc#multitenancy[Hibernate ORM multitenancy] or xref:mongodb-panache.adoc#multitenancy[MongoDB with Panache multitenancy] and both tenant ids are the same\n"
"and must be extracted from the Vert.x `RoutingContext`, you can pass the tenant id from the OIDC Tenant Resolver to the Hibernate ORM Tenant Resolver or MongoDB with Panache Mongo Database Resolver\n"
"as a `RoutingContext` attribute, for example:"
msgstr "xref:hibernate-orm.adoc#multitenancy[Hibernate ORM multitenancy] または xref:mongodb-panache.adoc#multitenancy[MongoDB with Panache multitenancy] も使用していて、両方のテナント ID が同じで、Vert.x `RoutingContext` から抽出する必要がある場合は、OIDC テナントリゾルバから Hibernate ORM テナントリゾルバまたは MongoDB with Panache Mongo Database リゾルバにテナント ID を `RoutingContext` 属性として渡すことができます："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Starting and configuring the Keycloak server"
msgstr "Keycloakサーバーの起動と設定"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "To start a Keycloak server, you can use Docker and run the following command:"
msgstr "Keycloakサーバーを起動するには、Dockerを使って以下のコマンドを実行します："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "where `keycloak.version` is set to `23.0.0` or higher."
msgstr "ここで、 `keycloak.version` は `23.0.0` 以上に設定されています。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Access your Keycloak server at http://localhost:8180[localhost:8180]."
msgstr "link:http://localhost:8180[localhost:8180の] Keycloakサーバーにアクセスします。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Log in as the `admin` user to access the Keycloak administration console.\n"
"The username and password are both `admin`."
msgstr "`admin` 、Keycloak管理コンソールにアクセスするユーザーとしてログインします。ユーザー名とパスワードはどちらも `admin` 。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Now, import the realms for the two tenants:"
msgstr "次に、2つのテナントのレルムをインポートします："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Import the link:{quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart/config/default-tenant-realm.json[default-tenant-realm.json] to create the default realm."
msgstr "link:{quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart/config/default-tenant-realm.json[default-tenant-realm.json] をインポートして、デフォルトのrealmを作成します。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Import the link:{quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart/config/tenant-a-realm.json[tenant-a-realm.json] to create the realm for the tenant `tenant-a`."
msgstr "link:{quickstarts-tree-url}/security-openid-connect-multi-tenancy-quickstart/config/tenant-a-realm.json[tenant-a-realm.json] をインポートして、テナントのレルムを作成します `tenant-a` 。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "For more information, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm]."
msgstr "詳細については、 link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[新しいレルムを作成] する方法についてKeycloakのドキュメントを参照してください。"

#: _guides/security-openid-connect-multitenancy.adoc
msgid "Running and using the application"
msgstr "アプリケーションの実行と使用"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Running in developer mode"
msgstr "開発者モードで実行"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "To run the microservice in dev mode, use:"
msgstr "マイクロサービスをdevモードで実行する場合、次を実行して下さい:"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Running in JVM mode"
msgstr "JVMモードでの実行"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "After exploring the application in dev mode, you can run it as a standard Java application."
msgstr "開発モードでアプリケーションを探索した後、標準のJavaアプリケーションとして実行することができます。"

#: _guides/security-openid-connect-multitenancy.adoc
msgid "First, compile it:"
msgstr "まず、コンパイルします:"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "Then run it:"
msgstr "次に、以下を実行してください。"

#: _guides/security-openid-connect-multitenancy.adoc
msgid "Running in native mode"
msgstr "ネイティブモードでの実行"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "This same demo can be compiled into native code; no modifications are required."
msgstr "この同じデモをネイティブコードにコンパイルすることができます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"This implies that you no longer need to install a JVM on your\n"
"production environment, as the runtime technology is included in\n"
"the produced binary, and optimized to run with minimal resources."
msgstr "これは、ランタイム・テクノロジーが生成されたバイナリに含まれており、最小限のリソースで実行できるように最適化されているため、本番環境にJVMをインストールする必要がなくなったことを意味します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Compilation takes a bit longer, so this step is turned off by default;\n"
"let's build again by enabling the native build:"
msgstr "コンパイルには少し時間がかかるので、このステップはデフォルトではオフになっています。ネイティブビルドを有効にして、もう一度ビルドしてみましょう："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "After a little while, you can run this binary directly:"
msgstr "しばらくすると、このバイナリを直接実行できるようになります："

#: _guides/security-openid-connect-multitenancy.adoc
msgid "Test the application"
msgstr "アプリケーションのテスト"

#. type: Title ===
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "Use Dev Services for Keycloak"
msgstr "Dev Services for Keycloakの使用"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] is recommended for the integration testing against Keycloak.\n"
"Dev Services for Keycloak launches and initializes a test container: it imports configured realms and sets a base Keycloak URL for the `CustomTenantResolver` to calculate a realm-specific URL."
msgstr "xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloakは] Keycloakとの統合テストにお勧めします。Dev Services for Keycloakはテストコンテナを起動し、初期化します。設定されたrealmをインポートし、realm固有のURLを計算するために `CustomTenantResolver` 、ベースとなるKeycloak URLを設定します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "First, add the following dependencies:"
msgstr "まず、以下の依存関係を追加します："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"`quarkus-test-keycloak-server` provides a utility class `io.quarkus.test.keycloak.client.KeycloakTestClient` for acquiring the realm specific access tokens and which you can use with `RestAssured` for testing the `/{tenant}/bearer` endpoint expecting bearer access tokens.\n"
"`HtmlUnit` tests the `/{tenant}` endpoint and the authorization code flow."
msgstr "`quarkus-test-keycloak-server` `io.quarkus.test.keycloak.client.KeycloakTestClient` は、レルム固有のアクセストークンを取得するためのユーティリティクラスで、 エンドポイントがベアラアクセストークンを期待していることをテストするために、 とともに使用できます。 は、 エンドポイントと認可コードフローをテストします。 `/{tenant}/bearer` `RestAssured` `HtmlUnit` `/{tenant}`"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "Next, configure the required realms:"
msgstr "次に、必要なレルムを設定します:"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Finally, write your test, which runs in JVM mode:"
msgstr "最後に、JVMモードで実行するテストを書いてください："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "In native mode:"
msgstr "ネイティブ・モードの場合："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "For more information about how it is initialized and configured, see xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak]."
msgstr "初期化および設定方法の詳細については、 xref:security-openid-connect-dev-services.adoc[KeycloakのDev Services] を参照してください。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Use the browser"
msgstr "ブラウザを使用"

#: _guides/security-openid-connect-multitenancy.adoc
msgid "To test the application, open your browser and access the following URL:"
msgstr "アプリケーションの動作確認は、ブラウザを起動して以下のURLにアクセスしてください:"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "http://localhost:8080/default[http://localhost:8080/default]"
msgstr "http://localhost:8080/default[http://localhost:8080/default]"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"If everything works as expected, you are redirected to the Keycloak server to authenticate.\n"
"Be aware that the requested path defines a `default` tenant, which we don't have mapped in the configuration file.\n"
"In this case, the default configuration is used."
msgstr "期待通りに動作すると、Keycloakサーバーにリダイレクトされ、認証が行われます。要求されたパスは `default` テナントを定義していることに注意してください。設定ファイルにはマッピングされていません。この場合、デフォルトの設定が使用されます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "To authenticate to the application, enter the following credentials in the Keycloak login page:"
msgstr "アプリケーションを認証するには、Keycloakのログインページに以下のクレデンシャルを入力します："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Username: `alice`"
msgstr "ユーザー名 `alice`"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Password: `alice`"
msgstr "パスワード `alice`"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "After clicking the *Login* button, you are redirected back to the application."
msgstr "*ログイン* ボタンをクリックすると、アプリケーションに戻ります。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "If you try now to access the application at the following URL:"
msgstr "次の URL でアプリケーションにアクセスを試みます。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "http://localhost:8080/tenant-a[http://localhost:8080/tenant-a]"
msgstr "http://localhost:8080/tenant-a[http://localhost:8080/tenant-a]"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"You are redirected again to the Keycloak login page.\n"
"However, this time, you are going to authenticate by using a different realm."
msgstr "再びKeycloakのログインページにリダイレクトされます。しかし、今回は別のレルムを使用して認証します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"In both cases, the landing page shows the user's name and email if the user is successfully authenticated.\n"
"Although `alice` exists in both tenants, the application treats them as distinct users in separate realms."
msgstr "どちらの場合も、ユーザの認証に成功すると、ランディングページにはユーザの名前と電子メールが表示されます。 `alice` は両方のテナントに存在しますが、アプリケーションは別々の領域の別々のユーザーとして扱います。"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy, no-wrap
msgid "Static tenant configuration resolution"
msgstr "静的テナント構成の解決"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"When you set multiple tenant configurations in the `application.properties` file, you only need to specify how the tenant identifier gets resolved.\n"
"To configure the resolution of the tenant identifier, use one of the following options:"
msgstr "`application.properties` ファイルで複数のテナント構成を設定する場合は、テナント識別子の解決方法のみを指定する必要があります。テナント識別子の解決方法を設定するには、次のいずれかのオプションを使用します："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "<<tenant-resolver>>"
msgstr "<<tenant-resolver>>"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "<<annotations-tenant-resolver>>"
msgstr "<<annotations-tenant-resolver>>"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "<<configuration-based-tenant-resolver>>"
msgstr "<<configuration-based-tenant-resolver>>"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "<<default-tenant-resolver>>"
msgstr "<<default-tenant-resolver>>"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"These tenant resolution options are tried in the order they are listed until the tenant id gets resolved.\n"
"If the tenant id remains unresolved (`null`), the default (unnamed) tenant configuration is selected."
msgstr "これらのテナント解決オプションは、テナントIDが解決されるまで、リストされた順に試行されます。テナント ID が未解決のまま ( `null` ) の場合は、デフォルトの (名前のない) テナント構成が選択されます。"

#. type: Title ===
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy, no-wrap
msgid "Resolve with `TenantResolver`"
msgstr "で解決 `TenantResolver`"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The following `application.properties` example shows how you can resolve the tenant identifier of two tenants named `a` and `b` by using the `TenantResolver` method:"
msgstr "次の `application.properties` の例は、 `a` と `b` という 2 つのテナントのテナント識別子を、 `TenantResolver` メソッドを使用して解決する方法を示しています："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "You can return the tenant id of either `a` or `b` from `quarkus.oidc.TenantResolver`:"
msgstr "`quarkus.oidc.TenantResolver` から `a` または `b` のいずれかのテナント ID を返すことができます："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "In this example, the value of the last request path segment is a tenant id, but if required, you can implement a more complex tenant identifier resolution logic."
msgstr "この例では、最後のリクエストパスセグメントの値はテナントIDですが、必要に応じて、より複雑なテナント識別子解決ロジックを実装することができます。"

#. type: Title ===
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy, no-wrap
msgid "Resolve with annotations"
msgstr "アノテーションで解決"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "You can use the `io.quarkus.oidc.Tenant` annotation for resolving the tenant identifiers as an alternative to using `io.quarkus.oidc.TenantResolver`."
msgstr "`io.quarkus.oidc.TenantResolver` を使用する代わりに、 `io.quarkus.oidc.Tenant` アノテーションを使用してテナント識別子を解決することができます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Proactive HTTP authentication must be disabled (`quarkus.http.auth.proactive=false`) for this to work.\n"
"For more information, see the xref:security-proactive-authentication.adoc[Proactive authentication] guide."
msgstr "この機能を使用するには、プロアクティブHTTP認証を無効（ `quarkus.http.auth.proactive=false` ）にする必要があります。詳細については、 xref:security-proactive-authentication.adoc[プロアクティブ認証] ガイドを参照してください。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Assuming your application supports two OIDC tenants, the `hr` and default tenants, all resource methods and classes carrying `@Tenant(\"hr\")` are authenticated by using the OIDC provider configured by `quarkus.oidc.hr.auth-server-url`.\n"
"In contrast, all other classes and methods are still authenticated by using the default OIDC provider."
msgstr "アプリケーションが `hr` とデフォルトの 2 つの OIDC テナントをサポートしているとすると、 `@Tenant(\"hr\")` を持つすべてのリソースメソッドとクラスは、 `quarkus.oidc.hr.auth-server-url` で設定された OIDC プロバイダを使用して認証されます。対照的に、他のすべてのクラスとメソッドは、デフォルトの OIDC プロバイダを使用して認証されます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The `io.quarkus.oidc.Tenant` annotation must be placed on either the resource class or resource method."
msgstr "`io.quarkus.oidc.Tenant` アノテーションは、リソース・クラスかリソース・メソッドに付ける必要があります。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"In the example above, authentication of the `sayHello` endpoint is enforced with the `@Authenticated` annotation.\n"
"Alternatively, if you use an the xref:security-authorize-web-endpoints-reference.adoc#authorization-using-configuration[HTTP Security policy]\n"
"to secure the endpoint, then, for the `@Tenant` annotation be effective, you must delay this policy's permission check as shown in the example below:"
msgstr "上記の例では、 `@Authenticated` 注釈を使用して、 `sayHello` エンドポイントの認証が強制されます。あるいは、 xref:security-authorize-web-endpoints-reference.adoc#authorization-using-configuration[HTTP セキュリティ・ポリシー] を使用してエンドポイントを保護する場合、 `@Tenant` 注釈を有効にするには、以下の例に示すように、このポリシーの許可チェックを遅延させる必要があります："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Tell Quarkus to run the HTTP permission check after the tenant has been selected with the `@Tenant` annotation."
msgstr "`@Tenant` アノテーションでテナントを選択した後、HTTP権限チェックを実行するようにQuarkusに指示します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Resolve with configuration"
msgstr "コンフィギュレーションで解決"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"You can use the `quarkus.oidc.tenant-paths` configuration property for resolving the tenant identifier as an alternative to using `io.quarkus.oidc.TenantResolver`.\n"
"Here is how you can select the `hr` tenant for the `sayHello` endpoint of the `HelloResource` resource used in the previous example:"
msgstr "`io.quarkus.oidc.TenantResolver` を使用する代わりに、 `quarkus.oidc.tenant-paths` 構成プロパティを使用してテナント識別子を解決することもできます。以下は、前述の例で使用した `HelloResource` リソースの `sayHello` エンドポイントに対して `hr` テナントを選択する方法です："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Same path-matching rules apply as for the `quarkus.http.auth.permission.authenticated.paths=/api/hello` configuration property from the previous example."
msgstr "前の例の `quarkus.http.auth.permission.authenticated.paths=/api/hello` 構成プ ロパテ ィ と 同 じ パス マ ッ チ ン グ規則が適用 さ れます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The wildcard placed at the end of the path represents any number of path segments. However the path is less specific than the `/api/hello`, therefore the `hr` tenant will be used to secure the `sayHello` endpoint."
msgstr "パスの最後に置かれたワイルドカードは、任意の数のパスセグメントを表します。ただし、このパスは `/api/hello` よりも特定度が低いため、 `hr` テナントは `sayHello` エンドポイントを保護するために使用されます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The wildcard in the `/*/hello` represents exactly one path segment. Nevertheless, the wildcard is less specific than the `api`, therefore the `hr` tenant will be used."
msgstr "`/*/hello` のワイルドカードは、正確に1つのパスセグメントを表します。ただし、このワイルドカードは `api` よりも特定性が低いため、 `hr` のテナントが使用されます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Path-matching mechanism works exactly same as in the xref:security-authorize-web-endpoints-reference.adoc#authorization-using-configuration[Authorization using configuration]."
msgstr "パス・マッチングの仕組みは、 xref:security-authorize-web-endpoints-reference.adoc#authorization-using-configuration[Authorization using configurationと] 全く同じです。"

#. type: Title ===
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy, no-wrap
msgid "Default resolution"
msgstr "デフォルト解像度"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The default resolution for a tenant identifier is convention based, whereby the authentication request must include the tenant identifier in the last segment of the request path."
msgstr "テナント識別子のデフォルトの解決方法は規約に基づいており、認証要求には要求パスの最後のセグメントにテナント識別子を含める必要があります。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The following `application.properties` example shows how you can configure two tenants named `google` and `github`:"
msgstr "次の `application.properties` の例は、 `google` と `github` という 2 つのテナントを構成する方法を示しています："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"In the provided example, both tenants configure OIDC `web-app` applications to use an authorization code flow to authenticate users and require session cookies to be generated after authentication.\n"
"After Google or GitHub authenticates the current user, the user gets returned to the `/signed-in` area for authenticated users, such as a secured resource path on the JAX-RS endpoint."
msgstr "この例では、両方のテナントが OIDC `web-app` アプリケーションを構成して、認可コードフローを使用してユーザーを認証し、認証後にセッション Cookie の生成を要求しています。GoogleまたはGitHubが現在のユーザーを認証した後、ユーザーはJAX-RSエンドポイントの保護されたリソースパスなど、認証されたユーザー用の `/signed-in` 。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Finally, to complete the default tenant resolution, set the following configuration property:"
msgstr "最後に、デフォルトのテナント解決を完了するには、以下の設定プロパティを設定します："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"If the endpoint is running on `http://localhost:8080`, you can also provide UI options for users to log in to either `http://localhost:8080/google` or `http://localhost:8080/github`, without having to add specific `/google` or `/github` JAX-RS resource paths.\n"
"Tenant identifiers are also recorded in the session cookie names after the authentication is completed.\n"
"Therefore, authenticated users can access the secured application area without requiring either the `google` or `github` path values to be included in the secured URL."
msgstr "エンドポイントが `http://localhost:8080` で実行されている場合、ユーザがどちらかにログインするための UI オプションを提供することもできます。 `http://localhost:8080/google` または `http://localhost:8080/github` のいずれかにログインするための UI オプションを提供することもできます。特定の `/google` や `/github` JAX-RS リソースパスを追加する必要はありません。認証が完了すると、テナント識別子もセッション・クッキー名に記録されます。したがって、認証されたユーザーは、 `google` または `github` パス値をセキュアな URL に含めることなく、セキュアなアプリケーション領域にアクセスできます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Default resolution can also work for Bearer token authentication.\n"
"Still, it might be less practical because a tenant identifier must always be set as the last path segment value."
msgstr "デフォルトの解決は、ベアラー・トークン認証でも機能します。しかし、テナント識別子を常に最後のパスセグメント値として設定する必要があるため、実用的ではないかもしれません。"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy, no-wrap
msgid "Dynamic tenant configuration resolution"
msgstr "動的なテナント構成の解決"

#: _guides/security-openid-connect-multitenancy.adoc
msgid ""
"If you need a more dynamic configuration for the different tenants you want to support and don't want to end up with multiple\n"
"entries in your configuration file, you can use the `io.quarkus.oidc.TenantConfigResolver`."
msgstr "サポートしたいさまざまなテナントに対して、より動的な設定が必要で、設定ファイルに複数のエントリーを入れたくない場合は、 `io.quarkus.oidc.TenantConfigResolver` が利用出来ます。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "This interface allows you to dynamically create tenant configurations at runtime:"
msgstr "このインターフェイスを使用すると、実行時にテナント設定を動的に作成することができます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"The `OidcTenantConfig` returned by this method is the same one used to parse the `oidc` namespace configuration from the `application.properties`.\n"
"You can populate it by using any settings supported by the `quarkus-oidc` extension."
msgstr "このメソッドによって返される `OidcTenantConfig` は、 `application.properties` から `oidc` 名前空間設定をパースするために使用されるものと同じです。 `quarkus-oidc` エクステンションでサポートされている任意の設定を使用して、このメソッドに入力できます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "If the dynamic tenant resolver returns `null`, a <<static-tenant-resolution>> is attempted next."
msgstr "ダイナミック・テナント・リゾルバが `null` を返した場合、次に <<static-tenant-resolution>> 。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Tenant resolution for OIDC web-app applications"
msgstr "OIDCウェブアプリのテナント解決"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The simplest option for resolving the OIDC `web-app` application configuration is to follow the steps described in the <<default-tenant-resolver>> section."
msgstr "OIDC `web-app` アプリケーション構成を解決するための最も簡単なオプションは、 <<default-tenant-resolver>> セクションで説明されている手順に従うことです。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Try one of the options below if the default resolution strategy does not work for your application setup."
msgstr "アプリケーションのセットアップでデフォルトの解像度ストラテジーが機能しない場合は、以下のオプションのいずれかを試してください。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Several options are available for selecting the tenant configuration that should be used to secure the current HTTP request for both `service` and `web-app` OIDC applications, such as:"
msgstr "`service` および `web-app` OIDC アプリケーションの両方で、現在の HTTP リクエストをセキュアにするために使用するテナント構成を選択するために、次のようないくつかのオプションが利用可能です："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Check the URL paths.\n"
"For example, a `tenant-service` configuration must be used for the `/service` paths, while a `tenant-manage` configuration must be used for the `/management` paths."
msgstr "URLパスを確認してください。例えば、 `/service` のパスには `tenant-service` の設定を、 `/management` のパスには `tenant-manage` の設定を使用する必要があります。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Check the HTTP headers.\n"
"For example, with a URL path always being `/service`, a header such as `Realm: service` or `Realm: management` can help to select between the `tenant-service` and `tenant-manage` configurations."
msgstr "HTTPヘッダーをチェックしてください。例えば、URLパスが常に `/service` の場合、 `Realm: service` や `Realm: management` のようなヘッダは、 `tenant-service` と `tenant-manage` の設定を選択するのに役立ちます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"Check the URL query parameters.\n"
"It can work similarly to the way the headers are used to select the tenant configuration."
msgstr "URLクエリパラメータを確認します。これは、ヘッダーを使用してテナント構成を選択する方法と同様に機能します。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "All these options can be easily implemented with the custom `TenantResolver` and `TenantConfigResolver` implementations for the OIDC `service` applications."
msgstr "これらのオプションはすべて、OIDC `service` アプリケーションのカスタムの `TenantResolver` 実装や `TenantConfigResolver` 実装を使用して簡単に実装できます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "However, due to an HTTP redirect required to complete the code authentication flow for the OIDC `web-app` applications, a custom HTTP cookie might be needed to select the same tenant configuration before and after this redirect request because:"
msgstr "しかし、OIDC `web-app` アプリケーションのコード認証フローを完了するために HTTP リダイレクトが必要なため、このリダイレクトリクエストの前後で同じテナント構成を選択するためにカスタム HTTP クッキーが必要になる場合があります："

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid ""
"The URL path might not be the same after the redirect request if a single redirect URL has been registered in the OIDC provider.\n"
"The original request path can be restored after the tenant configuration has been resolved."
msgstr "OIDC プロバイダーに単一のリダイレクト URL が登録されている場合、リダイレクト要求後の URL パスが同じにならないことがあります。元のリクエストパスは、テナント構成が解決された後に復元できます。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The HTTP headers used during the original request are unavailable after the redirect."
msgstr "元のリクエストで使用された HTTP ヘッダーは、リダイレクト後には使用できません。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The custom URL query parameters are restored after the redirect but only after the tenant configuration is resolved."
msgstr "カスタムURLクエリパラメータはリダイレクト後に復元されますが、テナント構成が解決された後にのみ復元されます。"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "One option to ensure the information for resolving the tenant configurations for `web-app` applications is available before and after the redirect is to use a cookie, for example:"
msgstr "リダイレクトの前後に `web-app` アプリケーションのテナント設定を解決するための情報を確実に利用できるようにするための 1 つのオプションは、Cookie を使用することです。以下はその例です。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Disabling tenant configurations"
msgstr "テナント設定の無効化"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Custom `TenantResolver` and `TenantConfigResolver` implementations might return `null` if no tenant can be inferred from the current request and a fallback to the default tenant configuration is required."
msgstr "現在のリクエストからテナントが推測できず、デフォルトのテナント設定へのフォールバックが必要な場合、 `TenantResolver` と `TenantConfigResolver` のカスタム実装は `null` を返すかもしれません。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "If you expect the custom resolvers always to resolve a tenant, you do not need to configure the default tenant resolution."
msgstr "カスタム・リゾルバが常にテナントを解決することを想定している場合は、デフォルトのテナント解決を構成する必要はありません。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "To turn off the default tenant configuration, set  `quarkus.oidc.tenant-enabled=false`."
msgstr "デフォルトのテナント構成をオフにするには、 `quarkus.oidc.tenant-enabled=false` を設定します。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "The default tenant configuration is automatically disabled when `quarkus.oidc.auth-server-url` is not configured, but either custom tenant configurations are available or `TenantConfigResolver` is registered."
msgstr "`quarkus.oidc.auth-server-url` が設定されていない場合、デフォルトのテナント構成は自動的に無効になりますが、カスタムのテナント構成が利用可能であるか、 `TenantConfigResolver` が登録されています。"

#: _guides/security-openid-connect-multitenancy.adoc
#, fuzzy
msgid "Be aware that tenant-specific configurations can also be disabled, for example: `quarkus.oidc.tenant-a.tenant-enabled=false`."
msgstr "例えば、 `quarkus.oidc.tenant-a.tenant-enabled=false` のように、テナント固有の設定を無効にすることもできます。"

#. type: Title ==
#: _guides/security-openid-connect-multitenancy.adoc
#, no-wrap
msgid "References"
msgstr "参照"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "xref:security-oidc-configuration-properties-reference.adoc[OIDC configuration properties]"
msgstr "xref:security-oidc-configuration-properties-reference.adoc[OIDC設定プロパティ]"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "https://www.keycloak.org/documentation.html[Keycloak Documentation]"
msgstr "https://www.keycloak.org/documentation.html[Keycloak Documentation]"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "https://openid.net/connect/[OpenID Connect]"
msgstr "https://openid.net/connect/[OpenID Connect]"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "https://tools.ietf.org/html/rfc7519[JSON Web Token]"
msgstr "https://tools.ietf.org/html/rfc7519[JSON Web Token]"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "https://developers.google.com/identity/protocols/OpenIDConnect[Google OpenID Connect]"
msgstr "https://developers.google.com/identity/protocols/OpenIDConnect[Google OpenID Connect]"

#. type: Plain text
#: _guides/security-openid-connect-multitenancy.adoc
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "xref:security-overview.adoc[Quarkus Securityの概要]"
