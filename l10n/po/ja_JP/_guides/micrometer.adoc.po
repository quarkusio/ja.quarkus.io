# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-02-04 01:50+0900\n"
"PO-Revision-Date: 2021-12-01 11:23+0900\n"
"Last-Translator: Nobuhiro Sue <nobuhiro.sue@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/micrometer.adoc:6
#, no-wrap
msgid "Micrometer Metrics"
msgstr "Micrometerメトリクス"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:12
msgid "This guide demonstrates how your Quarkus application can utilize the Micrometer metrics library for runtime and application metrics."
msgstr "このガイドでは、QuarkusアプリケーションがランタイムメトリクスとアプリケーションメトリクスのためにMicrometerメトリクスライブラリを利用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:16
msgid "Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports built-in metrics."
msgstr "このガイドで説明されているアプリケーション固有のメトリクスとは別に、Quarkusのさまざまなエクステンションによって公開されているビルトインメトリクスを利用することもできます。これらについては、ビルトインメトリクスをサポートしている各エクステンションのガイドで説明します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:18
msgid "Micrometer is the recommended approach to metrics for Quarkus."
msgstr "Micrometerは、Quarkusのメトリクスとして推奨されるアプローチです。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:19
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:23
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:31
msgid "Micrometer defines a core library providing a registration mechanism for Metrics, and core metric types (Counters, Gauges, Timers, Distribution Summaries, etc.). These core types provide an abstraction layer that can be adapted to different backend monitoring systems. In essence, your application (or a library) can `register` a `Counter`, `Gauge`, `Timer`, or `DistributionSummary` with a `MeterRegistry`. Micrometer will then delegate that registration to one or more implementations, where each implementation handles the unique considerations for the associated monitoring stack."
msgstr "Micrometerは、メトリクスの登録メカニズムを提供するコアライブラリと、メトリクスのコアタイプ(カウンター、ゲージ、タイマー、ディストリビューション・サマリーなど)を定義しています。これらのコアタイプは、さまざまなバックエンド監視システムに適応できる抽象化レイヤーを提供します。要するに、アプリケーション（またはライブラリ）は、 `Counter`, `Gauge`, `Timer`, または `DistributionSummary` を `MeterRegistry` と共に `register` することができます。その後、Micrometerはその登録を1つまたは複数の実装に委ね、各実装は関連する監視スタックの独自の考慮事項を処理します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:37
msgid "Micrometer uses naming conventions to translate between registered Meters and the conventions used by various backend registries. Meter names, for example, should be created and named using dots to separate segments, `a.name.like.this`.  Micrometer then translates that name into the format that the selected registry prefers. Prometheus uses underscores, which means the previous name will appear as `a_name_like_this` in Prometheus-formatted metrics output."
msgstr "Micrometerでは、登録されたメーターと、さまざまなバックエンドレジストリで使用されている規約との間の翻訳に、命名規則を使用しています。たとえば、メーターの名前は、ドットでセグメントを区切って作成し、命名する必要があります。 `a.name.like.this` 。その後、Micrometerはその名前を、選択したレジストリが好むフォーマットに変換します。Prometheusではアンダースコアを使用しているため、Prometheus形式のメトリクス出力では前の名前が `a_name_like_this` と表示されます。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:38
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:42
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  You can skip right to the solution if you prefer. Either:"
msgstr "次のセクションで紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:44
msgid "Clone the git repository: `git clone {quickstarts-clone-url}`, or"
msgstr "Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:45
msgid "Download an {quickstarts-archive-url}[archive]."
msgstr "{quickstarts-archive-url}[アーカイブ] をダウンロードします。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:47
msgid "The solution is located in the `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[directory]."
msgstr "ソリューションは `micrometer-quickstart` {quickstarts-tree-url}/micrometer-quickstart[ディレクトリ] にあります。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:48
#, no-wrap
msgid "Creating the Maven Project"
msgstr "Mavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:53
msgid "Quarkus Micrometer extensions are structured similarly to Micrometer itself: `quarkus-micrometer` provides core micrometer support and runtime integration and other Quarkus and Quarkiverse extensions bring in additional dependencies and requirements to support specific monitoring systems."
msgstr "Quarkus MicrometerエクステンションはMicrometer 自身と同様に構成されています。`quarkus-micrometer` はコア micrometer サポートとランタイム統合を提供し、その他のQuarkus、Quarkiverse エクステンションは特定のモニタリングシステムをサポートするための追加の依存関係や要件を提供します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:55
msgid "For this example, we'll use the Prometheus registry."
msgstr "この例では、Prometheus のレジストリを使用します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:57
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:65
msgid "This command generates a Maven project, that imports the `micrometer-registry-prometheus` extension as a dependency.  This extension will load the core `micrometer` extension as well as additional library dependencies required to support prometheus."
msgstr "このコマンドは、 `micrometer-registry-prometheus` エクステンションを依存関係としてインポートする Maven プロジェクトを生成します。このエクステンションは、 `micrometer` エクステンションだけでなく、 Prometheus をサポートするために必要な追加のライブラリ依存関係もロードします。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:68
msgid "If you already have your Quarkus project configured, you can add the `micrometer-registry-prometheus` extension to your project by running the following command in your project base directory:"
msgstr "すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `micrometer-registry-prometheus` エクステンションを追加することができます。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:73
msgid "This will add the following to your build file:"
msgstr "これにより、 `pom.xml` に以下が追加されます:"

#. type: Block title
#: upstream/_guides/micrometer.adoc:75 upstream/_guides/micrometer.adoc:477
#: upstream/_guides/micrometer.adoc:495 upstream/_guides/micrometer.adoc:580
#, no-wrap
msgid "pom.xml"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:81
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/micrometer.adoc:84 upstream/_guides/micrometer.adoc:486
#: upstream/_guides/micrometer.adoc:508 upstream/_guides/micrometer.adoc:589
#, no-wrap
msgid "build.gradle"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:87
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-micrometer-registry-prometheus\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/micrometer.adoc:89
#, no-wrap
msgid "Writing the application"
msgstr "アプリケーションの作成"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:94
msgid "Micrometer provides an API that allows you to construct your own custom metrics. The most common types of meters supported by monitoring systems are gauges, counters, and summaries. The following sections build an example endpoint, and observes endpoint behavior using these basic meter types."
msgstr "Micrometerは、独自のカスタムメトリクスを構築するためのAPIを提供しています。モニタリング・システムでサポートされている最も一般的なメーターのタイプは、ゲージ、カウンター、サマリーです。以下のセクションでは、エンドポイントの例を構築し、これらの基本的なメータタイプを使用してエンドポイントの動作を観察します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:97
msgid "To register meters, you need a reference to a `MeterRegistry`, which is configured and maintained by the Micrometer extension. The `MeterRegistry` can be injected into your application as follows:"
msgstr "メーターを登録するには、Micrometerエクステンションによって設定され維持されている `MeterRegistry` への参照が必要です。 `MeterRegistry` は、次のようにしてアプリケーションに注入することができます。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:101
#, no-wrap
msgid "package org.acme.micrometer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:103
#, no-wrap
msgid "import io.micrometer.core.instrument.MeterRegistry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:108
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:112
#, no-wrap
msgid ""
"@Path(\"/example\")\n"
"@Produces(\"text/plain\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:114
#, no-wrap
msgid "    private final MeterRegistry registry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:119
#, no-wrap
msgid ""
"    ExampleResource(MeterRegistry registry) {\n"
"        this.registry = registry;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:124
msgid "Micrometer maintains an internal mapping between unique metric identifier and tag combinations and specific meter instances. Using `register`, `counter`, or other methods to increment counters or record values does not create a new instance of a meter unless that combination of identifier and tag/label values hasn't been seen before."
msgstr "Micrometerは、一意のメトリック識別子およびタグの組み合わせと、特定のメーターインスタンスとの間の内部マッピングを維持しています。 `register` や `counter` や他のメソッドを使用してカウンターを増加させたり値を記録したりしても、識別子とタグ/ラベル値の組み合わせがこれまでにないものでない限り、メーターの新しいインスタンスは作成されません。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:125
#, no-wrap
msgid "Gauges"
msgstr "ゲージ"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:130
msgid "Gauges measure a value that can increase or decrease over time, like the speedometer on a car. Gauges can be useful when monitoring the statistics for a cache or collection. Consider the following simple example that observes the size of a list:"
msgstr "ゲージは、車のスピードメーターのように、時間の経過とともに増えたり減ったりする値を測定するものです。ゲージは、キャッシュやコレクションの統計情報を監視する際に便利です。次の簡単な例では、リストのサイズを監視しています。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:134
#, no-wrap
msgid "    LinkedList<Long> list = new LinkedList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:140
#, no-wrap
msgid ""
"    // Update the constructor to create the gauge\n"
"    ExampleResource(MeterRegistry registry) {\n"
"        this.registry = registry;\n"
"        registry.gaugeCollectionSize(\"example.list.size\", Tags.empty(), list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:157
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"gauge/{number}\")\n"
"    public Long checkListSize(@PathParam(\"number\") long number) {\n"
"        if (number == 2 || number % 2 == 0) {\n"
"            // add even numbers to the list\n"
"            list.add(number);\n"
"        } else {\n"
"            // remove items from the list for odd numbers\n"
"            try {\n"
"                number = list.removeFirst();\n"
"            } catch (NoSuchElementException nse) {\n"
"                number = 0;\n"
"            }\n"
"        }\n"
"        return number;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:160
msgid "Note that even numbers are added to the list, and odd numbers remove an element from the list."
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:162
msgid "Start your application in dev mode:"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:166
msgid "Then try the following sequence and look for `example_list_size` in the plain text output:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:177
#, no-wrap
msgid ""
"curl http://localhost:8080/example/gauge/1\n"
"curl http://localhost:8080/example/gauge/2\n"
"curl http://localhost:8080/example/gauge/4\n"
"curl http://localhost:8080/q/metrics\n"
"curl http://localhost:8080/example/gauge/6\n"
"curl http://localhost:8080/example/gauge/5\n"
"curl http://localhost:8080/example/gauge/7\n"
"curl http://localhost:8080/q/metrics\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:182
msgid "It is important to note that gauges are sampled rather than set; there is no record of how the value associated with a gauge might have changed between measurements. In this example, the size of the list is observed when the Prometheus endpoint is visited."
msgstr "ゲージは設定されるのではなくサンプリングされることに注意してください。ゲージに関連付けられた値が測定間でどのように変化したかについての記録はありません。 この例では、Prometheusエンドポイントにアクセスしたときにリストのサイズが計測されます。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:186
msgid "Micrometer provides a few additional mechanisms for creating gauges. Note that Micrometer does not create strong references to the objects it observes by default. Depending on the registry, Micrometer either omits gauges that observe objects that have been garbage-collected entirely or uses `NaN` (not a number) as the observed value."
msgstr "Micrometerには、ゲージを作成するための追加のメカニズムがいくつかあります。なお、Micrometer はデフォルトでは、観測するオブジェクトへの強い参照を作成しません。レジストリによっては、ごみ収集されたオブジェクトを観測するゲージを完全に省略したり、観測値として `NaN` (not a number) を使用したりしています。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:190
msgid "When should you use a Gauge? Only if you can't use something else. Never gauge something you can count. Gauges can be less straight-forward to use than counters. If what you are measuring can be counted (because the value always increments), use a counter instead."
msgstr "どんなときにゲージを使うべきでしょうか？他のものが使えない場合に限ります。カウンターが使えるものでゲージを使ってはいけません。ゲージはカウンターよりも使いにくい場合があります。測定しているものが数えられる場合（値が常に増加するため）は、代わりにカウンターを使用してください。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:191
#, no-wrap
msgid "Counters"
msgstr "カウンター"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:195
msgid "Counters are used to measure values that only increase. In the example below, you will count the number of times you test a number to see if it is prime:"
msgstr "カウンタは、増加するだけの値を測定するために使用されます。以下の例では、ある数字が素数であるかどうかを調べる回数を数えます。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:207
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"prime/{number}\")\n"
"    public String checkIfPrime(@PathParam(\"number\") long number) {\n"
"        if (number < 1) {\n"
"            return \"Only natural numbers can be prime numbers.\";\n"
"        }\n"
"        if (number == 1 || number == 2 || number % 2 == 0) {\n"
"            return number + \" is not prime.\";\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:214
#, no-wrap
msgid ""
"        if ( testPrimeNumber(number) ) {\n"
"            return number + \" is prime.\";\n"
"        } else {\n"
"            return number + \" is not prime.\";\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:225
#, no-wrap
msgid ""
"    protected boolean testPrimeNumber(long number) {\n"
"        // Count the number of times we test for a prime number\n"
"        registry.counter(\"example.prime.number\").increment();\n"
"        for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"            if (number % i == 0) {\n"
"                return false;\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:231
msgid "It might be tempting to add a label or tag to the counter indicating what value was checked, but remember that each unique combination of metric name (`example.prime.number`) and label value produces a unique time series. Using an unbounded set of data as label values can lead to a \"cardinality explosion\", an exponential increase in the creation of new time series."
msgstr "どのような値がチェックされたかを示すラベルやタグをカウンタに追加したくなるかもしれませんが、メトリック名( `example.prime.number`)とラベル値のユニークな組み合わせは、それぞれユニークな時系列を生成することを覚えておいてください。ラベル値として無制限のデータセットを使用すると、新しい時系列の作成が指数関数的に増加する「カーディナリティ・エクスプロージョン（cardinality explosion）」が発生する可能性があります。"

#. type: delimited block =
#: upstream/_guides/micrometer.adoc:238
msgid "Label and tag can be used interchangably. You may also see \"attribute\" used in this context in some documentation.  The gist is each that each label or tag or attribute defines an additional bit of information associated with the single numerical measurement that helps you classify, group, or aggregate the measured value later. The Micrometer API uses `Tag` as the mechanism for specifying this additional data."
msgstr "ラベルとタグは同じ意味で使われています。また、ドキュメントによっては、この文脈で「属性」が使われていることもあります。要するに、それぞれのラベルやタグ、属性は、単一の数値測定に関連する追加の情報を定義するもので、後に測定値を分類したり、グループ化したり、集約したりするのに役立ちます。Micrometer APIでは、この追加データを指定する仕組みとして、 `Tag` を使用しています。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:242
msgid "It is possible to add a tag that would convey a little more information, however. Let's adjust our code, and move the counter to add some tags to convey additional information."
msgstr "しかし、もう少し情報を伝えるためのタグを追加することは可能です。コードを調整して、カウンターを動かし、追加の情報を伝えるタグを追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:260
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"prime/{number}\")\n"
"    public String checkIfPrime(@PathParam(\"number\") long number) {\n"
"        if (number < 1) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"not-natural\").increment();\n"
"            return \"Only natural numbers can be prime numbers.\";\n"
"        }\n"
"        if (number == 1 ) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"one\").increment();\n"
"            return number + \" is not prime.\";\n"
"        }\n"
"        if (number == 2 || number % 2 == 0) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"even\").increment();\n"
"            return number + \" is not prime.\";\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:269
#, no-wrap
msgid ""
"        if ( testPrimeNumber(number) ) {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"prime\").increment();\n"
"            return number + \" is prime.\";\n"
"        } else {\n"
"            registry.counter(\"example.prime.number\", \"type\", \"not-prime\").increment();\n"
"            return number + \" is not prime.\";\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:278
#, no-wrap
msgid ""
"    protected boolean testPrimeNumber(long number) {\n"
"        for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"            if (number % i == 0) {\n"
"                return false;\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:284
msgid "Looking at the data produced by this counter, you can tell how often a negative number was checked, or the number one, or an even number, and so on. Try the following sequence and look for `example_prime_number_total` in the plain text output. Note that the `_total` suffix is added when Micrometer applies Prometheus naming conventions to `example.prime.number`, the originally specified counter name."
msgstr "このカウンタが出力するデータを見ると、負の数、1の数、偶数の数などがどれくらいの頻度でチェックされたかがわかります。次のシーケンスを試して、プレーンテキストの出力で `example_prime_number_total` を探してみてください。なお、 `_total` サフィックスは、元々指定されていたカウンタ名 `example.prime.number` に Micrometer が Prometheus の命名規則を適用したときに付けられたものです。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:286 upstream/_guides/micrometer.adoc:340
msgid "If you did not leave Quarkus running in dev mode, start it again:"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:290 upstream/_guides/micrometer.adoc:344
msgid "Then execute the following sequence:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:300
#, no-wrap
msgid ""
"curl http://localhost:8080/example/prime/-1\n"
"curl http://localhost:8080/example/prime/0\n"
"curl http://localhost:8080/example/prime/1\n"
"curl http://localhost:8080/example/prime/2\n"
"curl http://localhost:8080/example/prime/3\n"
"curl http://localhost:8080/example/prime/15\n"
"curl http://localhost:8080/q/metrics\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:306
msgid "When should you use a counter? Only if you are doing something that can not be either timed (or summarized).  Counters only record a count, which may be all that is needed. However, if you want to understand more about how a value is changing, a timer (when the base unit of measurement is time) or a distribution summary might be more appropriate."
msgstr "どんな時にカウンターを使うべきでしょうか？時間を計ることもまとめることもできないようなことをしているときだけです。カウンターはカウントを記録するだけなので、それだけで十分な場合もあります。しかし、値がどのように変化しているかをより深く理解したい場合は、タイマー（基本的な測定単位が時間の場合）やディストリビューション・サマリーの方が適切かもしれません。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:307
#, no-wrap
msgid "Summaries and Timers"
msgstr "サマリーとタイマー"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:312
msgid "Timers and distribution summaries in Micrometer are very similar. Both allow you to record an observed value, which will be aggregated with other recorded values and stored as a sum. Micrometer also increments a counter to indicate the number of measurements that have been recorded and tracks the maximum observed value (within a decaying interval)."
msgstr "Micrometerのタイマーとディストリビューション・サマリーは非常によく似ています。どちらも観測値を記録することができ、その値は他の記録された値と合算されて合計値として保存されます。また、Micrometerでは、記録された測定値の数を示すカウンタをインクリメントし、（減衰間隔内で）最大の観測値を追跡します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:317
msgid "Distribution summaries are populated by calling the `record` method to record observed values, while timers provide additional capabilities specific to working with time and measuring durations. For example, we can use a timer to measure how long it takes to calculate prime numbers using one of the `record` methods that wraps the invocation of a Supplier function:"
msgstr "ディストリビューション・サマリーは、 `record` メソッドを呼び出して観測値を記録することで入力されます。一方、タイマーは、時間の扱いや持続時間の測定に特化した追加機能を提供します。例えば、タイマーを使って、Supplier関数の呼び出しをラップする `record` メソッドの1つを使って、素数の計算にかかる時間を測定することができます。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:331
#, no-wrap
msgid ""
"    protected boolean testPrimeNumber(long number) {\n"
"        Timer timer = registry.timer(\"example.prime.number.test\");\n"
"        return timer.record(() -> {\n"
"            for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"                if (number % i == 0) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            return true;\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:338
msgid "Micrometer will apply Prometheus conventions when emitting metrics for this timer. Prometheus measures time in seconds.  Micrometer converts measured durations into seconds and includes the unit in the metric name, per convention. After visiting the prime endpoint a few more times, look in the plain text output for the following three entries: `example_prime_number_test_seconds_count`, `example_prime_number_test_seconds_sum`, and `example_prime_number_test_seconds_max`."
msgstr "Micrometerは、このタイマーの測定値を出力する際に、Prometheus の規則を適用します。Prometheusでは、時間を秒単位で測定します。Micrometerは、測定された持続時間を秒に変換し、規約に従ってメトリック名に単位を含めます。プライムエンドポイントをさらに数回訪れた後、プレーンテキストの出力で次の3つのエントリを確認してください： `example_prime_number_test_seconds_count`, `example_prime_number_test_seconds_sum`, `example_prime_number_test_seconds_max` 。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:351
#, no-wrap
msgid ""
"curl http://localhost:8080/example/prime/256\n"
"curl http://localhost:8080/q/metrics\n"
"curl http://localhost:8080/example/prime/7919\n"
"curl http://localhost:8080/q/metrics\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:356
msgid "Both timers and distribution summaries can be configured to emit additional statistics, like histogram data, precomputed percentiles, or service level objective (SLO) boundaries. Note that the count, sum, and histogram data can be re-aggregated across dimensions (or across a series of instances), while precomputed percentile values cannot."
msgstr "タイマーとディストリビューションサマリーは、ヒストグラムデータ、事前に計算されたパーセンタイル、サービスレベル目標（SLO）の境界線など、追加の統計情報を出力するように設定できます。カウント、サム、ヒストグラムのデータは、ディメンション間（または一連のインスタンス間）で再集計できますが、事前に計算されたパーセンタイル値はできないことに注意してください。"

#. type: Title ===
#: upstream/_guides/micrometer.adoc:357
#, no-wrap
msgid "Review automatically generated metrics"
msgstr "自動生成されたメトリクスを確認する"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:360
msgid "To view metrics, execute `curl localhost:8080/q/metrics/`"
msgstr "メトリクスを表示するには、 `curl localhost:8080/q/metrics/` を実行します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:365
msgid "The Micrometer extension automatically times HTTP server requests. Following Prometheus naming conventions for timers, look for `http_server_requests_seconds_count`, `http_server_requests_seconds_sum`, and `http_server_requests_seconds_max`. Dimensional labels have been added for the requested uri, the HTTP method (GET, POST, etc.), the status code (200, 302, 404, etc.), and a more general outcome field."
msgstr "Micrometerエクステンションは、HTTPサーバーのリクエストの時間を自動的に計測します。Prometheus のタイマーの命名規則に従い、 `http_server_requests_seconds_count` 、 `http_server_requests_seconds_sum` 、 `http_server_requests_seconds_max` を参照してください。要求された URI、HTTP メソッド (GET、POST など)、ステータスコード (200、302、404 など)、そしてより一般的な結果フィールドのための次元ラベルが追加されました。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:376
#, no-wrap
msgid ""
"# HELP http_server_requests_seconds\n"
"# TYPE http_server_requests_seconds summary\n"
"http_server_requests_seconds_count{method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/example/prime/{number}\",} 1.0\n"
"http_server_requests_seconds_sum{method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/example/prime/{number}\",} 0.017385896\n"
"# HELP http_server_requests_seconds_max\n"
"# TYPE http_server_requests_seconds_max gauge\n"
"http_server_requests_seconds_max{method=\"GET\",outcome=\"SUCCESS\",status=\"200\",uri=\"/example/prime/{number}\",} 0.017385896\n"
"#\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:380
msgid "Note that metrics appear lazily, you often won't see any data for your endpoint until something tries to access it, etc."
msgstr "メトリクスは遅延的に表示され、何かがアクセスしようとするまでエンドポイントのデータが表示されないことが多いことに注意してください。"

#. type: Block title
#: upstream/_guides/micrometer.adoc:381
#, no-wrap
msgid "Ignoring endpoints"
msgstr "エンドポイントの無視"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:388
msgid "You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns` property. This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should be ignored. For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will ignore a request to `http://localhost:8080/example/prime/7919`. A request to `http://localhost:8080/example/gauge/7919` would still be measured."
msgstr "`quarkus.micrometer.binder.http-server.ignore-patterns` プロパティを使用して、HTTP エンドポイントの測定を無効にすることができます。このプロパティには、無視すべきURIパスを特定する単純な正規表現のマッチパターンをコンマで区切ったリストを指定できます。例えば、 `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` を設定すると、以下へのリクエストが無視されます。`http://localhost:8080/example/prime/7919` へのリクエストは無視されます。`http://localhost:8080/example/gauge/7919` へのリクエストは、依然として計測されます。"

#. type: Block title
#: upstream/_guides/micrometer.adoc:389
#, no-wrap
msgid "URI templates"
msgstr "URIテンプレート"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:394
msgid "The micrometer extension will make a best effort at representing URIs containing path parameters in templated form.  Using examples from above, a request to `http://localhost:8080/example/prime/7919` should appear as an attribute of `http_server_requests_seconds_*` metrics with a value of `uri=/example/prime/{number}`."
msgstr "micrometerエクステンションでは、パスパラメータを含むURIをテンプレート化して表現することに最善の努力を払います。上の例を使うと、次のようなリクエストは `http://localhost:8080/example/prime/7919` へのリクエストは、 `http_server_requests_seconds_*` メトリクスの属性として、 `uri=/example/prime/{number}` という値で表示されます。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:400
msgid "Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined. This property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement string. For example, setting `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value `/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`."
msgstr "正しいURLが特定できない場合は、 `quarkus.micrometer.binder.http-server.match-patterns` プロパティを使用します。このプロパティには、単純な正規表現パターンと置換文字列の関連性を定義するコンマ区切りのリストを指定できます。例えば、 `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` を設定すると、要求された uri が `/example/prime/[0-9]+` に一致した場合、uri 属性に `/example/{jellybeans}` の値が使用されます。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:401
#, no-wrap
msgid "Using MeterFilter to configure metrics"
msgstr "MeterFilter を使ってメトリクスを設定する"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:406
msgid "Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.  The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry` instances."
msgstr "Micrometerは `MeterFilter` インスタンスを使って、 `MeterRegistry` インスタンスが出力するメトリクスをカスタマイズします。 Micrometer エクステンションは、 `MeterFilter` のCDI Beanを検出して、 `MeterRegistry` インスタンスを初期化するときにそれを使います。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:411
#, no-wrap
msgid ""
"@Singleton\n"
"public class CustomConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:414
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"deployment.env\")\n"
"    String deploymentEnv;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:423
#, no-wrap
msgid ""
"    /** Define common tags that apply only to a Prometheus Registry */\n"
"    @Produces\n"
"    @Singleton\n"
"    @MeterFilterConstraint(applyTo = PrometheusMeterRegistry.class)\n"
"    public MeterFilter configurePrometheusRegistries() {\n"
"        return MeterFilter.commonTags(Arrays.asList(\n"
"                Tag.of(\"registry\", \"prometheus\")));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:431
#, no-wrap
msgid ""
"    /** Define common tags that apply globally */\n"
"    @Produces\n"
"    @Singleton\n"
"    public MeterFilter configureAllRegistries() {\n"
"        return MeterFilter.commonTags(Arrays.asList(\n"
"                Tag.of(\"env\", deploymentEnv)));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:451
#, no-wrap
msgid ""
"    /** Enable histogram buckets for a specific timer */\n"
"    @Produces\n"
"    @Singleton\n"
"    public MeterFilter enableHistogram() {\n"
"        return new MeterFilter() {\n"
"            @Override\n"
"            public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) {\n"
"                if(id.getName().startsWith(\"myservice\")) {\n"
"                    return DistributionStatisticConfig.builder()\n"
"                        .percentiles(0.5, 0.95)     // median and 95th percentile, not aggregable\n"
"                        .percentilesHistogram(true) // histogram buckets (e.g. prometheus histogram_quantile)\n"
"                        .build()\n"
"                        .merge(config);\n"
"                }\n"
"                return config;\n"
"            }\n"
"        };\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:458
msgid "In this example, a singleton CDI bean will produce two different `MeterFilter` beans. One will be applied only to Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied to all `MeterRegistry` instances. An application configuration property is also injected and used as a tag value.  Additional examples of MeterFilters can be found in the link:https://micrometer.io/docs/concepts[official documentation]."
msgstr "この例では、シングルトン CDI Beanは、2 つの異なる `MeterFilter` Beanを生成します。1 つは Prometheus `MeterRegistry` インスタンスのみに適用され ( `@MeterFilterConstraint` 修飾子を使用)、もう 1 つはすべての `MeterRegistry` インスタンスに適用されます。アプリケーション設定プロパティーも注入され、タグ値として使用されます。MeterFiltersのその他の例は、次のリンクにあります：link:https://micrometer.io/docs/concepts[公式ドキュメント] 。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:459
#, no-wrap
msgid "Does Micrometer support annotations?"
msgstr "Micrometerはアノテーションをサポートしていますか？"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:464
msgid "Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods. The `@Timed` annotation will wrap the execution of a method and will emit the following tags in addition to any tags defined on the annotation itself: class, method, and exception (either \"none\" or the simple class name of a detected exception)."
msgstr "Micrometerでは、メソッドに追加できる2つのアノテーション、 `@Counted` と `@Timed` が定義されています。 `@Timed` アノテーションは、メソッドの実行をラップし、アノテーション自体に定義されているタグに加えて、次のタグを出力します：class、method、exception（\"none \"または検出された例外のシンプルなクラス名）。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:467
msgid "Using annotations is limited, as you can't dynamically assign meaningful tag values. Also note that many methods, e.g.  REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box."
msgstr "意味のあるタグ値を動的に割り当てることができないため、アノテーションの使用には制限があります。また、RESTエンドポイント・メソッドやVert.x Routesなどの多くのメソッドは、最初から無設定でmicrometerエクステンションによってカウントされ、時間が計測されることに注意してください。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:468
#, no-wrap
msgid "Using other Registry implementations"
msgstr "他のレジストリ実装の使用"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:475
msgid "If you aren't using Prometheus, you have a few options. Some Micrometer registry implementations have been wrapped in https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverse extensions].  To use the Micrometer StackDriver MeterRegistry, for example, you would use the `quarkus-micrometer-registry-stackdriver` extension:"
msgstr "Prometheusを使用していない場合は、いくつかの選択肢があります。いくつかのMicrometerのレジストリーの実装は、 link:https://github.com/quarkiverse/quarkiverse-micrometer-registry[Quarkiverseのエクステンション] でラップされています。たとえば、Micrometer StackDriver MeterRegistryを使用するには、 `quarkiverse-micrometer-registry-stackdriver` エクステンションを使用します。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:483
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer-registry-stackdriver</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:489
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-micrometer-registry-stackdriver\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:493
msgid "If the Micrometer registry you would like to use does not yet have an associated extension, use the `quarkus-micrometer` extension and bring in the packaged MeterRegistry dependency directly:"
msgstr "使用したい Micrometer レジストリに関連するエクステンションがまだない場合は、 `quarkus-micrometer` エクステンションを使用して、パッケージ化された MeterRegistry の依存関係を直接取り込んでください。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:505
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>com.acme</groupId>\n"
"    <artifactId>custom-micrometer-registry</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:512
#, no-wrap
msgid ""
"implementation(\"io.quarkus:quarkus-micrometer\")\n"
"implementation(\"com.acme:custom-micrometer-registry\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:516
msgid "You will then need to specify your own provider to configure and initialize the MeterRegistry, as discussed in the next section."
msgstr "次に、次のセクションで説明するように、MeterRegistry を設定して初期化するために、独自のプロバイダを指定する必要があります。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:517
#, no-wrap
msgid "Creating a customized MeterRegistry"
msgstr "カスタマイズされたMeterRegistryの作成"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:520
msgid "Use a custom `@Produces` method to create and configure a customized `MeterRegistry` if you need to."
msgstr "必要に応じて、カスタム `@Produces` メソッドを使用して、カスタマイズされた `MeterRegistry` を作成して設定します。"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:522
msgid "The following example customizes the line format used for StatsD:"
msgstr "以下の例では、StatsDで使用される行フォーマットをカスタマイズしています。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:530
#, no-wrap
msgid ""
"@Produces\n"
"@Singleton\n"
"public StatsdMeterRegistry createStatsdMeterRegistry(StatsdConfig statsdConfig, Clock clock) {\n"
"    // define what to do with lines\n"
"    Consumer<String> lineLogger = line -> logger.info(line);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:537
#, no-wrap
msgid ""
"    // inject a configuration object, and then customize the line builder\n"
"    return StatsdMeterRegistry.builder(statsdConfig)\n"
"          .clock(clock)\n"
"          .lineSink(lineLogger)\n"
"          .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:541
msgid "This example corresponds to the following instructions in the Micrometer documentation: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink"
msgstr "この例は、Micrometerのドキュメントにある以下の指示に対応しています: https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:546
msgid "Note that the method returns the specific type of `MeterRegistry` as a `@Singleton`. Use MicroProfile Config to inject any configuration attributes you need to configure the registry. Most Micrometer registry extensions, like `quarkus-micrometer-registry-statsd`, define a producer for registry-specific configuration objects that are integrated with the Quarkus configuration model."
msgstr "このメソッドは、 `MeterRegistry` の特定の型を `@Singleton` として返すことに注意してください。レジストリーを設定するために必要な設定属性を注入するには、MicroProfile Configを使用します。 `quarkiverse-micrometer-registry-statsd` のようなほとんどのMicrometerのレジストリーエクステンションでは、Quarkusの設定モデルと統合されたレジストリー固有の設定オブジェクトのプロデューサを定義しています。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:547
#, no-wrap
msgid "Support for the MicroProfile Metrics API"
msgstr "MicroProfile Metrics API のサポート"

#. type: Plain text
#: upstream/_guides/micrometer.adoc:553
msgid "If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry. Note that naming conventions between the two systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change.  You can use a `MeterFilter` to remap names or tags according to your conventions."
msgstr "アプリケーションで MicroProfile Metrics API を使用している場合、Micrometer エクステンションは、これらのメトリクスを Micrometer レジストリにマッピングするための適応レイヤーを作成します。2 つのシステム間の命名規則は異なるので、MP MetricsをMicrometerと一緒に使用した場合に出力されるメトリクスは変化します。MeterFilters を使用して名前やタグをダッシュボードが必要とするものに再マッピングすることができます。"

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:560
#, no-wrap
msgid ""
"@Produces\n"
"@Singleton\n"
"public MeterFilter renameApplicationMeters() {\n"
"    final String targetMetric = MPResourceClass.class.getName() + \".mpAnnotatedMethodName\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:575
#, no-wrap
msgid ""
"    return MeterFilter() {\n"
"        @Override\n"
"        public Meter.Id map(Meter.Id id) {\n"
"            if (id.getName().equals(targetMetric)) {\n"
"                // Drop the scope tag (MP Registry type: application, vendor, base)\n"
"                List<Tag> tags = id.getTags().stream().filter(x -> !\"scope\".equals(x.getKey()))\n"
"                        .collect(Collectors.toList());\n"
"                // rename the metric\n"
"                return id.withName(\"my.metric.name\").replaceTags(tags);\n"
"            }\n"
"            return id;\n"
"        }\n"
"    };\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:578
msgid "Ensure the following dependency is present in your build file if you require the MicroProfile Metrics API:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:586
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.eclipse.microprofile.metrics</groupId>\n"
"    <artifactId>microprofile-metrics-api</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/micrometer.adoc:592
#, no-wrap
msgid "implementation(\"org.eclipse.microprofile.metrics:microprofile-metrics-api\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/micrometer.adoc:595
msgid "The MP Metrics API compatibility layer will be moved to a different extension in the future."
msgstr "MP Metrics API互換性レイヤは、将来的には別のエクステンションに移される予定です。"

#. type: Title ==
#: upstream/_guides/micrometer.adoc:596
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"

#~ msgid "To complete this guide, you need:"
#~ msgstr "このガイドを完成させるには、以下が必要です:"

#~ msgid "less than 15 minutes"
#~ msgstr "15分未満"

#~ msgid "an IDE"
#~ msgstr "IDE"

#~ msgid "JDK 11+ installed with `JAVA_HOME` configured appropriately"
#~ msgstr "JDK 11+ がインストールされ、 `JAVA_HOME` が適切に設定されていること"

#~ msgid "Apache Maven {maven-version}"
#~ msgstr "Apache Maven {maven-version}"

#~ msgid ""
#~ "# Compile and run the app in dev mode:\n"
#~ "./mvnw compile quarkus:dev\n"
#~ msgstr ""
#~ "# Compile and run the app in dev mode:\n"
#~ "./mvnw compile quarkus:dev\n"

#~ msgid "In this example, we build a very simple microservice which offers one REST endpoint and that determines if a number is prime."
#~ msgstr "この例では、1つのRESTエンドポイントを提供し、数値が素数かどうかを判定する非常にシンプルなマイクロサービスを構築します。"

#~ msgid "The application consists of a single class that implements an algorithm for checking whether a number is prime.  This algorithm is exposed over a REST interface. With the Micrometer extension enabled, metrics for all http server requests are collected automatically."
#~ msgstr "このアプリケーションは、数値が素数であるかどうかをチェックするアルゴリズムを実装した単一のクラスで構成されています。このアルゴリズムは REST インタフェースを介して公開されています。Micrometer エクステンションを有効にすると、すべての http サーバーのリクエストのメトリクスが自動的に収集されます。"

#~ msgid "We do want to add a few other metrics to demonstrate how those types work:"
#~ msgstr "これらのタイプのメトリクスがどのように機能するかを示すために、他にもいくつかのメトリクスを追加したいと考えています。"

#~ msgid "A counter will be incremented for every prime number discovered"
#~ msgstr "素数が発見されるごとにカウンタがインクリメントされます。"

#~ msgid "A gauge will store the highest prime number discovered"
#~ msgstr "ゲージには、発見された最高の素数が保存されます。"

#~ msgid "A timer will record the time spent testing if ia number is prime."
#~ msgstr "タイマーは、数値が素数であるかどうかのテストに費やした時間を記録します。"

#~ msgid "Running and using the application"
#~ msgstr "アプリケーションの実行と使用"

#~ msgid "Generate some values for the metrics"
#~ msgstr "メトリクスの値を生成する"

#~ msgid "First, ask the endpoint whether some numbers are prime numbers."
#~ msgstr "まず、ある数が素数であるかどうかをエンドポイントに問います。"

#~ msgid "The application will respond that 350 is not a prime number because it can be divided by 2."
#~ msgstr "このアプリケーションでは、350は2で割ることができるので素数ではないと答えます。"

#~ msgid "Now for some large prime number so that the test takes a bit more time:"
#~ msgstr "ここで、テストにもう少し時間がかかるように、大きな素数を用意します。"

#~ msgid "The application will respond that 629521085409773 is a prime number.  If you want, try some more calls with numbers of your choice."
#~ msgstr "アプリケーションは、629521085409773が素数であると答えます。  お好みの数値でさらに実行してみてください。"

#~ msgid "Prometheus-formatted metrics will be returned in plain text in no particular order."
#~ msgstr "Prometheusフォーマットのメトリクスは、プレーンテキストで順不同に返されます。"

#~ msgid "The application above has only one custom gauge that measures the time spent determining whether or not a number is prime. The Micrometer extension enables additional system, jvm, and http metrics. A subset of the collected metrics are shown below."
#~ msgstr "上のアプリケーションには、ある数字が素数かどうかを判断するのにかかった時間を測定するカスタムゲージが1つだけあります。Micrometerエクステンションでは、システム、JVM、httpのメトリクスを追加することができます。収集されたメトリクスの一部を以下に示します。"
