# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2021-02-23 17:26+0000\n"
"PO-Revision-Date: 2021-02-18 01:38+0900\n"
"Last-Translator: Nobuhiro Sue <nobuhiro.sue@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-reactive.adoc:6
#, no-wrap
msgid "Quarkus - Getting started with Reactive"
msgstr "Quarkus - リアクティブを始める"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:12
msgid "Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:"
msgstr "Quarkusを使用してリアクティブアプリケーションを作成する方法と、Quarkusが提供するさまざまなリアクティブ機能について説明します。このガイドでは、以下の内容を説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:14
msgid "A quick glance at the Quarkus engine and how it enables reactive"
msgstr "Quarkusエンジンの概要と、それがどのようにリアクティブを可能にしているかを簡単に説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:15
msgid "A brief introduction to Mutiny - the reactive programming library used by Quarkus"
msgstr "概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:16
msgid "The difference between RESTEasy, RESTEasy Reactive and Reactive Routes"
msgstr "RESTEasy、RESTEasy ReactiveとReactive Routes の違い"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:17
msgid "The bootstrap of a reactive application using RESTEasy Reactive"
msgstr "RESTEasy Reactiveを使ったリアクティブアプリケーションのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:18
msgid "Creating a reactive JAX-RS endpoint (asynchronous, streams...)"
msgstr "リアクティブな JAX-RS エンドポイントの作成（非同期、ストリーム...）"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:19
msgid "Using reactive database access"
msgstr "リアクティブデータベースアクセス"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:20
msgid "Interacting with other reactive APIs"
msgstr "その他のリアクティブAPIの使用"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:21
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:24
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下が必要です："

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:26
msgid "less than 15 minutes"
msgstr "15分以内"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:27
msgid "an IDE"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:28
msgid "JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 8 または 11+ がインストールされ、 `JAVA_HOME` が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:29
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:30
#, no-wrap
msgid "Solutions"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:33
msgid "We recommend that you follow the instructions from <<bootstrapping-the-project,Bootstrapping project>> and onwards to create the application step by step."
msgstr "<<bootstrapping-the-project,プロジェクトのブートストラップ>>とそれ以降の解説に従って、ステップバイステップでアプリを作成していくことをお勧めします。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:35
msgid "However, you can go right to the completed example."
msgstr "しかしながら、完成した例をすぐ確認することもできます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:37
msgid "Download an {quickstarts-archive-url}[archive] or clone the git repository:"
msgstr "{quickstarts-archive-url}[アーカイブ] をダウンロードするか、gitレポジトリをクローンします："

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:41
#, no-wrap
msgid "git clone {quickstarts-clone-url}\n"
msgstr "git clone {quickstarts-clone-url}\n"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:44
msgid "The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories."
msgstr "ソリューションは `getting-started-reactive` と `getting-started-reactive-crud` のディレクトリにあります。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:45
#, no-wrap
msgid "The multiple reactive facets of Quarkus"
msgstr "Quarkus の複数のリアクティブ断面"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:51
msgid "Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine."
msgstr "Quarkusはリアクティブです。ボンネットの下を見ると、Quarkusアプリケーションの動力源となっているリアクティブエンジンを見つけることができます。このエンジンはEclipse Vert.x（ https://vertx.io ）です。すべてのネットワークI/Oは、ノンブロッキングでリアクティブなVert.xエンジンを通過します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:53
msgid "image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]"
msgstr "image:quarkus-reactive-stack.png[alt=\"Quarkusはリアクティブなエンジンをベースとしている\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:61
msgid "Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread."
msgstr "2つの例を挙げて、その仕組みを説明してみましょう。入ってくるHTTPリクエストを想像してみてください。Quarkusに組み込まれたHTTPサーバー（Vert.x）がリクエストを受信し、アプリケーションにルーティングします。リクエストが _命令的な_ メソッド（従来のJAX-RS、 `@Blocking` ...で注釈されたコード）をターゲットにしている場合、ルーティング層は _ワーカースレッド_ でリソースメソッドを呼び出し、データが利用可能になるとレスポンスを書き込みます。今のところ、目新しいものも目立ったものもありません。次の図は、この動作を示しています。この場合、アプリケーションコードはワーカースレッドで呼び出され、ビジネスロジックはそのスレッドをブロックすることができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:63
msgid "image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]"
msgstr "image:http-blocking-sequence.png[alt=\"命令的な route を使ったときの挙動\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:65
msgid "But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:"
msgstr "しかし、HTTPリクエストがリアクティブなメソッド（RESTEasy Reactiveを使用したJAX-RS、リアクティブなルート、 `@Incoming` メソッドは `@Blocking` ...でアノテーションされていない）をターゲットにしている場合、ルーティング層はI/Oスレッド上でルートを呼び出し、より高い同時実行性とパフォーマンスなどの多くの利点を与えます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:67
msgid "image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]"
msgstr "image:http-reactive-sequence.png[alt=\"リアクティブな route を使ったときの挙動\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:74
msgid "Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread."
msgstr "QuarkusはI/Oスレッドを使用してコードを呼び出すため、コンテキストスイッチを節約し、大規模なスレッドプール管理を回避し、リソースの利用率を向上させます。ただし、コードはそのスレッドをブロックしてはいけ *ませ* ん。なぜでしょうか？なぜなら、I/O スレッドは複数の同時リクエストを処理するために使用されます。リクエストの処理がいくつかのI/Oを実行する必要があるために進行できなくなるとすぐに、これらのI/Oをスケジュールし、継続(continuation)を渡します。別のリクエストを処理できるスレッドを解放します。スケジュールされたI/Oが完了すると、I/Oスレッドに戻って継続(continuation)が実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:78
msgid "As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon."
msgstr "結果として、多くのQuarkusコンポーネントは、データベースアクセス（PostgreSQL、MySQL、Mongoなど）、アプリケーションサービス（メール、テンプレートエンジンなど）、メッセージング（Kafka、AMQPなど）など、リアクティブを念頭に置いて設計されています。しかし、このモデルの恩恵を十分に受けるためには、アプリケーションコードはノンブロッキングで書かれなければなりません。そこで、リアクティブ API を持つことが究極の武器となります。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:80
#, no-wrap
msgid "Mutiny - A reactive programming library"
msgstr "Mutiny - リアクティブプログラミングライブラリ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:84
msgid "https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:"
msgstr "link:https://github.com/smallrye/smallrye-mutiny[Mutiny] は、非同期アクションを表現したり構成したりすることができるリアクティブプログラミングライブラリです。2つのタイプがあります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:86
msgid "`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result"
msgstr "`io.smallrye.mutiny.Uni` - 0 または 1 の結果を提供する非同期アクション用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:87
msgid "`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams"
msgstr "`io.smallrye.mutiny.Multi` - マルチアイテム（バックプレッシャー付き）ストリーム用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:90
msgid "Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists)."
msgstr "どちらのタイプも lazy で、サブスクリプションパターンに従います。計算は、実際に必要とされる場合にのみ開始されます (すなわち、サブスクライバがエンリストした場合)。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:97
#, no-wrap
msgid ""
"uni.subscribe().with(\n"
"    result -> System.out.println(\"result is \" + result),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:102
#, no-wrap
msgid ""
"multi.subscribe().with(\n"
"    item -> System.out.println(\"Got \" + item),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:108
msgid "Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive."
msgstr "`Uni` も `Multi` もイベント駆動型の API を公開しています: 与えられたイベント (成功、失敗など) に対して何をしたいかを表現します。これらのAPIはグループ(操作の種類)に分けられており、より表現力を高め、1つのクラスに100個ものメソッドをアタッチすることを避けています。主な操作の種類は、失敗に反応するもの、完了するもの、アイテムを操作するもの、抽出するもの、収集するものなどです。ナビゲーション可能なAPIでスムーズなコーディングを実現し、結果的にリアクティブ周りの知識をあまり必要としないようにしています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:113
#, no-wrap
msgid ""
"httpCall\n"
"    .onFailure().recoverWithItem(\"my fallback\");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:119
msgid "You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex."
msgstr "https://www.reactive-streams.org/ `Multi` は Reactive Streams `Publisher` を実装しているので、Reactive Streams のバックプレッシャーメカニズムを実装しています。 `Uni` へのサブスクリプションは結果に興味があることを示すのに十分なので、 `Uni` は `Publisher` を実装していません。これは、Reactive Streams のサブスクリプション/リクエスト式がより複雑であるため、よりシンプルでスムーズな API のアイデアを念頭に置いたものです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:122
msgid "Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`."
msgstr "Quarkusのリアクティブな面と命令的な面の統合を受け入れた `Uni` と `Multi` は、両方とも命令的構造への橋渡しをしてくれます。たとえば、 `Multi` を `Iterable` に変換したり、 `Uni` .NET で生成されたアイテムを _待っ_ たりすることができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:127
#, no-wrap
msgid ""
"// Block until the result is available\n"
"String result = uni.await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:130
#, no-wrap
msgid ""
"// Transform an asynchronous stream into a blocking iterable\n"
"stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:134
msgid "At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:"
msgstr "この時点で、あなたがRxJavaやReactorのユーザーであれば、お馴染みの `Flowable` , `Single` , `Flux` , , `Mono` ... Mutinyでは、 `Unis` と `Multis` をRX JavaやReactorの型に変換することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:139
#, no-wrap
msgid ""
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:144
msgid "But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:"
msgstr "しかし、Vert.xはどうでしょうか？Vert.xのAPIはMutiny型を使っても利用できます。以下のスニペットは、Vert.x Web Clientの使い方を示しています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:164
#, no-wrap
msgid ""
"// Use io.vertx.mutiny.ext.web.client.WebClient\n"
"client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"// ...\n"
"Uni<JsonObject> uni =\n"
"    client.get(\"/api/fruit/\" + name)\n"
"        .send()\n"
"        .onItem().transform(resp -> {\n"
"            if (resp.statusCode() == 200) {\n"
"                return resp.bodyAsJsonObject();\n"
"            } else {\n"
"                return new JsonObject()\n"
"                        .put(\"code\", resp.statusCode())\n"
"                        .put(\"message\", resp.bodyAsString());\n"
"            }\n"
"        });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:167
msgid "Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline."
msgstr "最後になりますが、MutinyにはMicroProfile Context Propagationとの統合が組み込まれているので、リアクティブパイプラインでトランザクションやトレーサビリティデータなどを伝搬することができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:169
msgid "But enough talking, let's get our hands dirty!"
msgstr "話はもういい、手を汚すんだ！"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:170
#, no-wrap
msgid "Bootstrapping the project"
msgstr "プロジェクトのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:175
msgid "There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread."
msgstr "Quarkusでリアクティブアプリケーションを実装するには、いくつかの方法があります。このガイドでは、Quarkusのリアクティブエンジンの恩恵を受けるRESTEasyの実装であるRESTEasy Reactiveを使用します。デフォルトでは、I/Oスレッド上のHTTPエンドポイントを呼び出します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:178
msgid "While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose."
msgstr "_従来の_ RESTEasy を使用することは可能ですが、 `quarkus-resteasy-mutiny` 拡張モジュールを追加する必要があり、メソッドは _ワーカースレッド_ 上で呼び出されます。つまり、リアクティブプログラミングを使用するとはいえ、ワーカースレッドを必要とし、その目的は達成されません。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:180
msgid "The easiest way to create a new Quarkus project is to open a terminal and run the following command:"
msgstr "新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行することです："

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:182
msgid "For Linux and macOS users"
msgstr "LinuxおよびmacOSユーザーの場合"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:192
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive \\\n"
"    -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"resteasy-reactive\"\n"
"cd getting-started-reactive\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:195
msgid "For Windows users"
msgstr "Windowsユーザーの場合"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:197
msgid "If using cmd, (don't use forward slash `\\`)"
msgstr "cmd を使用する場合は、(前方スラッシュを使用しないでください `\\` )"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:201
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:204
msgid "If using Powershell, wrap `-D` parameters in double quotes"
msgstr "Powershell を使用する場合は、 `-D` のパラメータを二重引用符で囲みます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:208
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.getting.started.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:211
msgid "It generates the following in `./getting-started-reactive`:"
msgstr "`./getting-started-reactive` 内に以下が生成されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:213
msgid "the Maven structure"
msgstr "Mavenの構造"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:214
msgid "an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`"
msgstr "`/hello` で公開されている `org.acme.quickstart.ReactiveGreetingResource` リソース "

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:215
msgid "an associated unit test"
msgstr "関連するユニットテスト"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:216
msgid "a landing page that is accessible on `http://localhost:8080` after starting the application"
msgstr "アプリケーション起動後に `http://localhost:8080` でアクセス可能なランディングページ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:217
msgid "example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`"
msgstr "`src/main/docker` にある `native` と `jvm` の両方のモード用の `Dockerfile` ファイルの例"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:218
msgid "the application configuration file"
msgstr "アプリケーション設定ファイル"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:219
#, no-wrap
msgid "Reactive JAX-RS resources"
msgstr "リアクティブな JAX-RS リソース"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:222
msgid "During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:"
msgstr "プロジェクト作成時に、 `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` ファイルは以下の内容で作成されています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:226
#: upstream/_guides/getting-started-reactive.adoc:269
#: upstream/_guides/getting-started-reactive.adoc:291
#, no-wrap
msgid "package org.acme.getting.started;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:231
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:234
#: upstream/_guides/getting-started-reactive.adoc:304
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:241
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello RESTEasy Reactive\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:245
msgid "It's a very simple REST endpoint, returning \"Hello RESTEasy Reactive\" to requests on \"/hello\".  As it uses RESTEAsy Reactive, this method is called on the I/O thread."
msgstr "これは非常にシンプルなRESTエンドポイントで、\"/hello\"上のリクエストに対して\"Hello RESTEasy Reactive\"を返します。RESTEAsy Reactiveを使用しているので、このメソッドはI/Oスレッド上で呼び出されます。"

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:250
msgid "To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:"
msgstr "_ワーカースレッド_ でこのメソッドを呼び出すようにQuarkusに指示するには、 `io.smallrye.common.annotation.Blocking` アノテーションを付けます。メソッドやクラスで `@Blocking` を使用したり、 `Application` クラスをアノテーションすることで、アプリケーション全体で を使用できるようにすることができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:256
#, no-wrap
msgid ""
"import javax.ws.rs.ApplicationPath;\n"
"import javax.ws.rs.core.Application;\n"
"import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:261
#, no-wrap
msgid ""
"@ApplicationPath(\"/\")\n"
"@Blocking\n"
"public class RestBlockingApplication extends Application {\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:265
msgid "Let's now create a `ReactiveGreetingService` class with the following content:"
msgstr "それでは、以下の内容の `ReactiveGreetingService` クラスを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:272
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:275
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:278
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveGreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:284
#, no-wrap
msgid ""
"    public Uni<String> greeting(String name) {\n"
"        return Uni.createFrom().item(name)\n"
"                .onItem().transform(n -> String.format(\"hello %s\", n));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:287
msgid "Then, edit the `ReactiveGreetingResource` class to match the following content:"
msgstr "次に、 `ReactiveGreetingResource` クラスを以下の内容に合わせて編集します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:297
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:301
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:307
#, no-wrap
msgid ""
"    @Inject\n"
"    ReactiveGreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:314
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"/greeting/{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return service.greeting(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:321
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:326
msgid "The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide."
msgstr "`ReactiveGreetingService` クラスには、 `Uni` を生成する簡単なメソッドが含まれています。この例では、結果として得られるアイテムがすぐに出力されますが、非同期 API で `Uni` を生成することは想像できます。これについては、このガイドで後ほど説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:328
msgid "Now, start the application using:"
msgstr "それでは、以下でアプリケーションを起動します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:332
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr "./mvnw quarkus:dev\n"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:335
msgid "Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo."
msgstr "実行したら、 http://localhost:8080/hello/greeting/neo を開いて、期待通りのグリーティングメッセージが表示されているか確認してください。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:336
#, no-wrap
msgid "Handling streams"
msgstr "ストリームの取り扱い"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:340
msgid "So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages."
msgstr "これまでは、非同期の結果を返すだけでした。このセクションでは、複数のアイテムを伝えるストリームを使ってアプリケーションを拡張します。これらのストリームは Kafka や他のデータソースからのものでも構いませんが、物事をシンプルに保つために、定期的にグリーティングメッセージを生成するだけにします。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:342
msgid "In the `ReactiveGreetingService`, add the following method:"
msgstr "`ReactiveGreetingService` で、以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:350
#, no-wrap
msgid ""
"public Multi<String> greetings(int count, String name) {\n"
"  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .onItem().transform(n -> String.format(\"hello %s - %d\", name, n))\n"
"        .transform().byTakingFirstItems(count);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:353
msgid "you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements."
msgstr "`import io.smallrye.mutiny.Multi;` と `import java.time.Duration;` のステートメントを追加する必要があるかもしれません。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:355
msgid "It generates a greeting message every second and stops after `count` messages."
msgstr "1秒ごとに greeting メッセージを生成し、 `count` メッセージの後に停止します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:357
msgid "In the `ReactiveGreetingResource` add the following method:"
msgstr "`ReactiveGreetingResource` で、以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:366
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Path(\"/greeting/{count}/{name}\")\n"
"public Multi<String> greetings(int count, String name) {\n"
"  return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:370
msgid "This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters."
msgstr "このエンドポイントは、アイテムをJSON配列としてクライアントにストリームします。メッセージの名前と数は、パスパラメータを使用してパラメータ化されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:372
msgid "So calling the endpoint produces something like:"
msgstr "そのため、エンドポイントを呼び出すと、次のようなものが生成されます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:377
#, no-wrap
msgid ""
"$ curl http://localhost:8080/hello/greeting/3/neo\n"
"[\"hello neo - 0\", \"hello neo - 1\", \"hello neo - 2\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:380
msgid "We can also generate Server-Sent Event responses by returning a `Multi`:"
msgstr "また、 `Multi` を返すことで Server-Sent Event レスポンスを生成することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:390
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestSseElementType(MediaType.TEXT_PLAIN)\n"
"@Path(\"/stream/{count}/{name}\")\n"
"public Multi<String> greetingsAsStream(int count, String name) {\n"
"    return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:394
msgid "The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event."
msgstr "先ほどのスニペットとの違いは、生成される型と、各イベントの型を示す `@RestSseElementType` アノテーションだけです。 `@Produces` アノテーションは `SERVER_SENT_EVENTS` を定義しているので、JAX-RS は各（入れ子になった）イベントのコンテンツタイプを知るために必要です。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:396
msgid "You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement."
msgstr "`import org.jboss.resteasy.reactive.RestSseElementType;` の文を追加する必要があるかもしれません。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:398
msgid "You can see the result using:"
msgstr "以下で結果を見ることができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:403
#, no-wrap
msgid ""
"$ curl -N http://localhost:8080/hello/stream/5/neo\n"
"data: hello neo - 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:405
#, no-wrap
msgid "data: hello neo - 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:407
#, no-wrap
msgid "data: hello neo - 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:409
#, no-wrap
msgid "data: hello neo - 3\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:411
#, no-wrap
msgid "data: hello neo - 4\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:413
#, no-wrap
msgid "Using Reactive APIs"
msgstr "リアクティブ API の使用"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:415
#, no-wrap
msgid "Using Quarkus reactive APIs"
msgstr "QuarkusのリアクティブAPIを使用する"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:419
msgid "Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way."
msgstr "QuarkusはMutinyモデルを使用した多くのリアクティブAPIを提供しています。このセクションでは、リアクティブPostgreSQLドライバを使用して、ノンブロッキングでリアクティブな方法でデータベースと対話する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:421
msgid "Create a new project using:"
msgstr "以下で新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:431
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive-crud \\\n"
"    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-reactive,resteasy-reactive-jackson,reactive-pg-client\"\n"
"cd getting-started-reactive-crud\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:434
msgid "This application is interacting with a PostgreSQL database, so you need one:"
msgstr "このアプリケーションはPostgreSQLデータベースと対話しているので、DBが必要です。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:441
#, no-wrap
msgid ""
"docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n"
"           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n"
"           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n"
"           -p 5432:5432 postgres:11.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:445
msgid "Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:"
msgstr "続いて、データソースを設定してみましょう。 `src/main/resources/application.properties` を開き、以下の内容を追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:453
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n"
"myapp.schema.create=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:457
msgid "The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized."
msgstr "最初の3行はデータソースを定義しています。最後の行は、アプリケーションが初期化されたときにいくつかの項目を挿入するかどうかを示すためにアプリケーションで使用されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:460
msgid "Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:"
msgstr "では、 _エンティティを_ 作成しましょう。以下の内容で `org.acme.reactive.crud.Fruit` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:464
#: upstream/_guides/getting-started-reactive.adoc:538
#: upstream/_guides/getting-started-reactive.adoc:581
#, no-wrap
msgid "package org.acme.reactive.crud;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:471
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import io.vertx.mutiny.sqlclient.Row;\n"
"import io.vertx.mutiny.sqlclient.RowSet;\n"
"import io.vertx.mutiny.sqlclient.Tuple;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:473
#, no-wrap
msgid "import java.util.stream.StreamSupport;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:475
#, no-wrap
msgid "public class Fruit {\n"
msgstr "public class Fruit {\n"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:477
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:479
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:483
#, no-wrap
msgid ""
"    public Fruit() {\n"
"        // default constructor.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:487
#, no-wrap
msgid ""
"    public Fruit(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:492
#, no-wrap
msgid ""
"    public Fruit(Long id, String name) {\n"
"        this.id = id;\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:500
#, no-wrap
msgid ""
"    public static Multi<Fruit> findAll(PgPool client) {\n"
"        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute()\n"
"                // Create a Multi from the set of rows:\n"
"                .onItem().transformToMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n"
"                // For each row create a fruit instance\n"
"                .onItem().transform(Fruit::from);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:506
#, no-wrap
msgid ""
"    public static Uni<Fruit> findById(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(RowSet::iterator)\n"
"                .onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:511
#, no-wrap
msgid ""
"    public Uni<Long> save(PgPool client) {\n"
"        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\").execute(Tuple.of(name))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:516
#, no-wrap
msgid ""
"    public Uni<Boolean> update(PgPool client) {\n"
"        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\").execute(Tuple.of(name, id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:521
#, no-wrap
msgid ""
"    public static Uni<Boolean> delete(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:526
#, no-wrap
msgid ""
"    private static Fruit from(Row row) {\n"
"        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:532
msgid "This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects."
msgstr "この _エンティティに_ は、データベースから行を検索、更新、削除するためのいくつかのフィールドとメソッドが含まれています。これらのメソッドは、結果が取得されると非同期的に生成されるので、 `Unis` または `Multis` のいずれかを返します。反応型PostgreSQLクライアントは既に `Uni` と `Multi` のインスタンスを提供していることに注意してください。つまり、データベースからの結果を _ビジネスに適した_ オブジェクトに変換するだけです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:534
msgid "For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:"
msgstr "アプリケーションの起動時にデータベースを初期化する目的で、以下の内容の `DBInit` という名前のクラスを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:542
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:545
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:548
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class DBInit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:551
#, no-wrap
msgid ""
"    private final PgPool client;\n"
"    private final boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:556
#, no-wrap
msgid ""
"    public DBInit(PgPool client, @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\") boolean schemaCreate) {\n"
"        this.client = client;\n"
"        this.schemaCreate = schemaCreate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:562
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {\n"
"        if (schemaCreate) {\n"
"            initdb();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:573
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:577
msgid "Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:"
msgstr "次に、この `Fruit` クラスを `FruitResource` . `FruitResource` クラスを以下の内容に合わせて編集します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:583
#, no-wrap
msgid "import java.net.URI;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:595
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.PUT;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.ResponseBuilder;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:599
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:604
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:606
#, no-wrap
msgid "    private final PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:610
#, no-wrap
msgid ""
"    public FruitResource(PgPool client) {\n"
"        this.client = client;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:620
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:625
#, no-wrap
msgid ""
"    @GET\n"
"    public Multi<Fruit> get() {\n"
"        return Fruit.findAll(client);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:633
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> getSingle(Long id) {\n"
"        return Fruit.findById(client, id)\n"
"                .onItem().transform(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n"
"                .onItem().transform(ResponseBuilder::build);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:640
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<Response> create(Fruit fruit) {\n"
"        return fruit.save(client)\n"
"                .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n"
"                .onItem().transform(uri -> Response.created(uri).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:648
#, no-wrap
msgid ""
"    @PUT\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> update(Long id, Fruit fruit) {\n"
"        return fruit.update(client)\n"
"                .onItem().transform(updated -> updated ? Status.OK : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:657
#, no-wrap
msgid ""
"    @DELETE\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> delete(Long id) {\n"
"        return Fruit.delete(client, id)\n"
"                .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:660
msgid "This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class."
msgstr "このリソースは、 `Fruit` クラスが生成した結果に基づいて `Uni` と `Multi` のインスタンスを返します。"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:661
#, no-wrap
msgid "Using Vert.x clients"
msgstr "Vert.xクライアントの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:665
msgid "The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly."
msgstr "先ほどの例では、Quarkusが提供する _サービス_ を使用しています。また、Vert.xクライアントを直接使用することもできます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:667
msgid "First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:"
msgstr "まず、 `quarkus-vertx` の エクステンションが存在することを確認してください。存在しない場合は、以下のコマンドを実行して エクステンションを有効にします。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:672
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n"
"    -Dextensions=vertx\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:675
msgid "Or add `quarkus-vertx` into your dependencies manually."
msgstr "または、手動で `quarkus-vertx` を依存関係に追加してください。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:682
#, no-wrap
msgid ""
"<dependency>\n"
"\t<groupId>io.quarkus</groupId>\n"
"\t<artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:686
msgid "There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:"
msgstr "Vert.x APIのMutinyバージョンがあります。このAPIは独立してインポートできるいくつかのアーティファクトに分かれています。"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:688
#, fuzzy, no-wrap
msgid "groupId:artifactId"
msgstr "グループＩＤ：アーティファクトＩＤ"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:690
#, no-wrap
msgid "Description"
msgstr "説明"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:691
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-core`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-core`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:693
#, no-wrap
msgid "Mutiny API for Vert.x Core"
msgstr "Vert.x Core 用のMutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:694
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:696
#, no-wrap
msgid "Mutiny API for the Vert.x Mail Client"
msgstr "Vert.x メールクライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:697
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:699
#, no-wrap
msgid "Mutiny API for the Vert.x Web Client"
msgstr "Vert.x ウェブクライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:700
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:702
#, no-wrap
msgid "Mutiny API for the Vert.x Mongo Client"
msgstr "Vert.x Mongo クライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:703
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:705
#, no-wrap
msgid "Mutiny API for the Vert.x Redis Client"
msgstr "Vert.x Redis クライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:706
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:708
#, no-wrap
msgid "Mutiny API for the Vert.x Cassandra Client"
msgstr "Vert.x Cassandraクライアント用のMutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:709
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:711
#, no-wrap
msgid "Mutiny API for the Vert.x Consul Client"
msgstr "Vert.x Consul クライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:712
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:714
#, no-wrap
msgid "Mutiny API for the Vert.x Kafka Client"
msgstr "Vert.x Kafka クライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:715
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:717
#, no-wrap
msgid "Mutiny API for the Vert.x AMQP Client"
msgstr "Vert.x AMQP クライアント用の Mutiny API"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:718
#, fuzzy, no-wrap
msgid "`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`"
msgstr "`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:719
#, no-wrap
msgid "Mutiny API for the Vert.x RabbitMQ Client"
msgstr "Vert.x RabbitMQクライアント用のMutiny API"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:722
msgid "You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/."
msgstr "また、 http://smallrye.io/smallrye-reactive-utils/apidocs/ で利用可能な API を確認できます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:725
msgid "Let's take an example.  Add the following dependency to your application:"
msgstr "例を挙げてみましょう。以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:732
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:736
msgid "It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:"
msgstr "Vert.x Web ClientのMutiny APIを提供します。すると、以下のようにWebクライアントを利用することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:740
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:747
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:754
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:757
#, no-wrap
msgid ""
"@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:760
#, no-wrap
msgid ""
"    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:762
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:769
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:786
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .map(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:788
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:791
msgid "There are 2 important points:"
msgstr "重要なポイントは2つあります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:793
msgid "The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;"
msgstr "インジェクションされた Vert.x インスタンスは、Vert.x の Mutiny バリアントである `io.vertx.mutiny.core.Vertx` タイプを持っています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:794
msgid "The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`."
msgstr "Web クライアントは `io.vertx.mutiny.ext.web.client.WebClient` から作成されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:796
msgid "The Mutiny version of the Vert.x APIs also offers:"
msgstr "Vert.x APIのMutinyバージョンも提供しています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:799
msgid "`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way."
msgstr "`sendAndAwait` . `andAwait` のような `andAwait` メソッドは、結果が得られるまで呼び出し元のスレッドがブロックされていることを示しています。そのような方法でイベントループ/IOスレッドをブロックしないように注意してください。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:803
msgid "`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription."
msgstr "`andForget` `writeAndForget` のような `Uni` を返すメソッドが利用可能です。`andForget` は操作の成否を示す結果の `Uni` を必要としないことを示しています。しかし、サブスクライブしないと操作が発動しないことを覚えておいてください。`andForget` はこれを管理してくれるうえに、サブスクリプションも管理します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:804
msgid "`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`"
msgstr "`toMulti` メソッドは Vert.x `ReadStream` を `Multi` に変換できます"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:805
msgid "`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`"
msgstr "`toBlockingIterable` / `toBlockingStream` メソッドは、Vert.x `ReadStream` をブロッキング可能な iterable またはブロッキング可能な `java.util.Stream` に変換することができます。 "

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:806
#, no-wrap
msgid "Using RxJava or Reactor APIs"
msgstr "RxJavaやReactor APIを使う"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:809
msgid "Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`."
msgstr "Mutiny は RxJava 2 と Project Reactor の型を `Uni` と `Multi` に変換するユーティリティを提供します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:811
msgid "RxJava 2 converters are available in the following dependency:"
msgstr "RxJava 2のコンバータは以下の依存関係にあります。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:818
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-rxjava</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:821
msgid "So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:"
msgstr "そこで、RxJava 2 の型を返す API ( `Completable` , `Single` , `Maybe` , `Observable` , `Flowable` ) を持っている場合は、以下のように `Unis` と `Multis` を作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:833
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniRxConverters;\n"
"// ...\n"
"Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n"
"Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n"
"Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n"
"Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n"
"Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n"
"Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:840
#, no-wrap
msgid ""
"Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n"
"Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n"
"Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n"
"Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n"
"Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n"
"Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:843
msgid "You can also transform `Unis` and `Multis` into RxJava types:"
msgstr "`Unis` と `Multis` を RxJava 型に変換することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:860
#, no-wrap
msgid ""
"Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n"
"Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n"
"Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n"
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n"
"Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n"
"// ...\n"
"Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n"
"Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n"
"Single<String> single2 = multi.convert().with(MultiRxConverters\n"
"        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n"
"Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n"
"Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n"
"Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:863
msgid "Project Reactor converters are available in the following dependency:"
msgstr "Project Reactorコンバータは、以下の依存関係で利用できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:870
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-reactor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:873
msgid "So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:"
msgstr "そこで、Reactorの型を返すAPI( `Mono` , `Flux` )を持っている場合は、以下のように `Unis` と `Multis` を作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:881
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n"
"// ...\n"
"Uni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters.fromMono(), mono);\n"
"Uni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:884
#, no-wrap
msgid ""
"Multi<String> multiFromMono = Multi.createFrom().converter(MultiReactorConverters.fromMono(), mono);\n"
"Multi<String> multiFromFlux = Multi.createFrom().converter(MultiReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:887
msgid "You can also transform `Unis` and `Multis` into Reactor types:"
msgstr "また、 `Unis` と `Multis` を Reactor タイプに変換することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:892
#, no-wrap
msgid ""
"Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\n"
"Flux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:895
#, no-wrap
msgid ""
"Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\n"
"Flux<String> flux2 = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:897
#, no-wrap
msgid "Using CompletionStages or Publisher API"
msgstr "CompletionStagesまたはPublisher APIを使用する"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:901
msgid "If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier<CompletionStage>`. For example:"
msgstr "`CompletionStage` , `CompletableFuture` , `Publisher` を使った API に対面している場合、双方向に変換することができます。まず、 `Uni` も `Multi` も `CompletionStage` から作成することも、 `Supplier<CompletionStage>` から作成することもできます。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:907
#, no-wrap
msgid ""
"CompletableFuture<String> future = Uni\n"
"        // Create from a Completion Stage\n"
"        .createFrom().completionStage(CompletableFuture.supplyAsync(() -> \"hello\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:910
msgid "On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`."
msgstr "`Uni` 上で、あなたはまた、 `subscribeAsCompletionStage()` を使用して `CompletionStage` を生成することができます。 `Uni` によって放出されたアイテムまたは障害を取得するだろう `CompletionStage` を生成します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:914
msgid "You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`."
msgstr "`createFrom().publisher(Publisher)` を使って `Unis` と `Multis` を `Publisher` のインスタンスから作成することもできます。 `Uni` を `toMulti` を使って `Publisher` に変換することもできます。実際、 `Multi` は `Publisher` を実装しています。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:915
#, no-wrap
msgid "What's next?"
msgstr "次のステップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:920
msgid "This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:"
msgstr "このガイドでは、Quarkusでのリアクティブについて紹介します。Quarkusの機能の中には、すでにリアクティブになっているものがたくさんあります。以下のリストでは、いくつかの例を紹介します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:922
msgid "link:rest-json#reactive[Using Mutiny with RestEasy]"
msgstr "link:rest-json#reactive[RestEasyでMutinyを使用する]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:923
msgid "link:mailer[Sending email]"
msgstr "link:mailer[メール送信]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:924
msgid "link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]"
msgstr "link:mongodb#reactive[MongoDB] と link:mongodb-panache#reactive[MongoDBをPanacheで] link:mongodb#reactive[使う]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:925
msgid "link:reactive-sql-clients[Reactive Database Clients]"
msgstr "link:reactive-sql-clients[リアクティブデータベースクライアント]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:926
msgid "link:vertx[Using Vert.x]"
msgstr "link:vertx[Vert.xの使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:927
msgid "link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"
msgstr "link:kafka[Kafkaとの] インタラクションと link:amqp[AMQPとのインタラクション]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:neo4j#reactive[Using Neo4J]"
msgstr "link:neo4j#reactive[Neo4Jの使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:reactive-routes[Using reactive routes]"
msgstr "link:reactive-routes[リアクティブルートの使用]"
