# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-05 12:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka-streams.adoc:6
#, fuzzy, no-wrap
msgid "Quarkus - Using Apache Kafka Streams"
msgstr "Quarkus - Apache Kafkaストリームの使用"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:11
msgid "This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka."
msgstr "このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:12
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:15
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下が必要です:"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:17
#, fuzzy
msgid "less than 30 minutes"
msgstr "三十分以内"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:18
msgid "an IDE"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:19
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:20
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:21
#, fuzzy
msgid "Docker Compose to start an Apache Kafka development cluster"
msgstr "Docker ComposeでApache Kafka開発クラスターを起動する"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:22
#, fuzzy
msgid "GraalVM installed if you want to run in native mode."
msgstr "ネイティブモードで動作させたい場合は、GraalVMをインストールします。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:24
#, fuzzy
msgid "It is recommended, that you have read the {quickstarts-tree-url}/kafka-quickstart[Kafka quickstart] before."
msgstr "事前に{quickstarts-tree-url}/kafka-quickstart[Kafka quickstart]を読んでおくことをお勧めします。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:29
#, fuzzy
msgid "The Quarkus extension for Kafka Streams allows for very fast turnaround times during development by supporting the Quarkus Dev Mode (e.g. via `./mvnw compile quarkus:dev`).  After changing the code of your Kafka Streams topology, the application will automatically be reloaded when the next input message arrives."
msgstr "Kafka Streams用のQuarkus拡張機能を使用すると、Quarkus Dev Modeをサポートすることで、開発期間を非常に短縮することができます(例: `./mvnw compile quarkus:dev` を参照)。Kafka Streamsトポロジーのコードを変更した後、次の入力メッセージが到着すると、アプリケーションが自動的にリロードされます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:32
#, fuzzy
msgid "A recommended development set-up is to have some producer which creates test messages on the processed topic(s) in fixed intervals, e.g. every second and observe the streaming application's output topic(s) using a tool such as `kafkacat`.  Using the dev mode, you'll instantly see messages on the output topic(s) as produced by the latest version of your streaming application when saving."
msgstr "推奨される開発セットアップは、処理されたトピックに対して一定の間隔 (たとえば毎秒) でテストメッセージを作成するプロデューサを用意し、 `kafkacat` のようなツールを使用してストリーミング アプリケーションの出力トピックを観察することです。開発モードを使用すると、保存時にストリーミングアプリケーションの最新バージョンによって生成された出力トピッ ク上のメッセージを即座に見ることができます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:34
#, fuzzy
msgid "For the best development experience, we recommend applying the following configuration settings to your Kafka broker:"
msgstr "最高の開発環境を実現するために、以下の設定を Kafka ブローカーに適用することをお勧めします。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:38
#, no-wrap
msgid "group.min.session.timeout.ms=250\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:41
#, fuzzy
msgid "Also specify the following settings in your Quarkus `application.properties`:"
msgstr "また、以下の設定をQuarkusで指定します `application.properties` ."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:46
#, no-wrap
msgid ""
"kafka-streams.consumer.session.timeout.ms=250\n"
"kafka-streams.consumer.heartbeat.interval.ms=200\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:49
#, fuzzy
msgid "Together, these settings will ensure that the application can very quickly reconnect to the broker after being restarted in dev mode."
msgstr "これらの設定を併用することで、アプリケーションを開発モードで再起動した後に、非常に迅速にブローカに再接続できるようになります。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka-streams.adoc:51
#: upstream/_guides/kafka-streams.adoc:69
#: upstream/_guides/kafka-streams.adoc:811
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:56
#, fuzzy
msgid "In this guide, we are going to generate (random) temperature values in one component (named `generator`).  These values are associated to given weather stations and are written in a Kafka topic (`temperature-values`).  Another topic (`weather-stations`) contains just the master data about the weather stations themselves (id and name)."
msgstr "このガイドでは、(ランダムな)温度値を 1 つのコンポーネント ( `generator` ) で生成します。これらの値は、与えられた気象観測所に関連付けられ、Kafka トピック ( `temperature-values` ) に書き込まれます。別のトピック ( `weather-stations` ) には、気象観測所自体に関するマスターデータ (id と名前) だけが格納されています。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:58
#, fuzzy
msgid "A second component (`aggregator`) reads from the two Kafka topics and processes them in a streaming pipeline:"
msgstr "2 つ目のコンポーネント ( `aggregator` ) は、2 つの Kafka トピックから読み込み、ストリーミングパイプラインで処理します。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:60
#, fuzzy
msgid "the two topics are joined on weather station id"
msgstr "ウェザーステーションIDでは、この2つのトピックが結合されています。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:61
#, fuzzy
msgid "per weather station the min, max and average temperature is determined"
msgstr "各気象台ごとに最低、最高、平均気温が決定されます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:62
#, fuzzy
msgid "this aggregated data is written out to a third topic (`temperatures-aggregated`)"
msgstr "この集約されたデータは、第三のトピック ( `temperatures-aggregated` ) に書き出されます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:66
#, fuzzy
msgid "The data can be examined by inspecting the output topic.  By exposing a Kafka Streams https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html[interactive query], the latest result for each weather station can alternatively be obtained via a simple REST query."
msgstr "出力トピックを検査することで、データを調べることができます。Kafka Streams の link:https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html[対話型クエリを] 公開することで、各気象観測所の最新の結果を単純な REST クエリで取得することができます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:68
#, fuzzy
msgid "The overall architecture looks like so:"
msgstr "全体的な建築はこんな感じです。"

#. type: Target for macro image
#: upstream/_guides/kafka-streams.adoc:69
#, no-wrap
msgid "kafka-streams-guide-architecture.png"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:71
#, fuzzy, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:75
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:77
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:79
#, fuzzy
msgid "The solution is located in the `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-quickstart[directory]."
msgstr "ソリューションは `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:80
#, fuzzy, no-wrap
msgid "Creating the Producer Maven Project"
msgstr "Producer Maven プロジェクトの作成"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:84
#, fuzzy
msgid "First, we need a new project with the temperature value producer.  Create a new project with the following command:"
msgstr "まず、温度値プロデューサを持つ新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:93
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-streams-quickstart-producer \\\n"
"    -Dextensions=\"kafka\" \\\n"
"    -DnoExamples \\\n"
"    && mv kafka-streams-quickstart-producer producer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:96
#, fuzzy
msgid "This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions."
msgstr "このコマンドは、Reactive Messaging と Kafka コネクタ拡張をインポートして Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:99
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:"
msgstr "すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-reactive-messaging-kafka` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:103
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"quarkus-smallrye-reactive-messaging-kafka\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:106
#: upstream/_guides/kafka-streams.adoc:260
msgid "This will add the following to your `pom.xml`:"
msgstr "これにより、 `pom.xml` に以下が追加されます:"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:113
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:115
#, fuzzy, no-wrap
msgid "The Temperature Value Producer"
msgstr "温度値プロデューサー"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:119
#, fuzzy
msgid "Create the `producer/src/main/java/org/acme/kafka/streams/producer/generator/ValuesGenerator.java` file, with the following content:"
msgstr "以下の内容の `producer/src/main/java/org/acme/kafka/streams/producer/generator/ValuesGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:123
#, no-wrap
msgid "package org.acme.kafka.streams.producer.generator;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:132
#, no-wrap
msgid ""
"import java.math.BigDecimal;\n"
"import java.math.RoundingMode;\n"
"import java.time.Duration;\n"
"import java.time.Instant;\n"
"import java.util.Arrays;\n"
"import java.util.Collections;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:134
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr "import javax.enterprise.context.ApplicationScoped;\n"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:139
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.reactive.messaging.kafka.Record;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:148
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random temperature data every second.\n"
" * The values are written to a Kafka topic (temperature-values).\n"
" * Another topic contains the name of weather stations (weather-stations).\n"
" * The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class ValuesGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:150
#, no-wrap
msgid "    private static final Logger LOG = Logger.getLogger(ValuesGenerator.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:152
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr "    private Random random = new Random();\n"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:165
#, no-wrap
msgid ""
"    private List<WeatherStation> stations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                    new WeatherStation(1, \"Hamburg\", 13),\n"
"                    new WeatherStation(2, \"Snowdonia\", 5),\n"
"                    new WeatherStation(3, \"Boston\", 11),\n"
"                    new WeatherStation(4, \"Tokio\", 16),\n"
"                    new WeatherStation(5, \"Cusco\", 12),\n"
"                    new WeatherStation(6, \"Svalbard\", -7),\n"
"                    new WeatherStation(7, \"Porthsmouth\", 11),\n"
"                    new WeatherStation(8, \"Oslo\", 7),\n"
"                    new WeatherStation(9, \"Marrakesh\", 20)\n"
"            ));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:175
#, no-wrap
msgid ""
"    @Outgoing(\"temperature-values\")                                        // <1>\n"
"    public Multi<Record<Integer, String>> generate() {\n"
"        return Multi.createFrom().ticks().every(Duration.ofMillis(500))    // <2>\n"
"                .onOverflow().drop()\n"
"                .map(tick -> {\n"
"                    WeatherStation station = stations.get(random.nextInt(stations.size()));\n"
"                    double temperature = BigDecimal.valueOf(random.nextGaussian() * 15 + station.averageTemperature)\n"
"                            .setScale(1, RoundingMode.HALF_UP)\n"
"                            .doubleValue();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:180
#, no-wrap
msgid ""
"                    LOG.infov(\"station: {0}, temperature: {1}\", station.name, temperature);\n"
"                    return Record.of(station.id, Instant.now() + \";\" + temperature);\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:190
#, no-wrap
msgid ""
"    @Outgoing(\"weather-stations\")                                          // <3>\n"
"    public Multi<Record<Integer, String>> weatherStations() {\n"
"        return Multi.createFrom().items(stations.stream()\n"
"            .map(s -> Record.of(\n"
"                    s.id,\n"
"                    \"{ \\\"id\\\" : \" + s.id +\n"
"                    \", \\\"name\\\" : \\\"\" + s.name + \"\\\" }\"))\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:192
#, no-wrap
msgid "    private static class WeatherStation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:196
#, no-wrap
msgid ""
"        int id;\n"
"        String name;\n"
"        int averageTemperature;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:204
#, no-wrap
msgid ""
"        public WeatherStation(int id, String name, int averageTemperature) {\n"
"            this.id = id;\n"
"            this.name = name;\n"
"            this.averageTemperature = averageTemperature;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:206
#, fuzzy
msgid "Instruct Reactive Messaging to dispatch the items from the returned `Multi` to `temperature-values`."
msgstr "返却された `Multi` から `temperature-values` にアイテムを発送するように Reactive Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:207
#, fuzzy
msgid "The method returns a Mutiny _stream_ (`Multi`) emitting a random temperature value every 0.5 seconds."
msgstr "このメソッドは、0.5 秒ごとにランダムな温度値を放出する Mutiny _ストリーム_ ( `Multi` ) を返します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:208
#, fuzzy
msgid "Instruct Reactive Messaging to dispatch the items from the returned `Multi` (static list of weather stations) to `weather-stations`."
msgstr "返された `Multi` (気象観測所の静的リスト) から `weather-stations` にアイテムをディスパッチするように、Reactive Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:210
#, fuzzy
msgid "The two methods each return a _reactive stream_ whose items are sent to the streams named `temperature-values` and `weather-stations`, respectively."
msgstr "この 2 つのメソッドは、それぞれ `temperature-values` と `weather-stations` という名前のストリームにアイテムが送信される _反応型ストリーム_ を返します。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:211
#, fuzzy, no-wrap
msgid "Topic Configuration"
msgstr "トピック構成"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:215
#, fuzzy
msgid "The two channels are mapped to Kafka topics using the Quarkus configuration file `application.properties`.  For that, add the following to the file `producer/src/main/resources/application.properties`:"
msgstr "2つのチャンネルは、Quarkus設定ファイル `application.properties` を使用してKafkaトピックにマッピングされます。そのためには、ファイル `producer/src/main/resources/application.properties` に次のように追加します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:220
#, no-wrap
msgid ""
"# Configure the Kafka broker location\n"
"kafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:224
#, no-wrap
msgid ""
"mp.messaging.outgoing.temperature-values.connector=smallrye-kafka\n"
"mp.messaging.outgoing.temperature-values.key.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.temperature-values.value.serializer=org.apache.kafka.common.serialization.StringSerializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:228
#, no-wrap
msgid ""
"mp.messaging.outgoing.weather-stations.connector=smallrye-kafka\n"
"mp.messaging.outgoing.weather-stations.key.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.weather-stations.value.serializer=org.apache.kafka.common.serialization.StringSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:232
#, fuzzy
msgid "This configures the Kafka bootstrap server, the two topics and the corresponding (de-)serializers.  More details about the different configuration options are available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation."
msgstr "これは、Kafka ブートストラップサーバー、2 つのトピック、および対応する (脱)シリアライザを設定します。さまざまな設定オプションの詳細については、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:233
#, fuzzy, no-wrap
msgid "Creating the Aggregator Maven Project"
msgstr "アグリゲータMavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:238
#, fuzzy
msgid "With the producer application in place, it's time to implement the actual aggregator application, which will run the Kafka Streams pipeline.  Create another project like so:"
msgstr "プロデューサアプリケーションを用意したら、Kafka Streams パイプラインを実行するアグリゲータアプリケーションを実装しましょう。このように別のプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:247
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-streams-quickstart-aggregator \\\n"
"    -Dextensions=\"resteasy,kafka-streams,resteasy-jackson\" \\\n"
"    -DnoExamples \\\n"
"    && mv kafka-streams-quickstart-aggregator aggregator\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:250
#, fuzzy
msgid "This creates the `aggregator` project with the Quarkus extension for Kafka Streams and with RESTEasy support for Jackson."
msgstr "これにより、Kafka Streams用のQuarkus拡張機能とJackson用のRESTEasyサポートを備えた `aggregator` プロジェクトが作成されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:253
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add the `kafka-streams` extension to your project by running the following command in your project base directory:"
msgstr "すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `kafka-streams` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:257
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"kafka-streams\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:267
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-kafka-streams</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:269
#, fuzzy, no-wrap
msgid "The Pipeline Implementation"
msgstr "パイプラインの実装"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:273
#, fuzzy
msgid "Let's begin the implementation of the stream processing application by creating a few value objects for representing temperature measurements, weather stations and for keeping track of aggregated values."
msgstr "ストリーム処理アプリケーションの実装を開始しましょう。温度測定、気象観測所を表現し、集約された値を追跡するためのいくつかの値オブジェクトを作成することから始めましょう。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:276
#, fuzzy
msgid "First, create the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStation.java`, representing a weather station, with the following content:"
msgstr "まず、次の内容で、ファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStation.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:280
#: upstream/_guides/kafka-streams.adoc:298
#: upstream/_guides/kafka-streams.adoc:324
#: upstream/_guides/kafka-streams.adoc:686
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.model;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:282
#: upstream/_guides/kafka-streams.adoc:329
#: upstream/_guides/kafka-streams.adoc:688
#, no-wrap
msgid "import io.quarkus.runtime.annotations.RegisterForReflection;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:285
#, no-wrap
msgid ""
"@RegisterForReflection // <1>\n"
"public class WeatherStation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:289
#, no-wrap
msgid ""
"    public int id;\n"
"    public String name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:291
#, fuzzy
msgid "By adding the `@RegisterForReflection` annotation, it is ensured that this type can be instantiated reflectively when running the application in native mode."
msgstr "`@RegisterForReflection` アノテーションを追加することで、ネイティブモードでアプリケーションを実行しているときに、この型が反射的にインスタンス化されることが保証されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:294
#, fuzzy
msgid "Then the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/TemperatureMeasurement.java`, representing temperature measurements for a given station:"
msgstr "次に、指定されたステーションの温度測定値を表すファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/TemperatureMeasurement.java` 。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:300
#: upstream/_guides/kafka-streams.adoc:367
#, no-wrap
msgid "import java.time.Instant;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:302
#, no-wrap
msgid "public class TemperatureMeasurement {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:307
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public Instant timestamp;\n"
"    public double value;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:316
#, no-wrap
msgid ""
"    public TemperatureMeasurement(int stationId, String stationName, Instant timestamp,\n"
"            double value) {\n"
"        this.stationId = stationId;\n"
"        this.stationName = stationName;\n"
"        this.timestamp = timestamp;\n"
"        this.value = value;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:320
#, fuzzy
msgid "And finally `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/Aggregation.java`, which will be used to keep track of the aggregated values while the events are processed in the streaming pipeline:"
msgstr "そして最後に `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/Aggregation.java` 、イベントがストリーミング・パイプラインで処理されている間、集約された値を追跡するために使用されます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:327
#, no-wrap
msgid ""
"import java.math.BigDecimal;\n"
"import java.math.RoundingMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:332
#, no-wrap
msgid ""
"@RegisterForReflection\n"
"public class Aggregation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:340
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public double min = Double.MAX_VALUE;\n"
"    public double max = Double.MIN_VALUE;\n"
"    public int count;\n"
"    public double sum;\n"
"    public double avg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:344
#, no-wrap
msgid ""
"    public Aggregation updateFrom(TemperatureMeasurement measurement) {\n"
"        stationId = measurement.stationId;\n"
"        stationName = measurement.stationName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:349
#, no-wrap
msgid ""
"        count++;\n"
"        sum += measurement.value;\n"
"        avg = BigDecimal.valueOf(sum / count)\n"
"                .setScale(1, RoundingMode.HALF_UP).doubleValue();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:352
#, no-wrap
msgid ""
"        min = Math.min(min, measurement.value);\n"
"        max = Math.max(max, measurement.value);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:356
#, no-wrap
msgid ""
"        return this;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:361
#, fuzzy
msgid "Next, let's create the actual streaming query implementation itself in the `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/TopologyProducer.java` file.  All we need to do for that is to declare a CDI producer method which returns the Kafka Streams `Topology`; the Quarkus extension will take care of configuring, starting and stopping the actual Kafka Streams engine."
msgstr "次に、実際のストリーミングクエリの実装自体を `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/TopologyProducer.java` ファイルで作成してみましょう。そのために必要なのは、Kafka Streams `Topology` を返す CDI プロデューサメソッドを宣言することだけです。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:365
#: upstream/_guides/kafka-streams.adoc:602
#: upstream/_guides/kafka-streams.adoc:649
#: upstream/_guides/kafka-streams.adoc:873
#: upstream/_guides/kafka-streams.adoc:927
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.streams;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:370
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:383
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.model.Aggregation;\n"
"import org.acme.kafka.streams.aggregator.model.TemperatureMeasurement;\n"
"import org.acme.kafka.streams.aggregator.model.WeatherStation;\n"
"import org.apache.kafka.common.serialization.Serdes;\n"
"import org.apache.kafka.streams.StreamsBuilder;\n"
"import org.apache.kafka.streams.Topology;\n"
"import org.apache.kafka.streams.kstream.Consumed;\n"
"import org.apache.kafka.streams.kstream.GlobalKTable;\n"
"import org.apache.kafka.streams.kstream.Materialized;\n"
"import org.apache.kafka.streams.kstream.Produced;\n"
"import org.apache.kafka.streams.state.KeyValueBytesStoreSupplier;\n"
"import org.apache.kafka.streams.state.Stores;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:385
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperSerde;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:388
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class TopologyProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:390
#, no-wrap
msgid "    static final String WEATHER_STATIONS_STORE = \"weather-stations-store\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:394
#, no-wrap
msgid ""
"    private static final String WEATHER_STATIONS_TOPIC = \"weather-stations\";\n"
"    private static final String TEMPERATURE_VALUES_TOPIC = \"temperature-values\";\n"
"    private static final String TEMPERATURES_AGGREGATED_TOPIC = \"temperatures-aggregated\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:398
#, no-wrap
msgid ""
"    @Produces\n"
"    public Topology buildTopology() {\n"
"        StreamsBuilder builder = new StreamsBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:402
#, no-wrap
msgid ""
"        ObjectMapperSerde<WeatherStation> weatherStationSerde = new ObjectMapperSerde<>(\n"
"                WeatherStation.class);\n"
"        ObjectMapperSerde<Aggregation> aggregationSerde = new ObjectMapperSerde<>(Aggregation.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:405
#, no-wrap
msgid ""
"        KeyValueBytesStoreSupplier storeSupplier = Stores.persistentKeyValueStore(\n"
"                WEATHER_STATIONS_STORE);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:409
#, no-wrap
msgid ""
"        GlobalKTable<Integer, WeatherStation> stations = builder.globalTable( // <1>\n"
"                WEATHER_STATIONS_TOPIC,\n"
"                Consumed.with(Serdes.Integer(), weatherStationSerde));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:436
#, no-wrap
msgid ""
"        builder.stream(                                                       // <2>\n"
"                        TEMPERATURE_VALUES_TOPIC,\n"
"                        Consumed.with(Serdes.Integer(), Serdes.String())\n"
"                )\n"
"                .join(                                                        // <3>\n"
"                        stations,\n"
"                        (stationId, timestampAndValue) -> stationId,\n"
"                        (timestampAndValue, station) -> {\n"
"                            String[] parts = timestampAndValue.split(\";\");\n"
"                            return new TemperatureMeasurement(station.id, station.name,\n"
"                                    Instant.parse(parts[0]), Double.valueOf(parts[1]));\n"
"                        }\n"
"                )\n"
"                .groupByKey()                                                 // <4>\n"
"                .aggregate(                                                   // <5>\n"
"                        Aggregation::new,\n"
"                        (stationId, value, aggregation) -> aggregation.updateFrom(value),\n"
"                        Materialized.<Integer, Aggregation> as(storeSupplier)\n"
"                            .withKeySerde(Serdes.Integer())\n"
"                            .withValueSerde(aggregationSerde)\n"
"                )\n"
"                .toStream()\n"
"                .to(                                                          // <6>\n"
"                        TEMPERATURES_AGGREGATED_TOPIC,\n"
"                        Produced.with(Serdes.Integer(), aggregationSerde)\n"
"                );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:440
#, no-wrap
msgid ""
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:442
#, fuzzy
msgid "The `weather-stations` table is read into a `GlobalKTable`, representing the current state of each weather station"
msgstr "`weather-stations` テーブルは、各気象台の現在の状態を表す `GlobalKTable` に読み込まれます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:443
#, fuzzy
msgid "The `temperature-values` topic is read into a `KStream`; whenever a new message arrives to this topic, the pipeline will be processed for this measurement"
msgstr "`temperature-values` トピックは `KStream` に読み込まれます。このトピックに新しいメッセージが到着するたびに、パイプラインはこの測定のために処理されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:444
#, fuzzy
msgid "The message from the `temperature-values` topic is joined with the corresponding weather station, using the topic's key (weather station id); the join result contains the data from the measurement and associated weather station message"
msgstr "`temperature-values` トピックからのメッセージは、トピックのキー (ウェザーステーション ID) を使用して、対応するウェザーステーションと結合されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:445
#, fuzzy
msgid "The values are grouped by message key (the weather station id)"
msgstr "値はメッセージキー(ウェザーステーションID)によってグループ化されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:446
#, fuzzy
msgid "Within each group, all the measurements of that station are aggregated, by keeping track of minimum and maximum values and calculating the average value of all measurements of that station (see the `Aggregation` type)"
msgstr "各グループ内では、最小値と最大値を追跡し、そのステーションのすべての測定値の平均値を計算することで、そのステーションのすべての測定値が集約されます( `Aggregation` タイプを参照)。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:447
#, fuzzy
msgid "The results of the pipeline are written out to the `temperatures-aggregated` topic"
msgstr "パイプラインの結果は `temperatures-aggregated` トピックに書き出しています。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:450
#, fuzzy
msgid "The Kafka Streams extension is configured via the Quarkus configuration file `application.properties`.  Create the file `aggregator/src/main/resources/application.properties` with the following contents:"
msgstr "Kafka Streamsの拡張子は、Quarkusの設定ファイル `application.properties` で設定します。ファイル `aggregator/src/main/resources/application.properties` を以下の内容で作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:456
#, no-wrap
msgid ""
"quarkus.kafka-streams.bootstrap-servers=localhost:9092\n"
"quarkus.kafka-streams.application-server=${hostname}:8080\n"
"quarkus.kafka-streams.topics=weather-stations,temperature-values\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:463
#, no-wrap
msgid ""
"# pass-through options\n"
"kafka-streams.cache.max.bytes.buffering=10240\n"
"kafka-streams.commit.interval.ms=1000\n"
"kafka-streams.metadata.max.age.ms=500\n"
"kafka-streams.auto.offset.reset=earliest\n"
"kafka-streams.metrics.recording.level=DEBUG\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:470
#, fuzzy
msgid "The options with the `quarkus.kafka-streams` prefix can be changed dynamically at application startup, e.g. via environment variables or system properties.  `bootstrap-servers` and `application-server` are mapped to the Kafka Streams properties `bootstrap.servers` and `application.server`, respectively.  `topics` is specific to Quarkus: the application will wait for all the given topics to exist before launching the Kafka Streams engine.  This is to done to gracefully await the creation of topics that don't yet exist at application startup time."
msgstr "`quarkus.kafka-streams` `bootstrap-servers` と は、それぞれ Kafka Streams プロパティー と にマップされます。 は Quarkus に固有のもので、アプリケーションは Kafka Streams エンジンを起動する前に、指定したすべてのトピックが存在するのを待ちます。これは、アプリケーションの起動時にまだ存在しないトピックの作成を優雅に待つために行われます。 `application-server` `bootstrap.servers` `application.server` `topics`"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:472
#, fuzzy
msgid "Alternatively, you can use `kafka.bootstrap.servers` instead of `quarkus.kafka-streams.bootstrap-servers` as you did in the _generator_ project above."
msgstr "あるいは、上記の _ジェネレーター・プロジェクト_ で行ったように、 `quarkus.kafka-streams.bootstrap-servers` の代わりに `kafka.bootstrap.servers` を使用することもできます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:475
#, fuzzy
msgid "All the properties within the `kafka-streams` namespace are passed through as-is to the Kafka Streams engine.  Changing their values requires a rebuild of the application."
msgstr "`kafka-streams` ネームスペース内のすべてのプロパティーは、そのまま Kafka Streams エンジンに渡されます。プロパティーの値を変更するには、アプリケーションの再構築が必要です。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:476
#, fuzzy, no-wrap
msgid "Building and Running the Applications"
msgstr "アプリケーションの構築と実行"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:479
#, fuzzy
msgid "We now can build the `producer` and `aggregator` applications:"
msgstr "`producer` と `aggregator` のアプリケーションを構築できるようになりました。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:484
#, no-wrap
msgid ""
"./mvnw clean package -f producer/pom.xml\n"
"./mvnw clean package -f aggregator/pom.xml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:489
#, fuzzy
msgid "Instead of running them directly on the host machine using the Quarkus dev mode, we're going to package them into container images and launch them via Docker Compose.  This is done in order to demonstrate scaling the `aggregator` aggregation to multiple nodes later on."
msgstr "Quarkusのdevモードを使ってホストマシン上で直接実行するのではなく、コンテナーイメージにパッケージ化してDocker Compose経由で起動します。これは、後で `aggregator` のアグリゲーションを複数のノードにスケーリングすることを実証するために行います。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:492
#, fuzzy
msgid "The `Dockerfile` created by Quarkus by default needs one adjustment for the `aggregator` application in order to run the Kafka Streams pipeline.  To do so, edit the file `aggregator/src/main/docker/Dockerfile.jvm` and replace the line `FROM fabric8/java-alpine-openjdk8-jre` with `FROM fabric8/java-centos-openjdk8-jdk`."
msgstr "Quarkusがデフォルトで作成した `Dockerfile` は、Kafka Streamsパイプラインを実行するために、 `aggregator` アプリケーションに1つの調整が必要です。そのためには、 `aggregator/src/main/docker/Dockerfile.jvm` ファイルを編集して、 `FROM fabric8/java-alpine-openjdk8-jre` の行を `FROM fabric8/java-centos-openjdk8-jdk` に置き換えます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:494
#, fuzzy
msgid "Next create a Docker Compose file (`docker-compose.yaml`) for spinning up the two applications as well as Apache Kafka and ZooKeeper like so:"
msgstr "次に、2 つのアプリケーションを回転させるための Docker Compose ファイル ( `docker-compose.yaml` ) を作成し、Apache Kafka と ZooKeeper と同様に以下のようにします。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:498
#, no-wrap
msgid "version: '3.5'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:530
#, no-wrap
msgid ""
"services:\n"
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
"    networks:\n"
"      - kafkastreams-network\n"
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT} --override num.partitions=$${KAFKA_NUM_PARTITIONS}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
"      KAFKA_NUM_PARTITIONS: 3\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:540
#, no-wrap
msgid ""
"  producer:\n"
"    image: quarkus-quickstarts/kafka-streams-producer:1.0\n"
"    build:\n"
"      context: producer\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      KAFKA_BOOTSTRAP_SERVERS: kafka:9092\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:550
#, no-wrap
msgid ""
"  aggregator:\n"
"    image: quarkus-quickstarts/kafka-streams-aggregator:1.0\n"
"    build:\n"
"      context: aggregator\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS: kafka:9092\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:554
#, no-wrap
msgid ""
"networks:\n"
"  kafkastreams-network:\n"
"    name: ks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:558
#, fuzzy
msgid "To launch all the containers, building the `producer` and `aggregator` container images, run `docker-compose up --build`."
msgstr "`producer` と `aggregator` のコンテナーイメージを構築して、すべてのコンテナーを起動するには、 `docker-compose up --build` を実行します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:560
#, fuzzy
msgid "Instead of `QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS`, you can use `KAFKA_BOOTSTRAP_SERVERS`."
msgstr "`QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS` の代わりに、 `KAFKA_BOOTSTRAP_SERVERS` ."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:562
#, fuzzy
msgid "You should see log statements from the `producer` application about messages being sent to the \"temperature-values\" topic."
msgstr "`producer` アプリケーションから、\"temperature-values\" トピックに送信されたメッセージに関するログステートメントが表示されるはずです。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:565
#, fuzzy
msgid "Now run an instance of the _debezium/tooling_ image, attaching to the same network all the other containers run in.  This image provides several useful tools such as _kafkacat_ and _httpie_:"
msgstr "ここで _debezium/tooling_ イメージのインスタンスを実行し、他のすべてのコンテナーが実行しているのと同じネットワークにアタッチします。このイメージは、 _kafkacat_ や _httpie_ などの便利なツールを提供しています。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:569
#, no-wrap
msgid "docker run --tty --rm -i --network ks debezium/tooling:1.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:572
#, fuzzy
msgid "Within the tooling container, run _kafkacat_ to examine the results of the streaming pipeline:"
msgstr "ツールコンテナー内で、 _kafkacatを_ 実行して、ストリーミングパイプラインの結果を調べます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:576
#, no-wrap
msgid "kafkacat -b kafka:9092 -C -o beginning -q -t temperatures-aggregated\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:581
#, no-wrap
msgid ""
"{\"avg\":34.7,\"count\":4,\"max\":49.4,\"min\":16.8,\"stationId\":9,\"stationName\":\"Marrakesh\",\"sum\":138.8}\n"
"{\"avg\":15.7,\"count\":1,\"max\":15.7,\"min\":15.7,\"stationId\":2,\"stationName\":\"Snowdonia\",\"sum\":15.7}\n"
"{\"avg\":12.8,\"count\":7,\"max\":25.5,\"min\":-13.8,\"stationId\":7,\"stationName\":\"Porthsmouth\",\"sum\":89.7}\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:585
#, fuzzy
msgid "You should see new values arrive as the producer continues to emit temperature measurements, each value on the outbound topic showing the minimum, maximum and average temperature values of the represented weather station."
msgstr "プロデューサが温度測定値を出力し続けると、新しい値が表示され、送信トピックの各値は、表現された気象観測所の最小、最大、および平均温度値を表示します。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:586
#, fuzzy, no-wrap
msgid "Interactive Queries"
msgstr "インタラクティブクエリ"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:594
#, fuzzy
msgid "Subscribing to the `temperatures-aggregated` topic is a great way to react to any new temperature values.  It's a bit wasteful though if you're just interested in the latest aggregated value for a given weather station.  This is where Kafka Streams interactive queries shine: they let you directly query the underlying state store of the pipeline for the value associated to a given key.  By exposing a simple REST endpoint which queries the state store, the latest aggregation result can be retrieved without having to subscribe to any Kafka topic."
msgstr "`temperatures-aggregated` のトピックを購読することは、新しい気温の値に反応するための素晴らしい方法です。しかし、特定の気象観測所の最新の集計値だけに興味があるのであれば、少しもったいないです。そこで、Kafka Streams の対話型クエリが威力を発揮します。ステートストアをクエリするシンプルな REST エンドポイントを公開することで、Kafka トピックを購読しなくても最新の集計結果を取得することができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:596
#, fuzzy
msgid "Let's begin by creating a new class `InteractiveQueries` in the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/InteractiveQueries.java`:"
msgstr "`InteractiveQueries` まず、ファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/InteractiveQueries.java` ."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:598
#, fuzzy
msgid "one more method to the `KafkaStreamsPipeline` class which obtains the current state for a given key:"
msgstr "`KafkaStreamsPipeline` クラスに、与えられたキーの現在の状態を取得するメソッドをもう一つ追加しました。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:605
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:612
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.model.Aggregation;\n"
"import org.acme.kafka.streams.aggregator.model.WeatherStationData;\n"
"import org.apache.kafka.streams.KafkaStreams;\n"
"import org.apache.kafka.streams.errors.InvalidStateStoreException;\n"
"import org.apache.kafka.streams.state.QueryableStoreTypes;\n"
"import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:615
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class InteractiveQueries {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:618
#, no-wrap
msgid ""
"    @Inject\n"
"    KafkaStreams streams;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:621
#, no-wrap
msgid ""
"    public GetWeatherStationDataResult getWeatherStationData(int id) {\n"
"        Aggregation result = getWeatherStationStore().get(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:629
#, no-wrap
msgid ""
"        if (result != null) {\n"
"            return GetWeatherStationDataResult.found(WeatherStationData.from(result)); // <1>\n"
"        }\n"
"        else {\n"
"            return GetWeatherStationDataResult.notFound();                             // <2>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:640
#, no-wrap
msgid ""
"    private ReadOnlyKeyValueStore<Integer, Aggregation> getWeatherStationStore() {\n"
"        while (true) {\n"
"            try {\n"
"                return streams.store(TopologyProducer.WEATHER_STATIONS_STORE, QueryableStoreTypes.keyValueStore());\n"
"            } catch (InvalidStateStoreException e) {\n"
"                // ignore, store not ready yet\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:642
#, fuzzy
msgid "A value for the given station id was found, so that value will be returned"
msgstr "指定された駅IDの値が見つかったので、その値が返されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:643
#, fuzzy
msgid "No value was found, either because a non-existing station was queried or no measurement exists yet for the given station"
msgstr "存在しないステーションがクエリされたか、指定されたステーションに測定がまだ存在しないため、値が見つかりませんでした。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:645
#, fuzzy
msgid "Also create the method's return type in the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java`:"
msgstr "また、メソッドの戻り値の型もファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java` ."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:652
#: upstream/_guides/kafka-streams.adoc:876
#, no-wrap
msgid ""
"import java.util.Optional;\n"
"import java.util.OptionalInt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:654
#: upstream/_guides/kafka-streams.adoc:878
#, no-wrap
msgid "import org.acme.kafka.streams.aggregator.model.WeatherStationData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:656
#: upstream/_guides/kafka-streams.adoc:880
#, no-wrap
msgid "public class GetWeatherStationDataResult {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:659
#, no-wrap
msgid ""
"    private static GetWeatherStationDataResult NOT_FOUND =\n"
"            new GetWeatherStationDataResult(null);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:661
#, no-wrap
msgid "    private final WeatherStationData result;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:665
#, no-wrap
msgid ""
"    private GetWeatherStationDataResult(WeatherStationData result) {\n"
"        this.result = result;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:669
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult found(WeatherStationData data) {\n"
"        return new GetWeatherStationDataResult(data);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:673
#: upstream/_guides/kafka-streams.adoc:906
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult notFound() {\n"
"        return NOT_FOUND;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:678
#, no-wrap
msgid ""
"    public Optional<WeatherStationData> getResult() {\n"
"        return Optional.ofNullable(result);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:682
#, fuzzy
msgid "Also create `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStationData.java`, which represents the actual aggregation result for a weather station:"
msgstr "また、気象台の実際の集計結果を表す `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStationData.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:691
#, no-wrap
msgid ""
"@RegisterForReflection\n"
"public class WeatherStationData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:698
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public double min = Double.MAX_VALUE;\n"
"    public double max = Double.MIN_VALUE;\n"
"    public int count;\n"
"    public double avg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:708
#, no-wrap
msgid ""
"    private WeatherStationData(int stationId, String stationName, double min, double max,\n"
"            int count, double avg) {\n"
"        this.stationId = stationId;\n"
"        this.stationName = stationName;\n"
"        this.min = min;\n"
"        this.max = max;\n"
"        this.count = count;\n"
"        this.avg = avg;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:719
#, no-wrap
msgid ""
"    public static WeatherStationData from(Aggregation aggregation) {\n"
"        return new WeatherStationData(\n"
"                aggregation.stationId,\n"
"                aggregation.stationName,\n"
"                aggregation.min,\n"
"                aggregation.max,\n"
"                aggregation.count,\n"
"                aggregation.avg);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:723
#, fuzzy
msgid "We now can add a simple REST endpoint (`aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/WeatherStationEndpoint.java`), which invokes `getWeatherStationData()` and returns the data to the client:"
msgstr "これで、 `getWeatherStationData()` を呼び出してクライアントにデータを返すシンプルな REST エンドポイント ( `aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/WeatherStationEndpoint.java` ) を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:727
#: upstream/_guides/kafka-streams.adoc:947
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:731
#: upstream/_guides/kafka-streams.adoc:951
#, no-wrap
msgid ""
"import java.net.URI;\n"
"import java.net.URISyntaxException;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:740
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:743
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.streams.GetWeatherStationDataResult;\n"
"import org.acme.kafka.streams.aggregator.streams.KafkaStreamsPipeline;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:747
#: upstream/_guides/kafka-streams.adoc:970
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Path(\"/weather-stations\")\n"
"public class WeatherStationEndpoint {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:750
#: upstream/_guides/kafka-streams.adoc:973
#, no-wrap
msgid ""
"    @Inject\n"
"    InteractiveQueries interactiveQueries;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:755
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/data/{id}\")\n"
"    public Response getWeatherStationData(@PathParam(\"id\") int id) {\n"
"        GetWeatherStationDataResult result = interactiveQueries.getWeatherStationData(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:765
#, no-wrap
msgid ""
"        if (result.getResult().isPresent()) {  // <1>\n"
"            return Response.ok(result.getResult().get()).build();\n"
"        }\n"
"        else {\n"
"            return Response.status(Status.NOT_FOUND.getStatusCode(),\n"
"                    \"No data found for weather station \" + id).build();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:767
#, fuzzy
msgid "Depending on whether a value was obtained, either return that value or a 404 response"
msgstr "値が取得されたかどうかに応じて、その値を返すか、404 レスポンスを返すかのどちらかを選択します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:769
#, fuzzy
msgid "With this code in place, it's time to rebuild the application and the `aggregator` service in Docker Compose:"
msgstr "このコードを用意して、Docker Composeでアプリケーションと `aggregator` サービスを再構築しましょう。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:775
#, no-wrap
msgid ""
"./mvnw clean package -f aggregator/pom.xml\n"
"docker-compose stop aggregator\n"
"docker-compose up --build -d\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:780
#, fuzzy
msgid "This will rebuild the `aggregator` container and restart its service.  Once that's done, you can invoke the service's REST API to obtain the temperature data for one of the existing stations.  To do so, you can use `httpie` in the tooling container launched before:"
msgstr "これにより、 `aggregator` コンテナーが再構築され、サービスが再起動されます。これが完了したら、サービスの REST API を呼び出して、既存のステーションの 1 つの温度データを取得することができます。そのためには、前に起動したツーリングコンテナーで `httpie` を使用します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:784
#, no-wrap
msgid "http aggregator:8080/weather-stations/data/1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:790
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 85\n"
"Content-Type: application/json\n"
"Date: Tue, 18 Jun 2019 19:29:16 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:799
#, no-wrap
msgid ""
"{\n"
"    \"avg\": 12.9,\n"
"    \"count\": 146,\n"
"    \"max\": 41.0,\n"
"    \"min\": -25.6,\n"
"    \"stationId\": 1,\n"
"    \"stationName\": \"Hamburg\"\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:801
#, fuzzy, no-wrap
msgid "Scaling Out"
msgstr "スケーリングアウト"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:808
#, fuzzy
msgid "A very interesting trait of Kafka Streams applications is that they can be scaled out, i.e. the load and state can be distributed amongst multiple application instances running the same pipeline.  Each node will then contain a subset of the aggregation results, but Kafka Streams provides you with https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html#querying-remote-state-stores-for-the-entire-app[an API] to obtain the information which node is hosting a given key.  The application can then either fetch the data directly from the other instance, or simply point the client to the location of that other node."
msgstr "つまり、同じパイプラインを実行している複数のアプリケーションインスタンス間で負荷や状態を分散させることができます。各ノードには集約結果のサブセットが含まれますが、Kafka Streams は、与えられたキーをホストしているノードの情報を取得するための link:https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html#querying-remote-state-stores-for-the-entire-app[API を] 提供しています。アプリケーションは、他のインスタンスから直接データを取得するか、クライアントにその他のノードの場所を指定するだけです。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:810
#, fuzzy
msgid "Launching multiple instances of the `aggregator` application will make look the overall architecture like so:"
msgstr "`aggregator` アプリケーションの複数のインスタンスを起動すると、全体のアーキテクチャがこのようになります。"

#. type: Target for macro image
#: upstream/_guides/kafka-streams.adoc:811
#, no-wrap
msgid "kafka-streams-guide-architecture-distributed.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:814
#, fuzzy
msgid "The `InteractiveQueries` class must be adjusted slightly for this distributed architecture:"
msgstr "`InteractiveQueries` クラスは、この分散型アーキテクチャ用に少し調整する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:823
#, no-wrap
msgid ""
"public GetWeatherStationDataResult getWeatherStationData(int id) {\n"
"    StreamsMetadata metadata = streams.metadataForKey(                  // <1>\n"
"            TopologyProducer.WEATHER_STATIONS_STORE,\n"
"            id,\n"
"            Serdes.Integer().serializer()\n"
"    );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:831
#, no-wrap
msgid ""
"    if (metadata == null || metadata == StreamsMetadata.NOT_AVAILABLE) {\n"
"        LOG.warn(\"Found no metadata for key {}\", id);\n"
"        return GetWeatherStationDataResult.notFound();\n"
"    }\n"
"    else if (metadata.host().equals(host)) {                            // <2>\n"
"        LOG.info(\"Found data for key {} locally\", id);\n"
"        Aggregation result = getWeatherStationStore().get(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:849
#, no-wrap
msgid ""
"        if (result != null) {\n"
"            return GetWeatherStationDataResult.found(WeatherStationData.from(result));\n"
"        }\n"
"        else {\n"
"            return GetWeatherStationDataResult.notFound();\n"
"        }\n"
"    }\n"
"    else {                                                              // <3>\n"
"        LOG.info(\n"
"            \"Found data for key {} on remote host {}:{}\",\n"
"            id,\n"
"            metadata.host(),\n"
"            metadata.port()\n"
"        );\n"
"        return GetWeatherStationDataResult.foundRemotely(metadata.host(), metadata.port());\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:862
#, no-wrap
msgid ""
"public List<PipelineMetadata> getMetaData() {                           // <4>\n"
"    return streams.allMetadataForStore(TopologyProducer.WEATHER_STATIONS_STORE)\n"
"            .stream()\n"
"            .map(m -> new PipelineMetadata(\n"
"                    m.hostInfo().host() + \":\" + m.hostInfo().port(),\n"
"                    m.topicPartitions()\n"
"                        .stream()\n"
"                        .map(TopicPartition::toString)\n"
"                        .collect(Collectors.toSet()))\n"
"            )\n"
"            .collect(Collectors.toList());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:864
#, fuzzy
msgid "The streams metadata for the given weather station id is obtained"
msgstr "与えられた気象観測所IDのストリームメタデータが取得されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:865
#, fuzzy
msgid "The given key (weather station id) is maintained by the local application node, i.e. it can answer the query itself"
msgstr "与えられたキー(測候所ID)はローカルのアプリケーションノードによって管理されています。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:866
#, fuzzy
msgid "The given key is maintained by another application node; in this case the information about that node (host and port) will be returned"
msgstr "与えられたキーは別のアプリケーションノードによって管理されています; この場合、そのノードに関する情報(ホストとポート)が返されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:867
#, fuzzy
msgid "The `getMetaData()` method is added to provide callers with a list of all the nodes in the application cluster."
msgstr "`getMetaData()` メソッドが追加され、アプリケーション・クラスター内の全ノードのリストを呼び出し元に提供するようになりました。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:869
#, fuzzy
msgid "The `GetWeatherStationDataResult` type must be adjusted accordingly:"
msgstr "`GetWeatherStationDataResult` のタイプは、それに合わせて調整する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:883
#, no-wrap
msgid ""
"    private static GetWeatherStationDataResult NOT_FOUND =\n"
"            new GetWeatherStationDataResult(null, null, null);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:887
#, no-wrap
msgid ""
"    private final WeatherStationData result;\n"
"    private final String host;\n"
"    private final Integer port;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:894
#, no-wrap
msgid ""
"    private GetWeatherStationDataResult(WeatherStationData result, String host,\n"
"            Integer port) {\n"
"        this.result = result;\n"
"        this.host = host;\n"
"        this.port = port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:898
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult found(WeatherStationData data) {\n"
"        return new GetWeatherStationDataResult(data, null, null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:902
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult foundRemotely(String host, int port) {\n"
"        return new GetWeatherStationDataResult(null, host, port);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:910
#, no-wrap
msgid ""
"    public Optional<WeatherStationData> getResult() {\n"
"        return Optional.ofNullable(result);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:914
#, no-wrap
msgid ""
"    public Optional<String> getHost() {\n"
"        return Optional.ofNullable(host);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:919
#, no-wrap
msgid ""
"    public OptionalInt getPort() {\n"
"        return port != null ? OptionalInt.of(port) : OptionalInt.empty();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:923
#, fuzzy
msgid "Also the return type for `getMetaData()` must be defined (`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java`):"
msgstr "また、 `getMetaData()` のリターンタイプも定義しなければなりません ( `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java` )。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:929
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:931
#, no-wrap
msgid "public class PipelineMetadata {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:934
#, no-wrap
msgid ""
"    public String host;\n"
"    public Set<String> partitions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:940
#, no-wrap
msgid ""
"    public PipelineMetadata(String host, Set<String> partitions) {\n"
"        this.host = host;\n"
"        this.partitions = partitions;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:943
#, fuzzy
msgid "Lastly, the REST endpoint class must be updated:"
msgstr "最後に、RESTエンドポイントクラスを更新する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:962
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:966
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.streams.GetWeatherStationDataResult;\n"
"import org.acme.kafka.streams.aggregator.streams.KafkaStreamsPipeline;\n"
"import org.acme.kafka.streams.aggregator.streams.PipelineMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:980
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/data/{id}\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Response getWeatherStationData(@PathParam(\"id\") int id) {\n"
"        GetWeatherStationDataResult result = interactiveQueries.getWeatherStationData(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:994
#, no-wrap
msgid ""
"        if (result.getResult().isPresent()) {                     // <1>\n"
"            return Response.ok(result.getResult().get()).build();\n"
"        }\n"
"        else if (result.getHost().isPresent()) {                  // <2>\n"
"            URI otherUri = getOtherUri(result.getHost().get(), result.getPort().getAsInt(),\n"
"                    id);\n"
"            return Response.seeOther(otherUri).build();\n"
"        }\n"
"        else {                                                    // <3>\n"
"            return Response.status(Status.NOT_FOUND.getStatusCode(),\n"
"                    \"No data found for weather station \" + id).build();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1001
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/meta-data\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<PipelineMetadata> getMetaData() {                 // <4>\n"
"        return interactiveQueries.getMetaData();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1011
#, no-wrap
msgid ""
"    private URI getOtherUri(String host, int port, int id) {\n"
"        try {\n"
"            return new URI(\"http://\" + host + \":\" + port + \"/weather-stations/data/\" + id);\n"
"        }\n"
"        catch (URISyntaxException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1013
#, fuzzy
msgid "The data was found locally, so return it"
msgstr "データはローカルで見つかったので、それを返す"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1014
#, fuzzy
msgid "The data is maintained by another node, so reply with a redirect (HTTP status code 303) if the data for the given key is stored on one of the other nodes."
msgstr "データは他のノードで管理されているので、指定されたキーのデータが他のノードに保存されている場合は、リダイレクト(HTTPステータスコード303)で返信してください。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1015
#, fuzzy
msgid "No data was found for the given weather station id"
msgstr "データが見つかりませんでした。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1016
#, fuzzy
msgid "Exposes information about all the hosts forming the application cluster"
msgstr "アプリケーションクラスターを形成しているすべてのホストの情報を表示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1019
#, fuzzy
msgid "Now stop the `aggregator` service again and rebuild it.  Then let's spin up three instances of it:"
msgstr "ここで再び `aggregator` サービスを停止して再構築します。そして、3つのインスタンスをスピンアップしてみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1025
#, no-wrap
msgid ""
"./mvnw clean package -f aggregator/pom.xml\n"
"docker-compose stop aggregator\n"
"docker-compose up --build -d --scale aggregator=3\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1030
#, fuzzy
msgid "When invoking the REST API on any of the three instances, it might either be that the aggregation for the requested weather station id is stored locally on the node receiving the query, or it could be stored on one of the other two nodes."
msgstr "3つのインスタンスのいずれかでREST APIを呼び出す場合、要求されたウェザーステーションIDの集約は、クエリを受信したノードにローカルに格納されるか、他の2つのノードのいずれかに格納されるかのどちらかであるかもしれません。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1034
#, fuzzy
msgid "As the load balancer of Docker Compose will distribute requests to the `aggregator` service in a round-robin fashion, we'll invoke the actual nodes directly.  The application exposes information about all the host names via REST:"
msgstr "Docker Composeのロードバランサーがラウンドロビン方式で `aggregator` サービスにリクエストを配信するので、実際のノードを直接呼び出すことにします。アプリケーションはREST経由ですべてのホスト名の情報を公開しています。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1038
#, no-wrap
msgid "http aggregator:8080/weather-stations/meta-data\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1044
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 202\n"
"Content-Type: application/json\n"
"Date: Tue, 18 Jun 2019 20:00:23 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1065
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        \"host\": \"2af13fe516a9:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-2\"\n"
"        ]\n"
"    },\n"
"    {\n"
"        \"host\": \"32cc8309611b:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-1\"\n"
"        ]\n"
"    },\n"
"    {\n"
"        \"host\": \"1eb39af8d587:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-0\"\n"
"        ]\n"
"    }\n"
"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1069
#, fuzzy
msgid "Retrieve the data from one of the three hosts shown in the response (your actual host names will differ):"
msgstr "レスポンスに表示されている 3 つのホストのうちの 1 つからデータを取得します (実際のホスト名は異なります)。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1073
#, no-wrap
msgid "http 2af13fe516a9:8080/weather-stations/data/1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1076
#, fuzzy
msgid "If that node holds the data for key \"1\", you'll get a response like this:"
msgstr "そのノードがキー「1」のデータを保持している場合は、このようなレスポンスが得られます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1084
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 74\n"
"Content-Type: application/json\n"
"Date: Tue, 11 Jun 2019 19:16:31 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1093
#, no-wrap
msgid ""
"{\n"
"  \"avg\": 11.9,\n"
"  \"count\": 259,\n"
"  \"max\": 50.0,\n"
"  \"min\": -30.1,\n"
"  \"stationId\": 1,\n"
"  \"stationName\": \"Hamburg\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1096
#, fuzzy
msgid "Otherwise, the service will send a redirect:"
msgstr "そうでない場合、サービスはリダイレクトを送信します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1104
#, no-wrap
msgid ""
"HTTP/1.1 303 See Other\n"
"Connection: keep-alive\n"
"Content-Length: 0\n"
"Date: Tue, 18 Jun 2019 20:01:03 GMT\n"
"Location: http://1eb39af8d587:8080/weather-stations/data/1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1107
#, fuzzy
msgid "You can also have _httpie_ automatically follow the redirect by passing the `--follow option`:"
msgstr "また、 `--follow option` を渡すことで _httpie が_ 自動的にリダイレクトに従うようにすることもできます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1111
#, no-wrap
msgid "http --follow 2af13fe516a9:8080/weather-stations/data/1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1113
#, fuzzy, no-wrap
msgid "Running Natively"
msgstr "ネイティブランニング"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1117
#, fuzzy
msgid "The Quarkus extension for Kafka Streams enables the execution of stream processing applications natively via GraalVM without further configuration."
msgstr "Kafka Streams用のQuarkus拡張機能を使用すると、GraalVMを介してストリーム処理アプリケーションをネイティブに実行することができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1120
#, fuzzy
msgid "To run both the `producer` and `aggregator` applications in native mode, the Maven builds can be executed using the `native` profile:"
msgstr "`producer` と `aggregator` アプリケーションをネイティブモードで実行するには、 `native` プロファイルを使用して Maven ビルドを実行できます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1125
#, no-wrap
msgid ""
"./mvnw clean package -f producer/pom.xml -Pnative -Dnative-image.container-runtime=docker\n"
"./mvnw clean package -f aggregator/pom.xml -Pnative -Dnative-image.container-runtime=docker\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1128
#, fuzzy
msgid "Now create an environment variable named `QUARKUS_MODE` and with value set to \"native\":"
msgstr "ここで、 `QUARKUS_MODE` という名前の環境変数を作成し、値を\"native\"に設定します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1132
#, no-wrap
msgid "export QUARKUS_MODE=native\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1137
#, fuzzy
msgid "This is used by the Docker Compose file to use the correct `Dockerfile` when building the `producer` and `aggregator` images.  The Kafka Streams application can work with less than 50 MB RSS in native mode.  To do so, add the `Xmx` option to the program invocation in `aggregator/src/main/docker/Dockerfile.native`:"
msgstr "これは、 `producer` と `aggregator` 画像をビルドする際に正しい `Dockerfile` を使用するために Docker Compose ファイルで使用されます。Kafka Streams アプリケーションは、ネイティブモードでは 50 MB 未満の RSS で動作します。そのためには、 `aggregator/src/main/docker/Dockerfile.native` のプログラム呼び出しに `Xmx` オプションを追加します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1141
#, no-wrap
msgid "CMD [\"./application\", \"-Dquarkus.http.host=0.0.0.0\", \"-Xmx32m\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1145
#, fuzzy
msgid "Now start Docker Compose as described above (don't forget to rebuild the container images)."
msgstr "ここで、上記のようにDocker Composeを起動します(コンテナーイメージの再構築を忘れずに)。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1146
#, fuzzy, no-wrap
msgid "Kafka Streams Health Checks"
msgstr "カフカストリームの健康診断"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1149
#, fuzzy
msgid "If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka-streams` will automatically add:"
msgstr "`quarkus-smallrye-health` の拡張子を使用している場合は、 `quarkus-kafka-streams` が自動的に追加されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1151
#, fuzzy
msgid "a readiness health check to validate that all topics declared in the `quarkus.kafka-streams.topics` property are created,"
msgstr "`quarkus.kafka-streams.topics` プロパティーで宣言されたすべてのトピックが作成されているかどうかを検証するために、準備の健全性チェックを行います。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1152
#, fuzzy
msgid "a liveness health check based on the Kafka Streams state."
msgstr "カフカストリームの状態をもとにした活力健康診断。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1154
#, fuzzy
msgid "So when you access the `/q/health` endpoint of your application you will have information about the state of the Kafka Streams and the available and/or missing topics."
msgstr "そのため、アプリケーションの `/q/health` エンドポイントにアクセスすると、Kafka ストリームの状態や、利用可能なトピックや不足しているトピックについての情報を得ることができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1156
#, fuzzy
msgid "This is an example of when the status is `DOWN`:"
msgstr "これは、ステータスが `DOWN` ."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1159
#, no-wrap
msgid "curl -i http://aggregator:8080/q/health\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1163
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 454\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1184
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams state health check\",  <1>\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"state\": \"CREATED\"\n"
"            }\n"
"        },\n"
"        {\n"
"            \"name\": \"Kafka Streams topics health check\",  <2>\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"available_topics\": \"weather-stations,temperature-values\",\n"
"                \"missing_topics\": \"hygrometry-values\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1186
#, fuzzy
msgid "Liveness health check. Also available at `/q/health/live` endpoint."
msgstr "活力のある健康チェック。 `/q/health/live` エンドポイントでもご利用いただけます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1187
#, fuzzy
msgid "Readiness health check. Also available at `/q/health/ready` endpoint."
msgstr "準備状態の健康チェック。 `/q/health/ready` エンドポイントでも利用可能。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1189
#, fuzzy
msgid "So as you can see, the status is `DOWN` as soon as one of the `quarkus.kafka-streams.topics` is missing or the Kafka Streams `state` is not `RUNNING`."
msgstr "だから、ご覧のように、 `quarkus.kafka-streams.topics` のいずれかが欠けているか、カフカストリーム `state` が `RUNNING` でないとすぐにステータスが `DOWN` になります。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1192
#, fuzzy
msgid "If no topics are available, the `available_topics` key will not be present in the `data` field of the `Kafka Streams topics health check`.  As well as if no topics are missing, the `missing_topics` key will not be present in the `data` field of the `Kafka Streams topics health check`."
msgstr "トピックがない場合、 `Kafka Streams topics health check` .の `data` フィールドに `available_topics` キーは表示されません。また、トピックがない場合は、 `Kafka Streams topics health check` の `data` フィールドに `missing_topics` キーは表示されません。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1194
#, fuzzy
msgid "You can of course disable the health check of the `quarkus-kafka-streams` extension by setting the `quarkus.kafka-streams.health.enabled` property to `false` in your `application.properties`."
msgstr "`quarkus.kafka-streams.health.enabled` `false` もちろん、 `quarkus-kafka-streams` 拡張モジュールのヘルスチェックを無効にするには、 `application.properties` ."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1196
#, fuzzy
msgid "Obviously you can create your liveness and readiness probes based on the respective endpoints `/q/health/live` and `/q/health/ready`."
msgstr "もちろん、それぞれのエンドポイント `/q/health/live` と `/q/health/ready` に基づいて、活性度と準備状態のプローブを作成することができます。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:1197
#, fuzzy, no-wrap
msgid "Liveness health check"
msgstr "活性度チェック"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1200
#, fuzzy
msgid "Here is an example of the liveness check:"
msgstr "活力チェックの一例をご紹介します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1204
#, no-wrap
msgid "curl -i http://aggregator:8080/q/health/live\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1208
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 225\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1221
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams state health check\",\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"state\": \"CREATED\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1223
#, fuzzy
msgid "The `state` is coming from the `KafkaStreams.State` enum."
msgstr "`state` は `KafkaStreams.State` enum から来ています。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:1224
#, fuzzy, no-wrap
msgid "Readiness health check"
msgstr "準備状態の健康チェック"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1227
#, fuzzy
msgid "Here is an example of the readiness check:"
msgstr "ここでは、準備態勢チェックの一例をご紹介します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1231
#, no-wrap
msgid "curl -i http://aggregator:8080/q/health/ready\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1235
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 265\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1248
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams topics health check\",\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"missing_topics\": \"weather-stations,temperature-values\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1250
#, fuzzy, no-wrap
msgid "Going Further"
msgstr "さらなる飛躍を目指して"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1256
#, fuzzy
msgid "This guide has shown how you can build stream processing applications using Quarkus and the Kafka Streams APIs, both in JVM and native modes.  For running your KStreams application in production, you could also add health checks and metrics for the data pipeline.  Refer to the Quarkus guides on link:micrometer[Micrometer], link:microprofile-metrics[MicroProfile Metrics], and link:microprofile-health[health checks] to learn more."
msgstr "このガイドでは、QuarkusとKafka Streams APIを使用して、JVMとネイティブモードの両方でストリーム処理アプリケーションを構築する方法を紹介しました。KStreamsアプリケーションを本番環境で実行するために、データパイプラインのヘルスチェックやメトリクスを追加することもできます。詳細については、 link:micrometer[マイクロメーター] 、 link:microprofile-metrics[マイクロプロファイルメトリクス] 、 link:microprofile-health[ヘルスチェック] に関するQuarkusのガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1257
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"
