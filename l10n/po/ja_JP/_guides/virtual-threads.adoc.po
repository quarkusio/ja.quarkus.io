msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Virtual Thread support reference"
msgstr "仮想スレッドサポートリファレンス"

#: _guides/virtual-threads.adoc
msgid "This guide explains how to benefit from Java 21+ virtual threads in Quarkus application."
msgstr "このガイドでは、QuarkusアプリケーションでJava 21+の仮想スレッドを使用する方法について説明します。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "What are virtual threads?"
msgstr "仮想スレッドとは？"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Terminology"
msgstr "用語解説"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "OS thread"
msgstr "OS スレッド"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "A \"thread-like\" data structure managed by the Operating System."
msgstr "オペレーティングシステムによって管理される「スレッドのような」データ構造。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Platform thread"
msgstr "プラットフォームスレッド"

#: _guides/virtual-threads.adoc
msgid ""
"Until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, a wrapper around an OS thread.\n"
"Creating a platform thread creates an OS thread, and blocking a platform thread blocks an OS thread."
msgstr ""
"Java 19 までは、link:{thread}[スレッド] クラスのインスタンスはすべて、OS スレッドのラッパーであるプラットフォームスレッドでした。\n"
"プラットフォームスレッドを作成すると OS スレッドが作成され、プラットフォームスレッドがブロックされると OS スレッドもブロックされます。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Virtual thread"
msgstr "仮想スレッド"

#: _guides/virtual-threads.adoc
msgid ""
"Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.\n"
"Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr ""
"軽量で、JVM が管理するスレッド。link:{thread}[スレッド] クラスを拡張していますが、1 つの特定の OS スレッドに関連付けられていません。\n"
"したがって、仮想スレッドのスケジューリングは JVM の責任となります。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Carrier thread"
msgstr "キャリアースレッド"

#: _guides/virtual-threads.adoc
msgid ""
"A platform thread used to execute a virtual thread is called a **carrier** thread.\n"
"It isn't a class distinct from link:{Thread}[Thread] or `VirtualThread` but rather a functional denomination."
msgstr ""
"仮想スレッドを実行するために使用されるプラットフォームスレッドは、**キャリアースレッド** と呼ばれます。\n"
"これは link:{Thread}[スレッド] または `VirtualThread` とは異なるクラスではなく、機能的な呼称です。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "仮想スレッドとプラットフォームスレッドの違い"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "We will give a brief overview of the topic here; please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr "ここでは、このトピックに関する概要を説明しますが、詳細は link:{vthreadjep}[JEP 425] を参照してください。"

#: _guides/virtual-threads.adoc
msgid ""
"Virtual threads are a feature available since Java 19 (Java 21 is the first LTS version including virtual threads),\n"
"aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr ""
"仮想スレッドは、Java 19 から利用可能な機能で (Java 21 は、仮想スレッドを含む最初の LTS バージョン)、\n"
"I/O バウンドのワークロードに対して、プラットフォームスレッドの安価な代替を提供することを目的としています。"

#: _guides/virtual-threads.adoc
msgid ""
"Until now, platform threads were the concurrency unit of the JVM.\n"
"They are a wrapper over OS structures.\n"
"Creating a Java platform thread creates a \"thread-like\" structure in your operating system."
msgstr ""
"これまで、プラットフォームスレッドが JVM の同時実行ユニットでした。\n"
"スレッドは、OS 構造体のラッパーです。\n"
"Java プラットフォームスレッドを作成すると、オペレーティングシステムに「スレッドのような」構造が作成されます。"

#: _guides/virtual-threads.adoc
msgid ""
"Virtual threads, on the other hand, are managed by the JVM. To be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).\n"
"As such, they have been designed to offer the following characteristics:"
msgstr ""
"一方、仮想スレッドは JVM によって管理されます。実行するには、(その仮想スレッドのキャリアーとして機能する) プラットフォームスレッドにマウントする必要があります。\n"
"そのため、以下のような特徴があります。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Lightweight "
msgstr "軽量 "

#: _guides/virtual-threads.adoc
msgid ""
"Virtual threads occupy less space than platform threads in memory.\n"
"Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the memory.\n"
"By default, platform threads are created with a stack of about 1 MB, whereas virtual threads stack is \"pay-as-you-go.\"\n"
"You can find these numbers and other motivations for virtual threads in this https://youtu.be/lIq-x_iI-kc?t=543[presentation] given by the lead developer of project Loom (the project that added the virtual thread support to the JVM)."
msgstr ""
"仮想スレッドは、プラットフォームスレッドよりもメモリー上の占有領域が小さくなります。\n"
"したがって、メモリーを消費することなく、プラットフォームスレッドよりも多くの仮想スレッドを同時に使用することが可能になります。\n"
"デフォルトでは、プラットフォームスレッドは約 1MB のスタックで作成されますが、仮想スレッドのスタックは \"pay-as-you-go \"です。\n"
"Loom プロジェクト (JVM に仮想スレッドサポートを追加したプロジェクト) のリード開発者が行った link:https://youtu.be/lIq-x_iI-kc?t=543[プレゼンテーション] で、これらの数字や仮想スレッドの他の動機を見つけることができます。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Cheap to create"
msgstr "作成が安価"

#: _guides/virtual-threads.adoc
msgid ""
"Creating a platform thread in Java takes time.\n"
"Currently, techniques such as pooling, where threads are created once and then reused, are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).\n"
"Virtual threads are supposed to be disposable entities that we create when we need them,\n"
"it is discouraged to pool them or reuse them for different tasks."
msgstr ""
"Java でプラットフォームスレッドを作成するには時間がかかります。\n"
"現在では、スレッドを一度作成してから再利用するプーリングのようなテクニックが、スレッドの起動にかかる時間のロスを最小限に抑えるために強く推奨されています (同様に、メモリー消費量を低く抑えるためにスレッドの最大数を制限することも推奨されています）。\n"
"仮想スレッドは必要なときに作成する使い捨てのものであり、\n"
"スレッドをプールしたり別のタスクに再利用したりすることは推奨されません。"

#. type: Labeled list
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Cheap to block"
msgstr "安価なブロック"

#: _guides/virtual-threads.adoc
msgid ""
"When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue, and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.\n"
"Since the JVM manages virtual threads, no underlying OS thread is blocked when they perform a blocking operation.\n"
"Their state is stored in the heap, and another virtual thread is executed on the same Java platform (carrier) thread."
msgstr ""
"ブロッキング I/O を実行するとき、Java プラットフォームのスレッドによってラップされた基礎となる OS スレッドは待ち行列に入れられ、新しいスレッドコンテキストを CPU コアにロードするためにコンテキストスイッチが発生します。\n"
"この操作には時間がかかります。JVM は仮想スレッドを管理するため、OS スレッドがブロッキング操作を実行しても、そのスレッドがブロックされることはありません。\n"
"それらの状態はヒープに格納され、別の仮想スレッドが同じ Java プラットフォーム (キャリアー) スレッド上で実行されます。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "The Continuation Dance"
msgstr "継続的な動作"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "As mentioned above, the JVM schedules the virtual threads. These virtual threads are mounted on carrier threads. The scheduling comes with a pinch of magic. When the virtual thread attempts to use blocking I/O, the JVM _transforms_ this call into a non-blocking one, unmounts the virtual thread, and mounts another virtual thread on the carrier thread. When the I/O completes, the _waiting_ virtual thread becomes eligible again and will be re-mounted on a carrier thread to continue its execution. For the user, all this dance is invisible. Your synchronous code is executed asynchronously."
msgstr "前述のように、JVM は仮想スレッドをスケジュールします。これらの仮想スレッドはキャリアースレッドにマウントされます。このスケジューリングには少し魔法のような仕組みがあります。仮想スレッドがブロッキング I/O を使用しようとすると、JVM はこの呼び出しをノンブロッキングの呼び出しに _変換_ し、仮想スレッドをアンマウントして、別の仮想スレッドをキャリアースレッドにマウントします。I/O が完了すると、_待機していた_ 仮想スレッドが再び実行可能な状態になり、再びキャリアースレッドにマウントされて処理を続行します。ユーザーからは、この一連の動作はすべて見えません。同期コードは非同期で実行されます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Note that the virtual thread may not be re-mounted on the same carrier thread."
msgstr "仮想スレッドを同じキャリアースレッドに再マウントすることはできません。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "仮想スレッドはI/Oバウンドワークロードにのみに有効"

#: _guides/virtual-threads.adoc
msgid ""
"We now know we can create more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).\n"
"It is useless and counterproductive.\n"
"CPU-bound doesn't consist of quickly swapping threads while they need to wait for the completion of an I/O, but in leaving\n"
"them attached to a CPU core to compute something.\n"
"In this scenario, it is worse than useless to have thousands of threads if we have tens of CPU cores, virtual threads won't enhance the performance of CPU-bound workloads.\n"
"Even worse, when running a CPU-bound workload on a virtual thread, the virtual thread monopolizes the carrier thread on which it is mounted.\n"
"It will either reduce the chance for the other virtual thread to run or will start creating new carrier threads, leading to high memory usage."
msgstr ""
"私たちは、プラットフォームスレッドよりも多くの仮想スレッドを作成できることを理解しました。このため、長時間の計算 (CPU バウンドワークロード) をするために仮想スレッドを使用したいと考えるかもしれません。\n"
"しかし、これは無意味であり、逆効果です。\n"
"CPU バウンド処理は、I/O の完了を待つ間にスレッドをすばやく切り替えるのではなく、\n"
"スレッドを CPU コアにアタッチして何らかの計算を行うものです。\n"
"このようなケースでは、数十個の CPU コアに対して数千個のスレッドを持つことは非常に無意味で、仮想スレッドが CPU バウンドワークロードのパフォーマンスを向上させることはありません。\n"
"それどころか、仮想スレッド上で CPU バウンドワークロードを実行すると、仮想スレッドがマウントされているキャリアースレッドをその仮想スレッドが独占してしまいます。\n"
"その結果、他の仮想スレッドが実行される機会が減るか、新しいキャリアースレッドが次々に作成されることになり、メモリー使用量が増大してしまいます。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Run code on virtual threads using @RunOnVirtualThread"
msgstr "@RunOnVirtualThread を使用した仮想スレッド上でのコード実行"

#: _guides/virtual-threads.adoc
msgid ""
"In Quarkus, the support of virtual thread is implemented using the link:{runonvthread}[@RunOnVirtualThread] annotation.\n"
"This section briefly overviews the rationale and how to use it.\n"
"There are dedicated guides for extensions supporting that annotation, such as:"
msgstr ""
"Quarkus では、仮想スレッドのサポートは link:{runonvthread}[@RunOnVirtualThread] アノテーションを使用して実装されています。\n"
"このセクションでは、その論理的根拠と使い方について簡単に説明します。\n"
"このアノテーションをサポートするエクステンションには、以下のような専用のガイドも用意されています。"

#: _guides/virtual-threads.adoc
msgid "xref:./rest-virtual-threads.adoc[Virtual threads in REST applications]"
msgstr "xref:./rest-virtual-threads.adoc[REST アプリケーションにおける仮想スレッド]"

#: _guides/virtual-threads.adoc
msgid "xref:./messaging-virtual-threads.adoc[Virtual threads in reactive messaging applications]"
msgstr "xref:./messaging-virtual-threads.adoc[リアクティブメッセージングアプリケーションにおける仮想スレッド]"

#: _guides/virtual-threads.adoc
msgid "xref:./grpc-virtual-threads.adoc[Virtual threads in gRPC services]"
msgstr "xref:./grpc-virtual-threads.adoc[gRPCサービスの仮想スレッド]"

#: _guides/virtual-threads.adoc
msgid "xref:./scheduler-reference.adoc#virtual_threads[Execute periodic tasks on virtual threads]"
msgstr "xref:./scheduler-reference.adoc#virtual_threads[仮想スレッドでの定期的なタスクの実行]"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Why not run everything on virtual threads?"
msgstr "すべてを仮想スレッドで実行しない理由"

#: _guides/virtual-threads.adoc
msgid ""
"As mentioned above, not everything can run safely on virtual threads.\n"
"The risk of **monopolization** can lead to high-memory usage.\n"
"Also, there are situations where the virtual thread cannot be unmounted from the carrier thread.\n"
"This is called **pinning**.\n"
"Finally, some libraries use `ThreadLocal` to store and reuse objects.\n"
"Using virtual threads with these libraries will lead to massive allocation, as the intentionally pooled objects will be instantiated for every (disposable and generally short-lived) virtual thread."
msgstr ""
"前述したように、すべてが仮想スレッド上で安全に実行できるわけではありません。\n"
"**独占** のリスクはメモリー使用量の多さにつながります。\n"
"また、仮想スレッドをキャリアースレッドからアンマウントできない状況もあります。\n"
"これは **ピニング** と呼ばれます。\n"
"最後に、一部のライブラリーは `ThreadLocal` を使用してオブジェクトを保存し再利用します。\n"
"これらのライブラリーで仮想スレッドを使用すると、意図的にプールされたオブジェクトが (使い捨てで一般に短命な) 仮想スレッドごとにインスタンス化されるため、大量の割り当てが発生します。"

#: _guides/virtual-threads.adoc
msgid ""
"As of today, it is not possible to use virtual threads in a carefree manner.\n"
"Following such a laissez-faire approach could quickly lead to memory and resource starvation issues.\n"
"Thus, Quarkus uses an explicit model until the aforementioned issues disappear (as the Java ecosystem matures).\n"
"It is also the reason why _reactive_ extensions have the virtual thread support, and rarely the _classic_ ones.\n"
"We need to know when to dispatch on a virtual thread."
msgstr ""
"現在のところ、仮想スレッドを自由に使うことはできません。\n"
"このような自由放任のアプローチをとると、すぐにメモリやリソースの枯渇という問題が発生します。\n"
"そのため Quarkus では、前述の問題がなくなるまで (Javaエコシステムが成熟するまで) 明示的なモデルを使用します。 \n"
"_リアクティブ_ エクステンションが仮想スレッドをサポートし、_古典的な_ スレッドをほとんどサポートしない理由もここにあります。\n"
"仮想スレッドでディスパッチするタイミングを知る必要があります。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "It is essential to understand that these issues are not Quarkus limitations or bugs but are due to the current state of the Java ecosystem which needs to evolve to become virtual thread friendly."
msgstr "これらの問題は、Quarkusの制限やバグではなく、仮想スレッドフレンドリーに進化する必要があるJavaエコシステムの現状によるものであることを理解することが重要です。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "To learn more about the internal design and choices, check the https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment] paper."
msgstr "内部設計と選択の詳細については、link:https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in Java framework: a Quarkus example in resource-constrained environment] を参照してください。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Monopolization cases"
msgstr "独占の場合"

#: _guides/virtual-threads.adoc
msgid ""
"The monopolization has been explained in the xref:cpu-bound[Virtual threads are useful for I/O-bound workloads only] section.\n"
"When running long computations, we do not allow the JVM to unmount and switch to another virtual thread until the virtual thread terminates.\n"
"Indeed, the current scheduler does not support preempting tasks."
msgstr ""
"独占については、xref:cpu-bound[仮想スレッドは I/O バウンドのワークロードにのみ有効] のセクションで説明しました。\n"
"長い計算を実行する場合、仮想スレッドが終了するまで、JVM がアンマウントして別の仮想スレッドに切り替えることを許可しません。\n"
"実際、現在のスケジューラはタスクのプリエンプトをサポートしていません。"

#: _guides/virtual-threads.adoc
msgid ""
"This monopolization can lead to the creation of new carrier threads to execute other virtual threads.\n"
"Creating carrier threads results in creating platform threads.\n"
"So, there is a memory cost associated with this creation."
msgstr ""
"この独占は、他の仮想スレッドを実行するために新しいキャリアースレッドを作成することにつながります。\n"
"キャリアースレッドを作成すると、プラットフォームスレッドを作成することになります。\n"
"そのため、この作成にはメモリーコストがかかります。"

#: _guides/virtual-threads.adoc
msgid ""
"Suppose you run in a constrained environment, such as containers. In that case, monopolization can quickly become a concern, as the high memory usage can lead to out-of-memory issues and container termination.\n"
"The memory usage may be higher than with regular worker threads because of the inherent cost of the scheduling and virtual threads."
msgstr ""
"コンテナーのような制約のある環境で実行するとします。その場合、メモリー使用量の多さがメモリ不足の問題やコンテナーの終了につながる可能性があるため、独占はすぐに懸念事項となります。\n"
"メモリー使用量は、スケジューリングと仮想スレッドに固有のコストがかかるため、通常のワーカースレッドよりも高くなる可能性があります。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Pinning cases"
msgstr "ピニングの場合"

#: _guides/virtual-threads.adoc
msgid ""
"The promise of \"cheap blocking\" might not always hold: a virtual thread might _pin_ its carrier on certain occasions.\n"
"The platform thread is blocked in this situation, precisely as it would have been in a typical blocking scenario."
msgstr ""
"「安価なブロッキング」の約束は常に成り立つわけではありません。仮想スレッドは特定の状況でそのキャリアーを _ピン_ することがあります。\n"
"この場合、プラットフォームスレッドはブロックされ、通常のブロッキングシナリオと同様に動作します。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "link:{vthreadjep}[JEP 425] によると、これは次の 2 つの状況で発生する可能性があります。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr "仮想スレッドが `synchronized` ブロックまたはメソッドの内部でブロッキング操作を実行する場合"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "ネイティブメソッドや外部関数内でブロッキング操作を実行した場合"

#: _guides/virtual-threads.adoc
msgid ""
"It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.\n"
"Typically, while experimenting with virtual threads, we realized that versions older than 42.6.0 of the link:{pgsql-driver}[postgresql-JDBC driver] result in frequent pinning.\n"
"Most JDBC drivers still pin the carrier thread.\n"
"Even worse, many libraries require code changes."
msgstr ""
"コード内でこのような状況を回避するのは比較的簡単ですが、使用する依存関係をすべて検証することは困難です。\n"
"通常、仮想スレッドを試している際に、link:{pgsql-driver}[postgresql-JDBC driver] の 42.6.0 より古いバージョンでは、頻繁にピニングが発生することがわかりました。\n"
"ほとんどの JDBC ドライバーは、引き続きキャリアースレッドをピン留めします。\n"
"さらに悪いことに、多くのライブラリーではコードの変更が必要になります。"

#: _guides/virtual-threads.adoc
msgid "For more information, see link:https://quarkus.io/blog/virtual-thread-1/[When Quarkus meets Virtual Threads]"
msgstr "詳細は、link:https://quarkus.io/blog/virtual-thread-1/[When Quarkus meets Virtual Threads] を参照してください。"

#: _guides/virtual-threads.adoc
msgid ""
"This information about pinning cases applies to PostgreSQL JDBC driver 42.5.4 and earlier.\n"
"For PostgreSQL JDBC driver 42.6.0 and later, virtually all synchronized methods have been replaced by reentrant locks.\n"
"For more information, see the link:https://jdbc.postgresql.org/changelogs/2023-03-17-42.6.0-release/[Notable Changes] for PostgreSQL JDBC driver 42.6.0."
msgstr ""
"このピンニングのケースに関する情報は、PostgreSQL JDBC ドライバー 42.5.4 以前に適用されます。\n"
"PostgreSQL JDBC ドライバー 42.6.0 以降では、事実上すべての同期されたメソッドが再入可能ロックに置き換えられています。\n"
"詳細は、PostgreSQL JDBC ドライバー 42.6.0 の link:https://jdbc.postgresql.org/changelogs/2023-03-17-42.6.0-release/[Notable Changes] を参照してください。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "The pooling case"
msgstr "プーリングの場合"

#: _guides/virtual-threads.adoc
msgid ""
"Some libraries are using `ThreadLocal` as an object pooling mechanism.\n"
"Extremely popular libraries like https://github.com/FasterXML/jackson-core/issues/919[Jackson] and Netty assume that the application uses a limited number of threads, which are recycled (using a thread pool) to run multiple (unrelated but sequential) tasks."
msgstr ""
"一部のライブラリーは、オブジェクトプーリングメカニズムとして `ThreadLocal` を使用しています。\n"
"https://github.com/FasterXML/jackson-core/issues/919[Jackson] および Netty などの非常に人気の高いライブラリーは、アプリケーションが限られた数のスレッドを使用し、それらのスレッドが (スレッドプールを使用して) リサイクルされて、複数の (無関係だが連続した) タスクを実行することを前提としています。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "This pattern has multiple advantages, such as:"
msgstr "このパターンには、次のような複数の利点があります。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Allocation benefit: heavy objects are only allocated once per thread, but because the number of these threads was intended to be limited, it would not use too much memory."
msgstr "割り当ての利点: 重いオブジェクトはスレッドごとに 1 回だけ割り当てられますが、これらのスレッドの数は制限されることが意図されているため、メモリーがあまり使用されません。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Thread safety: only one thread can access the object stored in the thread local - preventing concurrent accesses."
msgstr "スレッドの安全性: スレッドローカルに格納されたオブジェクトにアクセスできるのは 1 つのスレッドのみであり、同時アクセスを防止します。"

#: _guides/virtual-threads.adoc
msgid ""
"However, this pattern is counter-productive when using virtual threads.\n"
"Virtual threads are not pooled and generally short-lived.\n"
"So, instead of a few of them, we now have many of them.\n"
"For each of them, the object stored in the `ThreadLocal` is created (often large and expensive) and won't be reused, as the virtual thread is not pooled (and won't be used to run another task once the execution completes).\n"
"This problem leads to high memory usage.\n"
"Unfortunately, it requires sophisticated code changes in the libraries themselves."
msgstr ""
"ただし、このパターンは仮想スレッドを使用する場合には逆効果になります。\n"
"仮想スレッドはプールされず、一般的に短命です。\n"
"そのため、少数のスレッドを使用するのではなく、大量のスレッドを扱うことになります。\n"
"それぞれのスレッドに対して、 `ThreadLocal` に格納されるオブジェクトが作成されます (多くの場合、サイズが大きく、コストもかかります)。しかし、仮想スレッドはプールされず (実行が完了した後に別のタスクを実行することもないため)、これらのオブジェクトは再利用されません。\n"
"この問題により、メモリー使用量が増加します。\n"
"残念ながら、この問題を解決するには、ライブラリー自体に高度なコード変更が必要になります。"

#: _guides/virtual-threads.adoc
msgid "Use @RunOnVirtualThread with Quarkus REST (formerly RESTEasy Reactive)"
msgstr "Quarkus REST (旧 RESTEasy Reactive) で @RunOnVirtualThread を使用する"

#: _guides/virtual-threads.adoc
msgid ""
"This section shows a brief example of using the link:{runonvthread}[@RunOnVirtualThread] annotation.\n"
"It also explains the various development and execution models offered by Quarkus."
msgstr ""
"このセクションでは、link:{runonvthread}[@RunOnVirtualThread] アノテーションの簡単な使用例を紹介します。\n"
"また、Quarkus が提供するさまざまな開発モデルと実行モデルについても説明します。"

#: _guides/virtual-threads.adoc
msgid ""
"The `@RunOnVirtualThread` annotation instructs Quarkus to invoke the annotated method on a **new** virtual thread instead of the current one.\n"
"Quarkus handles the creation of the virtual thread and the offloading."
msgstr ""
"`@RunOnVirtualThread` アノテーションは、Quarkusに対して、現在のスレッドではなく *新しい* 仮想スレッドでアノテーションされたメソッドを呼び出すように指示します。\n"
"Quarkusは仮想スレッドの作成とオフロードを処理します。"

#: _guides/virtual-threads.adoc
msgid "Since virtual threads are disposable entities, the fundamental idea of `@RunOnVirtualThread` is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop or worker thread (in the case of Quarkus REST)."
msgstr "仮想スレッドは使い捨てのエンティティーであるため、 `@RunOnVirtualThread` の基本的な考え方は、エンドポイントハンドラーの実行をイベントループやワーカースレッド (Quarkus REST の場合) で実行する代わりに、新しい仮想スレッド上でオフロードすることです。"

#: _guides/virtual-threads.adoc
msgid ""
"To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.\n"
"If the Java Virtual Machine used to **run** the application provides virtual thread support (so Java 21 or later versions), then the endpoint execution is offloaded to a virtual thread.\n"
"It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr ""
"そのためには、エンドポイントに link:{runonvthread}[@RunOnVirtualThread] アノテーションを追加すれば十分です。\n"
"アプリケーションの **実行** に使用される Java 仮想マシンが仮想スレッドのサポートを提供している場合 (Java 21 以降のバージョン)、エンドポイントの実行は仮想スレッドにオフロードされます。\n"
"これにより、仮想スレッドがマウントされているプラットフォームスレッドをブロックすることなく、ブロッキング処理を実行できるようになります。"

#: _guides/virtual-threads.adoc
msgid ""
"In the case of Quarkus REST, this annotation can only be used on endpoints annotated with link:{blockingannotation}[@Blocking] or\n"
"considered blocking because of their signature.\n"
"You can visit xref:rest.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking]\n"
"for more information."
msgstr ""
"Quarkus REST の場合、このアノテーションは、link:{blockingannotation}[@Blocking] のアノテーションが付与されたエンドポイント、\n"
"またはそのシグネチャーによりブロッキングと見なされるエンドポイントでのみ使用できます。\n"
"詳細は、xref:rest.adoc#execution-model-blocking-non-blocking[実行モデル、ブロッキング、ノンブロッキング] \n"
"を参照してください。"

#: _guides/virtual-threads.adoc
msgid "Get started with virtual threads with Quarkus REST"
msgstr "Quarkus REST で仮想スレッドを使い始める"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Add the following dependency to your build file:"
msgstr "ビルドファイルに以下の依存関係を追加します。"

#. type: Block title
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#: _guides/virtual-threads.adoc
msgid "Then, you also need to make sure that you are using Java 21+, this can be enforced in your pom.xml file with the following:"
msgstr "次に、Java 21 以降を使用していることも確認する必要があります。これは、pom.xml ファイルで次のように強制できます。"

#. type: Title ====
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Three development and execution models"
msgstr "3 つの開発および実行モデル"

#: _guides/virtual-threads.adoc
msgid ""
"The example below shows the differences between three endpoints, all of them querying a _fortune_ in the database then\n"
"returning it to the client."
msgstr ""
"以下の例は、3 つのエンドポイントの違いを示しています。これらのエンドポイントはすべて、データベース上の _財産_ を照会し、\n"
"それをクライアントに返します。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "1 つ目は伝統的なブロッキングスタイルを採用しており、そのシグネチャーからブロッキングとみなされます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "the second one uses Mutiny, it is considered non-blocking due to its signature."
msgstr "2 つ目は Mutiny を使用し、そのシグネチャーによりノンブロッキングとみなされます。"

#: _guides/virtual-threads.adoc
msgid ""
"the third one uses Mutiny but in a synchronous way, since it doesn't return a \"reactive type\" it is\n"
"considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr ""
"3 つ目は Mutiny を使用しますが、同期的な方法で使用し、\"reactive type\" を返さないので、ブロッキングとみなされ、\n"
"link:{runonvthread}[@RunOnVirtualThread] アノテーションを使用できます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "The following table summarizes the options:"
msgstr "以下の表は各選択肢の概要です。"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Model"
msgstr "モデル"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Example of signature"
msgstr "シグネチャーの例"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Pros"
msgstr "長所"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Cons"
msgstr "短所"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Synchronous code on worker thread"
msgstr "同期コードでワーカースレッド上"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "`Fortune blocking()`"
msgstr "`Fortune blocking()`"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Simple code"
msgstr "シンプルなコード"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Use worker thread (limit concurrency)"
msgstr "ワーカースレッドを使用 (同時実行に制限)"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Reactive code on event loop"
msgstr "リアクティブコードでイベントループ上"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "`Uni<Fortune> reactive()`"
msgstr "`Uni<Fortune> reactive()`"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "High concurrency and low resource usage"
msgstr "高い同時実行性と低いリソース使用量"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "More complex code"
msgstr "より複雑なコード"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Synchronous code on virtual thread"
msgstr "同期コードで仮想スレッド上"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "`@RunOnVirtualThread Fortune vt()`"
msgstr "`@RunOnVirtualThread Fortune vt()`"

#. type: Table
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Risk of pinning, monopolization and under-efficient object pooling"
msgstr "ピニング、独占、効率の悪いオブジェクトプーリングのリスク"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Note that all three models can be used in a single application."
msgstr "この 3 つのモデルすべてを 1 つのアプリケーションで使用できます。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Use virtual thread friendly clients"
msgstr "仮想スレッドフレンドリーなクライアントの使用"

#: _guides/virtual-threads.adoc
msgid ""
"As mentioned in the xref:why-not[Why not run everything on virtual threads?] section, the Java ecosystem is not entirely ready for virtual threads.\n"
"So, you need to be careful, especially when using a libraries doing I/O."
msgstr ""
"xref:why-not[すべてを仮想スレッドで実行しない理由] セクションで述べたように、Java エコシステムは仮想スレッドに完全には対応していません。\n"
"したがって、特に I/O を実行するライブラリーを使用する場合は注意が必要です。"

#: _guides/virtual-threads.adoc
msgid ""
"Fortunately, Quarkus provides a massive ecosystem that is ready to be used in virtual threads.\n"
"Mutiny, the reactive programming library used in Quarkus, and the Vert.x Mutiny bindings provides the ability to write blocking code (so, no fear, no learning curve) which do not pin the carrier thread."
msgstr ""
"幸いなことに、Quarkus は仮想スレッドですぐに使用できる大規模なエコシステムを提供しています。\n"
"Quarkus で使用されるリアクティブプログラミングライブラリーである Mutiny と Vert.x Mutiny バインディングは、キャリアースレッドをピン留めしないブロッキングコード (したがって、恐れる必要はなく、学習曲線もありません) を記述する機能を提供します。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "As a result:"
msgstr "上記の結果として、以下のようになります。"

#: _guides/virtual-threads.adoc
msgid ""
"Quarkus extensions providing blocking APIs on top of reactive APIs can be used in virtual threads.\n"
"This includes the REST Client, the Redis client, the mailer..."
msgstr ""
"リアクティブ API の上にブロッキング API を提供する Quarkus エクステンションは、仮想スレッドで使用できます。\n"
"これには、REST Client、Redis クライアント、メーラーなどが含まれます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "API returning `Uni` can be used directly using `uni.await().atMost(...)`. It blocks the virtual thread, without blocking the carrier thread, and also improves the resilience of your application with an easy (non-blocking) timeout support."
msgstr "`Uni` を返す API は、 `uni.await().atMost(...)` を使用して直接使用できます。これは、キャリアースレッドをブロックせずに仮想スレッドをブロックし、簡単な (非ブロッキング) タイムアウトサポートによってアプリケーションの耐障害性も向上させます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "If you use a https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Vert.x client using the Mutiny bindings], use the `andAwait()` methods which block until you get the result without pinning the carrier thread. It includes all the reactive SQL drivers."
msgstr "https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Mutiny バインディングを使用する Vert.x クライアント] を使用する場合は、キャリアースレッドをピニングせずに結果を取得するまでブロックする `andAwait()` メソッドを使用します。これには、すべてのリアクティブ SQL ドライバーが含まれます。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Detect pinned thread in tests"
msgstr "テストでピン留めされたスレッドを検出する"

#: _guides/virtual-threads.adoc
msgid ""
"We recommend to use the following configuration when running tests in application using virtual threads.\n"
"If would not fail the tests, but at least dump start traces if the code pins the carrier thread:"
msgstr ""
"仮想スレッドを使用するアプリケーションでテストを実行する場合は、以下の設定を使用することを推奨します。\n"
"テストが失敗することはありませんが、コードがキャリアースレッドをピン留めした場合は、少なくともスタートトレースをダンプします："

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Run application using virtual threads"
msgstr "仮想スレッドを使用したアプリケーションの実行"

#: _guides/virtual-threads.adoc
msgid "Prior to Java 21, virtual threads were still an experimental feature, you need to start your application with the `--enable-preview` flag."
msgstr "Java 21 以前では、仮想スレッドはまだ実験的な機能であったため、 `--enable-preview` フラグを付けてアプリケーションを起動する必要があります。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Build containers for application using virtual threads"
msgstr "仮想スレッドを使用したアプリケーションのコンテナーのビルド"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "When running your application in JVM mode (so not compiled into native, for native check xref:native[the dedicated section]), you can follow the xref:./container-image.adoc[containerization guide] to build a container."
msgstr "アプリケーションを JVM モードで実行する場合 (つまりネイティブにコンパイルしない場合、ネイティブについては xref:native[専用のセクション] を参照してください）、xref:./container-image.adoc[コンテナー化ガイド] に従ってコンテナーをビルドすることができます。"

#: _guides/virtual-threads.adoc
msgid ""
"In this section, we use JIB to build the container.\n"
"Refer to the xref:./container-image.adoc[containerization guide] to learn more about the alternatives."
msgstr ""
"このセクションでは、JIB を使用してコンテナーをビルドします。\n"
"他の方法については、 xref:./container-image.adoc[コンテナー化ガイド] を参照してください。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "To containerize your Quarkus application that use `@RunOnVirtualThread`, add the following properties in your `application.properties`:"
msgstr "`@RunOnVirtualThread` を使用する Quarkus アプリケーションをコンテナー化するには、 `application.properties` に以下のプロパティーを追加します。"

#: _guides/virtual-threads.adoc
msgid "Make sure you use a base image supporting virtual threads. Here we use an image providing Java 21. Quarkus picks an image providing Java 21+ automatically if you do not set one."
msgstr "仮想スレッドをサポートするベースイメージを使用するようにしてください。ここでは、Java 21 を提供するイメージを使用します。設定しない場合は、Quarkus によって Java 21+ を提供するイメージが自動的に選択されます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Select the target architecture. You can select more than one to build multi-archs images."
msgstr "ターゲットアーキテクチャーを選択します。複数選択して multi-archs イメージを構築できます。"

#: _guides/virtual-threads.adoc
msgid ""
"Then, build your container as you would do usually.\n"
"For example, if you are using Maven, run:"
msgstr ""
"次に、通常と同じようにコンテナーをビルドします。\n"
"例えば、Maven を使用している場合、次を実行します。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Compiling Quarkus application using virtual threads into native executable"
msgstr "仮想スレッドを使用した Quarkus アプリケーションのネイティブ実行可能ファイルへのコンパイル"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Using a local GraalVM installation"
msgstr "ローカルにインストールした GraalVM の使用"

#: _guides/virtual-threads.adoc
msgid "To compile a Quarkus applications leveraging `@RunOnVirtualThread` into a native executable, you must be sure to use a GraalVM / Mandrel `native-image` supporting virtual threads, so providing at least Java 21."
msgstr "`@RunOnVirtualThread` を活用した Quarkus アプリケーションをネイティブ実行可能ファイルにコンパイルするには、仮想スレッドをサポートする GraalVM/Mandrel `native-image` を使用する必要があり、少なくとも Java 21 を提供する必要があります。"

#: _guides/virtual-threads.adoc
msgid ""
"Build the native executable as indicated on xref:./building-native-image.adoc[the native compilation guide].\n"
"For example, with Maven, run:"
msgstr ""
"xref:./building-native-image.adoc[ネイティブコンパイルガイド] に示されているように、ネイティブ実行可能ファイルをビルドします。\n"
"たとえば、Maven の場合は、以下を実行します。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Using an in-container build"
msgstr "コンテナー内ビルドの使用"

#: _guides/virtual-threads.adoc
msgid ""
"In-container build allows building Linux 64 executables by using a `native-image` compiler running in a container.\n"
"It avoids having to install `native-image` on your machine, and also allows configuring the GraalVM version you need.\n"
"Note that, to use in-container build, you must have Docker or Podman installed on your machine."
msgstr ""
"コンテナー内ビルドでは、コンテナー内で動作する `native-image` コンパイラを使用して Linux 64 実行可能ファイルをビルドできます。\n"
"これは、 `native-image` をマシンにインストールする手間を省き、必要な GraalVM バージョンを設定することもできます。\n"
"コンテナー内ビルドを使用するには、DockerまたはPodmanがマシンにインストールされている必要があることに注意してください。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Then, add to your `application.properties` file:"
msgstr "そして `application.properties` ファイルに追加します。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Enables the in-container build"
msgstr "コンテナー内ビルドを有効にします。"

#. type: Block title
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "From ARM/64 to AMD/64"
msgstr "ARM/64 から AMD/64 へ"

#: _guides/virtual-threads.adoc
msgid ""
"If you are using a Mac M1 or M2 (using an ARM64 CPU), you need to be aware that the native executable you will get using an in-container build will be a Linux executable, but using your host (ARM 64) architecture.\n"
"You can use emulation to force the architecture when using Docker with the following property:"
msgstr ""
"Mac M1 または M2 (ARM64 CPU を使用) を使用している場合、コンテナー内ビルドを使用して取得するネイティブ実行可能ファイルは Linux 実行可能ファイルですが、ホスト (ARM64) アーキテクチャーを使用していることに注意する必要があります。\n"
"以下のプロパティーで Docker を使用する際に、エミュレーションを使用して強制的にアーキテクチャーを変更することができます。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "Be aware that it increases the compilation time... a lot (>10 minutes)."
msgstr "コンパイル時間がかなり長くなる (10分以上) ことに注意してください。"

#. type: Title ===
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Containerize native applications using virtual threads"
msgstr "仮想スレッドを使用したネイティブアプリケーションのコンテナー化"

#: _guides/virtual-threads.adoc
msgid ""
"To build a container running a Quarkus application using virtual threads compiled into a native executable, you must\n"
"make sure you have a Linux/AMD64 executable (or ARM64 if you are targeting ARM machines)."
msgstr ""
"ネイティブ実行可能ファイルにコンパイルされた仮想スレッドを使用して Quarkus アプリケーションを実行するコンテナーをビルドするには、\n"
"Linux/AMD64 実行ファイル (ARM マシンを対象としている場合はARM64) を用意する必要があります。"

#. type: delimited block =
#: _guides/virtual-threads.adoc
msgid "Make sure your `application.properties` contains the configuration explained in xref:native[the native compilation section]."
msgstr "`application.properties` に xref:native[ネイティブコンパイルのセクション] で説明した設定が含まれているようにしてください。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "If you ever want to build a native container image and already have an existing native image you can set `-Dquarkus.native.reuse-existing=true` and the native image build will not be re-run."
msgstr "ネイティブコンテナーイメージをビルドしたいときに、すでに既存のネイティブイメージがある場合は、 `-Dquarkus.native.reuse-existing=true` を設定すれば、ネイティブイメージのビルドは再実行されません。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Use the duplicated context in virtual threads"
msgstr "仮想スレッドで複製されたコンテキストの使用"

#: _guides/virtual-threads.adoc
msgid ""
"Methods annotated with `@RunOnVirtualThread` inherit from the original duplicated context (See the xref:duplicated-context.adoc[duplicated context reference guide] for details).\n"
"So, the data written in the duplicated context (and the request scope, as the request scoped is stored in the duplicated context) by filters and interceptors are available during the method execution (even if the filters and interceptors are not run on the virtual thread)."
msgstr ""
"`@RunOnVirtualThread` でアノテーションされたメソッドは、複製された元のコンテキストを継承します (詳細は xref:duplicated-context.adoc[複製されたコンテキストのリファレンスガイド] を参照)。\n"
"そのため、フィルタやインターセプタによって複製されたコンテキストに書き込まれたデータ (およびリクエストスコープが複製されたコンテキストに格納されているため、リクエストスコープ) は、メソッドの実行中に (フィルタやインターセプタが仮想スレッド上で実行されていなくても) 利用可能です。"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "However, thread locals are not propagated."
msgstr "ただし、スレッドローカルは伝播されません。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Virtual thread names"
msgstr "仮想スレッド名"

#: _guides/virtual-threads.adoc
msgid ""
"Virtual threads are created without a thread name by default, which is not practical to identify the execution for debugging and logging purposes.\n"
"Quarkus managed virtual threads are named and prefixed with `quarkus-virtual-thread-`.\n"
"You can customize this prefix, or disable the naming altogether configuring an empty value:"
msgstr ""
"仮想スレッドは、デフォルトではスレッド名なしで作成されます。これは、デバッグやロギング目的で実行を識別するためには実用的ではありません。\n"
"Quarkus の管理対象仮想スレッドには名前が付けられ、 `quarkus-virtual-thread-` というプレフィックスが付けられます。\n"
"このプレフィックスはカスタマイズすることも、空の値を設定して命名を完全に無効にすることもできます。"

#: _guides/virtual-threads.adoc
msgid "Inject the virtual thread executor"
msgstr "仮想スレッドエグゼキュータの注入"

#: _guides/virtual-threads.adoc
msgid ""
"In order to run tasks on virtual threads Quarkus manages an internal `ThreadPerTaskExecutor`.\n"
"In rare instances where you'd need to access this executor directly you can inject it using the `@VirtualThreads` CDI qualifier:"
msgstr ""
"仮想スレッド上でタスクを実行するために、Quarkus は内部 `ThreadPerTaskExecutor` を管理します。\n"
"まれにこのエクゼキューターに直接アクセスする必要がある場合は、 `@VirtualThreads` CDI 修飾子を使用して注入できます。"

#: _guides/virtual-threads.adoc
msgid "Injecting the Virtual Thread ExecutorService is experimental and may change in future versions."
msgstr "Virtual Thread ExecutorService の注入は実験的なもので、将来のバージョンで変更される可能性があります。"

#: _guides/virtual-threads.adoc
msgid "Testing virtual thread applications"
msgstr "仮想スレッドアプリケーションのテスト"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"As mentioned above, virtual threads have a few limitations that can drastically affect your application performance and memory usage.\n"
"The _junit-virtual-threads_ extension provides a way to detect pinned carrier threads while running your tests.\n"
"Thus, you can eliminate one of the most prominent limitations or be aware of the problem."
msgstr "上述したように、仮想スレッドにはいくつかの制限があり、 アプリケーションのパフォーマンスやメモリ使用量に大きな影響を与える可能性があります。 _junit-virtual-threads_ 拡張モジュールは、テストの実行中にピン留めされたキャリアスレッドを検出する方法を提供します。このため、最も顕著な制限のひとつを取り除いたり、 問題に気づいたりすることができます。"

#: _guides/virtual-threads.adoc
msgid "To enable this detection:"
msgstr "この検出を有効にするには"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "1) Add the `junit-virtual-threads` dependency to your project:"
msgstr "1) `junit-virtual-threads` の依存関係をプロジェクトに追加します："

#: _guides/virtual-threads.adoc
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus.junit</groupId>\n"
"    <artifactId>junit-virtual-threads</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>"
msgstr ""

#: _guides/virtual-threads.adoc
#, fuzzy
msgid "2) In your test case, add the `io.quarkus.test.junit.virtual.VirtualThreadUnit`  and `io.quarkus.test.junit.virtual.ShouldNotPin` annotations:"
msgstr "2) テストケースに、 `io.quarkus.test.junit.virtual.VirtualThreadUnit` と `io.quarkus.test.junit.virtual.ShouldNotPin` のアノテーションを追加します："

#: _guides/virtual-threads.adoc
msgid ""
"@QuarkusTest\n"
"@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n"
"@VirtualThreadUnit // Use the extension\n"
"@ShouldNotPin // Detect pinned carrier thread\n"
"class TodoResourceTest {\n"
"    // ...\n"
"}"
msgstr ""
"@QuarkusTest\n"
"@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n"
"@VirtualThreadUnit // Use the extension\n"
"@ShouldNotPin // Detect pinned carrier thread\n"
"class TodoResourceTest {\n"
"    // ...\n"
"}"

#: _guides/virtual-threads.adoc
msgid ""
"When you run your test (remember to use Java 21+), Quarkus detects pinned carrier threads.\n"
"When it happens, the test fails."
msgstr ""
"テストを実行する場合は (Java 21+ を使用することを忘れないでください)、Quarkus はピン留めされたキャリアースレッドを検出します。\n"
"この場合、テストは失敗します。"

#: _guides/virtual-threads.adoc
msgid "The `@ShouldNotPin` can also be used on methods directly."
msgstr "`@ShouldNotPin` はメソッドに直接使うこともできます。"

#: _guides/virtual-threads.adoc
#, fuzzy
msgid ""
"The _junit-virtual-threads_ also provides a `@ShouldPin` annotation for cases where pinning is unavoidable.\n"
"The following snippet demonstrates the `@ShouldPin` annotation usage."
msgstr "_junit-virtual-threadsは_ 、ピニングが避けられない場合のために `@ShouldPin` アノテーションも提供しています。次のスニペットは `@ShouldPin` アノテーションの使い方を示しています。"

#: _guides/virtual-threads.adoc
msgid "Virtual thread metrics"
msgstr "仮想スレッドメトリクス"

#: _guides/virtual-threads.adoc
msgid "You can enable the Micrometer Virtual Thread _binder_ by adding the following artifact to your application:"
msgstr "アプリケーションに次のアーティファクトを追加することで、Micrometer 仮想スレッド _バインダー_ を有効化できます。"

#: _guides/virtual-threads.adoc
msgid ""
"This binder keeps track of the number of pinning events and the number of virtual threads failed to be started or un-parked.\n"
"See the https://docs.micrometer.io/micrometer/reference/reference/jvm.html#_java_21_metrics[MicroMeter documentation] for more information."
msgstr ""
"このバインダーは、ピニングイベントの数と、開始またはパーク解除に失敗した仮想スレッドの数を追跡します。\n"
"詳細は、 https://docs.micrometer.io/micrometer/reference/reference/jvm.html#_java_21_metrics[MicroMeter ドキュメント] を参照してください。"

#: _guides/virtual-threads.adoc
msgid "You can explicitly disable the binder by setting the following property in your `application.properties`:"
msgstr "`application.properties` で次のプロパティーを設定することで、バインダーを明示的に無効化できます。"

#: _guides/virtual-threads.adoc
msgid "In addition, if the application is running on a JVM that does not support virtual threads (prior to Java 21), the binder is automatically disabled."
msgstr "さらに、アプリケーションが仮想スレッドをサポートしていない JVM (Java 21 より前) 上で実行されている場合、バインダーは自動的に無効化されます。"

#: _guides/virtual-threads.adoc
msgid "You can associate tags to the collected metrics by setting the following properties in your `application.properties`:"
msgstr "`application.properties` で次のプロパティーを設定することで、収集されたメトリクスにタグを関連付けできます。"

#. type: Title ==
#: _guides/virtual-threads.adoc
#, no-wrap
msgid "Additional references"
msgstr "参考文献"

#. type: Plain text
#: _guides/virtual-threads.adoc
msgid "https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment]"
msgstr "link:https://dl.acm.org/doi/10.1145/3583678.3596895[Javaフレームワークにおける仮想スレッドの統合に関する考察：リソース制約環境におけるQuarkusの例]"
