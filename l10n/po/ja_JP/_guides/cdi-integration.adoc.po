# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-23 11:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi-integration.adoc:6
#, fuzzy, no-wrap
msgid "Quarkus - CDI Integration Guide"
msgstr "Quarkus - CDI統合ガイド"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:16
#, fuzzy
msgid "ArC, the CDI container, is bootstrapped at build time.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API."
msgstr "CDI コンテナーである ArC はビルド時にブートストラップされます。このアプローチの欠点は、CDI Portable Extensionsをサポートできないことです。それにもかかわらず、Quarkus固有の拡張機能APIを使用して機能を実現することができます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:19
#, fuzzy
msgid "The container is bootstrapped in multiple phases.  From a high level perspective these phases go as follows:"
msgstr "コンテナーは複数のフェーズでブートストラップされます。高レベルの視点から見ると、これらのフェーズは以下のようになります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:21
#, fuzzy
msgid "Initialization"
msgstr "初期化"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:22
#, fuzzy
msgid "Bean discovery"
msgstr "豆の発見"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:23
#, fuzzy
msgid "Registration of synthetic components"
msgstr "合成成分の登録"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:24
#, fuzzy
msgid "Validation"
msgstr "バリデーション"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:31
#, fuzzy
msgid "In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.  _Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.  Subsequently, the extensions can register _synthetic components_.  Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.  Finally, the _deployment is validated_.  For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr "_初期化_ フェーズでは、準備作業が行われ、カスタムコンテキストが登録されます。その後、コンテナーがすべてのアプリケーションクラスを分析し、ビーンを識別し、提供されたメタデータに基づいてそれらをすべて配線するプロセスがビーン _発見_ である。その後、拡張機能は _合成コンポーネントを_ 登録することができます。これらのコンポーネントの属性は拡張機能によって完全に制御されます。最後に、 _デプロイメントが検証されます_ 。例えば、コンテナーはアプリケーション内のすべての注入ポイントを検証し、与えられた必要な型と修飾子を満たすBeanがない場合はビルドを失敗させます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:33
#, fuzzy
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr "追加のロギングを有効にすることで、ブートストラップに関するより多くの情報を見ることができます。 `-X` または `--debug` で Maven ビルドを実行し、 `io.quarkus.arc` を含む行を grep するだけです。 link:cdi-reference.html#dev-mode[開発モード] では、 `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` を使用することができ、2つの特別なエンドポイントも自動的に登録され、JSON形式でいくつかの基本的なデバッグ情報を提供します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:36
#, fuzzy
msgid "Quarkus build steps can produce and consume various build items and hook into each phase.  In the following sections we will describe all the relevant build items and common scenarios."
msgstr "Quarkusのビルドステップでは、さまざまなビルドアイテムを生成したり消費したりして、各フェーズにフックすることができます。以下のセクションでは、関連するすべてのビルド項目と一般的なシナリオについて説明します。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:37
#, fuzzy, no-wrap
msgid "Metadata Sources"
msgstr "メタデータソース"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:44
#, fuzzy
msgid "Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during <<cdi-reference.adoc#bean_discovery,bean discovery>>.  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register <<synthetic_beans,synthetic components>>.  This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr "クラスとアノテーションは、ビーンレベルのメタデータの主要なソースです。初期のメタデータは、ビーン link:cdi-reference.html#bean_discovery[の発見] 時に様々なソースから構築される不変の link:https://github.com/wildfly/jandex[Jandexインデックス, window=\"_blank\"] である _ビーンアーカイブインデックス_ から読み込まれます。しかし、拡張機能は、ブートストラップの特定の段階でメタデータを追加、削除、変換することができます。さらに、拡張機能は link:#synthetic_beans[合成コンポーネントを] 登録することもできます。これは、CDIコンポーネントをQuarkusに統合する際に実現すべき重要な側面です。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:47
#, fuzzy
msgid "This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.  For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr "このようにして、拡張機能は、そうでなければ無視されていたクラスをビーンに変えたり、その逆を行ったりすることができます。例えば、 `@Scheduled` メソッドを宣言するクラスは、たとえそれがビーン定義アノテーションでアノテーションされておらず、通常は無視されるようなクラスであっても、常にビーンとして登録されます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:51
#, fuzzy, no-wrap
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr "使用例 - クラスがBeanとして認識されない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:57
#, fuzzy
msgid "An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_."
msgstr "`UnsatisfiedResolutionException` は、 link:cdi.html#typesafe_resolution[タイプセーフの解決] 時に問題があることを示しています。クラスパス上にインジェクションが可能なクラスがあっても、インジェクションポイントを満たすことができないことがあります。クラスが認識されない理由はいくつかありますが、それを解決する方法もいくつかあります。最初のステップでは、その _理由_ を特定する必要があります。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:59
#, fuzzy, no-wrap
msgid "_Reason 1_: Class Is Not discovered "
msgstr "_理由1_ :クラスが発見されない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:64
#, fuzzy
msgid "Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "Quarkusには link:cdi-reference.html#bean_discovery[簡易ディスカバリー] があります。クラスがアプリケーションのインデックスに含まれていないことが起こるかもしれません。例えば、Quarkus拡張の _ランタイムモジュール_ のクラスは自動的にインデックス化されません。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:68
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem`.  This build item can be used to specify one or more additional classes to be analyzed during the discovery.  Additional bean classes are transparently added to the application index processed by the container."
msgstr "_解決策_ 。 `AdditionalBeanBuildItem` .このビルド項目は、ディスカバリー中に解析する1つ以上の追加クラスを指定するために使用することができます。追加のビーン・クラスは、コンテナーによって処理されるアプリケーション・インデックスに透過的に追加されます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:69
#, fuzzy, no-wrap
msgid "`AdditionalBeanBuildItem` Example"
msgstr "`AdditionalBeanBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:76
#, no-wrap
msgid ""
"@BuildStep\n"
"AdditionalBeanBuildItem additionalBeans() {\n"
"     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:78
#, fuzzy
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr "`AdditionalBeanBuildItem.Builder` は、より複雑なユースケースに使用することができます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:83
#, fuzzy
msgid "Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
msgstr "`AdditionalBeanBuildItem` 経由で追加された Bean クラスは、デフォルトでは _取り外し可能です_ 。コンテナーがそれらを link:cdi-reference.html#remove_unused_beans[未使用] とみなした場合、それらはただ無視されます。しかし、 `AdditionalBeanBuildItem.Builder.setUnremovable()` メソッドを使用して、このビルド項目を介して登録されたビーンクラスを絶対に削除しないようにコンテナーに指示することができます。詳細は、未使用のBeanの link:cdi-reference.html#remove_unused_beans[削除] と link:#unremovable_builditem[[unremovable_builditem]] も参照してください。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:86
#, fuzzy
msgid "It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.  The default scope is only used if there is no scope declared on the bean class."
msgstr "`AdditionalBeanBuildItem.Builder#setDefaultScope()` からデフォルトのスコープを設定することも可能です。デフォルトのスコープは、ビーンクラスにスコープが宣言されていない場合にのみ使用されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:88
#: upstream/_guides/cdi-integration.adoc:130
#, fuzzy
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr "デフォルトスコープが指定されていない場合は `@Dependent` 擬似スコープが使用されます。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:89
#, fuzzy, no-wrap
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr "_理由2_ : クラスは発見されたが、Beanを定義するアノテーションがない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:94
#, fuzzy
msgid "In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].  Therefore, bean classes that don't have a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.  Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`."
msgstr "Quarkusでは、アプリケーションは単一のビーンアーカイブで表現され、ビ link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[ーン発見モード `annotated`, window=\"_blank\"] .したがって、ビーン link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[定義アノテーション, window=\"_blank\"] を持たないビーンクラスは無視されます。Bean定義アノテーションはクラスレベルで宣言され、スコープ、ステレオタイプ、 `@Interceptor` ."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:96
#, fuzzy
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr "_解決策1_ : `AutoAddScopeBuildItem` .このビルド項目を使用すると、特定の条件を満たすクラスにスコープを追加することができます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:97
#, fuzzy, no-wrap
msgid "`AutoAddScopeBuildItem` Example"
msgstr "`AutoAddScopeBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:106
#, no-wrap
msgid ""
"@BuildStep\n"
"AutoAddScopeBuildItem autoAddScope() {\n"
"   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n"
"      .defaultScope(BuiltinScope.SINGLETON) <2>\n"
"      .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:108
#, fuzzy
msgid "Find all classes annotated with `@Scheduled`."
msgstr "`@Scheduled` でアノテーションされたすべてのクラスを検索します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:109
#, fuzzy
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr "デフォルトのスコープとして `@Singleton` を追加。既にスコープでアノテーションされているクラスは自動的にスキップされます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:111
#, fuzzy
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr "_解決策2_ : 特定のアノテーションでアノテーションされたクラスを処理する必要がある場合、 `BeanDefiningAnnotationBuildItem` ."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:112
#, fuzzy, no-wrap
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr "`BeanDefiningAnnotationBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:119
#, no-wrap
msgid ""
"@BuildStep\n"
"BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n"
"   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:121
#, fuzzy
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr "`org.eclipse.microprofile.graphql.GraphQLApi` をビーン定義アノテーションのセットに追加します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:125
#, fuzzy
msgid "Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.  However, you can change the default behavior.  See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
msgstr "`BeanDefiningAnnotationBuildItem` 経由で追加されたビーンクラスはデフォルトでは _削除できません_ 。しかし、デフォルトの動作を変更することができます。詳細については、未使用のビーン link:cdi-reference.html#remove_unused_beans[の削除] と link:#unremovable_builditem[[unremovable_builditem]] も参照してください。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:128
#, fuzzy
msgid "It is also possible to specify the default scope.  The default scope is only used if there is no scope declared on the bean class."
msgstr "デフォルトのスコープを指定することも可能です。デフォルトのスコープは、ビーンクラスにスコープが宣言されていない場合にのみ使用されます。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:132
#, fuzzy, no-wrap
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr "_理由3_ : クラスが発見され、Bean定義アノテーションを持っていたが削除された"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:139
#, fuzzy
msgid "The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.  This optimization allows for _framework-level dead code elimination_.  In few special cases, it's not possible to correctly identify an unused bean.  In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.  Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr "コンテナーは、デフォルトではビルド中に link:cdi-reference.html#remove_unused_beans[すべての未使用のビーンを削除] しようとします。この最適化により、 _フレームワークレベルでのデッドコードの除去_ が可能になります。いくつかの特別なケースでは、未使用のビーンを正しく識別することができません。特に、Quarkusは `CDI.current()` 静的メソッドの使用状況をまだ検出できません。拡張機能では、 `UnremovableBeanBuildItem` ."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:140
#, fuzzy, no-wrap
msgid "`UnremovableBeanBuildItem` Example"
msgstr "`UnremovableBeanBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:147
#, no-wrap
msgid ""
"@BuildStep\n"
"UnremovableBeanBuildItem unremovableBeans() {\n"
"   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:149
#, fuzzy
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr "`@Startup` でアノテーションされたすべてのクラスを削除できないようにする。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:150
#, fuzzy, no-wrap
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr "使用例 - アノテーションが修飾子またはインターセプターバインディングとして認識されない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:154
#, fuzzy
msgid "It is likely that the annotation class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "アノテーションクラスがアプリケーションインデックスの一部ではない可能性があります。例えば、Quarkus拡張の _ランタイムモジュール_ からのクラスは自動的にインデックス化されません。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:156
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>."
msgstr "_解決方法_ 。 link:#additional_bean_build_item[additional_bean_build_item]] に記載されているように、 `AdditionalBeanBuildItem` を使用します。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:158
#, fuzzy, no-wrap
msgid "Use Case - I Need To Transform Metadata"
msgstr "ユースケース - メタデータを変換する必要がある"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:163
#, fuzzy
msgid "In some cases, it's useful to be able to modify the metadata.  Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].  With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr "場合によっては、メタデータを修正できると便利です。Quarkusは、以下のような強力な代替手段を提供します。 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] . `AnnotationsTransformerBuildItem` で、ビーンクラスに存在するアノテーションをオーバーライドすることが可能です。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:166
#, fuzzy
msgid "For example, you might want to add an interceptor binding to a specific bean class.  Here is how to do it:"
msgstr "例えば、特定のビーンクラスにインターセプターバインディングを追加したいとします。以下にその方法を示します。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:167
#, fuzzy, no-wrap
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr "`AnnotationsTransformerBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:173
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:177
#, no-wrap
msgid ""
"      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n"
"         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n"
"      }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:185
#, no-wrap
msgid ""
"      public void transform(TransformationContext context) {\n"
"         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n"
"            context.transform().add(MyInterceptorBinding.class).done(); <2>\n"
"         }\n"
"      }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:187
#, fuzzy
msgid "The transformer is only applied to classes."
msgstr "トランスはクラスにのみ適用されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:188
#, fuzzy
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`."
msgstr "クラス名が `org.acme.Bar` に等しい場合は、 `@MyInterceptorBinding` を追加します。 `Transformation#done()` を呼び出すことを忘れないでください。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:190
#, fuzzy
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr "注釈変換器は、ビーンの発見が始まる _前に_ 生成されなければならないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:192
#, fuzzy
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr "ビルド手順では、 `TransformedAnnotationsBuildItem` を介して、指定されたアノテーション ターゲットの変換されたアノテーションをクエリすることができます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:193
#, fuzzy, no-wrap
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr "`TransformedAnnotationsBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:203
#, no-wrap
msgid ""
"@BuildStep\n"
"void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n"
"   ClassInfo myClazz = ...;\n"
"   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:205
#, fuzzy
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr "`TransformedAnnotationsBuildItem.getAnnotations()` は、変換された可能性のあるアノテーションのセットを返します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:207
#, fuzzy
msgid "There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>."
msgstr "他にも変換に特化したビルド項目があります。 link:#additional_interceptor_bindings[additional_interceptor_bindings]] と link:#injection_point_transformation[[injection_point_transformation]] です。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:209
#, fuzzy, no-wrap
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr "使用例 - 豆、オブザーバー、インジェクションポイントの検査"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:211
#, fuzzy, no-wrap
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr "_解決策1._ `BeanDiscoveryFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:215
#, fuzzy
msgid "Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.  However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr "`BeanDiscoveryFinishedBuildItem` の消費者は、アプリケーションに登録されているすべてのクラスベースのビーンズ、オブザーバー、インジェクションポイントを簡単に検査することができます。ただし、このビルド項目は合成成分が登録される _前に_ 生成されるため、合成ビーンズとオブザーバーは _含まれ_ ません。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:217
#, fuzzy
msgid "Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "さらに、 `BeanDiscoveryFinishedBuildItem#getBeanResolver()` から返されたビーンリゾルバは、タイプセーフな解決ルールを適用するために使用することができます。例えば、必要な型と修飾子の特定の組み合わせを満たすビーンがあるかどうかを調べるために使用します。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:218
#, fuzzy, no-wrap
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr "`BeanDiscoveryFinishedBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:226
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:228
#, fuzzy
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr "結果として得られるリストには `@Named` 合成豆は含まれません。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:229
#, fuzzy, no-wrap
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr "_解決策2_ . `SynthesisFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:232
#, fuzzy
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr "`SynthesisFinishedBuildItem` の消費者は、アプリケーションに登録されているすべてのビーンズ、オブザーバー、インジェクションポイントを簡単に検査することができます。このビルドアイテムは、合成コンポーネントが登録された _後に_ 生成されるため、合成ビーンズとオブザーバーが含まれています。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:234
#, fuzzy
msgid "Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "さらに、 `SynthesisFinishedBuildItem#getBeanResolver()` から返されたビーンリゾルバは、タイプセーフな解決ルールを適用するために使用することができます。例えば、必要な型と修飾子の特定の組み合わせを満たすビーンがあるかどうかを調べるために使用します。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:235
#, fuzzy, no-wrap
msgid "`SynthesisFinishedBuildItem` Example"
msgstr "`SynthesisFinishedBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:243
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:245
#, fuzzy
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr "結果として得られるリストには `@Named` 合成豆が含まれます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:247
#, fuzzy, no-wrap
msgid "Use Case - The Need for Synthetic Beans"
msgstr "ユースケース - 合成豆の必要性"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:253
#, fuzzy
msgid "Sometimes it is practical to be able to register a _synthetic bean_.  Bean attributes of a synthetic bean are not derived from a Java class, method or field.  Instead, all the attributes are defined by an extension.  In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods."
msgstr "_合成ビーン_ を登録できることが実用的な場合もあります。合成ビーンのビーン属性は,Javaクラス,メソッド,フィールドから派生したものではありません。その代わり、すべての属性は拡張機能によって定義されます。通常のCDIでは、これは link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] メソッドを使用します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:255
#, fuzzy
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr "_解決策_ 。合成豆を登録する必要がある場合は、 `SyntheticBeanBuildItem` ."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:256
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr "`SyntheticBeanBuildItem` 例1"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:266
#, no-wrap
msgid ""
"@BuildStep\n"
"SyntheticBeanBuildItem syntheticBean() {\n"
"   return SyntheticBeanBuildItem.configure(String.class)\n"
"             .qualifiers(new MyQualifierLiteral())\n"
"             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n"
"             .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:268
#, fuzzy
msgid "Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr "`javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` 実装のバイトコードを生成します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:272
#, fuzzy
msgid "The output of a bean configurator is recorded as bytecode.  Therefore, there are some limitations in how a synthetic bean instance is created at runtime.  You can:"
msgstr "ビーンコンフィギュレータの出力はバイトコードとして記録されます。そのため、実行時に合成ビーンインスタンスを生成する方法にはいくつかの制限があります。あなたができるのは"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:274
#, fuzzy
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr "`Contextual#create(CreationalContext<T>)` メソッドのバイトコードを `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)` を介して直接生成します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:275
#, fuzzy
msgid "Pass a `io.quarkus.arc.BeanCreator` implementation class via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`."
msgstr "`io.quarkus.arc.BeanCreator` の実装クラスを `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)` で渡し、 `ExtendedBeanConfigurator#param()` でいくつかのパラメーターを指定することもできます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:276
#, fuzzy
msgid "Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder` method>> and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`."
msgstr "link:writing-extensions.html#bytecode-recording[`@Recorder`] メソッドから返されたプロキシーを介してランタイムインスタンスを生成し、 `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` または `ExtendedBeanConfigurator#supplier(Supplier<?>)` ."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:277
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr "`SyntheticBeanBuildItem` 例2"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:287
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo()) <2>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:289
#, fuzzy
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr "デフォルトでは、合成ビーンは `STATIC_INIT` ."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:290
#, fuzzy
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr "ビーンのインスタンスは,レコーダメソッドから返された値によって供給されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:293
#, fuzzy
msgid "It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.  See the <<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr "`RUNTIME_INIT` の間に初期化される合成ビーンをマークすることが可能です。 `STATIC_INIT` と `RUNTIME_INIT` の違いについては、 link:writing-extensions.html#bootstrap-three-phases[ブートストラップとQuarkusの哲学の3つのフェーズ] を参照してください。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:294
#, fuzzy, no-wrap
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr "`RUNTIME_INIT` `SyntheticBeanBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:305
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .setRuntimeInit() <2>\n"
"                .runtimeValue(recorder.createFoo())\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:307
#, fuzzy
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr "レコーダーは `ExecutionTime.RUNTIME_INIT` フェーズで実行する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:308
#, fuzzy
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr "Beanインスタンスは、 `RUNTIME_INIT` ."

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:312
#, fuzzy
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr "`RUNTIME_INIT` の間に初期化された合成ビーンは、 `STATIC_INIT` . `RUNTIME_INIT` の間にアクセスしてはいけません。実行時に初期化された合成ビーンにアクセスするビルドステップは、 `SyntheticBeansRuntimeInitBuildItem` ."

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:321
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) \n"
"@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n"
"void accessFoo(TestRecorder recorder) {\n"
"   recorder.foo(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:323
#, fuzzy
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr "このビルドステップは `syntheticBean()` が完了した後に実行する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:324
#, fuzzy
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr "このレコーダメソッドは、 `Foo` ビーンのインスタンスに呼び出される結果となります。"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:327
#, fuzzy
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr "`BeanRegistrationPhaseBuildItem` を使って合成豆を登録することも可能です。しかし、拡張機能の作者には、Quarkusの方がより慣用的な `SyntheticBeanBuildItem` にこだわることをお勧めします。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:329
#, fuzzy, no-wrap
msgid "Use Case - Synthetic Observers"
msgstr "ユースケース - 合成オブザーバー"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:332
#, fuzzy
msgid "Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr "link:#synthetic_beans[合成ビーンズ] と同様に、合成オブザーバ・メソッドの属性はJavaメソッドから派生したものではありません。その代わり、すべての属性は拡張子によって定義されます。"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:334
#, fuzzy
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr "_解決方法_ 。合成オブザーバーを登録する必要がある場合は、 `ObserverRegistrationPhaseBuildItem` ."

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:336
#, fuzzy
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "`ObserverRegistrationPhaseBuildItem` を消費するビルドステップは、常に `ObserverConfiguratorBuildItem` を生成するか、少なくともこのビルド項目のために `BuildProducer` を注入すべきです。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:337
#, fuzzy, no-wrap
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr "`ObserverRegistrationPhaseBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:350
#, no-wrap
msgid ""
"@BuildStep\n"
"void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem, \n"
"            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n"
"   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n"
"                             .notify(mc -> {\n"
"                               // do some gizmo bytecode generation...\n"
"                             }).done();\n"
"   myBuildItem.produce(new MyBuildItem());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:355
#, fuzzy
msgid "The output of a `ObserverConfigurator` is recorded as bytecode.  Therefore, there are some limitations in how a synthetic observer is invoked at runtime.  Currently, you must generate the bytecode of the method body directly."
msgstr "`ObserverConfigurator` の出力はバイトコードとして記録されます。そのため、実行時に合成オブザーバをどのように呼び出すかには制限があります。現在のところ、メソッド本体のバイトコードを直接生成する必要があります。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:357
#, fuzzy, no-wrap
msgid "Use Case - I Have a Generated Bean Class"
msgstr "使用例 - 生成されたBeanクラスを持っています"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:361
#, fuzzy
msgid "No problem.  You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr "問題ありません。ビーンクラスのバイトコードを手動で生成することができ、あとは `GeneratedClassBuildItem` の代わりに `GeneratedBeanBuildItem` を生成するだけです。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:362
#, fuzzy, no-wrap
msgid "`GeneratedBeanBuildItem` Example"
msgstr "`GeneratedBeanBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:374
#, no-wrap
msgid ""
"@BuildStep\n"
"void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n"
"    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n"
"    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n"
"                .className(\"org.acme.MyBean\")\n"
"                .build();\n"
"    beanClassCreator.addAnnotation(Singleton.class);\n"
"    beanClassCreator.close(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:376
#, fuzzy
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` は、Gizmo の構成要素から `GeneratedBeanBuildItem` s を簡単に生成することができます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:377
#, fuzzy
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr "結果として得られるビーンクラスは `public class @Singleton MyBean { }` のようなものになります。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:378
#, fuzzy, no-wrap
msgid "Use Case - I Need to Validate the Deployment"
msgstr "ユースケース - デプロイメントを検証する必要がある"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:381
#, fuzzy
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr "時々、拡張機能はビーンズ、オブザーバ、インジェクションポイントを検査し、追加の検証を行い、何か問題があればビルドを失敗させる必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:383
#, fuzzy
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr "_解決策_ 。拡張機能がデプロイメントを検証する必要がある場合は、 `ValidationPhaseBuildItem` ."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:385
#, fuzzy
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "`ValidationPhaseBuildItem` を消費するビルドステップは、常に `ValidationErrorBuildItem` を生成するか、少なくともこのビルド項目のために `BuildProducer` を注入すべきです。"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:397
#, no-wrap
msgid ""
"@BuildStep\n"
"void validate(ValidationPhaseBuildItem validationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem, \n"
"            BuildProducer<ValidationErrorBuildItem> errors) {\n"
"   if (someCondition) {\n"
"     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:400
#, fuzzy
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr "`ValidationPhaseBuildItem.getContext().beans()` メソッドから返される便利な `BeanStream` を使って、すべての登録された豆を簡単にフィルタリングすることができます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:402
#, fuzzy, no-wrap
msgid "Use Case - Register a Custom CDI Context"
msgstr "ユースケース - カスタム CDI コンテキストの登録"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:405
#, fuzzy
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr "時々、拡張機能は組み込みの CDI コンテキストのセットを拡張する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:407
#, fuzzy
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr "_解決方法_ 。カスタムコンテキストを登録する必要がある場合は、 `ContextRegistrationPhaseBuildItem` ."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:409
#, fuzzy
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "`ContextRegistrationPhaseBuildItem` を消費するビルドステップは、常に `ContextConfiguratorBuildItem` を生成するか、少なくともこのビルド項目のために `BuildProducer` を注入すべきです。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:411
#, fuzzy
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr "`ContextRegistrationPhaseBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:417
#, no-wrap
msgid ""
"@BuildStep\n"
"ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n"
"      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:420
#, fuzzy
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr "さらに、 `ContextRegistrationPhaseBuildItem` を介してカスタム CDI コンテキストを登録する各拡張機能は、カスタムスコープアノテーション名をビーン定義アノテーションのセットに貢献するために `CustomScopeBuildItem` も生成しなければなりません。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:422
#, fuzzy
msgid "`CustomScopeBuildItem` Example"
msgstr "`CustomScopeBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:428
#, no-wrap
msgid ""
"@BuildStep\n"
"CustomScopeBuildItem customScope() {\n"
"   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:430
#, fuzzy, no-wrap
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr "アプリケーションで使用するスコープをすべて知る必要がある場合は?"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:433
#, fuzzy
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr "_解決方法_ です。ビルドステップで `CustomScopeAnnotationsBuildItem` を注入して、 `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()` ."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:435
#, fuzzy, no-wrap
msgid "Use Case - Additional Interceptor Bindings"
msgstr "使用例 - 追加のインターセプターバインディング"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:440
#, fuzzy
msgid "In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.  We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr "まれに、 `@javax.interceptor.InterceptorBinding` でアノテーションされていない既存のアノテーションをインターセプターバインディングとしてプログラムで登録しておくと便利かもしれません。これは CDI が `BeforeBeanDiscovery#addInterceptorBinding()` を通して実現していることに似ています。しかし、ここでは `InterceptorBindingRegistrarBuildItem` を使ってそれを実現しようとしています。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:441
#, fuzzy, no-wrap
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr "`InterceptorBindingRegistrarBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:454
#, no-wrap
msgid ""
"@BuildStep\n"
"InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n"
"    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n"
"        @Override\n"
"        public Map<DotName, Set<String>> registerAdditionalBindings() {\n"
"            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n"
"                                        Collections.emptySet());\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:456
#, fuzzy, no-wrap
msgid "Use Case - Additional Qualifiers"
msgstr "使用例 - 追加のインターセプターバインディング"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:461
#, fuzzy
msgid "Sometimes it might be useful to register an existing annotation that is not annotated with `@javax.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr "まれに、 `@javax.interceptor.InterceptorBinding` でアノテーションされていない既存のアノテーションをインターセプターバインディングとしてプログラムで登録しておくと便利かもしれません。これは CDI が `BeforeBeanDiscovery#addInterceptorBinding()` を通して実現していることに似ています。しかし、ここでは `InterceptorBindingRegistrarBuildItem` を使ってそれを実現しようとしています。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:462
#, fuzzy, no-wrap
msgid "`QualifierRegistrarBuildItem` Example"
msgstr "`InterceptorBindingRegistrarBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:475
#, no-wrap
msgid ""
"@BuildStep\n"
"QualifierRegistrarBuildItem addQualifiers() {\n"
"    return new QualifierRegistrarBuildItem(new QualifierRegistrar() {\n"
"        @Override\n"
"        public Map<DotName, Set<String>> getAdditionalQualifiers() {\n"
"            return Collections.singletonMap(DotName.createSimple(NotAQualifier.class.getName()),\n"
"                                        Collections.emptySet());\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:478
#, fuzzy, no-wrap
msgid "Use Case - Injection Point Transformation"
msgstr "ユースケース - インジェクションポイント変換"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:483
#, fuzzy
msgid "Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.  You can do just that with `InjectionPointTransformerBuildItem`.  The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr "インジェクションポイントの修飾子をプログラムで変更できるのは便利です。 `InjectionPointTransformerBuildItem` を使用すると、それが可能になります。 `MyQualifier` 次のサンプルは、 `Foo` 型のインジェクション ポイントに変換を適用する方法を示しています。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:484
#, fuzzy, no-wrap
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr "`InjectionPointTransformerBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:490
#, no-wrap
msgid ""
"@BuildStep\n"
"InjectionPointTransformerBuildItem transformer() {\n"
"    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:494
#, no-wrap
msgid ""
"        public boolean appliesTo(Type requiredType) {\n"
"            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:506
#, no-wrap
msgid ""
"        public void transform(TransformationContext context) {\n"
"            if (context.getQualifiers().stream()\n"
"                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n"
"                context.transform()\n"
"                        .removeAll()\n"
"                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n"
"                        .done();\n"
"            }\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:509
#, fuzzy
msgid "In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr "理論的には、 link:#annotations_transformer_build_item[`AnnotationsTransformer`] を使って同じ目的を達成することができます。しかし、 `InjectionPointsTransformer` をこの特定のタスクに適したものにするには、いくつかの違いがあります。 `InjectionPointsTransformer` (1) アノテーション変換器はビーン発見時にすべてのクラスに適用されるのに対し、 `InjectionPointsTransformer` はビーン発見後に発見された注入ポイントにのみ適用されます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:510
#, fuzzy, no-wrap
msgid "Use Case - Resource Annotations and Injection"
msgstr "使用例 - リソースアノテーションとインジェクション"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:514
#, fuzzy
msgid "The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.  An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr "`ResourceAnnotationBuildItem` は、ジャカルタ EE リソースなどの非 CDI インジェクションポイントの解決を可能にするリソースアノテーションを指定するために使用することができます。インテグレータは、対応する `io.quarkus.arc.ResourceReferenceProvider` サービス・プロバイダの実装も提供する必要があります。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:515
#, fuzzy, no-wrap
msgid "`ResourceAnnotationBuildItem` Example"
msgstr "`ResourceAnnotationBuildItem` 例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:524
#, no-wrap
msgid ""
"@BuildStep\n"
"void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n"
"    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n"
"        MyResourceReferenceProvider.class.getName().getBytes()));\n"
"    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:527
#, fuzzy, no-wrap
msgid "Available Build Time Metadata"
msgstr "利用可能なビルド時間のメタデータ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:531
#, fuzzy
msgid "Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.  The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr "`BuildExtension.BuildContext` で動作する上記の拡張機能はいずれも、ビルド時に生成される特定のビルド時メタデータを利用することができます。 `io.quarkus.arc.processor.BuildExtension.Key` にある組み込みキーは以下の通りです。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:532
#, fuzzy, no-wrap
msgid "ANNOTATION_STORE"
msgstr "アノテーションストア"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:533
#, fuzzy
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr "`AnnotationStore` を含み、注釈変換器を適用した後のすべての `AnnotationTarget` の注釈に関する情報を保持します。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:533
#, fuzzy, no-wrap
msgid "INJECTION_POINTS"
msgstr "インジェクションポイント"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:534
#, fuzzy
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr "`Collection<InjectionPointInfo>` すべての注入ポイントを含む"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:534
#, fuzzy, no-wrap
msgid "BEANS"
msgstr "豆"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:535
#, fuzzy
msgid "`Collection<BeanInfo>` containing all beans"
msgstr "`Collection<BeanInfo>` すべての豆を含む"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:535
#, fuzzy, no-wrap
msgid "REMOVED_BEANS"
msgstr "REMOVED_BEANS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:536
#, fuzzy
msgid "`Collection<BeanInfo>` containing all the removed beans; see <<cdi-reference.adoc#remove_unused_beans,Removing unused beans>> for more information"
msgstr "`Collection<BeanInfo>` 削除されたすべての link:cdi-reference.html#remove_unused_beans[ビーンズ] が含まれています。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:536
#, fuzzy, no-wrap
msgid "OBSERVERS"
msgstr "監視者"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:537
#, fuzzy
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr "`Collection<ObserverInfo>` 全観測者を含む"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:537
#, fuzzy, no-wrap
msgid "SCOPES"
msgstr "スコープス"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:538
#, fuzzy
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr "`Collection<ScopeInfo>` カスタムスコープを含むすべてのスコープを含む"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:538
#, fuzzy, no-wrap
msgid "QUALIFIERS"
msgstr "資格者"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:539
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr "`Map<DotName, ClassInfo>` すべての修飾子を含む"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:539
#, fuzzy, no-wrap
msgid "INTERCEPTOR_BINDINGS"
msgstr "インターセプターバインディング"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:540
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr "`Map<DotName, ClassInfo>` すべてのインターセプターバインディングを含む"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:540
#, fuzzy, no-wrap
msgid "STEREOTYPES"
msgstr "ステレオタイプ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:541
#, fuzzy
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr "`Map<DotName, StereotypeInfo>` すべてのステレオタイプを含む"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:546
#, fuzzy
msgid "To get hold of these, simply query the extension context object for given key.  Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.  If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.  Here is a summary of which extensions can access which metadata:"
msgstr "これらのメタデータを取得するには、与えられたキーのエクステンションコンテキストオブジェクトをクエリするだけです。これらのメタデータはビルドが進むにつれて利用可能になることに注意してください。拡張モジュールがまだ生成されていないメタデータを取得しようとすると、 `null` が返されます。どの拡張機能がどのメタデータにアクセスできるかをまとめてみました。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:547
#, fuzzy, no-wrap
msgid "AnnotationsTransformer"
msgstr "アノテーショントランスフォーマ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:548
#, fuzzy
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr "ブートストラップのどのフェーズでもいつでも使えるので、メタデータに頼るべきではありません。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:548
#, fuzzy, no-wrap
msgid "ContextRegistrar"
msgstr "コンテキストレジスタ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:549
#: upstream/_guides/cdi-integration.adoc:550
#: upstream/_guides/cdi-integration.adoc:551
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr "`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` . `STEREOTYPES`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:549
#, fuzzy, no-wrap
msgid "InjectionPointsTransformer"
msgstr "インジェクションポイントトランスフォーマ"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:550
#, fuzzy, no-wrap
msgid "ObserverTransformer"
msgstr "オブザーバトランスフォーマ"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:551
#, fuzzy, no-wrap
msgid "BeanRegistrar"
msgstr "BeanRegistrar"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:552
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` (クラスベースのビーンズのみ)、 `OBSERVERS` (クラスベースのオブザーバーのみ)にアクセスできます。 `INJECTION_POINTS`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:552
#, fuzzy, no-wrap
msgid "ObserverRegistrar"
msgstr "オブザーバレジスタ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:553
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` , `OBSERVERS` (クラスベースのオブザーバーのみ)にアクセス可能。 `INJECTION_POINTS`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:553
#, fuzzy, no-wrap
msgid "BeanDeploymentValidator"
msgstr "BeanDeploymentValidator"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:553
#, fuzzy
msgid "Has access to all build metadata"
msgstr "すべてのビルドメタデータにアクセスできる"
