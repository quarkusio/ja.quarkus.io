# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-12-11 00:18+0000\n"
"PO-Revision-Date: 2022-09-18 22:22+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.1.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-built-in-authentication.adoc:6
#, no-wrap
msgid "Built-In Authentication Support"
msgstr "ビルトイン認証サポート"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:11
msgid "The following section describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC, and Mutual TLS authentication. Proactive authentication is also described."
msgstr "このドキュメントでは、HTTPベースのFORM認証、BASIC認証、相互TLS認証、およびプロアクティブ認証のためのQuarkusのビルトイン認証メカニズムについて説明します。また、プロアクティブ認証についても説明します。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:18
#, no-wrap
msgid "Form Based Authentication"
msgstr "フォームベース認証"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:24
msgid "Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead, the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key)."
msgstr "Quarkusには、従来のServletのフォームベース認証と同様に動作する、フォームベース認証があります。従来のフォーム認証とは異なり、Quarkusではクラスタ化されたHTTPセッションがサポートされていないため、認証されたユーザーはHTTPセッションに保存されません。代わりに、認証情報は暗号化されたクッキーに保存されます。このクッキーは、クラスタのすべてのメンバーが読み取ることができます（ただし、すべてのメンバーが同じ暗号化キーを共有している場合）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:30
msgid "The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use."
msgstr "暗号化キーは `quarkus.http.auth.session.encryption-key` プロパティーを使って設定でき、少なくとも 16 文字の長さでなければなりません。このキーは SHA-256 を使ってハッシュ化され、その結果のダイジェストがクッキー値の AES-256 暗号化のキーとして使用されます。このクッキーは暗号化された値の一部として有効期限を含んでいますので、クラスター内のすべての ノードはクロックを同期させなければなりません。1 分間隔で、セッションが使用中であれば、更新された有効期限時間を持つ新しいクッキーが生成されます。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:32
msgid "The following properties can be used to configure form based auth:"
msgstr "以下のプロパティーを使用して、フォームベース認証を設定することができます。 :"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:36
#, no-wrap
msgid "Mutual TLS Authentication"
msgstr "相互TLS認証"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:39
msgid "Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates."
msgstr "QuarkusはmTLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:41
msgid "To use this authentication method, you should first enable SSL for your application. For more details, check the xref:http-reference.adoc#ssl[Supporting secure connections with SSL] guide."
msgstr "この認証方法を使用するには、まずアプリケーションでSSLを有効にする必要があります。詳しくは、 link:http-reference.html#ssl[「Supporting secure connections with SSL]」をご覧ください。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:45
msgid "Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources."
msgstr "アプリケーションが安全な接続を受け入れたら、次のステップは、アプリケーションが信頼するすべての証明書を保持する `quarkus.http.ssl.certificate.trust-store-file` を設定し、クライアント(例: ブラウザや他のサービス)が保護されたリソースにアクセスしようとしたときに、アプリケーションがどのように証明書を要求するかを設定します。"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:53
#, no-wrap
msgid ""
"quarkus.http.ssl.certificate.key-store-file=server-keystore.jks            <1>\n"
"quarkus.http.ssl.certificate.key-store-password=the_key_store_secret\n"
"quarkus.http.ssl.certificate.trust-store-file=server-truststore.jks        <2>\n"
"quarkus.http.ssl.certificate.trust-store-password=the_trust_store_secret\n"
"quarkus.http.ssl.client-auth=required                                      <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:56
#, no-wrap
msgid ""
"quarkus.http.auth.permission.default.paths=/*                              <4>\n"
"quarkus.http.auth.permission.default.policy=authenticated\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:58
msgid "Configures a key store where the server's private key is located."
msgstr "サーバーの秘密鍵が置かれている鍵ストアを設定します。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:59
msgid "Configures a trust store from where the trusted certificates are going to be loaded from."
msgstr "信頼された証明書がロードされるトラストストアを構成します。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:62
msgid "Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS."
msgstr "サーバーが *常に*クライアントからの証明書を要求することを定義します。 `REQUEST` を使用することで、この動作を緩和することができます。mTLS 以外の認証方法もサポートしている場合に便利です。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:63
msgid "Defines a policy where only authenticated users should have access to resources from your application."
msgstr "認証されたユーザーのみがアプリケーションからリソースにアクセスできるようにするポリシーを定義します。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:66
msgid "Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:"
msgstr "受信したリクエストがトラストストアの有効な証明書と一致したら、アプリケーションは以下のように `SecurityIdentity` を注入するだけでサブジェクトを取得できるようになるでしょう。 :"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:68
#, no-wrap
msgid "Obtaining the subject"
msgstr "Subjectの取得"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:73
#, no-wrap
msgid ""
"@Inject\n"
"SecurityIdentity identity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:79
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"public String hello() {\n"
"    return String.format(\"Hello, %s\", identity.getPrincipal().getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:82
msgid "You should also be able to get the certificate as follows:"
msgstr "また、以下のように証明書を取得できるようにしておきましょう:"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:84
#, no-wrap
msgid "Obtaining the certificate"
msgstr "証明書の取得"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:89
#, no-wrap
msgid ""
"import java.security.cert.X509Certificate;\n"
"import io.quarkus.security.credential.CertificateCredential;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:92
#, no-wrap
msgid ""
"CertificateCredential credential = identity.getCredential(CertificateCredential.class);\n"
"X509Certificate certificate = credential.getCertificate();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:94
#, no-wrap
msgid "Authorization"
msgstr "認可"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:98
msgid "The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, and so on.  Please see the xref:security-customization.adoc#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`."
msgstr "クライアント証明書の情報は、Quarkus `SecurityIdentity` を強化するために使用できます。例えば、クライアント証明書のサブジェクト名を確認した後に新しいロールを追加することなどができます。Quarkus `SecurityIdentity`  のカスタマイズの詳細については、 link:security-customization.html#security-identity-customization[SecurityIdentity Customization]のセクションを参照してください。。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:100
#, no-wrap
msgid "Proactive Authentication"
msgstr "プロアクティブ認証"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:104
msgid "By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication)."
msgstr "デフォルトでは、Quarkusはプロアクティブ認証と呼ばれるものを行います。つまり、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます（ターゲットページが認証を必要としない場合でも）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:107
msgid "This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`."
msgstr "これは、公開ページであっても、無効なクレデンシャルを持つリクエストは常に拒否されることを意味します。この動作を変更して、 `quarkus.http.auth.proactive=false` を設定することで必要な場合のみ認証を行うことができます。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:111
msgid "If you disable proactive authentication then the authentication process will only be run when an identity is requested, either because there are security rules that requires the user to be authenticated, or due to programmatic access to the current identity."
msgstr "プロアクティブ認証を無効にすると、認証プロセスは ID が要求されたときにのみ実行されます。これは、ユーザーを認証する必要があるセキュリティルールが存在するか、 現在の ID にプログラムによるアクセスがあるためです。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:119
msgid "Note that if proactive authentication is in use accessing the `SecurityIdentity` is a blocking operation. This is because authentication may not have happened yet, and accessing it may require calls to external systems such as databases that may block. For blocking applications this is no problem, however if you have disabled authentication in a reactive application this will fail (as you cannot do blocking operations on the IO thread). To work around this you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation`, and call the `Uni<SecurityIdentity> getDeferredIdentity();` method. You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available."
msgstr "プロアクティブ認証が使用されている場合、 `SecurityIdentity` へのアクセスはブロックされることに注意してください。これは、認証がまだ行われていない可能性があるためです。また、データベースなどの外部システムを呼び出す必要があるため、ブロックされる可能性があります。ブロッキングアプリケーションでは問題ありませんが、リアクティブアプリケーションで認証を無効にしている場合、これは失敗します(IOスレッドでブロッキング操作を行うことができないため)。これを回避するには、`io.quarkus.security.identity.CurrentIdentityAssociation`のインスタンスを `@Inject` して、`Uni<SecurityIdentity> getDeferredIdentity();` メソッドを呼び出す必要があります。そして、生成された `Uni` をサブスクライブすることで、認証が完了し、ID が利用可能になったときに通知されるようになります。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:124
#, fuzzy
msgid "It's still possible to access the `SecurityIdentity` synchronously with `public SecurityIdentity getIdentity()` in the xref:resteasy-reactive.adoc[RESTEasy Reactive] from endpoints annotated with `@RolesAllowed`, `@Authenticated`, or with respective configuration authorization checks as authentication has already happened. The same is also valid for the xref:reactive-routes.adoc[Reactive routes] if a route response is synchronous."
msgstr " `@RolesAllowed` , `@Authenticated` , またはそれぞれの設定の認証チェックでアノテーションされたエンドポイントから、 link:resteasy-reactive.html[RESTEasy Reactiveの] `public SecurityIdentity getIdentity()` と同期して `SecurityIdentity` にアクセスすることは、すでに認証が行われているため可能である。ルートレスポンスが同期的である場合、 link:reactive-routes.html[Reactiveルートについても] 同様である。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:128
msgid "xref:security-authorization.adoc#standard-security-annotations[Standard security annotations] on CDI beans are not supported on IO thread if a non-void secured method returns a value synchronously and proactive authentication is disabled, as they need to access the `SecurityIdentity`.  In the example below, we have defined `HelloResource` and `HelloService`. It's easy to see that any GET request to `/hello` will run on IO thread and throw `BlockingOperationNotAllowedException` exception.  There is more than one way to fix the example:"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:130
msgid "switch to a worker thread (annotate `hello` endpoint with `@Blocking`)"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:131
msgid "change `sayHello` method return type (use reactive or asynchronous data type)"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:132
msgid "arguably the safest way is to move `@RolesAllowed` annotation to the endpoint, as accessing `SecurityIdentity` from endpoint methods is never the blocking operation"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:139
#, no-wrap
msgid ""
"import javax.annotation.security.PermitAll;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:141
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr "import io.smallrye.mutiny.Uni;\n"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:145
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@PermitAll\n"
"public class HelloResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:148
#, no-wrap
msgid ""
"    @Inject\n"
"    HelloService helloService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:153
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<String> hello() {\n"
"        return Uni.createFrom().item(helloService.sayHello());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:155
#: upstream/_guides/security-built-in-authentication.adoc:171
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:161
#, no-wrap
msgid ""
"import javax.annotation.security.RolesAllowed;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:164
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class HelloService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:169
#, no-wrap
msgid ""
"    @RolesAllowed(\"admin\")\n"
"    public String sayHello() {\n"
"        return \"Hello\";\n"
"    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:174
#, no-wrap
msgid "How to customize authentication exception responses"
msgstr "認証の例外応答をカスタマイズする方法"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:177
msgid "By default, the authentication security constraints are enforced before the JAX-RS chain starts and only way to handle Quarkus Security authentication exceptions is to provide a failure handler like this one:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:181
#: upstream/_guides/security-built-in-authentication.adoc:213
#, no-wrap
msgid "package io.quarkus.it.keycloak;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:184
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:189
#, no-wrap
msgid ""
"import io.quarkus.security.AuthenticationFailedException;\n"
"import io.vertx.core.Handler;\n"
"import io.vertx.ext.web.Router;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:192
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class AuthenticationFailedExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:206
#, no-wrap
msgid ""
"    public void init(@Observes Router router) {\n"
"        router.route().failureHandler(new Handler<RoutingContext>() {\n"
"            @Override\n"
"            public void handle(RoutingContext event) {\n"
"                if (event.failure() instanceof AuthenticationFailedException) {\n"
"                    event.response().setStatusCode(401).end(CUSTOMIZED_RESPONSE);\n"
"                } else {\n"
"                    event.next();\n"
"                }\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:209
#, fuzzy
#| msgid "By default, the authentication security constraints are enforced before the JAX-RS chain starts.  Disabling the proactive authentication effectively shifts this process to the moment when the JAX-RS chain starts running thus making it possible to use JAX-RS `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgid "Disabling the proactive authentication effectively shifts this process to the moment when the JAX-RS chain starts running thus making it possible to use JAX-RS `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgstr "デフォルトでは、認証セキュリティ制約は、JAX-RSチェーンが開始される前に実施されます。プロアクティブ認証を無効にすると、このプロセスがJAX-RSチェーンの実行開始時に効果的に移行されるため、JAX-RS `ExceptionMapper` を使用して、例えば `io.quarkus.security.AuthenticationFailedException` などのQuarkus Security認証の例外を取得することが可能になります。 :"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:219
#, no-wrap
msgid ""
"import javax.annotation.Priority;\n"
"import javax.ws.rs.Priorities;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.ext.ExceptionMapper;\n"
"import javax.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:221
#, no-wrap
msgid "import io.quarkus.security.AuthenticationFailedException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:225
#, no-wrap
msgid ""
"@Provider\n"
"@Priority(Priorities.AUTHENTICATION)\n"
"public class AuthenticationFailedExceptionMapper implements ExceptionMapper<AuthenticationFailedException> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:228
#, no-wrap
msgid ""
"    @Context\n"
"    UriInfo uriInfo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:234
#, no-wrap
msgid ""
"    @Override\n"
"    public Response toResponse(AuthenticationFailedException exception) {\n"
"        return Response.status(401).header(\"WWW-Authenticate\", \"Basic realm=\\\"Quarkus\\\"\").build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:236
#, no-wrap
msgid "References"
msgstr "参照"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:238
msgid "xref:security.adoc[Quarkus Security]"
msgstr "xref:security.adoc[Quarkus Security]"

#~ msgid "Basic Authentication"
#~ msgstr "ベーシック認証"

#~ msgid "HTTP Basic Authentication uses fields in the HTTP header and is the easiest to set up. Also, it is one of the least resource-demanding techniques that enforce access controls to the Web resources without requiring HTTP cookies, session identifiers, or login pages."
#~ msgstr "HTTPのベーシック認証は、HTTPヘッダーのフィールドを使用し、最も簡単に設定することができます。また、HTTPクッキーやセッション識別子、ログインページを必要とせず、Webリソースへのアクセス制御を実施する、最もリソース需要の少ない技術の一つです。"

#~ msgid "In the context of an HTTP request, Basic authentication is a method for an HTTP user agent, such as a web browser, to provide a user name and password when creating a request. In Basic HTTP Authentication, a request contains a header field in the form of `Authorization: Basic <credentials>`, where credentials are the Base64 encoding of a user ID and password joined by a colon as described in the following example."
#~ msgstr "HTTPリクエストのコンテキストでは、ベーシック認証は、WebブラウザのようなHTTPユーザー エージェントが、リクエストを作成するときにユーザー名とパスワードを提供する ための方法である。HTTPのベーシック認証では、リクエストは `Authorization: Basic <credentials>` という形式のヘッダーフィールドを含みます。ここで、認証情報は、次の例で説明するように、ユーザーIDとパスワードをコロンでつないだBase64エンコーディングです。"

#~ msgid "Example"
#~ msgstr "例"

#~ msgid "If the user name is `Alice` and the password is `secret`, the HTTP authorization header looks authorization as `Authorization: Basic QWxjZTpzZWNyZXQ=`, where `QWxjZTpzZWNyZXQ=` is a Base64 encoded representation of the `Alice:secret` string."
#~ msgstr "ユーザー名が `Alice` でパスワードが `secret` の場合，HTTP認証ヘッダーは `Authorization: Basic QWxjZTpzZWNyZXQ=` のように認証が見えます。ここで `QWxjZTpzZWNyZXQ=` は `Alice:secret` の文字列を Base64 で符号化したもので`Basic QWxjZTpzZWNyZXQ=` となります。"

#~ msgid "The Basic Authentication mechanism does not provide confidentiality protection for the transmitted credentials. The credentials are merely encoded with Base64 when in transit and not encrypted or hashed in any way. Therefore, Basic Authentication is used with HTTPS to provide confidentiality."
#~ msgstr "Basic Authenticationの仕組みは、送信されるクレデンシャルに対して機密性の保護を提供しません。認証情報は転送中にBase64でエンコードされるだけで、暗号化もハッシュ化もされない。したがって、基本認証は機密性を提供するために HTTPS と共に使用されます。"

#~ msgid "Basic Authentication is a well-specified, simple challenge and response scheme that all web browsers and most web servers understand. However, there are a few limitations associated with Basic Authentication, which include:"
#~ msgstr "ベーシック認証は、すべてのウェブブラウザーとほとんどのウェブサーバーが理解できる、よく規定されたシンプルなチャレンジとレスポンスのスキームです。しかし、ベーシック認証には、以下のような制限があります:"

#~ msgid "Credentials are sent as plain text"
#~ msgstr "認証情報がプレーンテキストで送信されます"

#~ msgid "It is required to use HTTPS with Basic Authentication to avoid exposing the credentials. However, if the load balancer terminates HTTPS, the risk of exposing credentials as plain text increases when a request is forwarded to Quarkus over HTTP."
#~ msgstr "資格情報が公開されないようにするには、HTTPS と一緒にベーシック認証を使用する必要があります。ただし、ロードバランサーがHTTPSを終端すると、HTTPでQuarkusにリクエストが転送されたときに、認証情報がプレーンテキストとして公開されるリスクが高まります。"

#~ msgid "Also, in multi-hop deployments, the credentials can be exposed if HTTPS is used between the client and the first Quarkus endpoint only, and the credentials are propagated to the next Quarkus endpoint over HTTP."
#~ msgstr "また、マルチホップデプロイメントでは、クライアントと最初のQuarkusエンドポイント間のみでHTTPSを使用し、次のQuarkusエンドポイントにHTTPで認証情報を伝達する場合、認証情報が漏洩する可能性があります。"

#~ msgid "Credentials are sent with each request"
#~ msgstr "認証情報はリクエスト毎に送信されます"

#~ msgid "In Basic Authentication, a username and password need to be sent with each request, which increases the risk of credentials being exposed."
#~ msgstr "ベーシック認証では、ユーザー名とパスワードをリクエスト毎に送信する必要があります。これは、認証情報が漏洩するリスクを高めます。"

#~ msgid "Application complexity increases"
#~ msgstr "アプリケーションの複雑性の増大"

#~ msgid "The Quarkus application needs to ensure itself that usernames, passwords, and roles are managed securely, which increases the application complexity."
#~ msgstr "Quarkus アプリケーションは、ユーザー名、パスワード、およびロールが安全に管理されていることを確認する必要があるため、アプリケーションの複雑さが増大します。"

#~ msgid "Enabling Basic Authentication"
#~ msgstr "ベーシック認証の有効化"

#~ msgid "Prerequisites"
#~ msgstr "前提条件"

#~ msgid "You have installed at least one extension that provides an `IdentityProvider` based on username and password, such as xref:security-jdbc.adoc[Elytron JDBC]."
#~ msgstr "ユーザ名とパスワードに基づいた `IdentityProvider` を提供する拡張機能が1つ以上インストールされています。例えば、xref:security-jdbc.adoc [Elytron JDBC] などです。"

#~ msgid "Procedure"
#~ msgstr "手順"

#~ msgid "Enable Basic Authentication by setting the value of `quarkus.http.auth.basic` property to `true`."
#~ msgstr "ベーシック認証を有効にするには `quarkus.http.auth.basic` プロパティの値を `true` に設定します。"

#~ msgid "quarkus.http.auth.basic=true\n"
#~ msgstr "quarkus.http.auth.basic=true\n"

#~ msgid "For a Basic Authentication configuration walk-through that uses `JPA`, see the xref:security-getting-started.adoc[Getting Started With Security] guide."
#~ msgstr "`JPA` を使用したベーシック認証の設定のウォークスルーについては、『 link:security-getting-started.html[Getting Started With Security] 』ガイドを参照してください。"

#~ msgid "Additional resources"
#~ msgstr "その他のリソース"

#~ msgid "xref:security.adoc#identity-providers[Security Identity Providers]"
#~ msgstr "詳しくは「 link:security.html#identity-providers[Security Identity Providers]」をご覧ください。"

#~ msgid "xref:security-testing.adoc#configuring-user-information[Configuring User Information in application.properties]"
#~ msgstr "また、「 link:security-testing.html#configuring-user-information[application.propertiesでユーザー情報を設定する]」も参照してください。"
