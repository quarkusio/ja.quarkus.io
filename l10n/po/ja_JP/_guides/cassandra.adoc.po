# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2021-07-29 10:11+0000\n"
"PO-Revision-Date: 2021-04-14 16:57+0900\n"
"Last-Translator: Nobuhiro Sue <nobuhiro.sue@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cassandra.adoc:6
#, no-wrap
msgid "Quarkus - Using the Cassandra Client"
msgstr "Quarkus - Cassandraクライアントの使用"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:13
msgid "Apache Cassandra® is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure."
msgstr "Apache Cassandra®は、フリーでオープンソースの分散型ワイドカラムストアのNoSQLデータベース管理システムで、多くのコモディティサーバーにまたがる大量のデータを処理するように設計されており、単一障害点のない高可用性を提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:15
msgid "In this guide, we will see how you can get your REST services to use a Cassandra database."
msgstr "このガイドでは、RESTサービスでCassandraデータベースを使用する方法を見ていきます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:18
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:21
msgid "To complete this quickstart guide, you need:"
msgstr "このガイドを完成させるには、以下が必要です:"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:23
msgid "an IDE;"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:24
#, fuzzy
#| msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately;"
msgid "JDK 11+ installed with `JAVA_HOME` configured appropriately;"
msgstr "JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:27
msgid "link:https://www.graalvm.org/[GraalVM] installed with the `GRAALVM_HOME` environment variable configured appropriately, if you want to link:https://quarkus.io/guides/building-native-image[use the native mode];"
msgstr "ネイティブモードを使用したい場合は、 `GRAALVM_HOME` が適切に設定された GraalVM がインストールされていること"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:28
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:32
msgid "A running link:https://cassandra.apache.org[Apache Cassandra], link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) or link:https://astra.datastax.com[DataStax Astra] database; or alternatively, a fresh Docker installation."
msgstr "稼働中の link:https://cassandra.apache.org[Apache Cassandra]、 link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise]（DSE）、または link:https://astra.datastax.com[DataStax Astra]データベース、あるいはきれいなDockerのインストール"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:33
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:39
msgid "This quickstart guide shows how to build a REST application using the link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus extension], which allows you to connect to an Apache Cassandra, DataStax Enterprise (DSE) or DataStax Astra database, using the link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java driver]."
msgstr "このクイックスタート・ガイドでは、 link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Javaドライバー]を使用してApache Cassandra、DataStax Enterprise（DSE）、またはDataStax Astraデータベースに接続できる link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkusエクステンション]を使用してRESTアプリケーションを構築する方法を説明します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:44
#, fuzzy
#| msgid "We will be building a REST application using the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] to simplify the Data Access Layer code."
msgid "This guide will also use the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] – a powerful Java-to-CQL mapping framework that greatly simplifies your application's data access layer code by sparing you the hassle of writing your CQL queries by hand."
msgstr "Data Access Layerのコードを簡略化するために、 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] を使ってRESTアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:48
msgid "The application built in this quickstart guide is quite simple: the user can add elements in a list using a form, and the items list is updated. All the information between the browser and the server is formatted as JSON, and the elements are stored in the Cassandra database."
msgstr "このガイドで構築されたアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、アイテムリストが更新されます。ブラウザーとサーバー間の情報はすべてJSONフォーマットで、各要素はCassandraデータベースに保存されます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:49
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:53
msgid "We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:57
msgid "The solution is located in the link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[quickstart directory] of the Cassandra Quarkus extension GitHub repository."
msgstr "ソリューションは `quickstart` link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[ディレクトリー] にあります。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:58
#, no-wrap
msgid "Creating a Blank Maven Project"
msgstr "Mavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:62
msgid "First, create a new Maven project and copy the `pom.xml` file that is present in the `quickstart` directory."
msgstr "まず、新しいMavenプロジェクトを作成し、 `quickstart` ディレクトリーに存在する `pom.xml` ファイルをコピーします。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:64
msgid "The `pom.xml` is importing all the Quarkus extensions and dependencies you need."
msgstr "`pom.xml` 、必要なQuarkusのエクステンションや依存関係をすべてインポートしています。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:65
#, no-wrap
msgid "Creating the Data Model and Data Access Objects"
msgstr "データモデルとデータアクセスオブジェクトの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:68
msgid "In this example, we will create an application to manage a list of fruits."
msgstr "この例では、果物のリストを管理するアプリケーションを作成します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:70
msgid "First, let's create our data model – represented by the `Fruit` class – as follows:"
msgstr "まず、以下のように `Fruit` クラスであらわされるデータもデールを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:76
#, no-wrap
msgid ""
"@Entity\n"
"@PropertyStrategy(mutable = false)\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:79
#, no-wrap
msgid ""
"    @PartitionKey\n"
"    private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:81
#, no-wrap
msgid "    private final String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:88
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"      this.name = name;\n"
"      this.description = description;\n"
"    }\n"
"  // getters, hashCode, equals, toString methods omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:93
msgid "As stated above, we are using the DataStax Object Mapper. In other words, we are not going to write our CQL queries manually; instead, we will annotate our data model with a few annotations, and the mapper will generate proper CQL queries underneath."
msgstr "前述のとおり、ここではDataStax Object Mapperを使用しています。つまり、CQLクエリーを手動で記述するのではなく、データ・モデルにいくつかのアノテーションを付け、裏側でマッパーが適切なCQLクエリーを生成するのです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:98
msgid "This is why the `Fruit` class is annotated with `@Entity`: this annotation marks it as an _entity class_ that is mapped to a Cassandra table. Its instances are meant to be automatically persisted into, and retrieved from, the Cassandra database. Here, the table name will be inferred from the class name: `fruit`."
msgstr "これが、 `Fruit` クラスが `@Entity` でアノテーションされている理由です。このアノテーションは、Cassandraテーブルにマッピングされる _エンティティ・クラス_としてマークされます。このクラスのインスタンスは、Cassandraデータベースに自動的に永続化され、そこから取得されます。ここでは、テーブル名はクラス名から推測されます： `fruit` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:101
#, fuzzy
msgid "Also, the `name` field represents a Cassandra partition key, and so we are annotating it with `@PartitionKey` – another annotation from the Object Mapper library."
msgstr "また、 `name` フィールドはCassandraのパーティション・キーを表しているので、Object Mapperライブラリのアノテーションである `@PartitionKey` でアノテーションを付けています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:104
#, fuzzy
msgid "Entity classes are normally required to have a default no-arg constructor, unless they are annotated with `@PropertyStrategy(mutable = false)`, which is the case here."
msgstr "エンティティクラスは、 `@PropertyStrategy(mutable = false)` でアノテーションされている場合を除き、通常、デフォルトの引数なしのコンストラクタを持つことが要求されます（ここではそのようになっています）。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:107
#, fuzzy
msgid "The next step is to create a DAO (Data Access Object) interface that will manage instances of `Fruit` entities:"
msgstr "次のステップは、 `Fruit` エンティティのインスタンスを管理する DAO（Data Access Object）インターフェースを作成することです。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:114
#, no-wrap
msgid ""
"@Dao\n"
"public interface FruitDao {\n"
"  @Update\n"
"  void update(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:118
#, no-wrap
msgid ""
"  @Select\n"
"  PagingIterable<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:123
#, fuzzy
msgid "This interface exposes operations that will be used in our REST service. Again, the annotation `@Dao` comes from the DataStax Object Mapper, which will also automatically generate an implementation of this interface for you."
msgstr "このインターフェースは、RESTサービスで使用されるオペレーションを公開します。繰り返しになりますが、アノテーション `@Dao` はDataStax Object Mapperから来ており、このインターフェイスの実装も自動的に生成されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:127
#, fuzzy
msgid "Note also the special return type of the `findAll` method, link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]: it's the base type of result sets returned by the driver."
msgstr "`findAll` メソッドの特別なリターンタイプにも注目してください。  link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]これは、ドライバーが返す結果セットの基本タイプです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:129
#, fuzzy
#| msgid "Finally, the Mapper itself:"
msgid "Finally, let's create the a Mapper interface:"
msgstr "最後に、マッパー本体です。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:137
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  @DaoFactory\n"
"  FruitDao fruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:142
#, fuzzy
msgid "The `@Mapper` annotation is yet another annotation recognized by the DataStax Object Mapper. A mapper is responsible for constructing instances of DAOs – in this case, out mapper is constructing an instance of our only DAO, `FruitDao`."
msgstr "`@Mapper` アノテーションは、DataStax Object Mapperによって認識されるもう1つのアノテーションです。マッパーはDAOのインスタンスを構築する役割を果たします。この場合、マッパーは唯一のDAOである `FruitDao` のインスタンスを構築しています。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:143
#, fuzzy, no-wrap
#| msgid "Creating JSON REST service"
msgid "Creating a Service & JSON REST Endpoint"
msgstr "JSON RESTサービスの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:147
#, fuzzy
#| msgid "Now create a `FruitService` that will be the business layer of our application and store/load the fruits from the Cassandra database."
msgid "Now let's create a `FruitService` that will be the business layer of our application and store/load the fruits from the Cassandra database."
msgstr "ここで、アプリケーションのビジネス層となる `FruitService` を作成し、Cassandraデータベースから果物をセーブ/ロードします。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:152
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:154
#, no-wrap
msgid "  @Inject FruitDao dao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:158
#, no-wrap
msgid ""
"  public void save(Fruit fruit) {\n"
"    dao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:163
#, no-wrap
msgid ""
"  public List<Fruit> getAll() {\n"
"    return dao.findAll().all();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:167
#, fuzzy
#| msgid "Note how the service receives a `FruitDao` instance in the constructor. This DAO instance is provided by `FruitDaoProducer` and injected automatically."
msgid "Note how the service is being injected a `FruitDao` instance. This DAO instance is injected automatically."
msgstr "コンストラクタで，サービスが `FruitDao` インスタンスを受け取っていることに注目してください．この DAO インスタンスは `FruitDaoProducer` によって提供され、自動的に注入されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:170
#, fuzzy
msgid "The Cassandra Quarkus extension allows you to inject any of the following beans in your own components:"
msgstr "Cassandra Quarkusエクステンションでは、以下のいずれかのBeanを独自のコンポーネントに注入することができます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:172
#, fuzzy
msgid "All `@Mapper`-annotated interfaces in your project."
msgstr "プロジェクト内のすべての `@Mapper`-annotated インターフェース。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:174
#, fuzzy
msgid "All `@Dao`-annotated interfaces in your project, as long as they are produced by a corresponding `@DaoFactory`-annotated method declared in a mapper interface from your project."
msgstr "プロジェクト内のすべての `@Dao`-注釈付きインターフェイス。ただし、プロジェクト内のマッパー・インターフェイスで宣言された対応する `@DaoFactory`-注釈付きメソッドによって生成されている場合に限ります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:179
#, fuzzy
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] bean: this application-scoped, singleton bean is your main entry point to the Cassandra client; it is a specialized Cassandra driver session instance with a few methods tailored especially for Quarkus. Read its javadocs carefully!"
msgstr "のことです。  link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`]これは、Quarkus用に特別に用意されたいくつかのメソッドを持つ、特殊なCassandraドライバセッションインスタンスです。このビーンのjavadocsをよく読んでください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:182
#, fuzzy
msgid "In our example, both `FruitMapper` and `FruitDao` could be injected anywhere. We chose to inject `FruitDao` in `FruitService`."
msgstr "この例では、 `FruitMapper` と `FruitDao` の両方をどこにでも注入することができます。私たちは、 `FruitDao` を `FruitService` に注入することにしました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:184
msgid "The last missing piece is the REST API that will expose GET and POST methods:"
msgstr "最後に必要なのは、GETとPOSTのメソッドを公開するREST APIです。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:191
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:193
#, no-wrap
msgid "  @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:198
#, no-wrap
msgid ""
"  @GET\n"
"  public List<FruitDto> getAll() {\n"
"    return fruitService.getAll().stream().map(this::convertToDto).collect(Collectors.toList());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:203
#, no-wrap
msgid ""
"  @POST\n"
"  public void add(FruitDto fruit) {\n"
"    fruitService.save(convertFromDto(fruit));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:207 upstream/_guides/cassandra.adoc:509
#, no-wrap
msgid ""
"  private FruitDto convertToDto(Fruit fruit) {\n"
"    return new FruitDto(fruit.getName(), fruit.getDescription());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:212 upstream/_guides/cassandra.adoc:514
#, no-wrap
msgid ""
"  private Fruit convertFromDto(FruitDto fruitDto) {\n"
"    return new Fruit(fruitDto.getName(), fruitDto.getDescription());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:215
#, fuzzy
msgid "Notice how `FruitResource` is being injected a `FruitService` instance automatically."
msgstr "`FruitResource` が `FruitService` のインスタンスに自動的に注入されていることに注目してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:221
#, fuzzy
msgid "It is generally not recommended using the same entity object between the REST API and the data access layer. These layers should indeed be decoupled and use distinct APIs in order to allow each API to evolve independently of the other. This is the reason why our REST API is using a different object: the `FruitDto` class – the word DTO stands for \"Data Transfer Object\". This DTO object will be automatically converted to and from JSON in HTTP messages:"
msgstr "一般的に、REST APIとデータアクセス層で同じエンティティオブジェクトを使用することは推奨されません。REST API とデータ・アクセス・レイヤーの間で同じエンティティ・オブジェクトを使用することは、一般的に推奨されていません。これが、REST API が `FruitDto` クラスという別のオブジェクトを使用している理由です。DTO という言葉は「Data Transfer Object」の略です。このDTOオブジェクトは、HTTPメッセージ内のJSONとの間で自動的に変換されます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:225
#, no-wrap
msgid "public class FruitDto {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:228
#, no-wrap
msgid ""
"  private String name;\n"
"  private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:230
#, no-wrap
msgid "  public FruitDto() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:237
#, no-wrap
msgid ""
"  public FruitDto(String name, String description) {\n"
"    this.name = name;\n"
"    this.description = description;\n"
"  }\n"
"  // getters and setters omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:242
#, fuzzy
msgid "The translation to and from JSON is done automatically by the Quarkus RestEasy extension, which is included in this guide's pom.xml file. If you want to add it manually to your application, add the below snippet to your application's ppm.xml file:"
msgstr "JSONとの変換は、このガイドのpom.xmlファイルに含まれているQuarkus RestEasyエクステンションによって自動的に行われます。アプリケーションに手動で追加したい場合は、以下のスニペットをアプリケーションのppm.xmlファイルに追加してください。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:253
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:257
msgid "DTO classes used by the JSON serialization layer are required to have a default no-arg constructor."
msgstr "JSONのシリアライゼーションレイヤーで使用されるDTOクラスは、デフォルトの引数なしのコンストラクタが必要です。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:261
#, fuzzy
msgid "The conversion from DTO to JSON is handled automatically for us, but we still must convert from `Fruit` to `FruitDto` and vice versa. This must be done manually, which is why we have two conversion methods declared in `FruitResource`: `convertToDto` and `convertFromDto`."
msgstr "DTO から JSON への変換は自動的に処理されますが、 `Fruit` から `FruitDto` への変換、およびその逆の変換は手動で行う必要があります。これは手動で行わなければなりません。そのため、 `FruitResource` で宣言されている2つの変換メソッド、 `convertToDto` と `convertFromDto` があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:265
#, fuzzy
msgid "In our example, `Fruit` and `FruitDto` are very similar, so you might wonder why not use `Fruit` everywhere. In real life cases though, it's not uncommon to see DTOs and entities having very different structures."
msgstr "この例では、 `Fruit` と `FruitDto` は非常によく似ているので、なぜどこでも `Fruit` を使わないのかと思うかもしれません。しかし、実際のケースでは、DTOとエンティティが非常に異なる構造を持つことは珍しくありません。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:266
#, fuzzy, no-wrap
#| msgid "Configuring the Cassandra database"
msgid "Connecting to the Cassandra Database"
msgstr "Cassandra データベースの設定"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:268
#, no-wrap
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr "Apache CassandraまたはDataStax Enterprise(DSE)への接続"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:272
#, fuzzy
#| msgid "The main properties to configure are: `contact-points`, to access the Cassandra database, `local-datacenter`, which is required by the driver, and – optionally – the keyspace to bind to."
msgid "The main properties to configure are: `contact-points`, to access the Cassandra database; `local-datacenter`, which is required by the driver; and – optionally – the keyspace to bind to."
msgstr "構成する主なプロパティーは次のとおりです。 Cassandraデータベースにアクセスするための `contact-points` 、ドライバーによって必要とされる `local-datacenter` そしてオプションでバインド先のキースペースです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:274
msgid "A sample configuration should look like this:"
msgstr "設定のサンプルは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:280
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points={cassandra_ip}:9042\n"
"quarkus.cassandra.local-datacenter={dc_name}\n"
"quarkus.cassandra.keyspace={keyspace}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:284
msgid "In this example, we are using a single instance running on localhost, and the keyspace containing our data is `k1`:"
msgstr "この例では、localhost上で動作する単一のインスタンスを使用しており、データを含むキースペースは `k1` となっています。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:290
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points=127.0.0.1:9042\n"
"quarkus.cassandra.local-datacenter=datacenter1\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:294
#, fuzzy
#| msgid "If your cluster requires plain text authentication, you can also provide two more settings: `username` and `password`."
msgid "If your cluster requires plain text authentication, you must also provide two more settings: `username` and `password`."
msgstr "クラスタがプレーンテキスト認証を必要とする場合は、さらに2つの設定を行うことができます。 `username` と `password` です。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:299
#, no-wrap
msgid ""
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:301
#, fuzzy, no-wrap
#| msgid "Connecting to a cloud DataStax Astra database"
msgid "Connecting to a DataStax Astra Cloud Database"
msgstr "クラウドDataStax Astraデータベースへの接続"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:307
#, fuzzy
#| msgid "When connecting to Astra, instead of providing a contact point and a datacenter, you should provide `secure-connect-bundle`, which should point to a valid path to an Astra secure connect bundle, as well as `username` and`password`, since authentication is always required on Astra clusters."
msgid "When connecting to link:https://astra.datastax.com[DataStax Astra], instead of providing a contact point and a datacenter, you should provide a so-called _secure connect bundle_, which should point to a valid path to an Astra secure connect bundle file. You can download your secure connect bundle from the Astra web console."
msgstr "Astra に接続する際には、コンタクトポイントとデータセンターを提供する代わりに、`secure-connect-bundle` を提供する必要があります。これは、Astra のセキュアな接続バンドルへの有効なパスを指すとともに、Astra クラスタでは常に認証が必要となるため、 `username` と `password` も提供する必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:310
#, fuzzy
msgid "You will also need to provide a username and password, since authentication is always required on Astra clusters."
msgstr "また、Astraクラスターでは常に認証が必要なため、ユーザー名とパスワードを入力する必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:312
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr "DataStax Astraのサンプル構成は次のようになります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:319
#, no-wrap
msgid ""
"quarkus.cassandra.cloud.secure-connect-bundle=/path/to/secure-connect-bundle.zip\n"
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:321
#, fuzzy, no-wrap
#| msgid "Advanced driver configuration"
msgid "Advanced Driver Configuration"
msgstr "高度なドライバー設定"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:328
#, fuzzy
#| msgid "You can configure other Java driver settings using `application.conf` or `application.json` files.  They need to be located in the classpath of your application.  All settings will be passed automatically to the underlying driver configuration mechanism.  Settings defined in `application.properties` with the `quarkus.cassandra` prefix will have priority over settings defined in `application.conf` or `application.json`."
msgid "You can configure other Java driver settings using `application.conf` or `application.json` files.  They need to be located in the classpath of your application. All settings will be passed automatically to the underlying driver configuration mechanism. Settings defined in `application.properties` with the `quarkus.cassandra` prefix will have priority over settings defined in `application.conf` or `application.json`."
msgstr "`application.conf` または `application.json` ファイルを使用して、他の Java ドライバーの設定を設定することができます。これらのファイルは、アプリケーションのクラスパスに配置する必要があります。すべての設定は、基礎となるドライバー設定メカニズムに自動的に渡されます。 `application.properties` で `quarkus.cassandra` のプレフィックスを付けて定義された設定は、 `application.conf` または `application.json` で定義された設定よりも優先されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:332
msgid "To see the full list of settings, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference]."
msgstr "設定の全リストを見るには、 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[ドライバーの設定リファレンス] を参照してください。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:333
#, fuzzy, no-wrap
#| msgid "Running a Cassandra Database"
msgid "Running a Local Cassandra Database"
msgstr "Cassandraデータベースの実行"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:337
#, fuzzy
#| msgid "By default, `CassandraClient` is configured to access a local Cassandra database on port 9042 (the default Cassandra port)."
msgid "By default, the Cassandra client is configured to access a local Cassandra database on port 9042 (the default Cassandra port)."
msgstr "デフォルトでは、 `CassandraClient` は、ポート 9042(デフォルトの Cassandra ポート)でローカル Cassandra データベースにアクセスするように構成されています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:340
msgid "Make sure that the setting `quarkus.cassandra.local-datacenter` matches the datacenter of your Cassandra cluster."
msgstr "設定 `quarkus.cassandra.local-datacenter` が、Cassandraクラスターのデータセンターと一致していることを確認してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:343
msgid "If you don't know the name of your local datacenter, this value can be found by running the following CQL query: `SELECT data_center FROM system.local`."
msgstr "ローカルのデータセンターの名前がわからない場合は、以下の CQL クエリを実行することでこの値を見つけることができます : `SELECT data_center FROM system.local` "

#. type: Plain text
#: upstream/_guides/cassandra.adoc:346
#, fuzzy
#| msgid "If you want to use Docker to run a Cassandra database, you can use the following command to launch one:"
msgid "If you want to use Docker to run a Cassandra database, you can use the following command to launch one in the background:"
msgstr "Dockerを使用してCassandraデータベースを起動したい場合は、以下のコマンドを使用して起動することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:350
#, no-wrap
msgid "docker run --name local-cassandra-instance -p 9042:9042 -d cassandra\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:354
msgid "Next you need to create the keyspace and table that will be used by your application. If you are using Docker, run the following commands:"
msgstr "次に、アプリケーションで使用するキースペースとテーブルを作成する必要があります。Dockerを使用している場合は、以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:359
#, no-wrap
msgid ""
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE KEYSPACE IF NOT EXISTS k1 WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}\"\n"
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE TABLE IF NOT EXISTS k1.fruit(name text PRIMARY KEY, description text)\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:362
#, fuzzy
msgid "You can also use the CQLSH utility to interactively interrogate your database:"
msgstr "また、CQLSHユーティリティーを使って、データベースをインタラクティブに照会することもできます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:366
#, no-wrap
msgid "docker exec -it local-cassandra-instance cqlsh\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cassandra.adoc:368
#, fuzzy, no-wrap
msgid "Testing the REST API"
msgstr "REST APIのテスト"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:371
#, fuzzy
msgid "In the project root directory:"
msgstr "プロジェクトのルートディレクトリに"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:373
#, fuzzy
msgid "Run `mvn clean package` and then `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` to start the application;"
msgstr "`mvn clean package` を実行し、次に `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` を実行してアプリケーションを起動します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:374
#, fuzzy
msgid "Or better yet, run the application in dev mode: `mvn clean quarkus:dev`."
msgstr "また、より良い方法として、アプリケーションを開発モードで実行することもできます。 `mvn clean quarkus:dev`."

#. type: Plain text
#: upstream/_guides/cassandra.adoc:376
#, fuzzy
msgid "Now you can use curl commands to interact with the underlying REST API."
msgstr "これで、curlコマンドを使って、基礎となるREST APIを操作できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:378
#, fuzzy
msgid "To create a fruit:"
msgstr "果実を作るために"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:385
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"apple\",\"description\":\"red and tasty\"}' \\\n"
"  http://localhost:8080/fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:388
#, fuzzy
msgid "To retrieve fruits:"
msgstr "果実を取り出すために"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:392
#, fuzzy, no-wrap
#| msgid "open a browser to `http://localhost:8080/fruits.html`"
msgid "curl -X GET http://localhost:8080/fruits\n"
msgstr "ブラウザを開く `http://localhost:8080/fruits.html`"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:394
#, fuzzy, no-wrap
#| msgid "Creating a frontend"
msgid "Creating a Frontend"
msgstr "フロントエンドの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:397
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr "それでは、 `FruitResource` と対話するためのシンプルなウェブページを追加してみましょう。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:401
#, fuzzy
#| msgid "Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it."
msgid "Quarkus automatically serves static resources located under the `META-INF/resources` directory. In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the contents from link:src/main/resources/META-INF/resources/fruits.html[this file] in it."
msgstr "Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:403
msgid "You can now interact with your REST service:"
msgstr "これで、REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:405 upstream/_guides/cassandra.adoc:569
#, fuzzy
#| msgid "start Quarkus with `mvn clean quarkus:dev`"
msgid "If you haven't done yet, start your application with `mvn clean quarkus:dev`;"
msgstr "Quarkusを起動する `mvn clean quarkus:dev`"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:406
#, fuzzy
#| msgid "open a browser to `http://localhost:8080/fruits.html`"
msgid "Point your browser to `http://localhost:8080/fruits.html`;"
msgstr "ブラウザを開く `http://localhost:8080/fruits.html`"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:407 upstream/_guides/cassandra.adoc:571
#, fuzzy
#| msgid "add new fruits to the list via the form"
msgid "Add new fruits to the list via the form."
msgstr "フォームを使って新しいフルーツをリストに追加します"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:409
#, fuzzy, no-wrap
#| msgid "Reactive Cassandra Client"
msgid "Reactive Programming with the Cassandra Client"
msgstr "リアクティブCassandraクライアント"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:415
#, fuzzy
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession` interface] gives you access to a series of reactive methods that integrate seamlessly with Quarkus and its reactive framework, Mutiny."
msgstr "link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`]インターフェースでは、QuarkusとそのリアクティブフレームワークであるMutinyとシームレスに統合する一連のリアクティブメソッドにアクセスできます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:417
msgid "If you are not familiar with Mutiny, please check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:419
#, fuzzy
#| msgid "Let's rewrite the previous example using reactive programming with Mutiny."
msgid "Let's rewrite our application using reactive programming with Mutiny."
msgstr "先ほどの例をMutinyを使ったリアクティブプログラミングで書き換えてみましょう。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:421
#, fuzzy
#| msgid "Firstly, we need to implement the `@Dao` that works in a reactive way:"
msgid "First, let's to declare another DAO interface that works in a reactive way:"
msgstr "まず、リアクティブに動作する `@Dao` を実装する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:426
#, no-wrap
msgid ""
"@Dao\n"
"public interface ReactiveFruitDao {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:429
#, no-wrap
msgid ""
"  @Update\n"
"  Uni<Void> updateAsync(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:433
#, no-wrap
msgid ""
"  @Select\n"
"  MutinyMappedReactiveResultSet<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:440
#, fuzzy
#| msgid "Please note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to obtain the query execution info. If you don't need anything in that interface, you can also simply declare your method to return `Multi`: `Multi<Fruit> findByIdAsync(String id)`,"
msgid "Note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to obtain the query execution info. If you don't need anything in that interface, you can also simply declare your method to return `Multi`: `Multi<Fruit> findAll()`,"
msgstr "`MutinyMappedReactiveResultSet` の使い方に注意してください。これは、ドライバが返すオリジナルの `Publisher` から変換された特殊な `Mutiny` 型で、クエリの実行情報を取得するなど、いくつかの追加メソッドも公開されています。このインターフェイスで何も必要としない場合は、単純に `Multi` を返すようにメソッドを宣言することもできます。`Multi<Fruit> findByIdAsync(String id)`"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:443
msgid "Similarly, the method `updateAsync` returns a `Uni` - it is automatically converted from the original result set returned by the driver."
msgstr "同様に、メソッド `updateAsync` は `Uni` を返します。これは、ドライバーが返す元の結果セットから自動的に変換されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:451
msgid "The Cassandra driver uses the Reactive Streams `Publisher` API for reactive calls. The Quarkus framework however uses Mutiny. Because of that, the `CqlQuarkusSession` interface transparently converts the `Publisher` instances returned by the driver into the reactive type `Multi`.  `CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` – in this case, the publisher is expected to emit at most one row, then complete. This is suitable for write queries (they return no rows), or for read queries guaranteed to return one row at most (count queries, for example)."
msgstr "Cassandraドライバは、リアクティブコールにReactive Streamsの `Publisher` APIを使用しています。しかし、QuarkusフレームワークではMutinyを使用しています。そのため、 `CqlQuarkusSession` インターフェイスは、ドライバが返す `Publisher` インスタンスを透過的にリアクティブ型の `Multi` に変換します。 `CqlQuarkusSession` は `Publisher` を `Uni` に変換することもできます - この場合、パブリッシャーは最大で1行を出力し、その後完了することが期待されます。これは書き込みクエリ(行を返さない)や、最大で1行を返すことが 保証されている読み込みクエリ(例えばカウントクエリ)に適しています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:453
#, fuzzy
#| msgid "Next, we need to adapt the `FruitMapper` to construct a `FruitDaoReactive` instance:"
msgid "Next, we need to adapt the `FruitMapper` to construct a `ReactiveFruitDao` instance:"
msgstr "次に、 `FruitDaoReactive` のインスタンスを構築するために、 `FruitMapper` を適応させる必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:459
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  // the existing method omitted\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:463
#, no-wrap
msgid ""
"  @DaoFactory\n"
"  ReactiveFruitDao reactiveFruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:467
#, fuzzy
#| msgid "Now, we can create a `FruitReactiveService` that leverages the reactive `@Dao`:"
msgid "Now, we can create a `ReactiveFruitService` that leverages our reactive DAO:"
msgstr "これで、リアクティブな `@Dao` を利用した `FruitReactiveService` を作成することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:472
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveFruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:474
#, no-wrap
msgid "  @Inject ReactiveFruitDao fruitDao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:478
#, no-wrap
msgid ""
"  public Uni<Void> add(Fruit fruit) {\n"
"    return fruitDao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:483
#, no-wrap
msgid ""
"  public Multi<Fruit> getAll() {\n"
"    return fruitDao.findAll();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:486
#, fuzzy
#| msgid "Finally, we can create a `FruitReactiveResource`:"
msgid "Finally, we can create a `ReactiveFruitResource`:"
msgstr "最後に、 `FruitReactiveResource` を作成します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:493
#, no-wrap
msgid ""
"@Path(\"/reactive-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class ReactiveFruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:495
#, no-wrap
msgid "  @Inject ReactiveFruitService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:500
#, no-wrap
msgid ""
"  @GET\n"
"  public Multi<FruitDto> getAll() {\n"
"    return service.getAll().map(this::convertToDto);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:505
#, no-wrap
msgid ""
"  @POST\n"
"  public Uni<Void> add(FruitDto fruitDto) {\n"
"    return service.add(convertFromDto(fruitDto));\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:519
#, fuzzy
msgid "The above resource is exposing a new endpoint, `reactive-fruits`. Its capabilities are identical to the ones that we created before with `FruitResource`, but everything is handled in a reactive fashion, without any blocking operation."
msgstr "上記のリソースは、 `reactive-fruits` という新しいエンドポイントを公開しています。このエンドポイントの機能は、以前 `FruitResource` で作成したものと同じですが、すべての処理はブロック操作なしでリアクティブに行われます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:523
#, fuzzy
#| msgid "The `get()` method above returns `Multi`, and the `add()` method returns `Uni`; these types are compatible with the Quarkus reactive REST API."
msgid "The `getAll()` method above returns `Multi`, and the `add()` method returns `Uni`. These types are the same Mutiny types that we met before; they are automatically recognized by the Quarkus reactive REST API, so we don't need to convert them into JSON ourselves."
msgstr "上記の `get()` メソッドは `Multi` を返し、 `add()` メソッドは `Uni` を返します。これらのタイプは、Quarkus のリアクティブ REST API と互換性があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:526
#, fuzzy
#| msgid "To integrate the reactive logic with REST API, you need to have a dependency to `quarkus-resteasy-mutiny`:"
msgid "To effectively integrate the reactive logic with the REST API, your application needs to declare a dependency to the Quarkus RestEasy Mutiny extension:"
msgstr "リアクティブロジックをRESTAPIと統合するには、 `quarkus-resteasy-mutiny` への依存関係が必要です。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:533
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:537
#, fuzzy
msgid "This dependency is already included in this guide's pom.xml, but if you are starting a new project from scratch, make sure to include it."
msgstr "この依存関係は、本ガイドのpom.xmlにすでに含まれていますが、新しいプロジェクトをゼロから始める場合は、必ず含めるようにしてください。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:538
#, fuzzy, no-wrap
msgid "Testing the Reactive REST API"
msgstr "Reactive REST APIのテスト"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:542
#, fuzzy
msgid "Run the application in dev mode as explained above, then you can use curl commands to interact with the underlying REST API."
msgstr "上記のようにアプリケーションをdevモードで実行すると、curlコマンドを使って基礎となるREST APIを操作できるようになります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:544
#, fuzzy
msgid "To create a fruit using the reactive REST endpoint:"
msgstr "リアクティブRESTエンドポイントを使ってフルーツを作るには"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:551
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"banana\",\"description\":\"yellow and sweet\"}' \\\n"
"  http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:554
#, fuzzy
msgid "To retrieve fruits with the reactive REST endpoint:"
msgstr "リアクティブRESTエンドポイントでフルーツを取得するには、次のようにします。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:558
#, fuzzy, no-wrap
#| msgid "open a browser to `http://localhost:8080/reactive-fruits.html`"
msgid "curl -X GET http://localhost:8080/reactive-fruits\n"
msgstr "ブラザで `http://localhost:8080/reactive-fruits.html` を開きます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:560
#, fuzzy, no-wrap
#| msgid "Creating a reactive frontend"
msgid "Creating a Reactive Frontend"
msgstr "リアクティブなフロントエンドの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:565
#, fuzzy
#| msgid "Now let's add a simple web page to interact with our `FruitReactiveResource`.  In the `src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the content from this link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/reactive-fruits.html[reactive-fruits.html] file in it."
msgid "Now let's add a simple web page to interact with our `ReactiveFruitResource`. In the `src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the contents from link:src/main/resources/META-INF/resources/reactive-fruits.html[this file] in it."
msgstr "それでは、 `FruitReactiveResource` を操作する簡単なWebページを追加してみましょう。 `src/main/resources/META-INF/resources` ディレクトリに、この link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/resources/reactive-fruits.html[reactive-fruits.html] ファイルの内容を含む、 `reactive-fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:567
msgid "You can now interact with your reactive REST service:"
msgstr "これで、リアクティブな REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:570
#, fuzzy
#| msgid "open a browser to `http://localhost:8080/reactive-fruits.html`"
msgid "Point your browser to `http://localhost:8080/reactive-fruits.html`;"
msgstr "ブラザで `http://localhost:8080/reactive-fruits.html` を開きます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:572
#, fuzzy, no-wrap
#| msgid "Connection Health Check"
msgid "Health Checks"
msgstr "接続のヘルスチェック"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:578
#, fuzzy
#| msgid "If you are using the `quarkus-smallrye-health` extension, `cassandra-quarkus` will automatically add a readiness health check to validate the connection to the cluster."
msgid "If you are using the Quarkus SmallRye Health extension, then the Cassandra client will automatically add a readiness health check to validate the connection to the Cassandra cluster. This extension is already included in this guide's pom.xml, but if you need to include it manually in your application, add the following:"
msgstr "`quarkus-smallrye-health` エクステンションを使用している場合、 `quarkus-quarkus` は、クラスタへの接続を検証するための Readiness ヘルスチェックを自動的に追加します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:585
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-health</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:589
#, fuzzy
#| msgid "So when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status."
msgid "When health checks are available, you can access the `/health/ready` endpoint of your application and have information about the connection validation status."
msgstr "そのため、アプリケーションの `/q/health/ready` エンドポイントにアクセスすると、接続の検証状況に関する情報が表示されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:592
#, fuzzy
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to http://localhost:8080/health/ready you should see an output similar to the following one:"
msgstr "devモードで `mvn clean quarkus:dev` を起動し、ブラウザで http://localhost:8080/health/ready を表示すると、次のような出力が表示されます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:611
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"UP\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"DataStax Apache Cassandra Driver health check\",\n"
"            \"status\": \"UP\",\n"
"            \"data\": {\n"
"                \"cqlVersion\": \"3.4.4\",\n"
"                \"releaseVersion\": \"3.11.7\",\n"
"                \"clusterName\": \"Test Cluster\",\n"
"                \"datacenter\": \"datacenter1\",\n"
"                \"numberOfNodes\": 1\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:616
#, fuzzy
#| msgid "This behavior can be disabled by setting the `quarkus.cassandra.health.enabled` property to `false` in your `application.properties`."
msgid "If you need health checks globally enabled in your application, but don't want to activate Cassandra health checks, you can disable Cassandra health checks by setting the `quarkus.cassandra.health.enabled` property to `false` in your `application.properties`."
msgstr "この動作は、 `application.properties` で `quarkus.cassandra.health.enabled` プロパティを `false` に設定することで無効にできます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:617
#, no-wrap
msgid "Metrics"
msgstr "メトリクス"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:621
#, fuzzy
msgid "The Cassandra Quarkus client can provide metrics about the Cassandra session and about individual Cassandra nodes. It supports both Micrometer and MicroProfile."
msgstr "Cassandra Quarkusクライアントは、Cassandraセッションおよび個々のCassandraノードに関するメトリクスを提供できます。MicrometerとMicroProfileの両方をサポートしています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:624
#, fuzzy
msgid "The first step to enable metrics is to add a few additional dependencies depending on the metrics framework you plan to use."
msgstr "メトリクスを有効にするための最初のステップは、使用するメトリクス・フレームワークに応じて、いくつかの依存関係を追加することです。"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:625
#, fuzzy, no-wrap
msgid "Enabling Metrics with Micrometer"
msgstr "マイクロメーターで測定値を実現"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:628
#, fuzzy
msgid "Micrometer is the recommended metrics framework in Quarkus applications since Quarkus 1.9."
msgstr "Micrometerは、Quarkus 1.9以降のQuarkusアプリケーションで推奨されているメトリクスフレームワークです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:630
#, fuzzy
msgid "To enable Micrometer metrics in your application, you need to add the following to your pom.xml."
msgstr "アプリケーションでMicrometerメトリクスを有効にするには、pom.xmlに以下を追加する必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:632
#, fuzzy
msgid "For Quarkus 1.11+:"
msgstr "Quarkus 1.11+を対象としています。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:643
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:646
#, fuzzy
msgid "For Quarkus < 1.11:"
msgstr "Quarkus &lt; 1.11:"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:661
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.micrometer</groupId>\n"
"  <artifactId>micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:664
#, fuzzy
msgid "This guide uses Micrometer, so the above dependencies are already included in this guide's pom.xml."
msgstr "このガイドではMicrometerを使用しているので、上記の依存関係はこのガイドのpom.xmlにすでに含まれています。"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:665
#, fuzzy, no-wrap
msgid "Enabling Metrics with MicroProfile Metrics"
msgstr "MicroProfile Metricsでメトリクスを有効にする"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:668
#, fuzzy
msgid "Remove any dependency to Micrometer from your pom.xml, then add the following ones instead:"
msgstr "pom.xmlからMicrometerへの依存関係を削除し、代わりに以下の依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:679
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-microprofile</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-metrics</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:681
#, fuzzy, no-wrap
#| msgid "Running a Cassandra Database"
msgid "Enabling Cassandra Metrics"
msgstr "Cassandraデータベースの実行"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:686
#, fuzzy
msgid "Even when metrics are enabled in your application, the Cassandra client will not report any metrics, unless you opt-in for this feature. So your next step is to enable Cassandra metrics in your `application.properties` file."
msgstr "アプリケーションでメトリクスが有効になっていても、この機能をオプトインしない限り、Cassandraクライアントはメトリクスを報告しません。したがって、次のステップは、 `application.properties` ファイルで Cassandra メトリクスを有効にすることです。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:690
#, no-wrap
msgid "quarkus.cassandra.metrics.enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:693
#, fuzzy
msgid "That's it!"
msgstr "それだ！」と。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:697
#, fuzzy
msgid "The final (and optional) step is to customize which specific Cassandra metrics you would like the Cassandra client to track. Several metrics can be tracked; if you skip this step, a default set of useful metrics will be automatically tracked."
msgstr "最後の（オプションの）ステップは、Cassandraクライアントに追跡させたい特定のCassandraメトリクスをカスタマイズすることです。複数のメトリクスを追跡することができます。このステップを省略すると、有用なメトリクスのデフォルト・セットが自動的に追跡されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:703
#, fuzzy
#| msgid "For the full list of available metrics, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference] and the `advanced.metrics` section."
msgid "For the full list of available metric names, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference] page; search for the `advanced.metrics` section.  Also, Cassandra driver metrics are covered in detail in the https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[driver manual]."
msgstr "利用可能なメトリクスの全リストについては、リンク:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[ドライバーの設定リファレンス] と `advanced.metrics` セクションを参照してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:705
#, fuzzy
msgid "If you do wish to customize which metrics to track, you should use the following properties:"
msgstr "どのメトリクスを追跡するかをカスタマイズしたい場合は、以下のプロパティを使用してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:708
#, fuzzy
msgid "`quarkus.cassandra.metrics.session.enabled` should contain the session-level metrics to enable (metrics that are global to the session)."
msgstr "`quarkus.cassandra.metrics.session.enabled` には、有効にするセッションレベルのメトリクス（セッションにグローバルに適用されるメトリクス）を入れてください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:710
#, fuzzy
msgid "`quarkus.cassandra.metrics.node.enabled` should contain the node-level metrics to enable (metrics for which each node contacted by the Cassandra client gets its own metric value)."
msgstr "`quarkus.cassandra.metrics.node.enabled` には、有効にするノード・レベルのメトリクス（Cassandraクライアントが接触する各ノードが独自のメトリクス値を取得するメトリクス）を含める必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:712
#, fuzzy
msgid "Both properties accept a comma-separated list of valid metric names."
msgstr "どちらのプロパティも、有効なメトリック名をカンマで区切ったリストを受け付けます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:714
#, fuzzy
msgid "For example, let's assume that you wish to enable the following three Cassandra metrics:"
msgstr "例えば、以下の3つのCassandraメトリクスを有効にしたいとします。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:716
#, fuzzy
msgid "Session-level: `session.connected-nodes` and `session.bytes-sent`;"
msgstr "セッションレベル： `session.connected-nodes` と `session.bytes-sent`;"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:717
#, fuzzy
msgid "Node-level: `node.pool.open-connections`."
msgstr "ノードレベル: `node.pool.open-connections`."

#. type: Plain text
#: upstream/_guides/cassandra.adoc:719
#, fuzzy
msgid "Then you should add the following settings to your `application.properties`:"
msgstr "そして、以下の設定を `application.properties` に追加してください。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:725
#, no-wrap
msgid ""
"quarkus.cassandra.metrics.enabled=true\n"
"quarkus.cassandra.metrics.session.enabled=connected-nodes,bytes-sent\n"
"quarkus.cassandra.metrics.node.enabled=pool.open-connections\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:729
#, fuzzy
msgid "This guide's `application.properties` file has already many metrics enabled; you can use its metrics list as a good starting point for exposing useful Cassandra metrics in your application."
msgstr "このガイドの `application.properties` ファイルは、すでに多くのメトリクスが有効になっています。そのメトリクス・リストは、アプリケーションで有用なCassandraメトリクスを公開するための良い出発点として使用できます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:732
#, fuzzy
msgid "When metrics are properly enabled, metric reports for all enabled metrics are available at the `/metrics` REST endpoint of your application."
msgstr "メトリクスが適切に有効化されると、有効化されたすべてのメトリクスのメトリクス・レポートが、アプリケーションの `/metrics` RESTエンドポイントで利用できるようになります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:736
#, fuzzy
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to `http://localhost:8080/metrics` you should see a list of metrics; search for metrics whose names contain `cassandra`."
msgstr "開発モードで `mvn clean quarkus:dev` を実行している場合、ブラウザを以下に向けると、メトリクスのリストが表示されます。 `&lt;a href=\"http://localhost:8080/metrics\" class=\"bare\"&gt;http://localhost:8080/metrics&lt;/a&gt;`メトリクスのリストが表示されます。名前に `cassandra` が含まれるメトリクスを検索してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:740
#, fuzzy
msgid "For Cassandra metrics to show up, the Cassandra client needs to be initialized and connected; if you are using lazy initialization (see below), you won't see any Cassandra metrics until your application actually connects and hits the database for the first time."
msgstr "Cassandraメトリクスを表示するには、Cassandraクライアントを初期化して接続する必要があります。遅延初期化（下記参照）を使用している場合は、アプリケーションが実際に接続してデータベースに初めてヒットするまで、Cassandraメトリクスは表示されません。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:741
#, fuzzy, no-wrap
msgid "Running in native mode"
msgstr "ネイティブモードでの動作"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:745
#, fuzzy
msgid "If you installed GraalVM, you can link:https://quarkus.io/guides/building-native-image[build a native image] using:"
msgstr "GraalVMをインストールした場合は、以下の方法で link:https://quarkus.io/guides/building-native-image[ネイティブイメージを構築]することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:749
#, no-wrap
msgid "mvn clean package -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:753
#, fuzzy
msgid "Beware that native compilation can take a significant amount of time! Once the compilation is done, you can run the native executable as follows:"
msgstr "ネイティブのコンパイルにはかなりの時間がかかりますのでご注意ください。コンパイルが終わったら、次のようにしてネイティブの実行ファイルを実行します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:757
#, no-wrap
msgid "./target/cassandra-quarkus-quickstart-*-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:760
msgid "You can then point your browser to `http://localhost:8080/fruits.html` and use your application."
msgstr "その後、ブラウザで `http://localhost:8080/fruits.html` を開いてアプリケーションを使用します。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:761
#, fuzzy, no-wrap
msgid "Eager vs Lazy Initialization"
msgstr "EagerとLazyの初期化"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:764
#, fuzzy
msgid "This extension allows you to inject either:"
msgstr "この拡張機能では、どちらかを注入することができます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:766
#, fuzzy
msgid "a `QuarkusCqlSession` bean;"
msgstr "`QuarkusCqlSession` の豆です。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:767
#, fuzzy
msgid "or the asynchronous version of this bean, that is, `CompletionStage<QuarkusCqlSession>`;"
msgstr "や、このビーンの非同期バージョン、つまり `CompletionStage&amp;lt;QuarkusCqlSession&amp;gt;`;"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:768
#, fuzzy
msgid "or the reactive version of this bean, that is, `Uni<QuarkusCqlSession>`."
msgstr "または、このビーンのリアクティブバージョン、つまり、 `Uni&amp;lt;QuarkusCqlSession&amp;gt;` 。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:772
#, fuzzy
msgid "The most straightforward approach is obviously to inject `QuarkusCqlSession` directly. This should work just fine for most applications; however, the `QuarkusCqlSession` bean needs to be initialized before it can be used, and this process is blocking."
msgstr "最も簡単な方法は、当然ながら `QuarkusCqlSession` を直接注入することです。しかし、 `QuarkusCqlSession` ビーンを使用する前に初期化する必要があり、この処理はブロックされます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:779
#, fuzzy
msgid "Fortunately, it is possible to control when the initialization should happen: the `quarkus.cassandra.init.eager-init` parameter determines if the `QuarkusCqlSession` bean should be initialized on its first access (lazy) or when the application is starting (eager). The default value of this parameter is `false`, meaning the init process is lazy: the `QuarkusCqlSession` bean will be initialized lazily on its first access – for example, when there is a first REST request that needs to interact with the Cassandra database."
msgstr "幸いなことに、初期化を行うタイミングを制御することが可能です。 `quarkus.cassandra.init.eager-init` パラメータは、 `QuarkusCqlSession` ビーンを最初のアクセス時に初期化するか (遅延) 、アプリケーションの起動時に初期化するか (熱心) を決定します。このパラメータのデフォルト値は `false` で、これは init プロセスがレイジーであることを意味します。 `QuarkusCqlSession` Bean は、最初のアクセス時 (たとえば、Cassandra データベースと対話する必要がある最初の REST 要求がある場合など) にレイジーに初期化されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:786
#, fuzzy
msgid "Using lazy initialization speeds up your application startup time, and avoids startup failures if the Cassandra database is not available. However, it could also prove dangerous if your code is fully asynchronous, e.g. if you are using https://quarkus.io/guides/reactive-routes[reactive routes]: indeed, the lazy initialization could accidentally happen on a thread that is not allowed to block, such as a Vert.x event loop thread. Therefore, setting `quarkus.cassandra.init.eager-init` to `false` and injecting `QuarkusCqlSession` should be avoided in these contexts."
msgstr "遅延初期化を使用することで、アプリケーションの起動時間を短縮し、Cassandraデータベースが利用できない場合の起動失敗を回避することができます。実際、遅延初期化はVert.xのイベントループスレッドなど、ブロックすることが許されていないスレッドで偶発的に発生する可能性があります。したがって、 `quarkus.cassandra.init.eager-init` を `false` に設定して `QuarkusCqlSession` を注入することは、このような文脈では避けるべきです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:792
#, fuzzy
msgid "If you want to use Vert.x (or any other reactive framework) and keep the lazy initialization behavior, you should instead inject only `CompletionStage<QuarkusCqlSession>` or `Uni<QuarkusCqlSession>`. When injecting these beans, the initialization process will be triggered lazily, but it will happen in the background, in a non-blocking way, leveraging the Vert.x event loop. This way you don't risk blocking the Vert.x thread."
msgstr "Vert.x（または他のリアクティブフレームワーク）を使用し、遅延初期化動作を維持したい場合は、代わりに `CompletionStage&amp;lt;QuarkusCqlSession&amp;gt;` または `Uni&amp;lt;QuarkusCqlSession&amp;gt;` のみを注入してください。これらのBeanを注入すると、初期化プロセスが遅延的にトリガされますが、Vert.xのイベントループを利用してノンブロッキングでバックグラウンドで行われます。これにより、Vert.xスレッドをブロックする危険性がありません。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:797
#, fuzzy
msgid "Alternatively, you can set `quarkus.cassandra.init.eager-init` to true: in this case the session bean will be initialized eagerly during application startup, on the Quarkus main thread. This would eliminate any risk of blocking a Vert.x thread, at the cost of making your startup time (much)  longer."
msgstr "代わりに、 `quarkus.cassandra.init.eager-init` をtrueに設定することもできます。この場合、セッションBeanはアプリケーション起動時にQuarkusメインスレッドで熱心に初期化されます。これにより、Vert.xスレッドをブロックするリスクがなくなりますが、起動時間が（かなり）長くなります。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:798
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:802
msgid "Accessing a Cassandra database from a client application is easy with Quarkus and the Cassandra extension, which provides configuration and native support for the DataStax Java driver for Apache Cassandra."
msgstr "クライアント・アプリケーションからのCassandraデータベースへのアクセスは、QuarkusとCassandraエクステンションで簡単に行えます。"

#, fuzzy
#~| msgid "If you're not familiar with Mutiny, read the link:getting-started-reactive[Getting Started with Reactive guide] first."
#~ msgid "If you're not familiar with Mutiny, read the link:https://quarkus.io/guides/getting-started-reactive[Getting Started with Reactive guide] first."
#~ msgstr "Mutinyに慣れていない場合は、まず link:https://quarkus.io/guides/getting-started-reactive[Getting Started with Reactiveガイド] を読んでください。"

#~ msgid "Apache Maven 3.5.3+;"
#~ msgstr "Apache Maven 3.5.3+;"

#~ msgid "Cassandra or Docker installed"
#~ msgstr "CassandraまたはDockerのインストール"

#~ msgid "All the information between the browser and the server is formatted as JSON."
#~ msgstr "ブラウザとサーバー間の情報はすべてJSON形式になっています。"

#~ msgid "The elements are stored in the Cassandra database."
#~ msgstr "要素は Cassandra データベースに格納されています。"

#~ msgid "The `pom.xml` is importing the RESTEasy/JAX-RS, JSON-B, Context Propagation and Cassandra Client extensions."
#~ msgstr "`pom.xml` は、RESTEasy/JAX-RS、JSON-B、Context Propagation、Cassandraクライアントエクステンションをインポートしています。"

#~ msgid "The most important part of the `pom.xml` is adding the `cassandra-quarkus` extension:"
#~ msgstr "`pom.xml` で最も重要なのは、 `cassandra-quarkus` のエクステンションを追加することです。"

#~ msgid "Also make sure to follow the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper/config/[instructions] on how to add an annotation processor to the compiler configuration. When the project is compiled, additional mapper classes are generated."
#~ msgstr "また、コンパイラの設定にアノテーション・プロセッサーを追加する方法についても、必ず link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper/config/[指示] に従ってください。プロジェクトがコンパイルされると、追加のマッパークラスが生成されます。"

#~ msgid "We are using DataStax Java driver Object Mapper, which is why this class is annotated with an `@Entity`. Also, the `storeId` field represents a Cassandra partition key and `name` represents a clustering column, and so we are using the corresponding annotations from the Object Mapper library.  It will allow the Mapper to generate proper CQL queries underneath."
#~ msgstr "DataStax JavaドライバーのObject Mapperを使用しているので、このクラスには `@Entity` がアノテーションされています。また、 `storeId` フィールドは Cassandra パーティション・キーを表し、 `name` はクラスタリング・カラムを表しているので、Object Mapper ライブラリから対応するアノテーションを使用しています。これにより、Mapperはその下に適切なCQLクエリを生成することができるようになります。"

#~ msgid "Entity classes are required to have a default no-args constructor."
#~ msgstr "エンティティクラスには、デフォルトの引数なしのコンストラクタが必要です。"

#~ msgid "To leverage the Mapper logic in this app we need to create a DAO:"
#~ msgstr "このアプリでMapperロジックを活用するには、DAOを作成する必要があります。"

#~ msgid "This class exposes operations that will be used in the REST service."
#~ msgstr "このクラスは、RESTサービスで使用される操作を公開します。"

#~ msgid "The mapper is responsible for constructing instances of `FruitDao`. In the example above, the `FruitDao` instance will be connected to the same keyspace as the underlying session. More on that below."
#~ msgstr "マッパーは， `FruitDao` のインスタンスを構築する役割を果たします．上の例では、 `FruitDao` のインスタンスは、基礎となるセッションと同じキースペースに接続されます。詳細は後述します。"

#~ msgid "It is also possible to create DAO instances for different keyspaces. To learn how, see link:https://docs.datastax.com/en/developer/java-driver/4.7/manual/mapper/mapper/#dao-parameterization[DAO parameterization] in the driver docs."
#~ msgstr "異なるキースペース用の DAO インスタンスを作成することも可能です。方法については、ドライバードキュメントの link:https://docs.datastax.com/en/developer/java-driver/4.7/manual/mapper/mapper/#dao-parameterization[DAO パラメーター化] を参照してください。"

#~ msgid "Next, we need a component to create our DAO instances: `FruitDaoProducer`. Indeed, Mapper and Dao instances are stateful objects, and should be created only once, as application-scoped singletons.  This component will do exactly that, leveraging Quarkus Dependency Injection container:"
#~ msgstr "次に，DAOインスタンスを生成するためのコンポーネント `FruitDaoProducer` が必要です。実際、マッパーとDAOのインスタンスはステートフルなオブジェクトであり、アプリケーションスコープのシングルトンとして、一度だけ作成されるべきです。  このコンポーネントは、QuarkusのDependency Injectionコンテナを利用して、まさにそれを行います。"

#~ msgid "Note how the `QuarkusCqlSession` instance is injected automatically by the cassandra-quarkus extension in the `FruitDaoProducer` constructor."
#~ msgstr "`QuarkusCqlSession` のインスタンスが `FruitDaoProducer` コンストラクタの cassandra-quarkus エクステンションによって自動的に注入されていることに注意してください。"

#~ msgid "Also note that `FruitMapperBuilder` is one of the classes generated automatically by the `java-driver-mapper-processor` annotation processor."
#~ msgstr "また、 `FruitMapperBuilder` は `java-driver-mapper-processor` アノテーション・プロセッサーによって自動的に生成されるクラスの一つであることにも注意してください。"

#~ msgid ""
#~ "@Path(\"/fruits\")\n"
#~ "public class FruitResource {\n"
#~ msgstr ""
#~ "@Path(\"/fruits\")\n"
#~ "public class FruitResource {\n"

#~ msgid "The `list` and `add` operations are executed for the `storeId` \"acme\". This is the partition key of our data model. We can easily retrieve all rows from cassandra using that partition key.  They will be sorted by the clustering column. `FruitResource` is using `FruitService` which encapsulates the data access logic."
#~ msgstr "`list` と `add` の操作は `storeId` の \"acme \" に対して実行されます。これは私たちのデータモデルのパーティション・キーです。このパーティション・キーを使って、Cassandraからすべての行を簡単に取り出すことができます。  それらはクラスタリングカラムでソートされます。 `FruitResource` はデータアクセスロジックをカプセル化した `FruitService` を使用しています。"

#~ msgid "When creating the REST API we should not share the same entity object between REST API and data access layers. They should not be coupled to allow the API to evolve independently of the storage layer. This is the reason why the API is using a `FruitDto` class. This class will be used by Quarkus to convert JSON to java objects for client requests and java objects to JSON for the responses. The translation is done by quarkus-resteasy extension."
#~ msgstr "REST APIを作成する際には、REST APIとデータアクセス層の間で同じエンティティーオブジェクトを共有すべきではありません。それらは、APIがストレージ層から独立して進化できるように結合されるべきではありません。これが、APIが `FruitDto` クラスを使用している理由です。このクラスは、Quarkusによって、クライアントのリクエストに対してはJSONをjavaオブジェクトに、レスポンスに対してはjavaオブジェクトをJSONに変換するために使用されます。変換はquarkus-resteasyエクステンションによって行われます。"

#~ msgid "Note that only the 9042 port is required. All others all optional but provide enhanced features like JMX monitoring of the Cassandra instance."
#~ msgstr "9042ポートのみが必要であることに注意してください。他のすべてはオプションですが、CassandraインスタンスのJMX監視などのエクステンションを提供します。"

#~ msgid "If you're running Cassandra locally you can execute the cqlsh commands directly:"
#~ msgstr "ローカルでCassandraを実行している場合は、cqlshコマンドを直接実行できます。"

#~ msgid "When using `QuarkusCqlSession` you have access to reactive variant of methods that integrate with Quarkus and Mutiny."
#~ msgstr "`QuarkusCqlSession` を使うと、QuarkusとMutinyを統合したメソッドのリアクティブなバリアントにアクセスできます。"

#~ msgid "It provides an integration layer between `Multi`, `Uni` and the REST API."
#~ msgstr "これは `Multi` 、`Uni` 、REST APIの間の統合レイヤーを提供します。"

#~ msgid "All methods exposed via REST interface are returning reactive types from the Mutiny API."
#~ msgstr "RESTインターフェースを介して公開されているすべてのメソッドは、Mutiny APIからリアクティブ型を返しています。"

#~ msgid "If you are using the `quarkus-smallrye-metrics` extension, `cassandra-quarkus` can provide metrics about QuarkusCqlSession and Cassandra nodes."
#~ msgstr "`quarkus-smallrye-metrics` エクステンションを使用している場合、 `cassandra-quarkus` は、QuarkusCqlSession と Cassandra ノードに関するメトリクスを提供できます。"

#~ msgid "This behavior must first be enabled by setting the `quarkus.cassandra.metrics.enabled` property to `true` in your `application.properties`."
#~ msgstr "この動作を有効にするには、まず `application.properties` で `quarkus.cassandra.metrics.enabled` プロパティを `true` に設定する必要があります。"

#~ msgid "The next step that you need to do is set explicitly which metrics should be enabled."
#~ msgstr "次のステップでは、どのメトリクスを有効にするかを明示的に設定します。"

#~ msgid "The `quarkus.cassandra.metrics.session-enabled` and `quarkus.cassandra.metrics.node-enabled` properties should be used for enabling metrics; the former should contain a list of session-level metrics to enable, while the latter should contain a list of node-level metrics to enable. Both properties accept a comma-separated list of valid metric names."
#~ msgstr "`quarkus.cassandra.metrics.session-enabled` および `quarkus.cassandra.metrics.node-enabled` プロパティは、メトリクスを有効にするために使用する必要があります。前者は有効にするセッション・レベル・メトリクスのリストを含み、後者は有効にするノード・レベル・メトリクスのリストを含む必要があります。どちらのプロパティも、有効なメトリクス名をコンマで区切ったリストを受け付けます。"

#~ msgid "For example, to enable `session.connected-nodes`, `session.bytes-sent`, and `node.pool.open-connections` you should add the following settings to your `application.properties`:"
#~ msgstr "例えば、 `session.connected-nodes` 、 `session.bytes-sent` 、 `node.pool.open-connections` を有効にするには、 `application.properties` に以下の設定を追加します。"

#~ msgid "When metrics are enabled and you access the `/q/metrics` endpoint of your application, you will see metric reports for all enabled metrics."
#~ msgstr "メトリクスが有効になっていて、アプリケーションの `/q/metrics` エンドポイントにアクセスすると、有効になっているすべてのメトリクスのメトリクスレポートが表示されます。"

#~ msgid "Building a native executable"
#~ msgstr "ネイティブ実行可能ファイルの構築"

#~ msgid "You can use the Cassandra client in a native executable."
#~ msgstr "ネイティブ実行ファイルでCassandraクライアントを使用することができます。"

#~ msgid "You can build a native executable with the `mvn clean package -Dnative` command."
#~ msgstr "`mvn clean package -Dnative` コマンドでネイティブ実行ファイルをビルドすることができます。"

#~ msgid "Running it is as simple as executing `./target/quickstart-1.0.0-SNAPSHOT-runner`."
#~ msgstr "実行は `./target/quickstart-1.0.0-SNAPSHOT-runner` を実行するだけで簡単です。"
