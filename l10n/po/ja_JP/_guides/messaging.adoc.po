msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _guides/messaging.adoc
msgid "Quarkus Messaging Extensions"
msgstr "Quarkus Messaging エクステンション"

#: _guides/messaging.adoc
msgid ""
"Event-driven messaging systems have become the backbone of most modern applications,\n"
"enabling the building of message-driven microservices or complex data streaming pipelines."
msgstr ""
"イベント駆動型メッセージングシステムは、ほとんどの最新アプリケーションのバックボーンになっています。\n"
"これにより、メッセージ駆動型マイクロサービスや複雑なデータストリーミングパイプラインのビルドが可能になります。"

#: _guides/messaging.adoc
msgid ""
"Quarkus offers a comprehensive suite of messaging extensions designed to synchronize with leading messaging technologies effortlessly.\n"
"This empowers developers to concentrate on crafting the core application logic, liberating them from the necessity to delve into the complexities of individual APIs and messaging infrastructures."
msgstr ""
"Quarkus では、主要なメッセージングテクノロジーと簡単に同期できるように設計された包括的なメッセージングエクステンションスイートを提供しています。\n"
"これにより、開発者はコアアプリケーションロジックの作成に集中できるようになり、個々の API やメッセージングインフラストラクチャーの複雑さを詳しく調べる必要がなくなります。"

#: _guides/messaging.adoc
msgid "This page focuses on common features and the development model for all messaging extensions."
msgstr "このページでは、すべてのメッセージングエクステンションに共通する機能と開発モデルに焦点を当てています。"

#: _guides/messaging.adoc
msgid "Some of these extensions are maintained in the core Quarkus repository:"
msgstr "これらのエクステンションの一部は、コア Quarkus リポジトリーで管理されています。"

#: _guides/messaging.adoc
msgid "*Messaging*: The core extension defines the basic concepts and APIs to develop messaging applications"
msgstr "*メッセージング*: コアエクステンションは、メッセージングアプリケーションを開発するための基本的な概念と API を定義します。"

#: _guides/messaging.adoc
msgid "xref:kafka.adoc[*Messaging - Kafka Connector*]"
msgstr "xref:kafka.adoc[*Messaging - Kafka Connector*]"

#: _guides/messaging.adoc
msgid "xref:pulsar.adoc[*Messaging - Pulsar Connector*]"
msgstr "xref:pulsar.adoc[*Messaging - Pulsar Connector*]"

#: _guides/messaging.adoc
msgid "xref:rabbitmq-reference.adoc[*Messaging - RabbitMQ Connector*]"
msgstr "xref:rabbitmq-reference.adoc[*Messaging - RabbitMQ Connector*]"

#: _guides/messaging.adoc
msgid "xref:amqp-reference.adoc[*Messaging - AMQP 1.0 Connector*]"
msgstr "xref:amqp-reference.adoc[*Messaging - AMQP 1.0 Connector*]"

#: _guides/messaging.adoc
msgid "*Messaging - MQTT Connector*"
msgstr "*Messaging - MQTT Connector*"

#: _guides/messaging.adoc
msgid "Some extensions are contributed and maintained by the community:"
msgstr "いくつかのエクステンションはコミュニティーによって提供され、維持されています。"

#: _guides/messaging.adoc
msgid "link:{camel-smallrye-reactive-messaging}[Camel SmallRye Reactive Messaging]"
msgstr "link:{camel-smallrye-reactive-messaging}[Camel SmallRye Reactive Messaging]"

#: _guides/messaging.adoc
msgid "link:{nats-jetstream}[Nats Jetstream Connector]"
msgstr "link:{nats-jetstream}[Nats Jetstream Connector]"

#: _guides/messaging.adoc
msgid "link:{solace-quarkus}[Solace Messaging Connector]"
msgstr "link:{solace-quarkus}[Solace Messaging Connector]"

#: _guides/messaging.adoc
msgid "link:{http-websocket-connector}[Reactive HTTP and WebSocket Connector]"
msgstr "link:{http-websocket-connector}[Reactive HTTP および WebSocket Connector]"

#: _guides/messaging.adoc
msgid "AWS SQS Connector"
msgstr "AWS SQS Connector"

#: _guides/messaging.adoc
msgid "Other connectors, such as the *JMS Connector* or the *Google PubSub Connector*, do not benefit from the same level of integration and require more manual configuration to set up."
msgstr "*JMS Connector* や *Google PubSub Connector* などの他のコネクターでは、同じレベルのインテグレーションのメリットが得られず、セットアップには手動での設定がさらに必要となります。"

#: _guides/messaging.adoc
msgid ""
"On the other hand, some messaging-related extensions propose low-level provider-specific integrations.\n"
"The level of support covered on this page DOES NOT involve these low-level extensions.\n"
"A non-exhaustive list of this kind of extension are the following:"
msgstr ""
"一方、メッセージング関連のエクステンションの中には、低レベルのプロバイダー固有のインテグレーションを提案するものもあります。\n"
"このページで説明されているサポートレベルには、これらの低レベルのエクステンションは含まれません。\n"
"以下は、この種のエクステンションの一部を含むリストです。"

#: _guides/messaging.adoc
msgid "link:https://quarkus.io/guides/kafka-streams[Kafka Streams Extension]"
msgstr "リンク:https://quarkus.io/guides/kafka-streams[Kafka Streams エクステンション]"

#: _guides/messaging.adoc
msgid "link:https://docs.quarkiverse.io/quarkus-rabbitmq-client/dev/index.html[RabbitMQ Client]"
msgstr "リンク:https://docs.quarkiverse.io/quarkus-rabbitmq-client/dev/index.html[RabbitMQ Client]"

#: _guides/messaging.adoc
msgid "link:https://docs.quarkiverse.io/quarkus-hivemq-client/dev/index.html[HiveMQ Client]"
msgstr "リンク:https://docs.quarkiverse.io/quarkus-hivemq-client/dev/index.html[HiveMQ Client]"

#: _guides/messaging.adoc
msgid "link:https://docs.quarkiverse.io/quarkus-artemis/dev/quarkus-artemis-jms.html[Artemis Core & JMS]"
msgstr "リンク:https://docs.quarkiverse.io/quarkus-artemis/dev/quarkus-artemis-jms.html[Artemis Core & JMS]"

#: _guides/messaging.adoc
msgid "link:https://docs.quarkiverse.io/quarkus-google-cloud-services/main/pubsub.html[Google Cloud Pubsub]"
msgstr "リンク:https://docs.quarkiverse.io/quarkus-google-cloud-services/main/pubsub.html[Google Cloud Pubsub]"

#: _guides/messaging.adoc
msgid "Quarkus Messaging Development Model"
msgstr "Quarkus Messaging 開発モデル"

#: _guides/messaging.adoc
msgid ""
"Quarkus simplifies message-driven application development by establishing a uniform model for publishing, consuming, and processing messages, regardless of whether the underlying broker technology uses message queuing or event streaming.\n"
"Built upon the MicroProfile Reactive Messaging specification, Quarkus Messaging extensions ensure seamless integration with these technologies.\n"
"Importantly, proficiency in reactive programming is NOT a prerequisite for leveraging these capabilities."
msgstr ""
"Quarkus は、基盤となるブローカーテクノロジーがメッセージキューイングまたはイベントストリーミングを使用するかどうかに関係なく、メッセージの公開、消費、および処理のための統一モデルを確立することで、メッセージ駆動型アプリケーションの開発を簡素化します。\n"
"MicroProfile Reactive Messaging 仕様に基づいてビルドされた Quarkus Messaging エクステンションは、シームレスかつ確実にこれらのテクノロジーと統合します。\n"
"重要なのは、これらの機能を活用するために、リアクティブプログラミングを習熟していることが前提条件ではないという点です。"

#: _guides/messaging.adoc
msgid ""
"The Reactive Messaging specification defines a CDI-based programming model for implementing event-driven and message-driven applications.\n"
"Using a small set of annotations, CDI beans become building blocks for implementing interactions with message brokers.\n"
"These interactions happen through _channels_ where application components read and write messages."
msgstr ""
"Reactive Messaging 仕様は、イベント駆動型およびメッセージ駆動型のアプリケーションを実装するための CDI ベースのプログラミングモデルを定義します。\n"
"少数のアノテーションセットを使用することで、CDI Bean はメッセージブローカーとの対話を実装するための設定要素になります。\n"
"これらのやり取りは、アプリケーションコンポーネントがメッセージを読み書きする _チャネル_ を通じて行われます。"

#: _guides/messaging.adoc
msgid "_Channels_ are identified by a unique name and declared using a set of annotations."
msgstr "_チャネル_ は一意の名前で識別され、一連のアノテーションを使用して宣言されます。"

#: _guides/messaging.adoc
msgid "`@Incoming` and `@Outgoing` annotations"
msgstr "`@Incoming` および `@Outgoing` アノテーション"

#: _guides/messaging.adoc
msgid "`@Incoming` and `@Outgoing` method annotations define _channels_ allowing to consume messages from and produce messages to the message broker:"
msgstr "`@Incoming` および `@Outgoing` メソッドアノテーションは、メッセージブローカーからのメッセージの消費とメッセージブローカーへのメッセージの生成を可能にする _チャネル_ を定義します。"

#: _guides/messaging.adoc
msgid "`@Outgoing` can be used by itself on a method to generate messages:"
msgstr "`@Outgoing` は、メッセージを生成するメソッドで単独で使用できます。"

#: _guides/messaging.adoc
msgid "`@Incoming` can be used by itself to consume messages:"
msgstr "`@Incoming` は、メッセージを消費するために単独で使用できます。"

#: _guides/messaging.adoc
msgid ""
"Note that you should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code.\n"
"They are invoked by the framework.\n"
"Having user code invoking them would not have the expected outcome."
msgstr ""
"コードから直接 `@Incoming` や `@Outgoing` のアノテーションが付けられたメソッドを呼び出してはならない点に注意してください。\n"
"これらはフレームワークによって呼び出されます。\n"
"ユーザーコードがそれらを呼び出すと、期待どおりの結果は得られません。"

#: _guides/messaging.adoc
msgid "You can read more on supported method signatures in the link:{rm_doc_method_signatures}[SmallRye Reactive Messaging – Supported signatures]."
msgstr "サポートされるメソッド署名の詳細は、リンク:{rm_doc_method_signatures}[SmallRye Reactive Messaging – サポートされる署名] を参照してください。"

#: _guides/messaging.adoc
msgid "Emitters and `@Channel` annotation"
msgstr "Emitter と `@Channel` アノテーション"

#: _guides/messaging.adoc
msgid "An application often needs to combine messaging with other parts of the application, ex. produce messages from HTTP endpoints, or stream consumed messages as a response."
msgstr "アプリケーションでは、多くの場合、メッセージングをアプリケーションの他の部分と組み合わせる必要があります。たとえば、HTTP エンドポイントからメッセージを生成したり、消費されたメッセージをレスポンスとしてストリーミングしたりする必要があります。"

#: _guides/messaging.adoc
msgid "To send messages from imperative code to a specific channel, you need to inject an `Emitter` object identified by the `@Channel` annotation:"
msgstr "命令型コードから特定のチャネルにメッセージを送信するには、`@Channel` アノテーションで識別される `Emitter` オブジェクトを注入する必要があります。"

#: _guides/messaging.adoc
msgid ""
"The `@Channel` annotation lets you indicate to which channel you will send your payloads or messages.\n"
"The `Emitter` allows buffering messages sent to the channel."
msgstr ""
"`@Channel` アノテーションを使用すると、ペイロードまたはメッセージを送信するチャネルを指定できます。\n"
"`Emitter` を使用すると、チャネルに送信されたメッセージをバッファリングできます。"

#: _guides/messaging.adoc
msgid "For more control, using link:{mutiny}[Mutiny] APIs, you can use the `MutinyEmitter` emitter interface:"
msgstr "さらに制御するには、リンク:{mutiny}[Mutiny] APIs を使用して、`MutinyEmitter` エミッターインターフェイスを使用できます。"

#: _guides/messaging.adoc
msgid "The `@Channel` annotation can also be used to inject the stream of messages from an incoming channel:"
msgstr "`@Channel` アノテーションは、着信チャネルからのメッセージストリームを注入するためにも使用できます。"

#: _guides/messaging.adoc
msgid ""
"When consuming messages with `@Channel`, the application code is responsible for subscribing to the stream.\n"
"In the example above, the Quarkus REST (formerly RESTEasy Reactive) endpoint handles that for you."
msgstr ""
"`@Channel` でメッセージを消費する場合、アプリケーションコードがストリームへのサブスクライブを行います。\n"
"上記の例では、Quarkus REST (旧称 RESTEasy Reactive) エンドポイントがサブスクリプションを処理します。"

#: _guides/messaging.adoc
msgid "You can read more on the emitters and channels in the link:{rm_doc_emitter}[SmallRye Reactive Messaging – Emitter and Channels] documentation."
msgstr "エミッターとチャネルの詳細は、リンク:{rm_doc_emitter}[SmallRye Reactive Messaging – エミッターとチャネル] のドキュメントを参照してください。"

#: _guides/messaging.adoc
msgid "Messages and Metadata"
msgstr "メッセージとメタデータ"

#: _guides/messaging.adoc
msgid ""
"A `Message` is an envelope around a payload.\n"
"In the examples above only payloads were used, but every payload is wrapped around a `Message` internally in Quarkus Messaging."
msgstr ""
"`Message` はペイロードを包むエンベロープです。\n"
"上記の例ではペイロードのみが使用されていましたが、Quarkus Messaging ではすべてのペイロードが内部的に `Message` でラップされています。"

#: _guides/messaging.adoc
msgid ""
"The `Message<T>` interface associates a payload of type `<T>` with `Metadata`,\n"
"a set of arbitrary objects and asynchronous actions for acknowledgement (ack) and negative acknowledgement (nack)."
msgstr ""
"`Message<T>` インターフェイスは、確認応答 (ack) および否定応答 (nack) 用に `<T>` タイプのペイロードを `Metadata`、\n"
"任意のオブジェクトと非同期アクションのセットに関連付けます。"

#: _guides/messaging.adoc
msgid ""
"A message is acknowledged back to the broker when its processing or reception has been successful.\n"
"Acknowledgements between messages are chained, meaning that when processing a message,\n"
"the acknowledgement of an outgoing message triggers the acknowledgement of incoming message(s).\n"
"In most cases, acks and nacks are managed for you and connectors allow you to configure different strategies per channel.\n"
"So, you usually don't need to interact with the `Message` interface directly.\n"
"Only advanced use cases require dealing with the Message directly."
msgstr ""
"メッセージの処理または受信が成功すると、ブローカーに確認応答が返されます。\n"
"メッセージ間の確認応答は連鎖しており、メッセージを処理する際には、\n"
"発信メッセージの確認は、着信メッセージの確認をトリガーします。\n"
"ほとんどの場合、確認応答と否定応答は自動的に管理され、コネクターを使用するとチャネルごとに異なるストラテジーを設定できます。\n"
"したがって、通常は `Message` インターフェイスと直接やり取りする必要はありません。\n"
"高度なユースケースでのみ、Message と直接処理する必要があります。"

#: _guides/messaging.adoc
msgid ""
"Accessing the `Metadata`, on the other hand, can be practical in many cases.\n"
"Connectors add specific metadata objects to the message to give access to the message headers, properties, and other connector-specific information.\n"
"You do not need to interact with the `Message` interface to access connector-specific metadata.\n"
"You can simply inject the metadata object as a method parameter after the payload parameter:"
msgstr ""
"一方、`Metadata` にアクセスすることは、多くの場合実用的です。\n"
"コネクターは、メッセージヘッダー、プロパティー、およびその他のコネクター固有の情報にアクセスできるように、特定のメタデータオブジェクトをメッセージに追加します。\n"
"コネクター固有のメタデータにアクセスするために、`Message` インターフェイスを操作する必要はありません。\n"
"ペイロードパラメーターの後に、メタデータオブジェクトをメソッドパラメーターとして挿入するだけになります。"

#: _guides/messaging.adoc
msgid ""
"Depending on the connector, payload types available to consume in processing methods differ.\n"
"You can implement a custom `MessageConverter` to transform the payload to a type that is accepted by your application."
msgstr ""
"コネクターに応じて、処理方法で使用できるペイロードタイプが異なります。\n"
"カスタム `MessageConverter` を実装して、ペイロードをアプリケーションで受け入れられる型に変換できます。"

#: _guides/messaging.adoc
msgid "Channel configuration"
msgstr "チャネル設定"

#: _guides/messaging.adoc
msgid "Channel attributes can be configured using the `mp.messaging.incoming.<channel-name>` and `mp.messaging.outgoing.<channel-name>` configuration properties."
msgstr "チャネル属性は、`mp.messaging.incoming.<channel-name>` および `mp.messaging.outgoing.<channel-name>` 設定プロパティーを使用して設定できます。"

#: _guides/messaging.adoc
msgid "For example, to configure the Kafka connector to consume messages from the `my-topic` topic with a custom deserializer:"
msgstr "たとえば、カスタムデシリアライザーを使用して `my-topic` トピックからのメッセージを消費するように Kafka コネクターを設定するには、以下のようにします。"

#: _guides/messaging.adoc
msgid ""
"The `connector` attribute is required for all channels and specifies the connector to use.\n"
"You can omit this configuration if you have a single connector on your classpath, as Quarkus will automatically select the connector."
msgstr ""
"`connector` 属性はすべてのチャネルに必須であり、使用するコネクターを指定します。\n"
"クラスパスにコネクターが 1 つしかない場合は、Quarkus が自動的にコネクターを選択するため、この設定を省略できます。"

#: _guides/messaging.adoc
msgid "Global channel attributes can be configured using the connector name:"
msgstr "グローバルチャネル属性は、コネクター名を使用して設定できます。"

#: _guides/messaging.adoc
msgid "Connector-specific attributes are listed in connector documentation."
msgstr "コネクター固有の属性は、コネクターのドキュメントに記載されています。"

#: _guides/messaging.adoc
msgid "Channel wiring and Messaging patterns"
msgstr "チャネルワイヤリングとメッセージングパターン"

#: _guides/messaging.adoc
msgid ""
"At startup time, Quarkus analyzes declared channels to wire them together and verify that all channels are connected.\n"
"Concretely, each channel creates a _reactive stream_ of messages connected to another channel's _reactive stream_ of messages.\n"
"Adhering to the reactive stream protocol, the back-pressure mechanism is enforced between channels, allowing to control application resource usage and not over-commit and overloading part of the system."
msgstr ""
"起動時に、Quarkus は宣言されたチャネルを分析してそれらをワイヤリングし、すべてのチャネルが接続されていることを確認します。\n"
"具体的には、各チャネルは、別のチャネルのメッセージの _リアクティブストリーム_ に接続されたメッセージの _リアクティブストリーム_ を作成します。\n"
"リアクティブストリームプロトコルに準拠し、チャネル間でバックプレッシャーメカニズムが適用され、アプリケーションリソースの使用を制御し、過剰なコミットやシステムの一部への過負荷を防ぐことができます。"

#: _guides/messaging.adoc
msgid ""
"On the flip side it is NOT possible to create new channels programmatically at runtime.\n"
"There are, however, many patterns that let you implement most, if not all, messaging and integration use cases:"
msgstr ""
"その一方で、実行時にプログラムで新しいチャネルを作成することはできません。\n"
"ただし、すべてではないにしても、ほとんどのメッセージングおよびインテグレーションユースケースを実装できるパターンは多数あります。"

#: _guides/messaging.adoc
msgid ""
"Some messaging technologies allow consumers to subscribe to a set of topics or queues, and producers to send messages to a specific topic on message basis.\n"
"If you are sure you need to configure and create clients dynamically at runtime, you should consider using the low-level clients directly."
msgstr ""
"一部のメッセージングテクノロジーでは、コンシューマーがトピックまたはキューのセットをサブスクライブし、プロデューサーがメッセージベースで特定のトピックにメッセージを送信できます。\n"
"実行時にクライアントを動的に設定および作成する必要があることが確実な場合は、低レベルのクライアントを直接使用することを検討する必要があります。"

#: _guides/messaging.adoc
msgid "Internal Channels"
msgstr "内部チャネル"

#: _guides/messaging.adoc
msgid ""
"In some use cases, it is convenient to use messaging patterns to transfer messages inside the same application.\n"
"When you don't connect a channel to a messaging backend, i.e. a connector, everything happens internally to the application,\n"
"and the streams are created by chaining methods together.\n"
"Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr ""
"ユースケースによっては、メッセージングパターンを使用して同じアプリケーション内でメッセージを転送すると便利です。\n"
"チャネルをメッセージングバックエンド、つまりコネクターに接続しない場合は、すべてがアプリケーション内部で行われます。\n"
"そして、ストリームはメソッドを連鎖することで作成されます。\n"
"各チェーンは引き続きリアクティブストリームで、バックプレッシャープロトコルが適用されます。"

#: _guides/messaging.adoc
msgid ""
"The framework verifies that the producer/consumer chain is complete,\n"
"meaning that if the application writes messages into an internal channel (using a method with only `@Outgoing`, or an `Emitter`),\n"
"it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr ""
"フレームワークは、プロデューサー/コンシューマーチェーンが完全であることを確認します。\n"
"つまり、アプリケーションがメッセージをインターナルチャネルに書き込む場合 (`@Outgoing` のみを持つメソッド、または `Emitter` を使用)、\n"
"アプリケーション内からメッセージを消費する必要もあります (`@Incoming` のみを持つメソッド、またはアンマネージドストリームを使用)。"

#: _guides/messaging.adoc
msgid "Enable/Disable channels"
msgstr "チャネルを有効化/無効化"

#: _guides/messaging.adoc
msgid "All defined channels are enabled by default, but it is possible to disable a channel with the configuration:"
msgstr "定義されたすべてのチャネルはデフォルトで有効化されていますが、以下の設定でチャネルを無効化することもできます。"

#: _guides/messaging.adoc
msgid ""
"This can be used alongside Quarkus build profiles to enable/disable channels based on some build-time condition, such as the the target environment.\n"
"You need to make sure of two things when disabling a channel:"
msgstr ""
"これを Quarkus ビルドプロファイルと一緒に使用して、ターゲット環境などのビルド時の条件に基づいてチャネルを有効化/無効化することができます。\n"
"チャネルを無効化するときは、以下の 2 つの点を確認する必要があります。"

#: _guides/messaging.adoc
msgid "the disabled channel usage is located in a bean that can be filtered out at build time,"
msgstr "無効化されたチャネルの使用方法が、ビルド時にフィルタリングできる Bean 内に設定されていること。"

#: _guides/messaging.adoc
msgid "that without the channel, the remaining channels still work correctly."
msgstr "このチャネルがなくても、残りのチャネルが引き続き正常に動作すること。"

#: _guides/messaging.adoc
msgid "Pausable Channels"
msgstr "一時停止可能なチャネル"

#: _guides/messaging.adoc
msgid ""
"Injected `@Channel` streams are not subscribed to by default, so the flow of messages is controlled by the application code using reactive streams and Mutiny APIs.\n"
"But for `@Incoming` methods, the flow of messages is controlled by the runtime."
msgstr ""
"注入された `@Channel` ストリームはデフォルトではサブスクライブされないため、メッセージのフローはリアクティブストリームと Mutiny API を使用してアプリケーションコードによって制御されます。\n"
"ただし、`@Incoming` メソッドの場合、メッセージのフローはランタイムによって制御されます。"

#: _guides/messaging.adoc
msgid ""
"Pausable channels provide a mechanism to control message flow programmatically.\n"
"This is useful in scenarios where producers or consumers need to stop temporarily due to managing the lifecycle or performing maintenance operations."
msgstr ""
"一時停止可能なチャネルは、メッセージフローをプログラムで制御するメカニズムを提供します。\n"
"これは、ライフサイクルの管理やメンテナンス操作の実行のために、プロデューサーまたはコンシューマーが一時的に停止する必要がある場合に役立ちます。"

#: _guides/messaging.adoc
msgid "To use pausable channels, you need to activate it with the configuration property `pausable` set to `true`."
msgstr "一時停止可能なチャネルを使用するには、設定プロパティー `pausable` を `true` に設定してアクティブ化する必要があります。"

#: _guides/messaging.adoc
msgid "If a channel is configured to be pausable, you can get the `PausableChannel` by channel name from the `ChannelRegistry` programmatically, and pause or resume the channel as needed:"
msgstr "チャネルが一時停止可能に設定されている場合は、プログラにより `ChannelRegistry` からチャネル名で `PausableChannel` を取得し、必要に応じてチャネルを一時停止または再開できます。"

#: _guides/messaging.adoc
msgid ""
"This feature is independent of connectors and can be in theory used with channels backed by any connector.\n"
"Note that pausing message consumption applies back-pressure on the underlying consumer which receives messages from the remote broker."
msgstr ""
"この機能はコネクターに依存しておらず、理論的には任意のコネクターをベースとするチャネルで使用できます。\n"
"メッセージの消費を一時停止すると、リモートブローカーからメッセージを受信する基礎となるコンシューマーにバックプレッシャーが適用されることに注意してください。"

#: _guides/messaging.adoc
msgid ""
"Kafka consumers provide a similar feature to pause and resume the consumption of messages from topic-partitions.\n"
"The Quarkus Kafka connector allows xref:kafka.adoc#kafka-bare-clients[access to the underlying client] to pause/resume the consumption."
msgstr ""
"Kafka コンシューマーは、トピックパーティションからのメッセージの消費を一時停止および再開するための同様の機能を提供します。\n"
"Quarkus Kafka コネクターを使用すると、xref:kafka.adoc#kafka-bare-clients[基盤となるクライアントにアクセス] して消費を一時停止/再開できます。"

#: _guides/messaging.adoc
msgid ""
"However, by default, with the `pause-if-no-requests=true` configuration,\n"
"the connector handles automatically the back-pressure,\n"
"by the pausing and resuming the Kafka consumer based on downstream requests.\n"
"It is therefore recommended to use pausable channels with the default `pause-if-no-requests=true` configuration."
msgstr ""
"ただし、デフォルトでは、`pause-if-no-requests=true` 設定により、コネクターはダウンストリームのリクエストに基づいて Kafka コンシューマーを一時停止および再開し、自動的にバックプレッシャーを処理します。\n"
"したがって、デフォルトの `pause-if-no-requests=true` 設定で一時停止可能なチャネルを使用することを推奨します。"

#: _guides/messaging.adoc
msgid "Multiple Outgoings and `@Broadcast`"
msgstr "Multiple Outgoings と `@Broadcast`"

#: _guides/messaging.adoc
msgid ""
"By default, messages transmitted in a channel are only dispatched to a single consumer.\n"
"Having multiple consumers is considered an error and is reported at deployment time."
msgstr ""
"デフォルトでは、チャネルで送信されるメッセージは単一のコンシューマーにのみディスパッチされます。\n"
"複数のコンシューマーが存在するとエラーとみなされ、デプロイメント時に報告されます。"

#: _guides/messaging.adoc
msgid ""
"The `@Broadcast` annotation changes this behavior and indicates that messages transiting in the channel are dispatched to all the consumers.\n"
"`@Broadcast` must be used with the `@Outgoing` annotation:"
msgstr ""
"`@Broadcast` アノテーションはこの動作を変更し、チャネルを通過するメッセージがすべてのコンシューマーにディスパッチされることを示します。\n"
"`@Broadcast` は `@Outgoing` アノテーションと一緒に使用する必要があります。"

#: _guides/messaging.adoc
msgid "Similarly to `@Broadcast`, you can use `@Outgoing` annotation multiple times on the same method to indicate that the method produces messages to multiple channels:"
msgstr "`@Broadcast` と同様に、同じメソッドで `@Outgoing` アノテーションを複数回使用して、このメソッドが複数のチャネルにメッセージを生成することを示すことができます。"

#: _guides/messaging.adoc
msgid "Using Multiple Outgoings can be useful for implementing fan-out patterns, in which a single message is processed by multiple target channels."
msgstr "Multiple Outgoings を使用すると、単一のメッセージが複数のターゲットチャネルによって処理されるファンアウトパターンを実装する場合に役立ちます。"

#: _guides/messaging.adoc
msgid "You can selectively dispatch messages to multiple outgoings by returning `Targeted` from the processing method:"
msgstr "処理メソッドから `Targeted` を返すことで、メッセージを複数の送信先に選択的にディスパッチできます。"

#: _guides/messaging.adoc
msgid "Multiple Incomings and `@Merge`"
msgstr "Multiple Incomings と `@Merge`"

#: _guides/messaging.adoc
msgid ""
"By default, a single producer can transmit messages in a channel.\n"
"Having multiple producers is considered erroneous and is reported at deployment time.\n"
"The `@Merge` annotation changes this behavior and indicates that a channel can have multiple producers.\n"
"`@Merge` must be used with the `@Incoming` annotation:"
msgstr ""
"デフォルトでは、単一のプロデューサーがチャネル内でメッセージを送信できます。\n"
"複数のプロデューサーが存在するとエラーとみなされ、デプロイメント時に報告されます。\n"
"`@Merge` アノテーションはこの動作を変更し、チャネルに複数のプロデューサーが存在する可能性があることを示します。\n"
"`@Merge` は `@Incoming` アノテーションと一緒に使用する必要があります。"

#: _guides/messaging.adoc
msgid "Similarly to `@Merge`, you can use `@Incoming` annotation multiple times on the same method to indicate that the method consumes messages from multiple channels:"
msgstr "`@Merge` と同様に、同じメソッドで `@Incoming` アノテーションを複数回使用して、メソッドが複数のチャネルからのメッセージを消費することを示すことができます。"

#: _guides/messaging.adoc
msgid "Stream Processing"
msgstr "ストリーム処理"

#: _guides/messaging.adoc
msgid "In some advanced scenarios, you can manipulate directly the stream of messages instead of each individual message."
msgstr "一部の高度なシナリオでは、個々のメッセージではなく、メッセージのストリームを直接操作できます。"

#: _guides/messaging.adoc
msgid "Using link:{mutiny}[Mutiny APIs] in incoming and outgoing signatures allow you to process the stream of messages:"
msgstr "着信署名と発信署名でリンク:{mutiny}[Mutiny APIs] を使用すると、メッセージのストリームを処理できます。"

#: _guides/messaging.adoc
msgid "Execution Model"
msgstr "実行モデル"

#: _guides/messaging.adoc
msgid ""
"Quarkus Messaging sits on top of the xref:quarkus-reactive-architecture.adoc#engine[reactive engine] of Quarkus and leverages link:{eclipse-vertx}[Eclipse Vert.x] to dispatch messages for processing.\n"
"It supports three execution modes:"
msgstr ""
"Quarkus Messaging は、Quarkus の xref:quarkus-reactive-architecture.adoc#engine[リアクティブエンジン] の上に配置され、リンク:{eclipse-vertx}[Eclipse Vert.x] を活用して処理用にメッセージをディスパッチします。\n"
"以下の 3 つの実行モードをサポートしています。"

#: _guides/messaging.adoc
msgid ""
"*Event-loop*, where messages are dispatched on the Vert.x I/O thread.\n"
"Remember that you should not perform blocking operations on the event loop."
msgstr ""
"*イベントループ*: メッセージが Vert.x I/O スレッドにディスパッチされます。\n"
"イベントループではブロッキング操作を実行しないでください。"

#: _guides/messaging.adoc
msgid "*Worker-threads*, where messages are dispatched on a worker thread pool."
msgstr "*ワーカースレッド*: メッセージはワーカースレッドプールにディスパッチされます。"

#: _guides/messaging.adoc
msgid ""
"*Virtual-threads*, where messages are dispatched on a virtual thread (requires Java 21+).\n"
"As virtual threads are not pooled, a new virtual thread is created for each message.\n"
"Please refer to the dedicated xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support] guide for more information."
msgstr ""
"*仮想スレッド*: メッセージは仮想スレッドにディスパッチされます (Java 21 以降が必要です)。\n"
"仮想スレッドはプールされないため、メッセージごとに新しい仮想スレッドが作成されます。\n"
"詳細は、専用の xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread サポート] ガイドを参照してください。"

#: _guides/messaging.adoc
msgid ""
"Quarkus chooses the default execution mode based on the method signature.\n"
"If the method signature is _synchronous_, messages are dispatched on *worker threads* otherwise it defaults to *event-loop*:"
msgstr ""
"Quarkus はメソッド署名に基づいてデフォルトの実行モードを選択します。\n"
"メソッド署名が _synchronous_ の場合、メッセージは *ワーカースレッド* にディスパッチされ、それ以外の場合はデフォルトで *イベントループ* にディスパッチされます。"

#: _guides/messaging.adoc
msgid "Method signature"
msgstr "メソッド署名"

#: _guides/messaging.adoc
msgid "Default execution mode"
msgstr "デフォルトの実行モード"

#: _guides/messaging.adoc
msgid ""
"@Incoming(\"source\")\n"
"void process(String payload)"
msgstr ""
"@Incoming(\"source\")\n"
"void process(String payload)"

#: _guides/messaging.adoc
msgid "Worker-threads"
msgstr "ワークスレッド"

#: _guides/messaging.adoc
msgid ""
"@Incoming(\"source\")\n"
"Uni<Void> process(String payload)"
msgstr ""
"@Incoming(\"source\")\n"
"Uni<Void> process(String payload)"

#: _guides/messaging.adoc
msgid "Event-loop"
msgstr "イベントループ"

#: _guides/messaging.adoc
msgid ""
"@Incoming(\"source\")\n"
"CompletionStage<Void> process(Message<String> message)"
msgstr ""
"@Incoming(\"source\")\n"
"CompletionStage<Void> process(Message<String> message)"

#: _guides/messaging.adoc
msgid ""
"@Incoming(\"source\")\n"
"@Outgoing(\"sink\")\n"
"Multi<R> process(Multi<T> in)"
msgstr ""
"@Incoming(\"source\")\n"
"@Outgoing(\"sink\")\n"
"Multi<R> process(Multi<T> in)"

#: _guides/messaging.adoc
msgid "Stream-processing methods are executed at startup, then each message is dispatched on event loop."
msgstr "ストリーム処理メソッドは起動時に実行され、各メッセージはイベントループにディスパッチされます。"

#: _guides/messaging.adoc
msgid "Fine-grained control over the execution model is possible using annotations:"
msgstr "アノテーションを使用すると、実行モデルを細かく制御できます。"

#: _guides/messaging.adoc
msgid ""
"link:{rm_blocking_annotation}[`@Blocking`] will force the method to be executed on a worker thread pool.\n"
"The default pool of worker threads is shared between all channels.\n"
"Using `@Blocking(\"my-custom-pool\")` you can configure channels with a custom thread pool.\n"
"The configuration property `smallrye.messaging.worker.my-custom-pool.max-concurrency` specifies the maximum number of threads in the pool.\n"
"You can read more on the blocking processing in link:{rm_blocking_docs}[SmallRye Reactive Messaging documentation]."
msgstr ""
"リンク:{rm_blocking_annotation} [`@Blocking`] は、メソッドをワーカースレッドプールで強制的に実行します。\n"
"ワーカースレッドのデフォルトプールは、すべてのチャネル間で共有されます。\n"
"`@Blocking(\"my-custom-pool\")` を使用すると、カスタムスレッドプールを使用してチャネルを設定できます。\n"
"設定プロパティー `smallrye.messaging.worker.my-custom-pool.max-concurrency` は、プール内のスレッドの最大数を指定します。\n"
"ブロッキング処理の詳細は、リンク:{rm_blocking_docs}[SmallRye Reactive Messaging のドキュメント] を参照してください。"

#: _guides/messaging.adoc
msgid "`@NonBlocking` will force the method to be executed on the event-loop thread."
msgstr "`@NonBlocking` は、メソッドをイベントループスレッドで強制的に実行します。"

#: _guides/messaging.adoc
msgid ""
"`@RunOnVirtualThread` will force the method to be executed on a virtual thread.\n"
"To leverage the lightweight nature of virtual threads, the default maximum concurrency for methods annotated with `@RunOnVirtualThread` is 1024.\n"
"This can be changed by setting the `smallrye.messaging.worker.<virtual-thread>.max-concurrency` configuration property\n"
"or using together with the `@Blocking(\"my-custom-pool\")` annotation."
msgstr ""
"`@RunOnVirtualThread` は、メソッドを仮想スレッド上で強制的に実行します。\n"
"仮想スレッドの軽量な性質を活用するために、`@RunOnVirtualThread` アノテーションが付けられたメソッドのデフォルトの最大同時実行数は 1024 です。\n"
"これは、`smallrye.messaging.worker.<virtual-thread>.max-concurrency` 設定プロパティーを設定することで変更できます。\n"
"または、`@Blocking(\"my-custom-pool\")` アノテーションと一緒に使用することで変更できます。"

#: _guides/messaging.adoc
msgid "The presence of `@Transactional` annotation implies blocking execution."
msgstr "`@Transactional` アノテーションの存在は、実行をブロックすることを意味します。"

#: _guides/messaging.adoc
msgid ""
"In messaging applications, produced and consumed messages constitute an ordered stream of events,\n"
"either enforced by the broker (inside a topic or a queue)\n"
"or by the order of reception and emission in the application.\n"
"To preserve this order, Quarkus Messaging dispatches messages sequentially by default.\n"
"You can override this behavior by using `@Blocking(ordered = false)` or `@RunOnVirtualThread` annotation."
msgstr ""
"メッセージングアプリケーションでは、生成および消費されるメッセージは順序付けられたイベントのストリームを構成します。\n"
"これは、(トピックまたはキュー内に) ブローカーによって強制されるか、\n"
"アプリケーションの受付および発行の順序によって強制されます。\n"
"この順序を維持するために、Quarkus Messaging はデフォルトでメッセージを順番にディスパッチします。\n"
"`@Blocking(ordered = false)`または `@RunOnVirtualThread` アノテーションを使用して、この動作をオーバーライドできます。"

#: _guides/messaging.adoc
msgid "Incoming Channel Concurrency"
msgstr "着信チャネルの同時実行"

#: _guides/messaging.adoc
msgid "Some connectors support configuring the concurrency level of incoming channels."
msgstr "一部のコネクターは、着信チャネルの同時実行レベルの設定をサポートしています。"

#: _guides/messaging.adoc
msgid ""
"This creates four copies of the incoming channel under the hood, wiring them to the same processing method.\n"
"Depending on the broker technology, this can be useful to increase the application's throughput by processing multiple messages concurrently\n"
"while still preserving the partial order of messages received in different copies.\n"
"This is the case, for example, for Kafka, where multiple consumers can consume different topic partitions."
msgstr ""
"これにより、内部的に着信チャネルのコピーが 4 つ作成され、同じ処理方法にワイヤリングされます。\n"
"これは、ブローカーテクノロジーによっては、異なるコピーで受信されたメッセージの部分的な順序を保持したまま、\n"
"複数のメッセージを同時に処理することでアプリケーションのスループットを向上させる際に役立つ場合があります。\n"
"たとえば、複数のコンシューマーが異なるトピックパーティションを消費できる Kafka の場合がこれに該当します。"

#: _guides/messaging.adoc
msgid "Context Propagation"
msgstr "コンテキストの伝搬"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"In Quarkus Messaging, the default mechanism for propagating context between different processing stages is the\n"
"link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/message-context[message context].\n"
"This provides a consistent way to pass context information along with the message as it flows through different stages."
msgstr "Quarkus Messagingでは、異なる処理ステージ間でコンテキストを伝達するデフォルトのメカニズムは link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/message-context[メッセージコンテキスト] です。これは、異なるステージを流れるメッセージと共にコンテキスト情報を渡す一貫した方法を提供します。"

#: _guides/messaging.adoc
#, fuzzy
msgid "When integrating with other extensions, notably using Emitters, it relies on the Mutiny context propagation:"
msgstr "他のエクステンションと統合する場合、特に Emitters を使用する場合は、Mutiny コンテキスト伝搬に依存します："

#: _guides/messaging.adoc
#, fuzzy
msgid "Interaction with Mutiny and MicroProfile Context Propagation"
msgstr "Mutinyとの相互作用とMicroProfileコンテキストの伝播"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"Mutiny, which is the foundation of reactive programming in Quarkus, is integrated with the MicroProfile Context Propagation.\n"
"This integration enables automatic capturing and restoring of context across asynchronous boundaries.\n"
"To learn more about context propagation in Quarkus and Mutiny, refer to the xref:context-propagation.adoc[Context Propagation] guide."
msgstr "Quarkusのリアクティブプログラミングの基盤であるMutinyは、MicroProfile Context Propagationと統合されています。この統合により、非同期の境界をまたいだコンテキストの自動取得と復元が可能になります。QuarkusとMutinyのコンテキストプロパゲーションの詳細については、 xref:context-propagation.adoc[コンテキストプロパゲーションガイドを] 参照してください。"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"To ensure consistent behavior, Quarkus Messaging disables the propagation of any context during message dispatching through inbound or outbound connectors.\n"
"This means that context captured through Emitters won't be propagated to the outgoing channel, and incoming channels won't dispatch messages by activating a context (e.g. the request context).\n"
"This behaviour can be configured using `quarkus.messaging.connector-context-propagation` configuration property, by listing the context types to propagate.\n"
"For example `quarkus.messaging.connector-context-propagation=CDI` will only propagate the CDI context."
msgstr "一貫した動作を保証するため、Quarkus Messagingでは、受信コネクターまたは送信コネクターを介したメッセージのディスパッチ中にコンテキストが伝搬されることはありません。つまり、エミッタでキャプチャされたコンテキストは送信チャネルに伝搬されず、受信チャネルはコンテキスト（リクエストコンテキストなど）をアクティブにしてメッセージをディスパッチしません。この振る舞いは `quarkus.messaging.connector-context-propagation` の設定プロパティで設定することができます。たとえば `quarkus.messaging.connector-context-propagation=CDI` は CDI コンテキストのみを伝搬します。"

#: _guides/messaging.adoc
#, fuzzy
msgid "Context Propagation with Emitters"
msgstr "エミッタによるコンテキスト伝播"

#: _guides/messaging.adoc
#, fuzzy
msgid "When using messaging emitters, the context is not propagated by default."
msgstr "メッセージングエミッタを使用する場合、デフォルトではコンテキストは伝搬されません。"

#: _guides/messaging.adoc
#, fuzzy
msgid "In some scenarios, you might want to propagate the caller context to the message processing stage, using <<internal-channels,internal channels>>."
msgstr "シナリオによっては、 xref:internal-channels[内部チャネルを] 使用して、呼び出し元コンテキストをメッセージ処理ステージに伝搬させたい場合があります。"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus provides `ContextualEmitter`, a drop in replacement for `MutinyEmitter` and `Emitter`, that allows you to propagate the context when sending messages.\n"
"You can use the context propagation annotation `@CurrentThreadContext` to configure the contexts that will be propagated from an _emitter_ method.\n"
"The annotation configures the contexts that will be captured and propagated from that method,\n"
"and needs to be present on the propagator method, i.e. the caller of the emitter, not the processing method."
msgstr "Quarkusには、 `MutinyEmitter` と `Emitter` の代替となる `ContextualEmitter` が用意されており、メッセージ送信時にコンテキストを伝播することができます。コンテキスト伝播アノテーション `@CurrentThreadContext` を使用すると、 _エミッタ・_ メソッドから伝播されるコンテキストを設定できます。このアノテーションは、そのメソッドから取り込まれて伝搬されるコンテキストを構成し、伝搬メソッド、つまり処理メソッドではなくエミッタの呼び出し側に存在する必要があります。"

#: _guides/messaging.adoc
#, fuzzy
msgid "Let `RequestScopedBean` a request-scoped bean, `ContextualEmitter` can be used to dispatch messages locally through the internal channel `app`:"
msgstr "`RequestScopedBean` をリクエスト・スコープされたビーンとすると、 `ContextualEmitter` は内部チャネル `app` を通してローカルにメッセージをディスパッチするために使用することができます："

#: _guides/messaging.adoc
#, fuzzy
msgid "Then the request-scoped bean can be accessed in the message processing stage, regardless of the <<execution_model>>:"
msgstr "そして， <<execution_model>> に関係なく，要求スコープのBeanはメッセージ処理段階でアクセスできます："

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"You can also use the `@CurrentThreadContext` annotation to control which contexts are propagated.\n"
"The following example shows how to avoid propagating any context to the message processing stage:"
msgstr "`@CurrentThreadContext` アノテーションを使用して、伝播されるコンテキストを制御することもできます。以下の例では、メッセージ処理ステージへのコンテキスト伝搬を回避する方法を示します："

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"The execution context to which the RequestScoped context is bound, in the previous example the REST call, controls the lifecycle of the context.\n"
"This means that when the REST call is completed the RequestScoped context is destroyed.\n"
"Therefore, you need to make sure that your processing or message dispatch is completed before the REST call completes."
msgstr "RequestScopedコンテキストがバインドされている実行コンテキスト（前述の例ではREST呼び出し）は、コンテキストのライフサイクルを制御します。つまり、REST呼び出しが完了すると、RequestScopedコンテキストは破棄されます。したがって、REST呼び出しが完了する前に、処理またはメッセージディスパッチが完了していることを確認する必要があります。"

#: _guides/messaging.adoc
#, fuzzy
msgid "For more information check the xref:context-propagation.adoc#context-propagation-for-cdi[Context Propagation] guide."
msgstr "詳しくは xref:context-propagation.adoc#context-propagation-for-cdi[Context Propagation] ガイドをご覧ください。"

#: _guides/messaging.adoc
#, fuzzy
msgid "Request Context Activation"
msgstr "コンテキストのアクティブ化を要求"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"In some cases, you might need to activate the request context while processing messages consumed from a broker.\n"
"While using `@ActivateRequestContext` on the `@Incoming` method is an option, its lifecycle does not follow that of a Quarkus Messaging message.\n"
"For incoming channels, you can enable the request scope activation with the build time property `quarkus.messaging.request-scoped.enabled=true`.\n"
"This will activate the request context for each message processed by incoming channels, and close the context once the message is processed."
msgstr "場合によっては、ブローカーから消費されたメッセージの処理中にリクエストコンテキストをアクティブにする必要があるかもしれません。 `@Incoming` メソッドで `@ActivateRequestContext` を使用することはオプションですが、そのライフサイクルは Quarkus メッセージングメッセージのライフサイクルには従いません。受信チャネルの場合、ビルドタイムプロパティ `quarkus.messaging.request-scoped.enabled=true` でリクエストスコープのアクティブ化を有効にできます。これにより、受信チャンネルで処理されるメッセージごとにリクエストコンテキストがアクティブになり、メッセージが処理されるとコンテキストが閉じられます。"

#: _guides/messaging.adoc
msgid "Health Checks"
msgstr "ヘルスチェック"

#: _guides/messaging.adoc
msgid ""
"Together with the SmallRye Health extension, Quarkus Messaging extensions provide health check support per channel.\n"
"The implementation of _startup_, _readiness_ and _liveness_ checks depends on the connector.\n"
"Some connectors allow configuring the health check behavior or disabling them completely or per channel."
msgstr ""
"Quarkus Messaging エクステンションは、SmallRye Health エクステンションと組み合わせることで、チャネルごとにヘルスチェックのサポートを提供します。\n"
"_startup_、_readiness_、および _liveness_ チェックの実装はコネクターによって異なります。\n"
"一部のコネクターでは、ヘルスチェックの動作を設定したり、完全にまたはチャネルごとに無効にしたりできます。"

#: _guides/messaging.adoc
msgid ""
"Channel health checks can be disabled using `quarkus.messaging.health.<channel-name>.enabled` or per health check type,\n"
"ex. `quarkus.messaging.health.<channel-name>.liveness.enabled`."
msgstr ""
"チャネルのヘルスチェックは、`quarkus.messaging.health.<channel-name>.enabled` を使用して無効化できます。またはヘルスチェックタイプごとに無効化できます。\n"
"(例: `quarkus.messaging.health.<channel-name>.liveness.enabled`)"

#: _guides/messaging.adoc
msgid "Setting the `quarkus.messaging.health.enabled` configuration property to `false` completely disables the messaging health checks."
msgstr "`quarkus.messaging.health.enabled` 設定プロパティーを `false` に設定すると、メッセージングのヘルスチェックが完全に無効になります。"

#: _guides/messaging.adoc
msgid "Observability"
msgstr "オブザーバビリティ"

#: _guides/messaging.adoc
msgid "Micrometer Metrics"
msgstr "Micrometer メトリクス"

#: _guides/messaging.adoc
msgid ""
"Quarkus Messaging extensions provide simple but useful metrics to monitor the health of the messaging system.\n"
"The xref:telemetry-micrometer.adoc[Micrometer extension] exposes these metrics."
msgstr ""
"Quarkus Messaging エクステンションは、メッセージングシステムのヘルスを監視するためのシンプルかつ便利なメトリクスを提供します。\n"
"xref:telemetry-micrometer.adoc[Micrometer エクステンション] はこれらのメトリクスを公開します。"

#: _guides/messaging.adoc
msgid "The following metrics can be gathered per channel, identified with the `channel` tag:"
msgstr "`channel` タグで識別されるチャネルごとに、以下のメトリクスを収集できます。"

#: _guides/messaging.adoc
msgid "`quarkus.messaging.message.count` : The number of messages produced or received"
msgstr "`quarkus.messaging.message.count` : 生成または受信したメッセージの数"

#: _guides/messaging.adoc
msgid "`quarkus.messaging.message.acks` : The number of messages processed successfully"
msgstr "`quarkus.messaging.message.acks` : 正常に処理されたメッセージの数"

#: _guides/messaging.adoc
msgid "`quarkus.messaging.message.failures` : The number of messages processed with failures"
msgstr "`quarkus.messaging.message.failures` : 処理に失敗したメッセージの数"

#: _guides/messaging.adoc
msgid "`quarkus.messaging.message.duration` : The duration of the message processing"
msgstr "`quarkus.messaging.message.duration` : メッセージの処理時間"

#: _guides/messaging.adoc
msgid "For backwards compatibility reasons, channel metrics are not enabled by default and can be enabled with: `smallrye.messaging.observation.enabled=true`."
msgstr "下位互換性のため、チャネルメトリクスはデフォルトでは有効化されていませんが、`smallrye.messaging.observation.enabled=true` で有効化することができます。"

#: _guides/messaging.adoc
msgid "OpenTelemetry Tracing"
msgstr "OpenTelemetry トレース"

#: _guides/messaging.adoc
msgid ""
"Some Quarkus Messaging connectors integrate out-of-the-box with OpenTelemetry Tracing.\n"
"When the xref:opentelemetry.adoc[OpenTelemetry extension] is present, outgoing messages propagate the current tracing span.\n"
"On incoming channels, if a received message contains tracing information, the message processing inherits the message span as parent."
msgstr ""
"一部の Quarkus Messaging コネクターは、OpenTelemetry Tracing とすぐに統合されます。\n"
"xref:opentelemetry.adoc[OpenTelemetry エクステンション] が存在する場合、発信メッセージは現在のトレース範囲を伝播します。\n"
"着信チャネルでは、受信したメッセージにトレース情報が含まれている場合、メッセージ処理はメッセージスパンを親として継承します。"

#: _guides/messaging.adoc
msgid "You can disable tracing for a specific channel using the following configuration:"
msgstr "次の設定を使用して、特定のチャネルのトレースを無効にすることができます。"

#: _guides/messaging.adoc
msgid "TLS Configuration"
msgstr "TLS 設定"

#: _guides/messaging.adoc
msgid ""
"Some messaging extensions integrate with the xref:./tls-registry-reference.adoc[Quarkus TLS Registry] to configure the underlying client.\n"
"To configure the TLS on a channel, you need to provide the named TLS configuration to the `tls-configuration-name` property:"
msgstr ""
"一部のメッセージングエクステンションは、xref:./tls-registry-reference.adoc[Quarkus TLS レジストリー] と統合して、基盤となるクライアントを設定します。\n"
"チャネルで TLS を設定するには、`tls-configuration-name` プロパティーに名前付き TLS 設定を指定する必要があります。"

#: _guides/messaging.adoc
msgid "Or you can configure it globally on all channels of a connector:"
msgstr "または、コネクターのすべてのチャネルでグローバルに設定することもできます。"

#: _guides/messaging.adoc
msgid "Currently, the following messaging extensions support configuration through the Quarkus TLS Registry:"
msgstr "現在、次のメッセージングエクステンションは、Quarkus TLS レジストリーを介した設定をサポートしています。"

#: _guides/messaging.adoc
msgid "Kafka: Provides the `ssl.engine.factory.class` property for the Kafka client."
msgstr "Kafka: Kafka クライアントに `ssl.engine.factory.class` プロパティーを提供します。"

#: _guides/messaging.adoc
msgid "Pulsar: Only mTLS authentication is supported."
msgstr "Pulsar: mTLS 認証のみがサポートされます。"

#: _guides/messaging.adoc
msgid "RabbitMQ"
msgstr "RabbitMQ"

#: _guides/messaging.adoc
msgid "AMQP 1.0"
msgstr "AMQP 1.0"

#: _guides/messaging.adoc
msgid "MQTT"
msgstr "MQTT"

#: _guides/messaging.adoc
msgid "Testing"
msgstr "テスト"

#: _guides/messaging.adoc
msgid "Testing with Dev Services"
msgstr "Dev Services を使用したテスト"

#: _guides/messaging.adoc
msgid ""
"Most Quarkus Messaging extensions provide a Dev Service to simplify the development and testing of applications.\n"
"The Dev Service creates a broker instance configured to work out-of-the-box with the Quarkus Messaging extension."
msgstr ""
"ほとんどの Quarkus Messaging エクステンションは、アプリケーションの開発とテストを簡素化する Dev Service を提供します。\n"
"Dev Service は、Quarkus Messaging エクステンションですぐに使用できるように設定されたブローカーインスタンスを作成します。"

#: _guides/messaging.adoc
msgid "During testing Quarkus creates a separate broker instance to run the tests against it."
msgstr "Quarkus はテスト中、別のブローカーインスタンスを作成し、これに対してテストを実行します。"

#: _guides/messaging.adoc
msgid "You can read more about Dev Services in the xref:dev-services.adoc[Dev Services] guide, including a list of Dev Services provided by platform extensions."
msgstr "プラットフォームエクステンションによって提供される Dev Services のリストを含む Dev Services の詳細は、xref:dev-services.adoc[Dev Services] ガイドを参照してください。"

#: _guides/messaging.adoc
msgid "Testing with InMemoryConnector"
msgstr "InMemoryConnector を使用したテスト"

#: _guides/messaging.adoc
msgid ""
"It can be useful to test the application without starting a broker.\n"
"To achieve this, you can _switch_ the channels managed by a connector to _in-memory_."
msgstr ""
"ブローカーを起動せずにアプリケーションをテストすると便利です。\n"
"これを実現するには、コネクターで管理しているチャンネルを _in-memory_ に _切り替え_ できます。"

#: _guides/messaging.adoc
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。"

#: _guides/messaging.adoc
msgid "Let's say we want to test the following sample application:"
msgstr "以下のサンプルアプリケーションをテストするとします。"

#: _guides/messaging.adoc
msgid "First, add the following test dependency to your application:"
msgstr "まず、以下のテスト依存関係をアプリケーションに追加します。"

#: _guides/messaging.adoc
msgid "pom.xml"
msgstr "pom.xml"

#: _guides/messaging.adoc
msgid "build.gradle"
msgstr "build.gradle"

#: _guides/messaging.adoc
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "そして、以下のように Quarkus Test Resource を作成します。"

#: _guides/messaging.adoc
msgid "Switch the incoming channel `words-in` (consumed messages) to in-memory."
msgstr "着信チャネルl `words-in` (消費されたメッセージ)  をin-memory に切り替えます。"

#: _guides/messaging.adoc
msgid "Switch the outgoing channel `words-out` (produced messages) to in-memory."
msgstr "発信チャネル `words-out` (生成されたメッセージ) を in-memory に切り替えます。"

#: _guides/messaging.adoc
msgid "Switch the outgoing channel `uppercase` (processed messages) to in-memory."
msgstr "発信チャネル `uppercase` (処理済みメッセージ) を in-memory に切り替えます。"

#: _guides/messaging.adoc
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "in-memory チャネルを使用するためのアプリケーション設定に必要なすべてのプロパティーを含む `Map` をビルドして返します。"

#: _guides/messaging.adoc
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。"

#: _guides/messaging.adoc
msgid "Create a `@QuarkusTest` using the test resource created above:"
msgstr "上記で作成したテストリソースを使用して `@QuarkusTest` を作成します。"

#: _guides/messaging.adoc
msgid "Inject the in-memory connector in your test class, using the `@Connector` or `@Any` qualifier."
msgstr "`@Connector` または `@Any` 修飾子を使用して、テストクラスに in-memory コネクターを注入します。"

#: _guides/messaging.adoc
msgid "Retrieve the outgoing channel (`words-out`) - the channel must have been switched to in-memory in the test resource."
msgstr "発信チャネルの取得 (`words-out`) - テストリソース内でチャネルが in-memory に切り替えられている必要があります。"

#: _guides/messaging.adoc
msgid "Retrieve the incoming channel (`words-in`)"
msgstr "着信チャネルの取得 (`words-in`)"

#: _guides/messaging.adoc
msgid "Retrieve the outgoing channel (`uppercase`)"
msgstr "発信チャネルの取得 (`uppercase`)"

#: _guides/messaging.adoc
msgid "Use the injected application bean to call `sendMessage` method to send a message using the emitter with the channel `words-out`."
msgstr "注入されたアプリケーション Bean を使用して `sendMessage` メソッドを呼び出し、チャネル `words-out` を持つエミッターを使用してメッセージを送信します。"

#: _guides/messaging.adoc
msgid "Use the `received` method on `words-out` in-memory channel to check the message produced by the application."
msgstr "アプリケーションによって生成されたメッセージを確認するには、`words-out` in-memory チャネルの `received` メソッドを使用します。"

#: _guides/messaging.adoc
msgid ""
"Use the `send` mwthod on `words-in` in-memory channel to send a message.\n"
"The application will process this message and send a message to `uppercase` channel."
msgstr ""
"メッセージを送信するには、`words-in` in-memory チャネルの `send` メソッドを使用します。\n"
"アプリケーションはこのメッセージを処理し、`uppercase` チャネルにメッセージを送信します。"

#: _guides/messaging.adoc
msgid "Use the `received` method on `uppercase` channel to check the messages produced by the application."
msgstr "アプリケーションによって生成されたメッセージを確認するには、`uppercase` チャネルの `received` メソッドを使用します。"

#: _guides/messaging.adoc
msgid ""
"In-memory connector is solely intended for testing purposes.\n"
"There are some caveats to consider when using the in-memory connector:"
msgstr ""
"in-memory コネクターはテスト目的のみに使用されます。\n"
"in-memory コネクターを使用する際に考慮すべき注意事項がいくつかあります。"

#: _guides/messaging.adoc
msgid ""
"The in-memory connector only transmits objects (payloads or configured messages) sent using the `InMemorySource#send` method.\n"
"Messages received by the application methods won't contain connector-specific metadata."
msgstr ""
"in-memory コネクターは、`InMemorySource#send` メソッドを使用して送信されたオブジェクト (ペイロードまたは設定されたメッセージ) のみを送信します。\n"
"アプリケーションメソッドによって受信されるメッセージには、コネクター固有のメタデータは含まれません。"

#: _guides/messaging.adoc
msgid ""
"By default, in-memory channels dispatch messages on the caller thread of the `InMemorySource#send` method, which would be the main thread in unit tests.\n"
"However, most of the other connectors handle context propagation dispatching messages on separate duplicated Vert.x contexts."
msgstr ""
"デフォルトでは、in-memory チャネルは、ユニットテストのメインスレッドとなる `InMemorySource#send` メソッドの呼び出し元スレッドでメッセージをディスパッチします。\n"
"ただし、他のほとんどのコネクターは、個別の複製された Vert.x コンテキストでコンテキスト伝播ディスパッチメッセージを処理します。"

#: _guides/messaging.adoc
msgid "The `quarkus-test-vertx` dependency provides the `@io.quarkus.test.vertx.RunOnVertxContext` annotation, which when used on a test method, executes the test on a Vert.x context."
msgstr "`quarkus-test-vertx` 依存関係は `@io.quarkus.test.vertx.RunOnVertxContext` アノテーションを提供します。これをテストメソッドで使用すると、Vert.x コンテキストでテストが実行されます。"

#: _guides/messaging.adoc
msgid ""
"If your tests are dependent on context propagation, you can configure the in-memory connector channels with `run-on-vertx-context` attribute to dispatch events, including messages and acknowledgements, on a Vert.x context.\n"
"Alternatively you can switch this behaviour using the `InMemorySource#runOnVertxContext` method."
msgstr ""
"テストがコンテキストの伝播に依存している場合は、`run-on-vertx-context` 属性を使用して in-memory コネクターチャネルを設定し、メッセージや確認応答などのイベントを Vert.x コンテキストにディスパッチできます。\n"
"あるいは、`InMemorySource#runOnVertxContext` メソッドを使用して、この動作を切り替えることもできます。"

#: _guides/messaging.adoc
msgid "Channel Decorators"
msgstr "チャンネルデコレーター"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"https://smallrye.io/smallrye-reactive-messaging/latest/concepts/decorators/[Channel decorators] is a way to intercept and decorate the reactive streams corresponding to messaging channels.\n"
"This can be useful for adding custom behavior to the channels, such as logging, metrics, or error handling."
msgstr "link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/decorators/[チャネルデコレータは] 、メッセージングチャネルに対応するリアクティブストリームをインターセプトして装飾する方法です。これは、ロギングやメトリクス、エラーハンドリングなどのカスタムビヘイビアをチャネルに追加するのに便利です。"

#: _guides/messaging.adoc
#, fuzzy
msgid ""
"It is therefore possible to implement a bean implementing `PublisherDecorator` for incoming channels, and `SubscriberDecorator` for outgoing channels.\n"
"Since two APIs are symmetric, you can implement both interfaces in the same bean.\n"
"These beans are automatically discovered by Quarkus and applied by priority (from the least value to the greatest)."
msgstr "したがって、着信チャンネル用に `PublisherDecorator` を実装し、発信チャンネル用に `SubscriberDecorator` を実装したビーンを実装することが可能です。2つのAPIは対称なので、同じビーンで両方のインタフェースを実装できます。これらのBeanはQuarkusによって自動的に検出され、優先度（最小値から最大値まで）によって適用されます。"

#: _guides/messaging.adoc
#, fuzzy
msgid "Some decorators are included by default by Quarkus extensions."
msgstr "Quarkusの拡張機能には、デフォルトで含まれているデコレータがあります。"

#: _guides/messaging.adoc
#, fuzzy
msgid "Incoming channels (PublisherDecorator) in the order of priority:"
msgstr "優先順位の高い着信チャンネル（PublisherDecorator）："

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.quarkus.smallrye.reactivemessaging.runtime.ConnectorContextPropagationDecorator` (-100): Clears the context propagation for incoming channels"
msgstr "`io.quarkus.smallrye.reactivemessaging.runtime.ConnectorContextPropagationDecorator` (-100):受信チャネルのコンテキスト伝搬をクリアします。"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.locals.ContextDecorator` (0): Ensures messages are dispatched on the message context"
msgstr "`io.smallrye.reactive.messaging.providers.locals.ContextDecorator` (0):メッセージコンテキストでメッセージがディスパッチされるようにします。"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.quarkus.smallrye.reactivemessaging.runtime.RequestScopedDecorator` (100): Handles pausable channels"
msgstr "`io.quarkus.smallrye.reactivemessaging.runtime.RequestScopedDecorator` (100):一時停止可能なチャンネル"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.IncomingInterceptorDecorator` (500): Handles `IncomingInterceptor` beans"
msgstr "`io.smallrye.reactive.messaging.providers.IncomingInterceptorDecorator` (500): 豆の取り扱い `IncomingInterceptor` "

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.metrics.MicrometerDecorator` (1000): Micrometer Metrics support, enabled with `quarkus-micrometer` extension"
msgstr "`io.smallrye.reactive.messaging.providers.metrics.MicrometerDecorator` (1000):マイクロメーターメトリクスのサポート。 拡張で有効。 `quarkus-micrometer` "

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.extension.ObservationDecorator` (1000): Message observation support for incoming channels"
msgstr "`io.smallrye.reactive.messaging.providers.extension.ObservationDecorator` (1000):着信チャンネルに対するメッセージ観測のサポート"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.extension.PausableChannelDecorator` (1000): Handles pausable channels"
msgstr "`io.smallrye.reactive.messaging.providers.extension.PausableChannelDecorator` (1000):一時停止可能なチャンネル"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.quarkus.opentelemetry.runtime.tracing.intrumentation.reactivemessaging.ReactiveMessagingTracingIncomingDecorator` (1000): Included with `quarkus-opentelemetry` extension, propagates tracing information"
msgstr "`io.quarkus.opentelemetry.runtime.tracing.intrumentation.reactivemessaging.ReactiveMessagingTracingIncomingDecorator` (1000): 拡張に含まれ、トレース情報を伝播します。 `quarkus-opentelemetry` "

#: _guides/messaging.adoc
#, fuzzy
msgid "Outgoing channels (SubscriberDecorator):"
msgstr "発信チャンネル（SubscriberDecorator）："

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.quarkus.smallrye.reactivemessaging.runtime.ConnectorContextPropagationDecorator` (-100): Clears the context propagation for outgoing channels"
msgstr "`io.quarkus.smallrye.reactivemessaging.runtime.ConnectorContextPropagationDecorator` (-100):送信チャネルのコンテキスト伝搬をクリアします。"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.extension.OutgoingObservationDecorator` (1000): Message observation support for outgoing channels"
msgstr "`io.smallrye.reactive.messaging.providers.extension.OutgoingObservationDecorator` (1000):発信チャンネルにおけるメッセージ観測のサポート"

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.quarkus.opentelemetry.runtime.tracing.intrumentation.reactivemessaging.ReactiveMessagingTracingOutgoingDecorator` (1000): Included with `quarkus-opentelemetry` extension, propagates tracing information"
msgstr "`io.quarkus.opentelemetry.runtime.tracing.intrumentation.reactivemessaging.ReactiveMessagingTracingOutgoingDecorator` (1000): 拡張に含まれ、トレース情報を伝播します。 `quarkus-opentelemetry` "

#: _guides/messaging.adoc
#, fuzzy
msgid "`io.smallrye.reactive.messaging.providers.OutgoingInterceptorDecorator` (2000): Handles `OutgoingInterceptor` beans"
msgstr "`io.smallrye.reactive.messaging.providers.OutgoingInterceptorDecorator` (2000): 豆の取り扱い `OutgoingInterceptor` "

#: _guides/messaging.adoc
msgid "Going further"
msgstr "さらに詳しく"

#: _guides/messaging.adoc
msgid "This guide shows the general principles of Quarkus Messaging extensions."
msgstr "このガイドでは、Quarkus Messaging エクステンションの一般的な原則について説明します。"

#: _guides/messaging.adoc
msgid ""
"If you want to go further, you can check the link:{rm_doc}[SmallRye Reactive Messaging] documentation,\n"
"which has in-depth documentation for each of these concepts and more."
msgstr ""
"さらに詳しく知りたい場合は、リンク:{rm_doc}[SmallRye Reactive Messaging] のドキュメントを参照してください。\n"
"これには、それぞれのコンセプトなどに関する詳細なドキュメントが含まれています。"
