# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-02-04 01:49+0900\n"
"PO-Revision-Date: 2021-04-30 14:21+0900\n"
"Last-Translator: Nobuhiro Sue <nobuhiro.sue@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amazon-lambda-http.adoc:6
#, fuzzy, no-wrap
msgid "Amazon Lambda with RESTEasy, Undertow, or Reactive Routes"
msgstr "Amazon Lambda with RESTEasy, Undertow, or Reactive Routes"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:15
#, fuzzy
msgid "With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda."
msgstr "Quarkusでは、 link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API]または link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST] APIのいずれかを使用して、お気に入りのJava HTTPフレームワークをAmazon Lambdaとして展開することができます。つまり、RESTEasy（JAX-RS）、Undertow（サーブレット）、Reactive Routes、 link:funqy-http.html[Funqy HTTP]、その他のQuarkusのHTTPフレームワークで書かれたマイクロサービスを、AWS Lambdaとして展開することができるのです。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:18
msgid "You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework]."
msgstr "Lambda を純粋な Java jar としてデプロイすることもできますし、プロジェクトをネイティブイメージにコンパイルしてデプロイすることで、より少ないメモリーフットプリントと起動時間を実現することもできます。また、統合により、 https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[AmazonのSAM framework] で使用できるSAMデプロイメントファイルも生成されます。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:22
msgid "Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision."
msgstr "Quarkusでは、ゲートウェイAPIごとに異なるエクステンションを用意しています。HTTP Gateway APIは、 `quarkus-amazon-lambda-http` のエクステンションで実装されています。REST Gateway APIは、 `quarkus-amazon-lambda-rest` のエクステンションで実装されています。どのGateway製品を使用すべきか迷っている場合は、Amazonが決断を助ける為に link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[素晴らしいガイド]を提供しています。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:24
#, fuzzy
msgid "Like most Quarkus extensions, the Quarkus AWS Lambda HTTP/REST extensions support Live Coding."
msgstr "ほとんどのQuarkusエクステンションと同様に、Quarkus AWS Lambda HTTP/RESTエクステンションはLive Codingをサポートしています。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:27
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:32
msgid "https://aws.amazon.com[An Amazon AWS account]"
msgstr "link:https://aws.amazon.com[Amazon AWSのアカウント]"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:33
msgid "https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"
msgstr "link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:34
#, no-wrap
msgid "Getting Started"
msgstr "はじめに"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:38
#, fuzzy
msgid "This guide walks you through generating an example Java project via a Maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda."
msgstr "このガイドでは、MavenアーキタイプによるサンプルJavaプロジェクトの生成を説明します。その後、プロジェクトの構造を説明し、既存のプロジェクトにAmazon Lambdaを使用できるようにします。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:39
#, no-wrap
msgid "Installing AWS bits"
msgstr "AWSツールのインストール"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:43
msgid "Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI."
msgstr "AWSのすべてのツールをインストールすることは、おそらくこのガイドでは最も難しいことです。AWS CLIをインストールするためのすべての手順に従っていることを確認してください。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:44
#, no-wrap
msgid "Creating the Maven Deployment Project"
msgstr "Maven デプロイメントプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:47
#, fuzzy
msgid "Create the Quarkus AWS Lambda Maven project using our Maven Archetype."
msgstr "QuarkusのMaven Archetypeを使用して、Quarkus AWS LambdaのMavenプロジェクトを作成します。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:49
msgid "If you want to use the AWS Gateway HTTP API, generate your project with this script:"
msgstr "AWS Gateway HTTP APIを使用する場合は、このスクリプトでプロジェクトを生成します。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:55
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-http-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:58
msgid "If you want to use the AWS Gateway REST API, generate your project with this script:"
msgstr "AWS Gateway REST APIを使用する場合は、このスクリプトでプロジェクトを生成します。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:64
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-rest-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:67
#, no-wrap
msgid "Build and Deploy"
msgstr "ビルドとデプロイ"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:70
#, fuzzy
msgid "Build the project:"
msgstr "プロジェクトの構築"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:76
#, fuzzy
msgid "This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension."
msgstr "これにより、コードがコンパイルされ、生成されたプロジェクトに含まれるユニットテストが実行されます。ユニットテストは他のJavaプロジェクトと同じで、Amazonで実行する必要はありません。Quarkusのdevモードもこのエクステンションで利用できます。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:79
#, fuzzy
msgid "If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property to the build"
msgstr "ネイティブ実行可能ファイルをビルドしたい場合は、GraalVMが正しくインストールされていることを確認し、ビルドに `native` プロパティを追加するだけです。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:85
#, fuzzy
msgid "If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however."
msgstr "非Linuxシステムで構築する場合、Amazon LambdaがLinuxバイナリを必要とするため、QuarkusにDockerビルドを使用するよう指示するプロパティを渡す必要があります。これは、ビルドコマンドに `-Dquarkus.native.container-build=true` を渡すことで行うことができます。ただし、これにはDockerがローカルにインストールされている必要があります。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:88
#, no-wrap
msgid "Extra Build Generated Files"
msgstr "ビルド時に追加生成されるファイル"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:92
#, fuzzy
msgid "After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the the build directory: `target/` for Maven, `build/` for Gradle."
msgstr "ビルドを実行すると、使用しているQuarkus lambda extensionによっていくつかの追加ファイルが生成されます。これらのファイルはビルドディレクトリにあります。Mavenの場合は `target/` 、Gradleの場合は `build/` 。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:94
msgid "`function.zip` - lambda deployment file"
msgstr "`function.zip` - Lambda デプロイファイル"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:95
msgid "`sam.jvm.yaml` - sam cli deployment script"
msgstr "`sam.jvm.yaml` - SAM CLI デプロイメントスクリプト"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:96
msgid "`sam.native.yaml` - sam cli deployment script for native"
msgstr "`sam.native.yaml` - ネイティブ用の SAM CLI デプロイメントスクリプト"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:97
#, fuzzy, no-wrap
msgid "Live Coding and Simulating AWS Lambda Environment Locally"
msgstr "AWS Lambdaの環境を現地でライブコーディングしてシミュレーションする"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:103
#, fuzzy
msgid "In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI."
msgstr "開発およびテストモードでは、QuarkusはモックのAWS Lambdaイベントサーバーを起動し、HTTPリクエストを対応するAPI Gatewayイベントタイプに変換して、処理のために基礎となるQuarkus HTTP lambda環境にポストします。これは、DockerやSAM CLIなどのツールを必要とせず、AWS Lambda環境をローカルで可能な限りシミュレートします。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:107
#, fuzzy
msgid "When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop."
msgstr "Quarkus Dev Modeを使用している場合は、RESTエンドポイントをテストするときと同様に `&lt;a href=\"http://localhost:8080\" class=\"bare\"&gt;http://localhost:8080&lt;/a&gt;`にHTTPリクエストを発行します。このリクエストはMock Event Serverにヒットし、API Gatewayのjsonメッセージに変換されてQuarkus Lambda Pollループで消費されます。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:110
#, fuzzy
msgid "For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up."
msgstr "テストのために、Quarkusはポート8081で別のMock Eventサーバを起動します。Rest Assuredのデフォルトポートは、Quarkusによって自動的に8081に設定されるため、この設定を気にする必要はありません。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:115
#, fuzzy
msgid "If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:"
msgstr "より複雑なAPI Gatewayイベントをテストでシミュレートしたい場合は、手動でHTTP POSTを `&lt;a href=\"http://localhost:8080/_lambda_\" class=\"bare\"&gt;http://localhost:8080/_lambda_&lt;/a&gt;`(テストモードではポート8081)に生のAPI Gateway jsonイベントを手動で送信します。これらのイベントは、処理のためにQuarkus Lambdaのポールループに直接置かれます。以下にその例を示します。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:120
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:122
#: upstream/_guides/amazon-lambda-http.adoc:445
#: upstream/_guides/amazon-lambda-http.adoc:486
#, no-wrap
msgid "import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:124
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:134
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class AmazonLambdaSimpleTestCase {\n"
"    @Test\n"
"    public void testJaxrsCognitoJWTSecurityContext() throws Exception {\n"
"        APIGatewayV2HTTPEvent request = request(\"/security/username\");\n"
"        request.getRequestContext().setAuthorizer(new APIGatewayV2HTTPEvent.RequestContext.Authorizer());\n"
"        request.getRequestContext().getAuthorizer().setJwt(new APIGatewayV2HTTPEvent.RequestContext.Authorizer.JWT());\n"
"        request.getRequestContext().getAuthorizer().getJwt().setClaims(new HashMap<>());\n"
"        request.getRequestContext().getAuthorizer().getJwt().getClaims().put(\"cognito:username\", \"Bill\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:145
#, no-wrap
msgid ""
"        given()\n"
"                .contentType(\"application/json\")\n"
"                .accept(\"application/json\")\n"
"                .body(request)\n"
"                .when()\n"
"                .post(\"/_lambda_\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(\"body\", equalTo(\"Bill\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:148
#, fuzzy
msgid "The above example simulates sending a Cognito principal with an HTTP request to your HTTP Lambda."
msgstr "上記の例では、CognitoのプリンシパルをHTTPリクエストでHTTP Lambdaに送信することをシミュレーションしています。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:153
#, fuzzy
msgid "If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API."
msgstr "AWS HTTP APIの生のイベントをハンドコーディングしたい場合、AWS Lambdaライブラリには、 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` であるリクエストイベントタイプと、 `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse` であるレスポンスイベントタイプがあります。これは `quarkus-amazon-lambda-http` のエクステンションと AWS HTTP API に対応しています。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:157
#, fuzzy
msgid "If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API."
msgstr "AWS REST APIのrawイベントをハンドコーディングしたい場合、Quarkusには独自の実装があります： `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` と `io.quarkus.amazon.lambda.http.model.AwsProxyResponse` 。これは、 `quarkus-amazon-lambda-rest` エクステンションとAWS REST APIに対応しています。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:160
#, fuzzy
msgid "The mock event server is also started for `@NativeImageTest` unit tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker."
msgstr "モックイベントサーバーは、 `@NativeImageTest` ユニットテスト用にも起動されるので、ネイティブバイナリでも動作します。これらはすべて、Dockerのオーバーヘッドなしに、SAM CLIのローカルテストと同様の機能を提供します。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:163
#, fuzzy
msgid "Finally, if port 8080 or port 8081 is not available on your computer, you can modify the dev and test mode ports with application.properties"
msgstr "最後に、8080ポートまたは8081ポートがお使いのコンピューターで利用できない場合は、application.propertiesでdevおよびtestモードのポートを変更することができます。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:168
#, no-wrap
msgid ""
"quarkus.lambda.mock-event-server.dev-port=8082\n"
"quarkus.lambda.mock-event-server.test-port=8083\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:172
#, fuzzy, no-wrap
msgid "Simulate Amazon Lambda Deployment with SAM CLI"
msgstr "SAM CLIでAmazon Lambdaのデプロイをシミュレートする"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:176
#, fuzzy
msgid "The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:"
msgstr "AWS SAM CLIでは、ラップトップ上でLambdaをローカルに実行し、Lambdaのシミュレーション環境を構築することができます。これには、Dockerのインストールが必要です。Mavenプロジェクトをビルドした後、このコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:180
#, no-wrap
msgid "sam local start-api --template target/sam.jvm.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:184
#, fuzzy
msgid "This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment is started you can invoke the example lambda in your browser by going to:"
msgstr "これでAmazon's Lambdaのデプロイ環境を模したDockerコンテナが起動します。環境が起動したら、ブラウザでサンプルのLambdaを起動することができ、以下のようになります。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:186
msgid "http://127.0.0.1:3000/hello"
msgstr "http://127.0.0.1:3000/hello"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:189
msgid "In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java."
msgstr "コンソールには、ラムダからの起動メッセージが表示されます。この特定のデプロイメントでは、JVM を起動し、純粋な Java として Lambda をロードします。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:191
#, no-wrap
msgid "Deploy to AWS"
msgstr "AWSへのデプロイ"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:196
#, no-wrap
msgid "sam deploy -t target/sam.jvm.yaml -g\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:200
msgid "Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:"
msgstr "すべての質問に答えると、 Lambda がデプロイされ、API Gatewayへの必要なフックが設定されます。すべてが正常にデプロイされると、マイクロサービスのルート URL がコンソールに出力されます。このような感じです。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:205
#, no-wrap
msgid ""
"Key                 LambdaHttpApi\n"
"Description         URL for application\n"
"Value               https://234asdf234as.execute-api.us-east-1.amazonaws.com/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:208
msgid "The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end."
msgstr "`Value` 属性は Lambda のルート URL です。これをブラウザにコピーして、最後に `hello` を追加します。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:214
msgid "Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding."
msgstr "バイナリー型のレスポンスは自動的にbase64でエンコードされます。これは、生のバイトを返す `quarkus:dev` を使用した動作とは異なります。Amazon の API には、base64 エンコーディングを必要とする追加の制限があります。一般的に、クライアントコードは自動的にこのエンコーディングを処理しますが、特定のカスタムな状況では、手動でエンコーディングを管理する必要があるかもしれないことを認識しておく必要があります。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:215
#, no-wrap
msgid "Deploying a native executable"
msgstr "ネイティブ実行可能ファイルのデプロイ"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:218
#, fuzzy
msgid "To deploy a native executable, you must build it with GraalVM."
msgstr "ネイティブ実行可能ファイルをデプロイするには、GraalVMでビルドする必要があります。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:222
msgid "You can then test the executable locally with sam local"
msgstr "その後、ローカルで sam local を使って実行ファイルをテストすることができます。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:226
#, no-wrap
msgid "sam local start-api --template target/sam.native.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:229
msgid "To deploy to AWS Lambda:"
msgstr "AWS Lambda へのデプロイ"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:232
#, no-wrap
msgid "sam deploy -t target/sam.native.yaml -g\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:234
#, no-wrap
msgid "Examine the POM"
msgstr "POMを調べる"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:239
msgid "There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment."
msgstr "POM には `quarkus-amazon-lambda-http` エクステンション(AWS Gateway HTTP APIでデプロイしている場合) か `quarkus-amazon-lambda-rest` エクステンション( AWS Gateway REST APIでデプロイしている場合)が依存関係として含まれている以外に特別なことは何もありません。これらのエクステンションは Lambda のデプロイに必要なものをすべて自動的に生成します。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:243
#, fuzzy
msgid "Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment."
msgstr "また、少なくとも生成されたMavenアーキタイプ `pom.xml` では、 `quarkus-resteasy` 、 `quarkus-reactive-routes` 、 `quarkus-undertow` の依存関係はすべてオプションです。使用したいHTTPフレームワーク（JAX-RS、Reactive Routes、および/またはServlet）を選択し、他の依存関係を削除してデプロイメントを縮小してください。"

#. type: Title ===
#: upstream/_guides/amazon-lambda-http.adoc:244
#, no-wrap
msgid "Examine sam.yaml"
msgstr "sam.yaml を調べる"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:248
msgid "The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files."
msgstr "`sam.yaml` の構文はこのドキュメントの範囲を超えています。しかし、カスタムの `sam.yaml` デプロイメントファイルを作成しようとしている場合、幾つかの強調しなければならないことがあります。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:251
msgid "The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name."
msgstr "最初に注意することは、純粋なJavaラムダデプロイメントには特定のハンドラークラスが必要であるということです。 Lambdaハンドラー名は変更しないでください。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:257
#, no-wrap
msgid ""
"     Properties:\n"
"        Handler: io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest\n"
"        Runtime: java11\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:260
msgid "This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (JAX-RS, Servlet, etc.)"
msgstr "このハンドラは、ラムダランタイムと、使用しているQuarkus HTTPフレームワーク（JAX-RS、Servletなど）との間のブリッジとなります。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:263
msgid "If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:"
msgstr "ネイティブを利用する場合は、ネイティブのGraalVMデプロイメント用に設定する必要のある環境変数があります。 `sam.native.yaml` を見ると、次のことがわかります。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:269
#, no-wrap
msgid ""
"        Environment:\n"
"          Variables:\n"
"            DISABLE_SIGNAL_HANDLERS: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:272
msgid "This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment."
msgstr "この環境変数は、QuarkusとAmazon Lambdaカスタムランタイム環境との間のいくつかの非互換性を解決します。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:277
msgid "Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:"
msgstr "最後に、AWS Gateway RESTAPIへのデプロイに固有のことが一つあります。そのAPIは、設定でどのメディアタイプがバイナリーであるかを明示的に指定しない限り、HTTPレスポンスボディはテキストであることを想定しています。より簡単にするために、QuarkusエクステンションはすべてのHTTP応答メッセージのバイナリー(ベース64)エンコーディングを強制します。 `sam.yaml` ファイルでは、すべてのメディアタイプがバイナリーであると仮定するようにAPI Gatewayを設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:285
#, no-wrap
msgid ""
"  Globals:\n"
"    Api:\n"
"      EndpointConfiguration: REGIONAL\n"
"      BinaryMediaTypes:\n"
"        - \"*/*\"\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:287
#, no-wrap
msgid "Injectable AWS Context Variables"
msgstr "注入可能なAWSコンテキスト変数"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:291
#, fuzzy
msgid "If you are using RESTEasy and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation."
msgstr "RESTEasyとJAX-RSを使用している場合、JAX-RS `@Context` アノテーションを使用して、様々なAWS Context変数をJAX-RSリソースクラスに注入することができます。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:294
msgid "For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:"
msgstr "AWS HTTP APIでは、AWS変数 `com.amazonaws.services.lambda.runtime.Context` および `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` を注入することができます。以下はその例です。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:299
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:305
#: upstream/_guides/amazon-lambda-http.adoc:330
#, no-wrap
msgid ""
"@Path(\"/myresource\")\n"
"public class MyResource {\n"
"    @GET\n"
"    public String ctx(@Context com.amazonaws.services.lambda.runtime.Context ctx) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:308
#, no-wrap
msgid ""
"    @GET\n"
"    public String event(@Context APIGatewayV2HTTPEvent event) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:311
#, no-wrap
msgid ""
"    @GET\n"
"    public String requestContext(@Context APIGatewayV2HTTPEvent.RequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:314
#: upstream/_guides/amazon-lambda-http.adoc:338
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:318
msgid "For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:"
msgstr "AWS REST APIでは、AWS変数 `com.amazonaws.services.lambda.runtime.Context` と `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext` を注入することができます。以下はその例です。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:324
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:333
#, no-wrap
msgid ""
"    @GET\n"
"    public String reqContext(@Context AwsProxyRequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:336
#, no-wrap
msgid ""
"    @GET\n"
"    public String req(@Context AwsProxyRequest req) { }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:340
#, no-wrap
msgid "Tracing with AWS XRay and GraalVM"
msgstr "AWS XRay と GraalVMでのトレース"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:345
msgid "If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work."
msgstr "ネイティブイメージをビルドしていて、Lambda で link:https://aws.amazon.com/xray[AWS X-Ray Tracing] を使いたい場合は、 `quarkus-amazon-lambda-xray` を依存関係として pom に含める必要があります。AWS X-Ray ライブラリは GraalVM との完全な互換性がないため、これを動作させるためにいくつかの統合作業をしなければなりませんでした。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:346
#, fuzzy, no-wrap
msgid "Security Integration"
msgstr "セキュリティ・インテグレーション"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:351
#, fuzzy
msgid "When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes)."
msgstr "API GatewayでHTTPリクエストを呼び出すと、GatewayはそのHTTPリクエストを、Quarkus Lambdaに転送されるJSONイベントドキュメントに変換します。Quarkus Lambdaは、このJSONを解析して、QuarkusがサポートするHTTPフレームワーク（JAX-RS、サーブレット、Reactive Routes）で消費できるHTTPリクエストの内部表現に変換します。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:358
#, fuzzy
msgid "API Gateway supports many different ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information."
msgstr "API Gatewayは、LambdaとQuarkusによってバックアップされたHTTPエンドポイントを安全に呼び出すためのさまざまな方法をサポートしています。これを有効にすると、Quarkusは link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[イベントのjsonドキュメント]の関連部分を自動的に解析し、セキュリティベースのメタデータを探し、内部的に `java.security.Principal` を登録します。これは、 `javax.ws.rs.core.SecurityContext` を注入することでJAX-RSで調べることができ、サーブレットでは `HttpServletRequest.getUserPrincipal()` を経由し、Reactive Routesでは `RouteContext.user()` を経由して調べられます。より多くのセキュリティ情報が必要な場合は、 `Principal` オブジェクトを、より多くの情報を提供するクラスにタイプキャストすることができます。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:360
#, fuzzy
msgid "To enable this security feature, add this to your `application.properties` file:"
msgstr "このセキュリティ機能を有効にするには、 `application.properties` ファイルに追加してください。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:362
#, no-wrap
msgid "quarkus.lambda-http.enable-security=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:366
#, fuzzy
msgid "Here's how its mapped:"
msgstr "そのマッピングは以下の通りです。"

#. type: Block title
#: upstream/_guides/amazon-lambda-http.adoc:367
#: upstream/_guides/amazon-lambda-http.adoc:396
#, fuzzy, no-wrap
msgid "HTTP `quarkus-amazon-lambda-http`"
msgstr "HTTP `quarkus-amazon-lambda-http`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:370
#: upstream/_guides/amazon-lambda-http.adoc:380
#, fuzzy, no-wrap
msgid "Auth Type"
msgstr "認証タイプ"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:370
#: upstream/_guides/amazon-lambda-http.adoc:380
#, fuzzy, no-wrap
msgid "Principal Class"
msgstr "プリンシパルクラス"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:371
#: upstream/_guides/amazon-lambda-http.adoc:381
#, fuzzy, no-wrap
msgid "Json path of Principal Name"
msgstr "プリンシパルネームのJsonパス"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:371
#, fuzzy, no-wrap
msgid "Cognito JWT"
msgstr "コグニートJWT"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:371
#: upstream/_guides/amazon-lambda-http.adoc:381
#, fuzzy, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:372
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.jwt.claims.cognito:username`"
msgstr "`requestContext.authorizer.jwt.claims.cognito:username`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:372
#: upstream/_guides/amazon-lambda-http.adoc:382
#, fuzzy, no-wrap
msgid "IAM"
msgstr "IAM"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:372
#: upstream/_guides/amazon-lambda-http.adoc:382
#, fuzzy, no-wrap
msgid "`io.quarkus.amazon.lambda.http.IAMPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.IAMPrincipal`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:373
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.iam.userId`"
msgstr "`requestContext.authorizer.iam.userId`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:373
#: upstream/_guides/amazon-lambda-http.adoc:383
#, fuzzy, no-wrap
msgid "Custom Lambda"
msgstr "カスタムラムダ"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:373
#: upstream/_guides/amazon-lambda-http.adoc:383
#, fuzzy, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CustomPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CustomPrincipal`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:375
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.lambda.principalId`"
msgstr "`requestContext.authorizer.lambda.principalId`"

#. type: Block title
#: upstream/_guides/amazon-lambda-http.adoc:377
#: upstream/_guides/amazon-lambda-http.adoc:437
#, fuzzy, no-wrap
msgid "REST `quarkus-amazon-lambda-rest`"
msgstr "REST `quarkus-amazon-lambda-rest`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:381
#, fuzzy, no-wrap
msgid "Cognito"
msgstr "コグニート"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:382
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.claims.cognito:username`"
msgstr "`requestContext.authorizer.claims.cognito:username`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:383
#, fuzzy, no-wrap
msgid "`requestContext.identity.user`"
msgstr "`requestContext.identity.user`"

#. type: Table
#: upstream/_guides/amazon-lambda-http.adoc:385
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.principalId`"
msgstr "`requestContext.authorizer.principalId`"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:387
#, fuzzy, no-wrap
msgid "Custom Security Integration"
msgstr "カスタム・セキュリティ・インテグレーション"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:395
#, fuzzy
msgid "The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have can full control how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration."
msgstr "AWSセキュリティのデフォルトのサポートでは、プリンシパル名をQuarkusセキュリティAPIにマッピングするだけで、クレームやロール、パーミッションをマッピングすることはありません。 `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` インターフェースの実装を使用して、ラムダHTTPイベント内のセキュリティメタデータをQuarkusセキュリティAPIにマッピングする方法を完全に制御することができます。このインターフェイスを実装することで、プリンシパルのロールマッピングを定義したり、IAMやCognito、カスタムLambdaのセキュリティ統合で提供される追加属性を公開したりすることができます。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:400
#: upstream/_guides/amazon-lambda-http.adoc:441
#, no-wrap
msgid "package io.quarkus.amazon.lambda.http;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:410
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"    @Override\n"
"    default public Class<LambdaAuthenticationRequest> getRequestType() {\n"
"        return LambdaAuthenticationRequest.class;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:420
#, no-wrap
msgid ""
"    @Override\n"
"    default Uni<SecurityIdentity> authenticate(LambdaAuthenticationRequest request, AuthenticationRequestContext context) {\n"
"        APIGatewayV2HTTPEvent event = request.getEvent();\n"
"        SecurityIdentity identity = authenticate(event);\n"
"        if (identity == null) {\n"
"            return Uni.createFrom().optional(Optional.empty());\n"
"        }\n"
"        return Uni.createFrom().item(identity);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:432
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:436
#, fuzzy
msgid "For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`"
msgstr "HTTP の場合、オーバーライドする重要なメソッドは `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)` です。からのセキュリティデータをどのようにマッピングするかに基づいて、SecurityIdentity を割り当てることになります。 `APIGatewayV2HTTPEvent`"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:443
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:451
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
"import io.quarkus.security.identity.AuthenticationRequestContext;\n"
"import io.quarkus.security.identity.IdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:458
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:470
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:474
#, fuzzy
msgid "For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`."
msgstr "REST の場合、オーバーライドする重要なメソッドは `LambdaIdentityProvider.authenticate(AwsProxyRequest event)` です。ここから、 `AwsProxyRequest` のセキュリティデータをどのようにマッピングするかに基づいて、SecurityIdentity を割り当てることになります。"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:476
#, fuzzy
msgid "Your implemented provider must be a CDI bean.  Here's an example:"
msgstr "実装されるプロバイダは、CDI Beanである必要があります。以下はその例です。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:480
#: upstream/_guides/amazon-lambda-http.adoc:511
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:482
#: upstream/_guides/amazon-lambda-http.adoc:513
#, no-wrap
msgid "import java.security.Principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:484
#: upstream/_guides/amazon-lambda-http.adoc:515
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr "import javax.enterprise.context.ApplicationScoped;\n"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:491
#: upstream/_guides/amazon-lambda-http.adoc:522
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.LambdaIdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.quarkus.security.runtime.QuarkusPrincipal;\n"
"import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:504
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        if (event.getHeaders() == null || !event.getHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getHeaders().get(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:507
#, fuzzy
msgid "Here's the same example, but with the AWS Gateway REST API:"
msgstr "以下は同じ例ですが、AWS Gateway REST APIを使用しています。"

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:517
#, no-wrap
msgid "import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-lambda-http.adoc:535
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        if (event.getMultiValueHeaders() == null || !event.getMultiValueHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getMultiValueHeaders().getFirst(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:539
#, fuzzy
msgid "Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier."
msgstr "Quarkusはこの実装を自動的に検出し、前述のデフォルトの実装の代わりに使用します。"

#. type: Title ==
#: upstream/_guides/amazon-lambda-http.adoc:540
#, fuzzy, no-wrap
msgid "Simple SAM Local Principal"
msgstr "Simple SAM Local Principal"

#. type: Plain text
#: upstream/_guides/amazon-lambda-http.adoc:544
#, fuzzy
msgid "If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable"
msgstr "アプリケーションを `sam local` でテストしている場合は、環境変数 `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` を設定することで、アプリケーションの実行時に使用するプリンシパル名をハードコードすることができます。"
