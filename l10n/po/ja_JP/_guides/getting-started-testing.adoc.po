# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-11-24 10:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-testing.adoc:6
#, fuzzy, no-wrap
msgid "Testing Your Application"
msgstr "Quarkus - アプリケーションのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:23
msgid "Learn how to test your Quarkus Application.  This guide covers:"
msgstr "Quarkusアプリケーションのテスト方法について説明します。このガイドでは、以下の内容について説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:25
#, fuzzy
msgid "Testing in JVM mode"
msgstr "JVMモードでのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:26
msgid "Testing in native mode"
msgstr "ネイティブモードでのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:27
msgid "Injection of resources into tests"
msgstr "テストへのリソースの注入"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:28
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:31
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下が必要です:"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:33
msgid "less than 15 minutes"
msgstr "15分未満"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:34
msgid "an IDE"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:35
#, fuzzy
#| msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgid "JDK 11+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:36
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:37
msgid "The completed greeter application from the link:getting-started[Getting Started Guide]"
msgstr "link:getting-started[入門ガイド]の完成済のgreeterアプリケーション"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:38
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:42
msgid "In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables."
msgstr "このガイドでは、入門ガイドの一部として作成された最初のテストを拡張します。テストへのインジェクションと、ネイティブの実行ファイルをテストする方法もカバーしています。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:44
#, fuzzy
msgid "Quarkus supports Continuous testing, but this is covered by the link:continuous-testing[Continuous Testing Guide]."
msgstr "Quarkusは継続的テストをサポートしていますが、これについては link:continuous-testing[継続的テストガイド]で説明しています。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:45
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:49
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:51
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:53
msgid "The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory]."
msgstr "ソリューションは `getting-started-testing`  {quickstarts-tree-url}/getting-started-testing[ディレクトリー] にあります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:55
msgid "This guide assumes you already have the completed application from the `getting-started` directory."
msgstr "このガイドでは、 `getting-started`  ディレクトリーの完成したアプリケーションをすでに持っていることを前提としています。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:56
#, fuzzy, no-wrap
msgid "Recap of HTTP based Testing in JVM mode"
msgstr "JVMモードでのHTTPベースのテストのまとめ"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:60
msgid "If you have started from the Getting Started example you should already have a completed test, including the correct `pom.xml` setup."
msgstr "はじめにのサンプルから始めた場合は、正しい `pom.xml`  の設定を含めて、すでにテストが完了しているはずです。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:62
msgid "In the `pom.xml` file you should see 2 test dependencies:"
msgstr "`pom.xml`  ファイルには、2つのテスト依存関係があるはずです:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:75
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.rest-assured</groupId>\n"
"    <artifactId>rest-assured</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:80
msgid "`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required."
msgstr "`quarkus-junit5`  は、テストフレームワークを制御する `@QuarkusTest`  アノテーションを提供するため、テストには必須です。 `rest-assured`  は必須ではありませんが、HTTP エンドポイントをテストするのに便利な方法です。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:83
msgid "Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:"
msgstr "JUnit 5を使用しているので、 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]のバージョンを設定する必要があります。デフォルトのバージョンはJUnit 5をサポートしていない為です。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:96
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <configuration>\n"
"       <systemPropertyVariables>\n"
"          <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"          <maven.home>${maven.home}</maven.home>\n"
"       </systemPropertyVariables>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:100
msgid "We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any)."
msgstr "また、 `java.util.logging.manager`  システムプロパティーを設定して、テストが正しい logmanager と `maven.home`  を使用して、 `${maven.home}/conf/settings.xml` からのカスタム設定が適用されるようにしています (存在する場合)。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:102
msgid "The project should also contain a simple test:"
msgstr "プロジェクトには簡単なテストも含まれているはずです:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:106
#: upstream/_guides/getting-started-testing.adoc:201
#: upstream/_guides/getting-started-testing.adoc:276
#: upstream/_guides/getting-started-testing.adoc:328
#: upstream/_guides/getting-started-testing.adoc:367
#: upstream/_guides/getting-started-testing.adoc:451
#: upstream/_guides/getting-started-testing.adoc:498
#, no-wrap
msgid "package org.acme.getting.started.testing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:109
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:111
#: upstream/_guides/getting-started-testing.adoc:334
#, no-wrap
msgid "import java.util.UUID;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:114
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:117
#: upstream/_guides/getting-started-testing.adoc:1021
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:126
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:137
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreetingEndpoint() {\n"
"        String uuid = UUID.randomUUID().toString();\n"
"        given()\n"
"          .pathParam(\"name\", uuid)\n"
"          .when().get(\"/hello/greeting/{name}\")\n"
"          .then()\n"
"            .statusCode(200)\n"
"            .body(is(\"hello \" + uuid));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:139
#: upstream/_guides/getting-started-testing.adoc:427
#: upstream/_guides/getting-started-testing.adoc:724
#: upstream/_guides/getting-started-testing.adoc:1038
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:143
msgid "This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run."
msgstr "このテストはHTTPを使用して、RESTエンドポイントを直接テストします。テストが実行されると、テストが実行される前にアプリケーションが開始されます。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:144
#, no-wrap
msgid "Controlling the test port"
msgstr "テストポートの制御"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:148
msgid "While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel."
msgstr "Quarkusはデフォルトではポート `8080`  をリッスンしますが、テストを実行する場合はデフォルトで `8081`  をリッスンします。これにより、アプリケーションを並行して実行しながらテストを実行することができます。"

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:150
#, no-wrap
msgid "Changing the test port"
msgstr "テストポートの変更"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:153
msgid "You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:"
msgstr " `application.properties` の `quarkus.http.test-port` を設定することで、を HTTP 用にテストで使われるポートを設定出来、 `quarkus.http.test-ssl-port` を設定することで HTTPS 用にテストで使用するポートを設定することが出来ます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:157
#, no-wrap
msgid ""
"quarkus.http.test-port=8083\n"
"quarkus.http.test-ssl-port=8446\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:159
msgid "`0` will result in the use of a random port (assigned by the operating system)."
msgstr "`0` を使用すると、(オペレーティングシステムによって割り当てられた)ランダムなポートが使用されることになります。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:163
msgid "Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required."
msgstr "Quarkusはまた、テストを実行する前にRestAssuredによって使用されるデフォルトのポートを更新するRestAssuredインテグレーションも提供しているため、追加の設定は必要ありません。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:164
#, fuzzy, no-wrap
msgid "Controlling HTTP interaction timeout"
msgstr "HTTP インタラクションのタイムアウトの制御"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:168
msgid "When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:"
msgstr "テストで REST Assured を使用する場合、接続と応答のタイムアウトは 30 秒に設定されます。この設定は `quarkus.http.test-timeout`  プロパティーでオーバーライドできます:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:172
#, no-wrap
msgid "quarkus.http.test-timeout=10s\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:174
#, fuzzy, no-wrap
msgid "Injecting a URI"
msgstr "URIの注入"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:178
msgid "It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation."
msgstr "URLをテストに直接注入することも可能で、別のクライアントを使用するのが簡単になります。これは `@TestHTTPResource`  アノテーションで行います。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:181
msgid "Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :"
msgstr "静的なリソースをロードするための簡単なテストを書いてみましょう。まず、シンプルなHTMLファイルを `src/main/resources/META-INF/resources/index.html` に作成します:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:193
#, no-wrap
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Testing Guide</title>\n"
"    </head>\n"
"    <body>\n"
"        Information about testing\n"
"    </body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:196
msgid "We will create a simple test to ensure that this is being served correctly:"
msgstr "これが正しく提供されているかどうかを確認するための簡単なテストを作成します:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:207
#: upstream/_guides/getting-started-testing.adoc:282
#, no-wrap
msgid ""
"import java.io.ByteArrayOutputStream;\n"
"import java.io.IOException;\n"
"import java.io.InputStream;\n"
"import java.net.URL;\n"
"import java.nio.charset.StandardCharsets;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:210
#: upstream/_guides/getting-started-testing.adoc:285
#: upstream/_guides/getting-started-testing.adoc:372
#, no-wrap
msgid ""
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:213
#, no-wrap
msgid ""
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:216
#: upstream/_guides/getting-started-testing.adoc:292
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class StaticContentTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:219
#, no-wrap
msgid ""
"    @TestHTTPResource(\"index.html\") // <1>\n"
"    URL url;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:227
#, no-wrap
msgid ""
"    @Test\n"
"    public void testIndexHtml() throws Exception {\n"
"        try (InputStream in = url.openStream()) {\n"
"            String contents = readStream(in);\n"
"            Assertions.assertTrue(contents.contains(\"<title>Testing Guide</title>\"));\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:238
#: upstream/_guides/getting-started-testing.adoc:315
#, no-wrap
msgid ""
"    private static String readStream(InputStream in) throws IOException {\n"
"        byte[] data = new byte[1024];\n"
"        int r;\n"
"        ByteArrayOutputStream out = new ByteArrayOutputStream();\n"
"        while ((r = in.read(data)) > 0) {\n"
"            out.write(data, 0, r);\n"
"        }\n"
"        return new String(out.toByteArray(), StandardCharsets.UTF_8);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:240
msgid "This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL"
msgstr "このアノテーションを使用すると、QuarkusインスタンスのURLを直接注入することができます。アノテーションの値は、URLのパス部分になります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:242
msgid "For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL."
msgstr "今のところ `@TestHTTPResource`  では、URL の `URI` , `URL` , `String`  表現を注入することができます。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:243
#, no-wrap
msgid "Testing a specific endpoint"
msgstr "特定のエンドポイントのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:248
msgid "Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing."
msgstr "RESTassured と `@TestHTTPResource`  の両方で、パスをハードコーディングするのではなく、テストするエンドポイントクラスを指定することができます。これは現在、JAX-RS エンドポイント、サーブレット、リアクティブルートの両方をサポートしています。これにより、特定のテストがどのエンドポイントをテストしているかを正確に確認することが非常に簡単になりました。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:250
msgid "For the purposes of these examples I am going to assume we have an endpoint that looks like the following:"
msgstr "これらの例では、以下のようなエンドポイントを想定しています:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:255
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:262
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:266
msgid "This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path."
msgstr "これは現在、JAX-RS のコンテキストパスを設定するための `@ApplicationPath()`  アノテーションをサポートしていません。カスタムのコンテキストパスを設定したい場合は、代わりに `quarkus.resteasy.path`  の設定値を使用してください。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:267
#, no-wrap
msgid "TestHTTPResource"
msgstr "テストHTTPリソース"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:272
msgid "You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path."
msgstr "`io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用してエンドポイントのパスを指定することが出来、指定されたエンドポイントからパスが抽出されます。 `TestHTTPResource`  エンドポイントにも値を指定すると、エンドポイントパスの最後に追加されます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:289
#, no-wrap
msgid ""
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:296
#, no-wrap
msgid ""
"    @TestHTTPEndpoint(GreetingResource.class)  // <1>\n"
"    @TestHTTPResource\n"
"    URL url;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:304
#, no-wrap
msgid ""
"    @Test\n"
"    public void testIndexHtml() throws Exception {\n"
"        try (InputStream in = url.openStream()) {\n"
"            String contents = readStream(in);\n"
"            Assertions.assertTrue(contents.equals(\"hello\"));\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:318
msgid "Because `GreetingResource` is annotated with `@Path(\"/hello\")` the injected URL will end with `/hello`."
msgstr "`GreetingResource`  は `@Path(\"/hello\")`  とアノテーションされているので、注入された URL は `/hello`  で終わります。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:319
#, no-wrap
msgid "RESTassured"
msgstr "RESTassured"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:324
msgid "To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:"
msgstr "RESTassured ベースパス (すなわち、すべてのリクエストのルートとなるデフォルトパス) を制御するには、 `io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用できます。これはクラスやメソッドレベルで適用できます。グリーティングリソースをテストするには、以下のようにします:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:332
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:337
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.when;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:341
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestHTTPEndpoint(GreetingResource.class) //<1>\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:350
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        when().get()    //<2>\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:352
msgid "This tells RESTAssured to prefix all requests with `/hello`."
msgstr "これにより、RESTAssured はすべてのリクエストの前に `/hello` を付けます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:353
msgid "Note we don't need to specify a path here, as `/hello` is the default for this test"
msgstr "このテストでは `/hello`  がデフォルトなので、ここでパスを指定する必要はないことに注意してください。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:354
#, no-wrap
msgid "Injection into tests"
msgstr "テストへの注入"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:358
msgid "So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?"
msgstr "これまでは、HTTP エンドポイントを介してアプリをテストする統合スタイルのテストしか取り上げてきませんでしたが、ユニットテストを行い、Beanを直接テストしたい場合はどうでしょうか?"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:362
msgid "Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:"
msgstr "Quarkusでは、 `@Inject`  アノテーションを介してテストにCDI Beanを注入できるようにすることで、これをサポートしています(実際、Quarkusのテストは完全なCDI Beanなので、すべてのCDI機能を使用することができます)。HTTPを使用せずにグリーティングサービスを直接テストするシンプルなテストを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:369
#, no-wrap
msgid "import javax.inject.Inject;\n"
msgstr "import javax.inject.Inject;\n"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:374
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:377
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:380
#, no-wrap
msgid ""
"    @Inject // <1>\n"
"    GreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:386
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreetingService() {\n"
"        Assertions.assertEquals(\"hello Quarkus\", service.greeting(\"Quarkus\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:388
msgid "The `GreetingService` bean will be injected into the test"
msgstr "`GreetingService`  Beanがテストに注入されます。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:389
#, no-wrap
msgid "Applying Interceptors to Tests"
msgstr "テストへのインターセプターの適用"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:394
msgid "As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it."
msgstr "前述したように、Quarkusのテストは実際には完全なCDI Beanであり、通常のようにCDIインターセプターを適用することができます。例えば、トランザクションのコンテキスト内でテストメソッドを実行したい場合、 `@Transactional`  アノテーションをメソッドに適用するだけで、トランザクションインターセプターがそれを処理します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:397
msgid "In addition to this you can also create your own test stereotypes. For example we could create a `@TransactionalQuarkusTest` as follows:"
msgstr "これに加えて、独自のテスト・ステレオタイプを作成することもできます。例えば、次のように `@TransactionalQuarkusTest`  を作成することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:407
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@Stereotype\n"
"@Transactional\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"public @interface TransactionalQuarkusTest {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:411
msgid "If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:"
msgstr "このアノテーションをテストクラスに適用すると、 `@QuarkusTest`  と `@Transactional`  の両方のアノテーションを適用したかのように動作します。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:417
#, no-wrap
msgid ""
"@TransactionalQuarkusTest\n"
"public class TestStereotypeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:420
#, no-wrap
msgid ""
"    @Inject\n"
"    UserTransaction userTransaction;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:425
#, no-wrap
msgid ""
"    @Test\n"
"    public void testUserTransaction() throws Exception {\n"
"        Assertions.assertEquals(Status.STATUS_ACTIVE, userTransaction.getStatus());\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:429
#, no-wrap
msgid "Tests and Transactions"
msgstr "テストとトランザクション"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:435
msgid "You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes."
msgstr "テストでは標準のQuarkus `@Transactional`  アノテーションを使用することができますが、これは、テストでデータベースに加えた変更が永続化されることを意味します。テストの終了時に変更をロールバックしたい場合は、 `io.quarkus.test.TestTransaction`  アノテーションを使用することができます。これは、トランザクション内でテストメソッドを実行しますが、テストメソッドが完了したらロールバックして、データベースの変更を元に戻します。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:436
#, fuzzy, no-wrap
msgid "Enrichment via QuarkusTest*Callback"
msgstr "QuarkusTest*Callbackによるエンリッチメント"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:439
msgid "Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:"
msgstr "インターセプターの代わりに、あるいはインターセプターに加えて、以下のコールバックインターフェースを実装することで、 *すべての* `@QuarkusTest` クラスを充実させることができます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:441
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:442
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:443
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:444
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"
msgstr "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:446
msgid "Such a callback implementation has to be registered as a \"service provider\" as defined by `java.util.ServiceLoader`."
msgstr "このようなコールバックの実装は、 `java.util.ServiceLoader`  で定義されている「サービスプロバイダ」として登録する必要があります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:448
msgid "E.g. the following sample callback:"
msgstr "例えば、以下のようなサンプルコールバックです:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:454
#, no-wrap
msgid ""
"import io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback;\n"
"import io.quarkus.test.junit.callback.QuarkusTestMethodContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:456
#, no-wrap
msgid "public class MyQuarkusTestBeforeEachCallback implements QuarkusTestBeforeEachCallback {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:462
#, no-wrap
msgid ""
"    @Override\n"
"    public void beforeEach(QuarkusTestMethodContext context) {\n"
"        System.out.println(\"Executing \" + context.getTestMethod());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:464
msgid "has to be registered via `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` as follows:"
msgstr "これは、以下のように `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` で登録する必要があります:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:467
#, no-wrap
msgid "org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:470
msgid "It is possible to read annotations from the test class or method to control what the callback shall be doing."
msgstr "テストクラスやメソッドからアノテーションを読み込んで、コールバックが何をするかを制御することができます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:473
#, no-wrap
msgid ""
"While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has\n"
"         to run tests in a custom classloader which JUnit is not aware of.\n"
msgstr "`BeforeEachCallback` のような JUnit Jupiter コールバックインターフェイスを使うことも可能ですが、QuarkusはJUnitが把握しないカスタムクラスローダーでテストを実行する必要がある為、クラスローディングの問題にぶつかるかもしれません。\n"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:475
#, no-wrap
msgid "Testing Different Profiles"
msgstr "異なるプロファイルのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:480
msgid "So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shutdown at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations."
msgstr "これまでのところ、すべての例では、すべてのテストに対して一度だけQuarkusを起動しています。最初のテストが実行される前にQuarkusが起動し、次にすべてのテストが実行され、最後にQuarkusがシャットダウンします。これにより、非常に高速なテストが可能になりますが、異なる設定をテストすることができないため、少し制限があります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:484
msgid "To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility."
msgstr "この問題を回避するために、Quarkusはテストプロファイルの考え方をサポートしています。以前に実行したテストとは異なるプロファイルを持つテストがある場合、Quarkusはテストを実行する前にシャットダウンされ、新しいプロファイルで開始されます。これは、テスト時間にシャットダウン/起動サイクルが追加されるため、明らかに少し遅くなりますが、非常に大きな柔軟性が得られます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:490
#, fuzzy
msgid "In order to reduce the amount of times Quarkus needs to restart it is recommended that you place all tests that need a specific profile into their own package, and then run tests alphabetically.  Alternatively, you can register `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` as a global `ClassOrderer` in `junit-platform.properties` as described in the link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide]."
msgstr "Quarkusの再起動回数を減らすために、特定のプロファイルを必要とするすべてのテストをそれぞれのパッケージに入れ、アルファベット順にテストを実行することをお勧めします。あるいは、 link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide]に記載されているように、 `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` をグローバルに `ClassOrderer` を `junit-platform.properties` に登録することもできます。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:491
#, no-wrap
msgid "Writing a Profile"
msgstr "プロフィールの書き方"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:494
msgid "To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:"
msgstr "テストプロファイルを実装するには、 `io.quarkus.test.junit.QuarkusTestProfile` ."

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:503
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.List;\n"
"import java.util.Map;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:506
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTestProfile;\n"
"import io.quarkus.test.junit.QuarkusTestProfile.TestResourceEntry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:508
#, no-wrap
msgid "public class MockGreetingProfile implements QuarkusTestProfile {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:521
#, no-wrap
msgid ""
"    /**\n"
"     * Returns additional config to be applied to the test. This\n"
"     * will override any existing config (including in application.properties),\n"
"     * however existing config will be merged with this (i.e. application.properties\n"
"     * config will still take effect, unless a specific config key has been overridden).\n"
"     *\n"
"     * Here we are changing the JAX-RS root path.\n"
"     */\n"
"    @Override\n"
"    public Map<String, String> getConfigOverrides() {\n"
"        return Collections.singletonMap(\"quarkus.resteasy.path\",\"/api\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:532
#, no-wrap
msgid ""
"    /**\n"
"     * Returns enabled alternatives.\n"
"     *\n"
"     * This has the same effect as setting the 'quarkus.arc.selected-alternatives' config key,\n"
"     * however it may be more convenient.\n"
"     */\n"
"    @Override\n"
"    public Set<Class<?>> getEnabledAlternatives() {\n"
"        return Collections.singleton(MockGreetingService.class);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:543
#, no-wrap
msgid ""
"    /**\n"
"     * Allows the default config profile to be overridden. This basically just sets the quarkus.test.profile system\n"
"     * property before the test is run.\n"
"     *\n"
"     * Here we are setting the profile to test-mocked\n"
"     */\n"
"    @Override\n"
"    public String getConfigProfile() {\n"
"        return \"test-mocked\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:555
#, fuzzy, no-wrap
#| msgid "This method allows us to apply **additional** `QuarkusTestResourceLifecycleManager` classes, specific for this profile only. If this method is not overridden, then only the `QuarkusTestResourceLifecycleManager` classes enabled via the `@QuarkusTestResource` class annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all)."
msgid ""
"    /**\n"
"     * Additional {@link QuarkusTestResourceLifecycleManager} classes (along with their init params) to be used from this\n"
"     * specific test profile.\n"
"     *\n"
"     * If this method is not overridden, then only the {@link QuarkusTestResourceLifecycleManager} classes enabled via the {@link io.quarkus.test.common.QuarkusTestResource} class\n"
"     * annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).\n"
"     */\n"
"    @Override\n"
"    public List<TestResourceEntry> testResources() {\n"
"        return Collections.singletonList(new TestResourceEntry(CustomWireMockServerManager.class)); <4>\n"
"    }\n"
msgstr "このメソッドを使用すると、このプロファイル専用の `QuarkusTestResourceLifecycleManager`  クラスを *追加で* 適用することができます。このメソッドがオーバーライドされていない場合は、 `@QuarkusTestResource`  クラスアノテーションを介して有効化された `QuarkusTestResourceLifecycleManager`  クラスのみが、このプロファイルを使用するテストに使用されます (これは、プロファイルを全く使用しないテストと同じ動作です)。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:564
#, no-wrap
msgid ""
"    /**\n"
"     * If this is returns true then only the test resources returned from {@link #testResources()} will be started,\n"
"     * global annotated test resources will be ignored.\n"
"     */\n"
"    default boolean disableGlobalTestResources() {\n"
"        return false;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:574
#, no-wrap
msgid ""
"    /**\n"
"     * The tags this profile is associated with.\n"
"     * When the {@code quarkus.test.profile.tags} System property is set (its value is a comma separated list of strings)\n"
"     * then Quarkus will only execute tests that are annotated with a {@code @TestProfile} that has at least one of the\n"
"     * supplied (via the aforementioned system property) tags.\n"
"     */\n"
"    default Set<String> tags() {\n"
"        return Collections.emptySet();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:581
#, no-wrap
msgid ""
"    /**\n"
"     * The command line parameters that are passed to the main method on startup.\n"
"     */\n"
"    default String[] commandLineParameters() {\n"
"        return new String[0];\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:588
#, no-wrap
msgid ""
"    /**\n"
"     * If the main method should be run\n"
"     */\n"
"    default boolean runMainMethod() {\n"
"        return false;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:597
#, no-wrap
msgid ""
"    /**\n"
"     * If this method returns true then all {@code StartupEvent} and {@code ShutdownEvent} observers declared on application\n"
"     * beans should be disabled.\n"
"     */\n"
"    default boolean disableApplicationLifecycleObservers() {\n"
"        return false;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:600
msgid "Now we have defined our profile we need to include it on our test class. We do this with `@TestProfile(MockGreetingProfile.class)`."
msgstr "プロファイルを定義したので、それをテストクラスに含める必要があります。 `@TestProfile(MockGreetingProfile.class)` で、これを行うことが出来ます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:603
msgid "All the test profile config is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration."
msgstr "テストプロファイルの設定はすべて単一のクラスに保存されているので、前回のテストが同じ設定で実行されたかどうかが簡単にわかります。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:604
#, fuzzy, no-wrap
#| msgid "Testing a specific endpoint"
msgid "Running specific tests"
msgstr "特定のエンドポイントのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:608
#, fuzzy
msgid "Quarkus provides the ability to limit test execution to tests with specific `@TestProfile` annotations.  This works by leveraging the `tags` method of `QuarkusTestProfile` in conjunction with the `quarkus.test.profile.tags` system property."
msgstr "Quarkusでは、特定の `@TestProfile` アノテーションを持つテストにテストの実行を制限する機能を提供しています。これは、 `QuarkusTestProfile` の `tags` メソッドを `quarkus.test.profile.tags` システムプロパティと組み合わせて活用することで動作します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:612
#, fuzzy
msgid "Essentially, any `QuarkusTestProfile` with at least one matching tag matching the value of `quarkus.test.profile.tags` will be considered active and all the tests annotated with `@TestProfile` of active profiles, will be run while the rest will be skipped.  This is best shown in the following example."
msgstr "本質的には、 `quarkus.test.profile.tags` の値に少なくとも 1 つの一致するタグを持つ `QuarkusTestProfile` はすべてアクティブとみなされ、アクティブなプロファイルの `@TestProfile` でアノテーションされたすべてのテストが実行され、残りのテストはスキップされます。これは次の例で最もよく示されています。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:614
#, fuzzy
msgid "First let's define a few `QuarkusTestProfile` implementations like so:"
msgstr "まず、 `QuarkusTestProfile` の実装を以下のように定義してみましょう。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:617
#, no-wrap
msgid "public class Profiles {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:619
#, no-wrap
msgid "    public static class NoTags implements QuarkusTestProfile {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:621
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:628
#, no-wrap
msgid ""
"    public static class SingleTag implements QuarkusTestProfile {\n"
"        @Override\n"
"        public Set<String> tags() {\n"
"            return Collections.singleton(\"test1\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:636
#, no-wrap
msgid ""
"    public static class MultipleTags implements QuarkusTestProfile {\n"
"        @Override\n"
"        public Set<String> tags() {\n"
"            return new HashSet<>(Arrays.asList(\"test1\", \"test2\"));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:639
#, fuzzy
msgid "Now let's assume that we have the following tests:"
msgstr "では、次のようなテストがあると仮定してみましょう。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:644
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class NoQuarkusProfileTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:650
#: upstream/_guides/getting-started-testing.adoc:663
#: upstream/_guides/getting-started-testing.adoc:676
#: upstream/_guides/getting-started-testing.adoc:689
#, no-wrap
msgid ""
"    @Test\n"
"    public void test() {\n"
"        // test something\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:657
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.NoTags.class)\n"
"public class NoTagsTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:670
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.SingleTag.class)\n"
"public class SingleTagTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:683
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.MultipleTags.class)\n"
"public class MultipleTagsTest {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:692
#, fuzzy
msgid "Let's consider the following scenarios:"
msgstr "以下のシナリオを考えてみましょう。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:694
#, fuzzy
msgid "`quarkus.test.profile.tags` is not set: All tests will be executed."
msgstr "`quarkus.test.profile.tags` が設定されていません。すべてのテストが実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:696
#, fuzzy
msgid "`quarkus.test.profile.tags=foo`: In this case none of tests will be executed because none of the tags defined on the `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.  Note that `NoQuarkusProfileTest` is not executed either because it is not annotated with `@TestProfile`."
msgstr "`quarkus.test.profile.tags=foo`: この場合、 `QuarkusTestProfile` の実装で定義されたタグのどれも `quarkus.test.profile.tags` の値と一致しないため、どのテストも実行されません。 `NoQuarkusProfileTest` は `@TestProfile` とアノテーションされていないため、実行されないことに注意してください。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:698
#, fuzzy
msgid "`quarkus.test.profile.tags=test1`: In this case `SingleTagTest` and `MultipleTagsTest` will be run because the tags on their respective `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`."
msgstr "`quarkus.test.profile.tags=test1`: この場合、 `SingleTagTest` と `MultipleTagsTest` は、それぞれの `QuarkusTestProfile` 実装のタグが `quarkus.test.profile.tags` の値と一致するために実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:699
#, fuzzy
msgid "`quarkus.test.profile.tags=test1,test3`: This case results in the same tests being executed as the previous case."
msgstr "`quarkus.test.profile.tags=test1,test3`: このケースでは、前のケースと同じテストが実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:701
#, fuzzy
msgid "`quarkus.test.profile.tags=test2,test3`: In this case only `MultipleTagsTest` will be run because `MultipleTagsTest` is the only `QuarkusTestProfile` implementation whose `tags` method matches the value of `quarkus.test.profile.tags`."
msgstr "`quarkus.test.profile.tags=test2,test3`: `MultipleTagsTest` が `tags` メソッドが `quarkus.test.profile.tags` の値と一致する唯一の `QuarkusTestProfile` 実装であるため、この場合は `MultipleTagsTest` のみが実行されます。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:702
#, no-wrap
msgid "Mock Support"
msgstr "モックサポート"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:706
msgid "Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis."
msgstr "Quarkusでは、2つの異なるアプローチを使用したモックオブジェクトの使用をサポートしています。CDIの代替品を使用してすべてのテストクラスのBeanをモックアウトするか、 `QuarkusMock`  を使用してテストごとにBeanをモックアウトすることができます。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:707
#, no-wrap
msgid "CDI `@Alternative` mechanism."
msgstr "CDI `@Alternative`  メカニズム"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:713
msgid "To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:"
msgstr "これを使用するには、 `src/test/java`  ディレクトリーのクラスでモックしたいBeanをオーバーライドし、 `@Alternative`  と `@Priority(1)`  アノテーションをBeanに配置するだけです。あるいは、便利な `io.quarkus.test.Mock`  ステレオタイプアノテーションを使用することもできます。この組み込みステレオタイプは、 `@Alternative`  、 `@Priority(1)`  、 `@Dependent`  を宣言します。例えば、以下のようなサービスがあるとします:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:718
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ExternalService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:722
#, no-wrap
msgid ""
"    public String service() {\n"
"        return \"external\";\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:727
msgid "I could mock it with the following class in `src/test/java`:"
msgstr "`src/test/java`  で以下のクラスでモックできました:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:733
#, no-wrap
msgid ""
"@Mock\n"
"@ApplicationScoped // <1>\n"
"public class MockExternalService extends ExternalService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:739
#, no-wrap
msgid ""
"    @Override\n"
"    public String service() {\n"
"        return \"mock\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:741
msgid "Overrides the `@Dependent` scope declared on the `@Mock` stereotype."
msgstr "`@Mock`  ステレオタイプで宣言された `@Dependent`  スコープをオーバーライドします。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:744
msgid "It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing."
msgstr "代替品が `src/main/java`  ではなく `src/test/java`  ディレクトリーに存在することが重要です。そうでなければ、テスト以外も常に有効になってしまいます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:747
msgid "Note that at present this approach does not work with native image testing, as this would required the test alternatives to be baked into the native image."
msgstr "現在のところ、このアプローチはネイティブイメージテストでは機能しないことに注意してください。テスト代替品がネイティブイメージに焼き込まれる必要がある為です。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:749
#, fuzzy, no-wrap
msgid "Mocking using QuarkusMock"
msgstr "QuarkusMockを使ったモッキング"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:754
msgid "The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test."
msgstr "`io.quarkus.test.junit.QuarkusMock`  クラスは、通常のスコープ付きBeanを一時的にモックアウトするために使用することができます。 `@BeforeAll`  メソッドでこのメソッドを使用した場合、モックは現在のクラスのすべてのテストに対して有効になりますが、test メソッドでこれを使用した場合、モックは現在のテストの間のみ有効になります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:757
msgid "This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`)."
msgstr "この方法は、通常のスコープ付き CDI Bean(例: `@ApplicationScoped` , `@RequestScoped`  など、 `@Singleton`  と `@Dependent`  以外の基本的にすべてのスコープ)に対して使用することができます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:759
msgid "An example usage could look like:"
msgstr "使用例は次のようになります:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:764
#: upstream/_guides/getting-started-testing.adoc:836
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MockTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:767
#, no-wrap
msgid ""
"    @Inject\n"
"    MockableBean1 mockableBean1;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:770
#, no-wrap
msgid ""
"    @Inject\n"
"    MockableBean2 mockableBean2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:777
#, no-wrap
msgid ""
"    @BeforeAll\n"
"    public static void setup() {\n"
"        MockableBean1 mock = Mockito.mock(MockableBean1.class);\n"
"        Mockito.when(mock.greet(\"Stuart\")).thenReturn(\"A mock for Stuart\");\n"
"        QuarkusMock.installMockForType(mock, MockableBean1.class);  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:783
#, no-wrap
msgid ""
"    @Test\n"
"    public void testBeforeAll() {\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Hello Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:790
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPerTestMock() {\n"
"        QuarkusMock.installMockForInstance(new BonjourGreeter(), mockableBean2); // <2>\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Bonjour Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:793
#: upstream/_guides/getting-started-testing.adoc:863
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class MockableBean1 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:798
#: upstream/_guides/getting-started-testing.adoc:806
#: upstream/_guides/getting-started-testing.adoc:868
#, no-wrap
msgid ""
"        public String greet(String name) {\n"
"            return \"Hello \" + name;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:801
#: upstream/_guides/getting-started-testing.adoc:871
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class MockableBean2 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:814
#, no-wrap
msgid ""
"    public static class BonjourGreeter extends MockableBean2 {\n"
"        @Override\n"
"        public String greet(String name) {\n"
"            return \"Bonjour \" + name;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:816
msgid "As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods"
msgstr "インジェクションされたインスタンスはここでは利用できないので、 `installMockForType` を使用します。このモックは両方のテストメソッドに使用されます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:817
msgid "We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method."
msgstr "私たちは `installMockForInstance`  を使用して注入されたBeanを置き換えます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:820
msgid "Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require."
msgstr "Mockitoには依存しないことに注意してください。好きなモッキングライブラリを使うことができますし、必要な動作を提供するためにオブジェクトを手動でオーバーライドすることもできます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:824
#, fuzzy
msgid "Using `@Inject` will get you a CDI proxy to the mock instance you install, which is not suitable for passing to methods such as `Mockito.verify` which want the mock instance itself. So if you need to call methods such as `verify` you need to hang on to the mock instance in your test, or use `@InjectMock` as shown below."
msgstr "`@Inject` を使用すると、インストールしたモック・インスタンスへの CDI プロキシが得られますが、モック・インスタンス自体を必要とする `Mockito.verify` のようなメソッドに渡すのには適していません。そのため、 `verify` のようなメソッドを呼び出す必要がある場合は、テスト内でモックインスタンスを保持するか、以下のように `@InjectMock` を使用する必要があります。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:825
#, no-wrap
msgid "Further simplification with `@InjectMock`"
msgstr "`@InjectMock` での更なる単純化"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:829
msgid "Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency."
msgstr "`QuarkusMock`  で提供されている機能をベースに、Quarkusでは、 `QuarkusMock`  でサポートされているBeanをモックするために link:https://site.mockito.org/[Mockito を]簡単に利用できるようにしています。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectMock`  アノテーションを介して利用できます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:831
msgid "Using `@InjectMock`, the previous example could be written as follows:"
msgstr "`@InjectMock`  を使用すると、先ほどの例は次のように書くことができます:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:839
#, no-wrap
msgid ""
"    @InjectMock\n"
"    MockableBean1 mockableBean1; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:842
#, no-wrap
msgid ""
"    @InjectMock\n"
"    MockableBean2 mockableBean2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:847
#, no-wrap
msgid ""
"    @BeforeEach\n"
"    public void setup() {\n"
"        Mockito.when(mockableBean1.greet(\"Stuart\")).thenReturn(\"A mock for Stuart\"); // <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:853
#, no-wrap
msgid ""
"    @Test\n"
"    public void firstTest() {\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(null, mockableBean2.greet(\"Stuart\")); // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:860
#, no-wrap
msgid ""
"    @Test\n"
"    public void secondTest() {\n"
"        Mockito.when(mockableBean2.greet(\"Stuart\")).thenReturn(\"Bonjour Stuart\"); // <4>\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Bonjour Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:877
#, no-wrap
msgid ""
"        public String greet(String name) {\n"
"            return \"Hello \" + name;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:879
msgid "`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)"
msgstr "`@InjectMock` により、モックがテストクラスのテストメソッドに存在することになり、利用可能になります (他のテストクラスはこの影響を受け *ません* )。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:880
msgid "The `mockableBean1` is configured here for every test method of the class"
msgstr "クラスのすべてのテストメソッドに対して `mockableBean1`  が設定されています。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:881
msgid "Since the `mockableBean2` mock has not been configured, it will return the default Mockito response."
msgstr "`mockableBean2`  のモックが設定されていないので、デフォルトの Mockito レスポンスを返します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:882
msgid "In this test the `mockableBean2` is configured, so it returns the configured response."
msgstr "このテストでは、 `mockableBean2`  が設定されているので、設定されたレスポンスを返します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:886
msgid "Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:"
msgstr "上のテストは `@InjectMock`  の機能を示すのには良いですが、実際のテストを上手く表してはいません。実際のテストでは、ほとんどの場合、モックを設定し、モックされたBeanを使用するBeanをテストします。以下に例を示します:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:891
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MockGreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:894
#, no-wrap
msgid ""
"    @InjectMock\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:904
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreeting() {\n"
"        when(greetingService.greet()).thenReturn(\"hi\");\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hi\")); // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:907
#: upstream/_guides/getting-started-testing.adoc:971
#, no-wrap
msgid ""
"    @Path(\"greeting\")\n"
"    public static class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:909
#: upstream/_guides/getting-started-testing.adoc:973
#, no-wrap
msgid "        final GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:913
#: upstream/_guides/getting-started-testing.adoc:977
#, no-wrap
msgid ""
"        public GreetingResource(GreetingService greetingService) {\n"
"            this.greetingService = greetingService;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:920
#: upstream/_guides/getting-started-testing.adoc:984
#, no-wrap
msgid ""
"        @GET\n"
"        @Produces(\"text/plain\")\n"
"        public String greet() {\n"
"            return greetingService.greet();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:928
#: upstream/_guides/getting-started-testing.adoc:992
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class GreetingService {\n"
"        public String greet(){\n"
"            return \"hello\";\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:930
msgid "Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean"
msgstr "`greetingService`  をモックとして設定したので、 `GreetingService`  Beanを使用する `GreetingResource`  は、通常の `GreetingService` Beanのレスポンスの代わりにモックされたレスポンスを取得します。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:931
#, no-wrap
msgid "Using Spies instead of Mocks with `@InjectSpy`"
msgstr " `@InjectSpy` で、モックの代わりにスパイを使用する"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:935
msgid "Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency."
msgstr "`InjectMock`  で提供されている機能をベースに、 `QuarkusMock`  でサポートされているBeanをスパイするために link:https://site.mockito.org/[Mockito ]を簡単に利用できるようにしました。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectSpy`  アノテーションを介して利用できます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:939
msgid "Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:"
msgstr "テストを行う際に、特定の論理パスが取られたかどうかを確認するだけで済む場合もありますし、Spied クローン上で残りのメソッドを実行している間に、1つのメソッドのレスポンスをスタブアウトするだけで済む場合もあります。Spy パーシャル モックの詳細については link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito のドキュメント]を参照してください。いずれの場合も、オブジェクトの Spy が望ましいでしょう。 `@InjectSpy`  を使用して、先ほどの例は次のように書くことができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:944
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class SpyGreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:947
#, no-wrap
msgid ""
"    @InjectSpy\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:955
#, no-wrap
msgid ""
"    @Test\n"
"    public void testDefaultGreeting() {\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hello\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:958
#, no-wrap
msgid ""
"        Mockito.verify(greetingService, Mockito.times(1)).greet(); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:968
#, no-wrap
msgid ""
"    @Test\n"
"    public void testOverrideGreeting() {\n"
"        when(greetingService.greet()).thenReturn(\"hi\"); <2>\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hi\")); <3>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:994
msgid "Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test."
msgstr "値をオーバーライドするのではなく、 `GreetingService`  の greet メソッドがこのテストで呼び出されたことを確認したいだけです。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:995
msgid "Here we are telling the Spy to return \"hi\" instead of \"hello\". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean"
msgstr "ここでは、\"hello\"の代わりに\"hi\"を返すようにSpyに指示しています。 `GreetingResource`  が `GreetingService`  から挨拶を要求するとき、通常の `GreetingService`  Bean のレスポンスの代わりにモックされたレスポンスを取得します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:996
msgid "We are verifying that we get the mocked response from the Spy."
msgstr "私たちは、スパイからのモックされた応答を得ることを検証しています。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:997
#, no-wrap
msgid "Using `@InjectMock` with `@RestClient`"
msgstr "`@InjectMock`  との併用 `@RestClient`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1000
msgid "The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`."
msgstr "`@RegisterRestClient`  は、実行時に rest-client の実装を登録しています。Beanは通常のスコープである必要があるため、インターフェイスに `@ApplicationScoped` を付与する必要があります。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1007
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"@ApplicationScoped\n"
"@RegisterRestClient\n"
"public interface GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1013
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/hello\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    String hello();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1016
msgid "For the test class here is an example:"
msgstr "テストクラスの例です:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1025
#, no-wrap
msgid ""
"    @InjectMock\n"
"    @RestClient // <1>\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1029
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        Mockito.when(greetingService.hello()).thenReturn(\"hello from mockito\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1036
#, no-wrap
msgid ""
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello from mockito\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1040
msgid "Indicate that this injection point is meant to use an instance of `RestClient`."
msgstr "この注入ポイントが `RestClient`  のインスタンスを使用することを意味していることを示します。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1041
#, fuzzy, no-wrap
msgid "Mocking with Panache"
msgstr "パナッシュでモッキング"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1044
msgid "If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the link:hibernate-orm-panache#mocking[Hibernate ORM with Panache Mocking] and link:mongodb-panache#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access."
msgstr "`quarkus-hibernate-orm-panache`  や `quarkus-mongodb-panache` のエクステンションを使っている場合は、 link:hibernate-orm-panache#mocking[Hibernate ORM とPanache Mocking]や link:mongodb-panache#mocking[MongoDB とPanache Mocking]のドキュメントをチェックして、データアクセスをモックする最も簡単な方法を確認してください。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1045
#, no-wrap
msgid "Testing Security"
msgstr "セキュリティーのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1048
msgid "If you are using Quarkus Security, check out the link:security-testing[Testing Security] section for information on how to easily test security features of the application."
msgstr "Quarkus Securityを使用している場合、アプリケーションのセキュリティー機能を簡単にテストする方法については、「 link:security-testing[セキュリティーのテスト]」のセクションをご覧ください。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1050
#, fuzzy, no-wrap
msgid "Starting services before the Quarkus application starts"
msgstr "Quarkusアプリケーションの起動前にサービスを開始する"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1053
msgid "A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "非常に一般的なニーズは、Quarkusアプリケーションがテストを開始する前に、Quarkusアプリケーションに依存するいくつかのサービスを開始することです。このニーズに対応するために、Quarkusでは、 `@io.quarkus.test.common.QuarkusTestResource`  と `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を提供します。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1056
#, fuzzy
#| msgid "By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.  A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests."
msgid "By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.  A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests. When using multiple test resources they can be started concurrently. For that you need to set `@QuarkusTestResource(parallel = true)`."
msgstr "テストスイート内の任意のテストに `@QuarkusTestResource` をアノテーションするだけで、Quarkusは、テストを実行する前に対応する `QuarkusTestResourceLifecycleManager`  を実行します。テストスイートでは、複数の `@QuarkusTestResource`  アノテーションを自由に利用することもできます。この場合、対応するすべての `QuarkusTestResourceLifecycleManager`  オブジェクトがテストの前に実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1059
#, fuzzy
msgid "test resources are global, even if they are defined on a test class or custom profile, which means they will all be activated for all tests, even though we do remove duplicates. If you want to only enable a test resource on a single test class or test profile, you can use `@QuarkusTestResource(restrictToAnnotatedClass = true)`."
msgstr "テストリソースは、たとえテストクラスやカスタムプロファイルで定義されていても、グローバルなものです。単一のテストクラスやテストプロファイル上でのみテストリソースを有効にしたい場合は、 `@QuarkusTestResource(restrictToAnnotatedClass = true)`."

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1064
#, fuzzy
#| msgid "Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[here]), or starting a mock HTTP server using http://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here])."
msgid "Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus-quickstarts/blob/main/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[here]), or starting a mock HTTP server using http://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here])."
msgstr "Quarkusでは、 `QuarkusTestResourceLifecycleManager`  の実装がいくつか提供されていますが(H2データベースを起動する `io.quarkus.test.h2.H2DatabaseTestResource` や、モックKubernetes APIサーバーを起動する `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource`  を参照)、特定のアプリケーションのニーズに対応するためにカスタム実装を作成するのが一般的です。一般的なケースとしては、 link:https://www.testcontainers.org/[Testcontainers]を使ってdockerコンテナーを起動したり(その例は link:https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[こちら]にあります)、 link:http://wiremock.org/[Wiremock]を使ってモックHTTPサーバを起動したり(その例は link:https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[こちら]にあります)などがあります。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1066
#, fuzzy, no-wrap
#| msgid "Controlling the test port"
msgid "Altering the test class"
msgstr "テストポートの制御"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1069
#, fuzzy
msgid "When creating a custom `QuarkusTestResourceLifecycleManager` that needs to inject the something into the test class, the `inject` methods can be used.  If for example you have a test like the following:"
msgstr "テストクラスにsomethingを注入する必要のあるカスタム `QuarkusTestResourceLifecycleManager` を作成する場合、 `inject` のメソッドを使用することができます。たとえば、次のようなテストがあるとします。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1075
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(MyWireMockResource.class)\n"
"public class MyTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1078
#, no-wrap
msgid ""
"    @InjectWireMock // this a custom annotation you are defining in your own application\n"
"    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1084
#, no-wrap
msgid ""
"    @Test\n"
"    public someTest() {\n"
"        // control wiremock in some way and perform test\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1087
#, fuzzy
msgid "Making `MyWireMockResource` inject the `wireMockServer` field can be done as shown in the `inject` method of the following code snippet:"
msgstr "`MyWireMockResource` に `wireMockServer` フィールドを注入させることは、以下のコードスニペットの `inject` メソッドに示すように行うことができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1091
#, no-wrap
msgid "public class MyWireMockResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1093
#, no-wrap
msgid "    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1098
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        wireMockServer = new WireMockServer(8090);\n"
"        wireMockServer.start();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1100
#, no-wrap
msgid "        // create some stubs\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1103
#, no-wrap
msgid ""
"        return Map.of(\"some.service.url\", \"localhost:\" + wireMockServer.port());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1111
#, no-wrap
msgid ""
"    @Override\n"
"    public synchronized void stop() {\n"
"        if (wireMockServer != null) {\n"
"            wireMockServer.stop();\n"
"            wireMockServer = null;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1117
#, no-wrap
msgid ""
"    @Override\n"
"    public void inject(TestInjector testInjector) {\n"
"        testInjector.injectIntoFields(wireMockServer, new TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1121
#, fuzzy
msgid "It is worth mentioning that this injection into the test class is not under the control of CDI and happens after CDI has performed any necessary injections into the test class."
msgstr "このテストクラスへの注入は、CDI の制御下にはなく、CDI がテストクラスに必要な注入を行った後に行われることに注意してください。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1122
#, fuzzy, no-wrap
msgid "Annotation-based test resources"
msgstr "アノテーションベースのテストリソース"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1126
#, fuzzy
msgid "It is possible to write test resources that are enabled and configured using annotations. This is enabled by placing the `@QuarkusTestResource` on an annotation which will be used to enable and configure the test resource."
msgstr "アノテーションを使用して有効化・設定されたテストリソースを記述することができます。これは、テスト リソースの有効化と設定に使用されるアノテーションに `@QuarkusTestResource` を配置することで有効になります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1129
#, fuzzy
msgid "For example, this defines the `@WithKubernetesTestServer` annotation, which you can use on your tests to activate the `KubernetesServerTestResource`, but only for the annotated test class. You can also place them on your `QuarkusTestProfile` test profiles."
msgstr "例えば、これは `@WithKubernetesTestServer` アノテーションを定義しています。これは、 `KubernetesServerTestResource` を有効にするためにテストで使用できますが、アノテーションされたテストクラスに対してのみ使用できます。また、 `QuarkusTestProfile` テストプロファイルに配置することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1140
#, no-wrap
msgid ""
"@QuarkusTestResource(KubernetesServerTestResource.class)\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"public @interface WithKubernetesTestServer {\n"
"    /**\n"
"     * Start it with HTTPS\n"
"     */\n"
"    boolean https() default false;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1145
#, no-wrap
msgid ""
"    /**\n"
"     * Start it in CRUD mode\n"
"     */\n"
"    boolean crud() default true;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1151
#, no-wrap
msgid ""
"    /**\n"
"     * Port to use, defaults to any available port\n"
"     */\n"
"    int port() default 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1155
#, fuzzy
msgid "The `KubernetesServerTestResource` class has to implement the `QuarkusTestResourceConfigurableLifecycleManager` interface in order to be configured using the previous annotation:"
msgstr "`KubernetesServerTestResource` クラスは、前のアノテーションを使って設定するために `QuarkusTestResourceConfigurableLifecycleManager` インターフェースを実装しなければなりません。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1160
#, no-wrap
msgid ""
"public class KubernetesServerTestResource\n"
"        implements QuarkusTestResourceConfigurableLifecycleManager<WithKubernetesTestServer> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1164
#, no-wrap
msgid ""
"    private boolean https = false;\n"
"    private boolean crud = true;\n"
"    private int port = 0;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1171
#, no-wrap
msgid ""
"    @Override\n"
"    public void init(WithKubernetesTestServer annotation) {\n"
"        this.https = annotation.https();\n"
"        this.crud = annotation.crud();\n"
"        this.port = annotation.port();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1174
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1176
#, fuzzy, no-wrap
msgid "Hang Detection"
msgstr "ハング検出"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1181
#, fuzzy
msgid "`@QuarkusTest` has support for hang detection to help diagnose any unexpected hangs. If no progress is made for a specified time (i.e. no JUnit callbacks are invoked) then Quarkus will print a stack trace to the console to help diagnose the hang.  The default value for this timeout is 10 minutes."
msgstr "`@QuarkusTest` は、予期せぬハングを診断するのに役立つハング検出をサポートしています。指定した時間が経過しても何も進展がない (つまり JUnit コールバックが起動されていない) 場合は、スタックトレースをコンソールに出力してハングの診断に役立てます。このタイムアウトのデフォルト値は 10 分です。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1186
#, fuzzy
msgid "No further action will be taken, and the tests will continue as normal (generally until CI times out), however the printed stack traces should help diagnose why the build has failed. You can control this timeout with the `quarkus.test.hang-detection-timeout` system property (you can also set this in application.properties, but this won't be read until Quarkus has started, so the timeout for Quarkus start will be the default of 10 minutes)."
msgstr "それ以上のアクションは行われず、テストは通常通り（通常はCIがタイムアウトするまで）継続されますが、スタックトレースの印刷は、ビルドが失敗した理由を診断するのに役立つはずです。このタイムアウトは、 `quarkus.test.hang-detection-timeout` systemプロパティで制御できます（application.propertiesで設定することもできますが、Quarkusが起動するまで読み込まれないので、Quarkus起動時のタイムアウトはデフォルトの10分になります）。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1187
#, no-wrap
msgid "Native Executable Testing"
msgstr "ネイティブ実行可能ファイルテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1191
msgid "It is also possible to test native executables using `@NativeImageTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible)."
msgstr "`@NativeImageTest` を使用してネイティブ実行ファイルをテストすることも可能です。これは、テストに注入すること(そして、ネイティブ実行可能ファイルは別の非JVMプロセスで実行されることーこれは実際には可能ではありません)を除いて、このガイドで述べたすべての機能をサポートしています。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1194
msgid "This is covered in the link:building-native-image[Native Executable Guide]."
msgstr "これは link:building-native-image[ネイティブ実行可能ファイルガイド] で説明されています。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1199
#, fuzzy
msgid "Although `@NativeImageTest` is not yet deprecated, it will be in the future as its functionality is covered by `@QuarkusIntegrationTest` which is described in the following section."
msgstr "`@NativeImageTest` はまだ非推奨ではありませんが、その機能は次のセクションで説明する `@QuarkusIntegrationTest` でカバーされているため、将来的には非推奨となります。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1202
#, fuzzy, no-wrap
msgid "Using @QuarkusIntegrationTest"
msgstr "QuarkusIntegrationTestの使用"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1209
#, fuzzy
msgid "`@QuarkusIntegrationTest` should be used to launch and test the artifact produced by the Quarkus build, and supports testing a jar (of whichever type), a native image or container image.  Put simply, this means that if the result of a Quarkus build (`mvn package` or `gradle build`) is a jar, that jar will be launched as `java -jar ...` and tests run against it.  If instead a native image was built, then the application is launched as `./application ...` and again the tests run against the running application.  Finally, if a container image was created during the build (by including the `quarkus-container-image-jib` or `quarkus-container-image-docker` extensions and having the `quarkus.container-image.build=true` property configured), then a container is created and run (this requires the `docker` executable being present)."
msgstr "`@QuarkusIntegrationTest` は、Quarkusのビルドによって生成されたアーティファクトを起動してテストするために使用されるべきであり、（あらゆるタイプの）jar、ネイティブイメージ、コンテナイメージのテストをサポートしています。簡単に言うと、Quarkusのビルド（ `mvn package` または `gradle build` ）の結果がjarである場合、そのjarは `java -jar …​` として起動され、それに対してテストが実行されるということです。代わりにネイティブイメージがビルドされた場合は、アプリケーションが `./application …​` として起動され、実行中のアプリケーションに対してテストが実行されます。最後に、ビルド時にコンテナイメージが作成されていた場合（ `quarkus-container-image-jib` または `quarkus-container-image-docker` 拡張機能を使用し、 `quarkus.container-image.build=true` プロパティが設定されていた場合）、コンテナが作成され、実行されます（これには `docker` 実行可能ファイルが必要です）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1211
#, fuzzy
msgid "As is the case with `@NativeImageTest`, this is a black box test that supports the same set features and has the same limitations."
msgstr "`@NativeImageTest` の場合と同様に、これは同じセット機能をサポートするブラックボックステストであり、同じ制限があります。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1216
#, fuzzy
msgid "As a test annotated with `@QuarkusIntegrationTest` tests the result of the build, it should be run as part of the integration test suite - i.e. via the `maven-failsafe-plugin` if using Maven or an additional task if using Gradle.  These tests will **not** work if run in the same phase as `@QuarkusTest` as Quarkus has not yet created the final artifact."
msgstr "`@QuarkusIntegrationTest` はビルドの結果をテストするため、統合テストスイートの一部として実行する必要があります。すなわち、Mavenを使用している場合は `maven-failsafe-plugin` 、Gradleを使用している場合は追加のタスクを介して実行します。これらのテストは、 `@QuarkusTest` と同じフェーズで実行すると、Quarkusがまだ最終的なアーティファクトを作成していないため、機能し *ませ*ん。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1218
#, fuzzy, no-wrap
msgid "Launching containers"
msgstr "コンテナの起動"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1223
#, fuzzy
msgid "When `@QuarkusIntegrationTest` results in launching a container (because the application was built with `quarkus.container-image.build` set to `true`), the container is launched on a predictable container network. This facilitates writing integration tests that need to launch services to support the application.  This means that `@QuarkusIntegrationTest` works out of the box with containers launched via link:dev-services[Dev Services], but it also means that it enables using <<quarkus-test-resource,QuarkusTestLifecycleManager>> resources that launch additional containers.  This can be achieved by having your `QuarkusTestLifecycleManager` implement `io.quarkus.test.common.DevServicesContext.ContextAware`. A simple example could be the following:"
msgstr "`@QuarkusIntegrationTest` の結果、コンテナが起動した場合（アプリケーションが `quarkus.container-image.build` を `true` に設定してビルドされたため）、コンテナは予測可能なコンテナネットワーク上で起動します。これにより、アプリケーションをサポートするためにサービスを起動する必要がある統合テストの作成が容易になります。つまり、 `@QuarkusIntegrationTest` は、 link:dev-services[Dev Services]を介して起動されたコンテナですぐに動作しますが、追加のコンテナを起動する link:#quarkus-test-resource[QuarkusTestLifecycleManager]リソースの使用も可能です。これは、 `QuarkusTestLifecycleManager` が `io.quarkus.test.common.DevServicesContext.ContextAware` を実装することで実現できます。簡単な例を挙げると、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1228
#, no-wrap
msgid ""
"import io.quarkus.test.common.DevServicesContext;\n"
"import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1232
#, no-wrap
msgid ""
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1234
#, no-wrap
msgid "public class CustomResource implements QuarkusTestResourceLifecycleManager, DevServicesContext.ContextAware {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1236
#, no-wrap
msgid "    private Optional<String> containerNetworkId;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1241
#, no-wrap
msgid ""
"    @Override\n"
"    public void setIntegrationTestContext(DevServicesContext context) {\n"
"        containerNetworkId = context.containerNetworkId();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1245
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        // start a container making sure to call withNetworkMode() with the value of containerNetworkId if present\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1249
#, no-wrap
msgid ""
"        // return a map containing the configuration the application needs to use the service\n"
"        return new HashMap<>();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1255
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        // close container\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1258
#, fuzzy
msgid "`CustomResource` would be activated on a `@QuarkusIntegrationTest` using `@QuarkusTestResource` as is described in the corresponding section of this doc."
msgstr "`CustomResource` は、このドキュメントの対応するセクションで説明されているように、 `@QuarkusTestResource` を使用して `@QuarkusIntegrationTest` で起動されます。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1259
#, fuzzy, no-wrap
msgid "Executing against a running application"
msgstr "実行中のアプリケーションに対して実行する"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1264
#, fuzzy
msgid "This feature is considered experimental and is likely to change in future versions of Quarkus."
msgstr "この機能は実験的なものであり、Quarkusの将来のバージョンで変更される可能性があります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1268
#, fuzzy
msgid "`@QuarkusIntegrationTest` supports executing tests against an already running instance of the application. This can be achieved by setting the `quarkus.http.test-host` system property when running the tests."
msgstr "`@QuarkusIntegrationTest` は、すでに実行されているアプリケーションのインスタンスに対してテストを実行することをサポートしています。これは、テストの実行時に `quarkus.http.test-host` のシステムプロパティを設定することで実現できます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1270
#, fuzzy
msgid "An example use of this could be the following Maven command, that forces `@QuarkusIntegrationTest` to execute against that is accessible at `http://1.2.3.4:4321`:"
msgstr "例えば、次のようなMavenコマンドを使用すると、 `@QuarkusIntegrationTest` 、以下の場所でアクセス可能なものに対して実行させることができます。 `&lt;a href=\"http://1.2.3.4:4321\" class=\"bare\"&gt;http://1.2.3.4:4321&lt;/a&gt;`:"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1274
#, no-wrap
msgid "./mvnw verify -Dquarkus.http.test-host=1.2.3.4 -Dquarkus.http.test-port=4321\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1277
#, fuzzy, no-wrap
msgid "Mixing `@QuarkusTest` with other type of tests"
msgstr "`@QuarkusTest` と他のタイプのテストの混合"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1282
#, fuzzy
msgid "Mixing tests annotated with `@QuarkusTest` with tests annotated with either `@QuarkusDevModeTest`, `@QuarkusProdModeTest` or `@QuarkusUnitTest` is not allowed in a single execution run (in a single Maven Surefire Plugin execution, for instance), while the latter three can coexist."
msgstr "`@QuarkusTest` でアノテーションされたテストと、 `@QuarkusDevModeTest` 、 `@QuarkusProdModeTest` 、 `@QuarkusUnitTest` のいずれかでアノテーションされたテストを混在させることは、1回の実行（例えば、1回の Maven Surefire Plugin の実行）では許可されていませんが、後者の3つは共存可能となっています。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1285
#, fuzzy
msgid "The reason of this restriction is that `@QuarkusTest` starts a Quarkus server for the whole lifetime of the tests execution run, thus preventing the other tests to start their own Quarkus server."
msgstr "この制限の理由は、 `@QuarkusTest` がテスト実行中の全期間に渡ってQuarkusサーバーを起動するため、他のテストが自分のQuarkusサーバーを起動するのを妨げることにあります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1288
#, fuzzy
msgid "To alleviate this restriction, the `@QuarkusTest` annotation defines a JUnit 5 `@Tag`: `io.quarkus.test.junit.QuarkusTest`.  You can use this tag to isolate the `@QuarkusTest` test in a specific execution run, for example with the Maven Surefire Plugin:"
msgstr "この制限を緩和するために、 `@QuarkusTest` アノテーションは JUnit 5 の `@Tag`: `io.quarkus.test.junit.QuarkusTest` を定義しています。このタグを使うと、例えば Maven Surefire Plugin のように、 `@QuarkusTest` のテストを特定の実行時に隔離することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1320
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <id>default-test</id>\n"
"            <goals>\n"
"                <goal>test</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <excludedGroups>io.quarkus.test.junit.QuarkusTest</excludedGroups>\n"
"            </configuration>\n"
"        </execution>\n"
"        <execution>\n"
"            <id>quarkus-test</id>\n"
"            <goals>\n"
"                <goal>test</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <groups>io.quarkus.test.junit.QuarkusTest</groups>\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"    <configuration>\n"
"        <systemProperties>\n"
"            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"        </systemProperties>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1323
#, no-wrap
msgid "Running `@QuarkusTest` from an IDE"
msgstr "IDE から `@QuarkusTest`  を実行する"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1326
#, fuzzy
#| msgid "Most IDEs offer the possibility to run a selected class as JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:"
msgid "Most IDEs offer the possibility to run a selected class as a JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:"
msgstr "ほとんどの IDE では、選択したクラスを JUnit テストとして直接実行できるようになっています。そのためには、選択した IDE の設定でいくつかのプロパティーを設定する必要があります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1328
msgid "`java.util.logging.manager` (see link:logging[Logging Guide])"
msgstr "`java.util.logging.manager`  (ロ link:logging[ギングガイド]を参照)"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1330
#, fuzzy
msgid "`maven.home` (only if there are any custom settings in `${maven.home}/conf/settings.xml`, see link:maven-tooling[Maven Guide])"
msgstr "`maven.home` ( `${maven.home}/conf/settings.xml` にカスタム設定がある場合のみ、 link:maven-tooling[Mavenガイドを] 参照してください)"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1332
msgid "`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)"
msgstr "`maven.settings`  (カスタム版の `settings.xml`  ファイルをテストに使用する場合)"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1333
#, fuzzy, no-wrap
msgid "Eclipse separate JRE definition"
msgstr "Eclipse別のJREの定義"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1336
msgid "Copy your current \"Installed JRE\" definition into a new one, where you will add the properties as a new VM arguments:"
msgstr "現在の\"Installed JRE\"定義を新しい定義にコピーし、新しいVMの引数としてプロパティーを追加します:"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1338
msgid "`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`"
msgstr "`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1340
msgid "`-Dmaven.home=<path-to-your-maven-installation>`"
msgstr "`-Dmaven.home=&amp;lt;path-to-your-maven-installation&amp;gt;`"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1342
msgid "Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any \"Run as JUnit\" configuration."
msgstr "このJRE定義をQuarkusプロジェクトのターゲットランタイムとして使用すると、「Run as JUnit」設定に回避策が適用されます。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1343
#, no-wrap
msgid "VSCode \"run with\" configuration"
msgstr "VSCode \"run with\" 設定"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1346
#, fuzzy
#| msgid "The `settings.json` placed in the root of your project directory or in the workspace will need the workaround in your test configuration:"
msgid "The `settings.json` placed in the root of your project directory or in the workspace will need the following workaround in your test configuration:"
msgstr "プロジェクトディレクトリーやワークスペースのルートにある `settings.json`  は、テスト設定で回避策が必要です。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1356
#, no-wrap
msgid ""
"\"java.test.config\": [\n"
"    {\n"
"        \"name\": \"quarkusConfiguration\",\n"
"        \"vmargs\": [ \"-Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dmaven.home=<path-to-your-maven-installation> ...\" ],\n"
"        ...\n"
"    },\n"
"  ...\n"
"]\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1358
#, fuzzy, no-wrap
msgid "IntelliJ JUnit template"
msgstr "IntelliJ JUnit テンプレート"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1361
msgid "Nothing needed in IntelliJ because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`."
msgstr "IntelliJでは何も必要ありません。なぜなら、IDEは `systemPropertyVariables` を `pom.xml`のsurefireプラグイン設定から取得するからです。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1362
#, fuzzy, no-wrap
#| msgid "Testing Security"
msgid "Testing Dev Services"
msgstr "セキュリティーのテスト"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1366
#, fuzzy
msgid "By default tests should just work with link:dev-services[Dev Services], however from some use cases you may need access to the automatically configured properties in your tests."
msgstr "デフォルトでは、テストは link:dev-services[開発サービス]だけで動作するようになっていますが、ユースケースによっては、テストで自動的に構成されたプロパティにアクセスする必要があります。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1371
#, fuzzy
msgid "You can do this with `io.quarkus.test.common.DevServicesContext`, which can be injected directly into any `@QuarkusTest` or `@QuarkusIntegrationTest`. All you need to do is define a field of type `DevServicesContext` and it will be automatically injected. Using this you can retrieve any properties that have been set. Generally this is used to directly connect to a resource from the test itself, e.g. to connect to kafka to send messages to the application under test."
msgstr "これを実現するには、 `io.quarkus.test.common.DevServicesContext` を使って、 `@QuarkusTest` や `@QuarkusIntegrationTest` に直接注入することができます。必要なのは、 `DevServicesContext` タイプのフィールドを定義することだけで、それは自動的に注入されます。これを使って、設定されているプロパティを取得することができます。一般的には、テスト自体からリソースに直接接続するために使用します。例えば、kafka に接続してテスト対象のアプリケーションにメッセージを送信する場合などです。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1376
#, fuzzy
msgid "Injection is also supported into objects that implement `io.quarkus.test.common.DevServicesContext.ContextAware`. If you have a field that implements `io.quarkus.test.common.DevServicesContext.ContextAware` Quarkus will call the `setIntegrationTestContext` method to pass the context into this object. This allows client logic to be encapsulated in a utility class."
msgstr "また、 `io.quarkus.test.common.DevServicesContext.ContextAware` を実装したオブジェクトへの注入もサポートされています。 `io.quarkus.test.common.DevServicesContext.ContextAware` を実装したフィールドがある場合、Quarkusは `setIntegrationTestContext` メソッドを呼び出し、このオブジェクトにコンテキストを渡します。これにより、クライアントロジックをユーティリティクラスにカプセル化することができます。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1379
#, fuzzy
msgid "`QuarkusTestResourceLifecycleManager` implementations can also implement `ContextAware` to get access to these properties, which allows you to setup the resource before Quarkus starts (e.g. configure a KeyCloak instance, add data to a database etc)."
msgstr "`QuarkusTestResourceLifecycleManager` の実装では、これらのプロパティにアクセスするために `ContextAware` を実装することもできます。これにより、Quarkusの起動前にリソースを設定することができます（KeyCloakインスタンスの設定、データベースへのデータの追加など）。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1385
#, fuzzy
msgid "For `@QuarkusIntegrationTest` tests that result in launcher the application as a container, `io.quarkus.test.common.DevServicesContext` also provides access to the id of the container network on which the application container was launched (via the `containerNetworkId` method).  This can be used by `QuarkusTestResourceLifecycleManager` that need to launch additional containers that the application will communicate with."
msgstr "アプリケーションをコンテナとして起動する `@QuarkusIntegrationTest` のテストでは、 `io.quarkus.test.common.DevServicesContext` は、アプリケーション・コンテナが起動されたコンテナ・ネットワークの ID へのアクセスも提供します（ `containerNetworkId` メソッド経由）。これは、アプリケーションが通信する追加のコンテナを起動する必要がある `QuarkusTestResourceLifecycleManager` が使用できます。"

#~ msgid "This method allows us to override configuration properties. Here we are changing the JAX-RS root path."
#~ msgstr "この方法では、設定プロパティーをオーバーライドすることができます。ここでは、JAX-RSのルートパスを変更しています。"

#~ msgid "This method allows us to enable CDI `@Alternative` beans. This makes it easy to mock out certain beans functionality."
#~ msgstr "このメソッドを使うことで、CDI `@Alternative`  Beanを有効にすることができます。これにより、特定のBeanの機能を簡単にモックアウトすることができます。"

#~ msgid "This can be used to change the config profile. As this default is `test` this does nothing, but is included for completeness."
#~ msgstr "これは設定プロファイルを変更するために使用できます。このデフォルトは `test`  なので、これは何もしませんが、完全性を保つために含まれています。"

#~ msgid "In order to reduce the amount of times Quarkus needs to restart it is recommended that you place all tests that need a specific profile into their own package, and then run tests alphabetically."
#~ msgstr "Quarkusの再起動の回数を減らすために、特定のプロファイルを必要とするすべてのテストを独自のパッケージに入れ、アルファベット順にテストを実行することをお勧めします。"

#~ msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback` has been deprecated in favor of `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback` and will be removed in future releases of Quarkus"
#~ msgstr "`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback`  は `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`  に代わって非推奨となり、Quarkusの将来のリリースでは削除される予定です。"
