# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-23 11:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/vertx.adoc:6
#, fuzzy, no-wrap
msgid "Quarkus - Using Eclipse Vert.x"
msgstr "Quarkus - Eclipse Vert.xの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:13
#, fuzzy
msgid "Eclipse https://vertx.io[Vert.x] is a toolkit for building reactive applications.  It is designed to be lightweight and embeddable.  Vert.x defines a reactive execution model and provides a large ecosystem."
msgstr "Eclipse link:https://vertx.io[Vert.x] は、リアクティブなアプリケーションを構築するためのツールキットです。軽量で埋め込み可能なように設計されています。Vert.xはリアクティブ実行モデルを定義し、大規模なエコシステムを提供します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:18
#, fuzzy
msgid "Quarkus is based on Vert.x, and almost all network-related features rely on Vert.x.  While lots of reactive features from Quarkus don't _show_ Vert.x, it's used underneath.  Quarkus also integrates smoothly with the Vert.x event bus (to enable asynchronous messaging passing between application components) and some reactive clients.  You can also use various Vert.x APIs in your Quarkus application, such as deploying _verticles_, instantiating clients..."
msgstr "QuarkusはVert.xをベースにしており、ほとんどすべてのネットワーク関連機能はVert.xに依存しています。Quarkusのリアクティブ機能の多くはVert.xを _表示して_ いませんが、その下で使用されています。また、Quarkusは、Vert.xイベントバス(アプリケーションコンポーネント間の非同期メッセージングの受け渡しを可能にするため)やいくつかのリアクティブクライアントとスムーズに統合されています。また、Quarkusアプリケーションでは、さまざまなVert.x APIを使用することができます(例えば、 _バーティクル_ のデプロイ、クライアントのインスタンス化など)。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:20
#, fuzzy, no-wrap
msgid "Installing"
msgstr "インストール"

#. type: Plain text
#: upstream/_guides/vertx.adoc:24
#, fuzzy
msgid "To access Vert.x, well, you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter are follows:"
msgstr "Vert.xにアクセスするには、まあ、この機能を利用するには、 `vertx` 拡張機能を有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:34
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vertx-quickstart \\\n"
"    -DclassName=\"org.acme.vertx.GreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"resteasy,vertx\"\n"
"cd vertx-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:38
#, fuzzy
msgid "If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:"
msgstr "すでに作成済みのプロジェクトがある場合は、 `vertx` 拡張機能を既存のQuarkusプロジェクトに `add-extension` コマンドで追加することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:42
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"vertx\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:45
#, fuzzy
msgid "Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:"
msgstr "そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:52
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vertx.adoc:54
#, fuzzy, no-wrap
msgid "Native Transport"
msgstr "ネイティブトランスポート"

#. type: Plain text
#: upstream/_guides/vertx.adoc:60
#, fuzzy
msgid "Vert.x is capable of using https://netty.io/wiki/native-transports.html[Netty's native transports] which offers performance improvements on certain platforms. To enable them you must include the appropriate dependency for your platform. It's usually a good idea to include both to keep your application platform agnostic. Netty is smart enough to use the correct one, that includes none at all on unsupported platforms:"
msgstr "Vert.x は link:https://netty.io/wiki/native-transports.html[Netty のネイティブトランスポートを] 使用することができ、特定のプラットフォームでパフォーマンスを向上させることができます。これを有効にするには、プラットフォームに応じた適切な依存関係を含める必要があります。通常、アプリケーションのプラットフォームに依存しないようにするために、両方を含めるのが良いでしょう。Netty は、サポートされていないプラットフォームでは何も含まれていない正しい方を使うようにしています。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:68
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.netty</groupId>\n"
"  <artifactId>netty-transport-native-epoll</artifactId>\n"
"  <classifier>linux-x86_64</classifier>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:74
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.netty</groupId>\n"
"  <artifactId>netty-transport-native-kqueue</artifactId>\n"
"  <classifier>osx-x86_64</classifier>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:77
#, fuzzy
msgid "You will also have to explicitly configure Vert.x to use the native transport. In `application.properties` add:"
msgstr "また、ネイティブトランスポートを使用するために Vert.x を明示的に設定する必要があります。 `application.properties` で追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:81
#, no-wrap
msgid "quarkus.vertx.prefer-native-transport=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:84
#, fuzzy
msgid "Or in `application.yml`:"
msgstr "または `application.yml` ."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:90
#, no-wrap
msgid ""
"quarkus:\n"
"  vertx:\n"
"    prefer-native-transport: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:93
#, fuzzy
msgid "If all is well quarkus will log:"
msgstr "すべてがうまくいけば、クァーカスはログを取ります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:96
#, no-wrap
msgid "[io.qua.ver.cor.run.VertxCoreRecorder] (main) Vertx has Native Transport Enabled: true\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vertx.adoc:98
#, fuzzy, no-wrap
msgid "Native Linux Transport"
msgstr "ネイティブリナックストランスポート"

#. type: Plain text
#: upstream/_guides/vertx.adoc:101
#, fuzzy
msgid "On Linux you can enable the following socket options:"
msgstr "Linuxでは、以下のソケットオプションを有効にすることができます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:103 upstream/_guides/vertx.adoc:124
#, fuzzy
msgid "SO_REUSEPORT"
msgstr "SOREUSEPORT"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:105 upstream/_guides/vertx.adoc:126
#, no-wrap
msgid "quarkus.http.so-reuse-port=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:107
#, fuzzy
msgid "TCP_QUICKACK"
msgstr "TCP_QUICKACK"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:109
#, no-wrap
msgid "quarkus.http.tcp-quick-ack=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:111
#, fuzzy
msgid "TCP_CORK"
msgstr "TCP_CORK"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:113
#, no-wrap
msgid "quarkus.http.tcp-cork=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:115
#, fuzzy
msgid "TCP_FASTOPEN"
msgstr "TCP_FASTOPEN"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:117
#, no-wrap
msgid "quarkus.http.tcp-fast-open=true\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vertx.adoc:119
#, fuzzy, no-wrap
msgid "Native MacOS Transport"
msgstr "ネイティブMacOSトランスポート"

#. type: Plain text
#: upstream/_guides/vertx.adoc:122
#, fuzzy
msgid "On MacOS Sierra and above you can enable the following socket options:"
msgstr "MacOS Sierra以上では、以下のソケットオプションを有効にすることができます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:128
#, fuzzy, no-wrap
msgid "Accessing Vert.x"
msgstr "Vert.xへのアクセス"

#. type: Plain text
#: upstream/_guides/vertx.adoc:131
#, fuzzy
msgid "Once the extension has been added, you can access the _managed_ Vert.x instance using `@Inject`:"
msgstr "拡張機能を追加したら、 `@Inject` を使用して _管理されている_ Vert.x インスタンスにアクセスできます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:135 upstream/_guides/vertx.adoc:562
#, no-wrap
msgid "@Inject Vertx vertx;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:139
#, fuzzy
msgid "If you are familiar with Vert.x, you know that Vert.x provides different API models.  The _bare_ Vert.x uses callbacks, while the Mutiny variant uses `Uni` and `Multi`."
msgstr "Vert.x に詳しい方は、Vert.x が異なる API モデルを提供していることをご存知でしょう。例えば、素 _の_ Vert.x はコールバックを使用し、Mutiny バリアントは `Uni` と `Multi` を使用し、RX Java 2 バージョンは `Single` , `Maybe` , `Completable` , `Observable` と `Flowable` ..."

#. type: Plain text
#: upstream/_guides/vertx.adoc:141
#, fuzzy
msgid "Quarkus provides 2 Vert.x APIs:"
msgstr "Quarkusは4つのVert.x APIを提供しています。"

#. type: Table
#: upstream/_guides/vertx.adoc:145
#, fuzzy, no-wrap
msgid "Name"
msgstr "名前"

#. type: Table
#: upstream/_guides/vertx.adoc:145
#, fuzzy, no-wrap
msgid "Code"
msgstr "コード"

#. type: Table
#: upstream/_guides/vertx.adoc:147
#, fuzzy, no-wrap
msgid "Description"
msgstr "説明"

#. type: Table
#: upstream/_guides/vertx.adoc:147
#, fuzzy, no-wrap
msgid "_bare_"
msgstr "_剥き出し_"

#. type: Table
#: upstream/_guides/vertx.adoc:147
#, fuzzy, no-wrap
msgid "`@Inject io.vertx.core.Vertx vertx`"
msgstr "`@Inject io.vertx.core.Vertx vertx`"

#. type: Table
#: upstream/_guides/vertx.adoc:149
#, fuzzy, no-wrap
msgid "_bare_ Vert.x instance, the API uses callbacks."
msgstr "_bare_ Vert.x インスタンスの場合、API はコールバックを使用します。"

#. type: Table
#: upstream/_guides/vertx.adoc:149
#, fuzzy, no-wrap
msgid "https://smallrye.io/smallrye-mutiny/[Mutiny]"
msgstr "link:https://smallrye.io/smallrye-mutiny/[反乱]"

#. type: Table
#: upstream/_guides/vertx.adoc:149
#, fuzzy, no-wrap
msgid "`@Inject io.vertx.mutiny.core.Vertx vertx`"
msgstr "`@Inject io.vertx.mutiny.core.Vertx vertx`"

#. type: Table
#: upstream/_guides/vertx.adoc:151
#, fuzzy, no-wrap
msgid "The Mutiny API for Vert.x."
msgstr "Vert.x用のMutiny APIです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:155
#, fuzzy
msgid "You may inject any of the 2 flavors of `Vertx` as well as the `EventBus` in your Quarkus application beans: `bare` and `Mutiny`.  They are just shims and rely on a single _managed_ Vert.x instance."
msgstr "`Vertx` と `EventBus` の4つのフレーバーのいずれかをQuarkusアプリケーションビーンに注入することができます: `bare` , `Mutiny` , `Axle` , `RxJava2` .これらは単なるシムであり、単一の _管理された_ Vert.xインスタンスに依存しています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:157
#, fuzzy
msgid "You will pick one or the other depending on your use cases."
msgstr "ユースケースに応じてどちらかを選ぶことになります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:159
#, fuzzy
msgid "`bare`: for advanced usage or if you have existing Vert.x code you want to reuse in your Quarkus application"
msgstr "`bare` : 高度な使用方法や、Quarkusアプリケーションで再利用したい既存のVert.xコードがある場合に使用します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:160
#, fuzzy
msgid "`mutiny`: Mutiny is an event-driven reactive programming API. It uses 2 types: `Uni` and `Multi`. This is the recommended API."
msgstr "`mutiny` : Mutinyはイベント駆動型のリアクティブプログラミングAPIです。 `Uni` と `Multi` の2種類を使用しています。これが推奨APIです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:162
#, fuzzy
msgid "The following snippets illustrate the difference between these 4 APIs:"
msgstr "以下のスニペットは、これら4つのAPIの違いを説明しています。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:173
#, no-wrap
msgid ""
"// Bare Vert.x:\n"
"vertx.fileSystem().readFile(\"lorem-ipsum.txt\", ar -> {\n"
"    if (ar.succeeded()) {\n"
"        System.out.println(\"Content:\" + ar.result().toString(\"UTF-8\"));\n"
"    } else {\n"
"        System.out.println(\"Cannot read the file: \" + ar.cause().getMessage());\n"
"    }\n"
"});\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:182
#, no-wrap
msgid ""
"// Mutiny Vert.x:\n"
"vertx.fileSystem().readFile(\"lorem-ipsum.txt\")\n"
"    .onItem().transform(buffer -> buffer.toString(\"UTF-8\"))\n"
"    .subscribe()\n"
"    .with(\n"
"            content -> System.out.println(\"Content: \" + content),\n"
"            err -> System.out.println(\"Cannot read the file: \" + err.getMessage())\n"
"    );\n"
msgstr ""

#. type: Block title
#: upstream/_guides/vertx.adoc:185
#, no-wrap
msgid "Mutiny"
msgstr "Mutiny"

#. type: delimited block =
#: upstream/_guides/vertx.adoc:188
#, fuzzy
msgid "If you're not familiar with Mutiny, we recommend to read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first."
msgstr "Mutinyに慣れていない場合は、まずGet link:getting-started-reactive#mutiny[ting Started with Reactiveガイド] を読むことをお勧めします。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:190
#, fuzzy, no-wrap
msgid "Using Vert.x in Reactive JAX-RS resources"
msgstr "Reactive JAX-RSリソースでVert.xを使用する"

#. type: Plain text
#: upstream/_guides/vertx.adoc:193
#, fuzzy
msgid "Quarkus web resources support asynchronous processing and streaming results over https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[server-sent events]."
msgstr "Quarkusのウェブリソースは、 link:https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[サーバーから送信されたイベント] に対する非同期処理と結果のストリーミングをサポートしています。"

#. type: Title ===
#: upstream/_guides/vertx.adoc:194
#, fuzzy, no-wrap
msgid "Asynchronous processing"
msgstr "非同期処理"

#. type: Plain text
#: upstream/_guides/vertx.adoc:197
#, fuzzy
msgid "To asynchronously handle the HTTP request, the endpoint method must return a `java.util.concurrent.CompletionStage` or an `io.smallrye.mutiny.Uni` (requires the `quarkus-resteasy-mutiny` extension):"
msgstr "HTTP リクエストを非同期に処理するには、エンドポイントメソッドは `java.util.concurrent.CompletionStage` または `io.smallrye.mutiny.Uni` を返さなければなりません (拡張子 `quarkus-resteasy-mutiny` が必要です)。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:202 upstream/_guides/vertx.adoc:240
#, no-wrap
msgid ""
"@Path(\"/lorem\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:212
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> doSomethingAsync() {\n"
"        // Mimic an asynchronous computation.\n"
"        return Uni.createFrom()\n"
"                .item(() -> \"Hello!\")\n"
"                .onItem().delayIt().by(Duration.ofMillis(10));\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:218 upstream/_guides/vertx.adoc:525
#, no-wrap
msgid "./mvnw compile quarkus:dev\n"
msgstr "./mvnw compile quarkus:dev\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:221
#, fuzzy
msgid "Then, open your browser to http://localhost:8080/lorem and you should get the message."
msgstr "そして、ブラウザで http://localhost:8080/lorem を開くと、メッセージが表示されるはずです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:224
#, fuzzy
msgid "So far so good.  Now let's use the Vert.x API instead of this artificial delay:"
msgstr "ここまでは順調です。では、この人工的な遅延の代わりに Vert.x API を使ってみましょう。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:228 upstream/_guides/vertx.adoc:293
#: upstream/_guides/vertx.adoc:463
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:231
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:237
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:243 upstream/_guides/vertx.adoc:310
#: upstream/_guides/vertx.adoc:485
#, no-wrap
msgid ""
"    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:251
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> doSomethingAsync() {\n"
"        return vertx.fileSystem().readFile(\"/META-INF/resources/lorem.txt\")\n"
"                .onItem().transform(b -> b.toString(\"UTF-8\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:254
#, fuzzy
msgid "In this code, we inject the `vertx` instance (`io.vertx.mutiny.core.Vertx`) and read a file from the file system."
msgstr "このコードでは、 `vertx` インスタンス ( `io.vertx.mutiny.core.Vertx` ) を注入し、ファイルシステムからファイルを読み込んでいます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:256
#, fuzzy
msgid "Create the `src/main/resources/META_INF/resources/lorem.txt` file with the following content:"
msgstr "以下の内容の `src/main/resources/META_INF/resources/lorem.txt` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:260
#, no-wrap
msgid "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:263
#, fuzzy
msgid "Then, refresh the page, you should see the _lorem ipsum_ text."
msgstr "その後、ページを更新すると、 _lorem ipsumの_ テキストが表示されるはずです。"

#. type: Title ===
#: upstream/_guides/vertx.adoc:264
#, fuzzy, no-wrap
msgid "Streaming using Server-Sent Events"
msgstr "サーバーから送信されたイベントを使用したストリーミング"

#. type: Plain text
#: upstream/_guides/vertx.adoc:267
#, fuzzy
msgid "Quarkus web resources that need to send content as https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[server-sent events] must have a method:"
msgstr "link:https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[サーバー送信イベント] としてコンテンツを送信する必要があるQuarkusのウェブリソースには、メソッドが必要です。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:269
#, fuzzy
msgid "declaring the `text/event-stream` response content type"
msgstr "`text/event-stream` レスポンスコンテンツ型の宣言"

#. type: Plain text
#: upstream/_guides/vertx.adoc:270
#, fuzzy
msgid "returning a https://www.reactive-streams.org/[Reactive Streams] `Publisher` or Mutiny `Multi` (requires the `quarkus-resteasy-mutiny` extension)"
msgstr "link:https://www.reactive-streams.org/[Reactive Streams] `Publisher` または Mutiny `Multi` を返します ( `quarkus-resteasy-mutiny` の拡張子が必要です)。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:272
#, fuzzy
msgid "In practice, a streaming greeting service would look like:"
msgstr "実際には、ストリーミングのグリーティングサービスは次のようになります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:277
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class StreamingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:286
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @Path(\"/{name}\")\n"
"    public Multi<String> greeting(@PathParam String name) {\n"
"        // TODO: create a Reactive Streams publisher or a Mutiny Multi\n"
"        return publisher;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:289
#, fuzzy
msgid "Now we just need to return our `Publisher` or `Multi`:"
msgstr "あとは、 `Publisher` か `Multi` ."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:297
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:304
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.util.Date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:307
#, no-wrap
msgid ""
"@Path(\"/stream\")\n"
"public class StreamingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:319
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @Path(\"/{name}\")\n"
"    public Multi<String> greeting(@PathParam String name) {\n"
"        return vertx.periodicStream(2000).toMulti()\n"
"                .map(l -> String.format(\"Hello %s! (%s)%n\", name, new Date()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:323
#, fuzzy
msgid "The server side is ready.  In order to see the result in the browser, we need a web page."
msgstr "サーバー側の準備が整いました。ブラウザで結果を見るためにはWebページが必要です。"

#. type: Block title
#: upstream/_guides/vertx.adoc:325
#, fuzzy, no-wrap
msgid "META-INF/resources/streaming.html"
msgstr "META-INF/resources/streaming.html"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:338
#, no-wrap
msgid ""
"<!doctype html>\n"
"<html>\n"
"<head>\n"
"    <meta charset=\"utf-8\"/>\n"
"    <title>SSE with Vert.x - Quarkus</title>\n"
"    <script type=\"application/javascript\" src=\"streaming.js\"></script>\n"
"</head>\n"
"<body>\n"
"<div id=\"container\"></div>\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:342
#, fuzzy
msgid "Our web page just has an empty `<div>` container.  The magic, as always, lies in the Javascript code:"
msgstr "私たちのウェブページには、空の `<div>` コンテナーがあります。いつものように、マジックはJavascriptのコードにあります。"

#. type: Block title
#: upstream/_guides/vertx.adoc:344
#, fuzzy, no-wrap
msgid "META-INF/resources/streaming.js"
msgstr "META-INF/resources/streaming.js"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:357
#, no-wrap
msgid ""
"if (!!window.EventSource) {\n"
"    var eventSource = new EventSource(\"/stream/Quarkus\");\n"
"    eventSource.onmessage = function (event) {\n"
"        var container = document.getElementById(\"container\");\n"
"        var paragraph = document.createElement(\"p\");\n"
"        paragraph.innerHTML = event.data;\n"
"        container.appendChild(paragraph);\n"
"    };\n"
"} else {\n"
"    window.alert(\"EventSource not available on this browser.\")\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:361
#, fuzzy
msgid "Most browsers support SSE but some don't.  More about this in Mozilla's https://developer.mozilla.org/en-US/docs/Web/API/EventSource#Browser_compatibility[SSE browser-compatibility list]."
msgstr "ほとんどのブラウザは SSE をサポートしていますが、一部のブラウザはサポートしていません。これについての詳細は、Mozilla の link:https://developer.mozilla.org/en-US/docs/Web/API/EventSource#Browser_compatibility[SSE ブラウザ互換性リスト] を参照してください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:364
#, fuzzy
msgid "Navigate to http://localhost:8080/streaming.html.  A new greeting should show-up every 2 seconds."
msgstr "http://localhost:8080/streaming.html に移動します。2秒ごとに新しい挨拶が表示されます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:368
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:13:55 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:370
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:13:57 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:372
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:13:59 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:374
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:14:01 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:376
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:14:03 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:378
#, no-wrap
msgid "...\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vertx.adoc:380
#, fuzzy, no-wrap
msgid "Using Vert.x JSON"
msgstr "Vert.x JSONを使う"

#. type: Plain text
#: upstream/_guides/vertx.adoc:384
#, fuzzy
msgid "Vert.x API heavily relies on JSON, namely the `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray` types.  They are both supported as Quarkus web resource request and response bodies."
msgstr "Vert.x APIはJSON、すなわち `io.vertx.core.json.JsonObject` 型と `io.vertx.core.json.JsonArray` 型に大きく依存しています。これらはいずれもQuarkusのウェブリソースのリクエストボディとレスポンスボディとしてサポートされています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:386
#, fuzzy
msgid "Consider these endpoints:"
msgstr "これらのエンドポイントを考えてみましょう。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:392
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"public class VertxJsonResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:398
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}/object\")\n"
"    public JsonObject jsonObject(@PathParam String name) {\n"
"        return new JsonObject().put(\"Hello\", name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:405
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}/array\")\n"
"    public JsonArray jsonArray(@PathParam String name) {\n"
"        return new JsonArray().add(\"Hello\").add(name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:408
#, fuzzy
msgid "In your browser, navigate to http://localhost:8080/hello/Quarkus/object. You should see:"
msgstr "ブラウザで http://localhost:8080/hello/Quarkus/object に移動します。表示されるはずです。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:412
#, no-wrap
msgid "{\"Hello\":\"Quarkus\"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:415
#, fuzzy
msgid "Then, navigate to http://localhost:8080/hello/Quarkus/array:"
msgstr "そして、 http://localhost:8080/hello/Quarkus/array に移動します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:419
#, no-wrap
msgid "[\"Hello\",\"Quarkus\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:422
#, fuzzy
msgid "Needless to say, this works equally well when the JSON content is a request body or is wrapped in a `Uni`, `Multi`, `CompletionStage` or `Publisher`."
msgstr "言うまでもなく、これはJSONコンテンツがリクエストボディであったり、 `Uni` , `Multi` , `CompletionStage` , , `Publisher` でラップされている場合でも同様に動作します。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:423
#, fuzzy, no-wrap
msgid "Using Vert.x Clients"
msgstr "Vert.x クライアントの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:427
#, fuzzy
msgid "As you can inject a Vert.x instance, you can use Vert.x clients in a Quarkus application.  This section gives an example with the `WebClient`."
msgstr "Vert.xインスタンスを注入することができるので、QuarkusアプリケーションでVert.xクライアントを使用することができます。このセクションでは、 `WebClient` ."

#. type: Title ===
#: upstream/_guides/vertx.adoc:428
#, fuzzy, no-wrap
msgid "Picking the right dependency"
msgstr "正しい依存関係の選択"

#. type: Plain text
#: upstream/_guides/vertx.adoc:431
#, fuzzy
msgid "Depending on the API model you want to use you need to add the right dependency to your `pom.xml` file:"
msgstr "使用したいAPIモデルに応じて、 `pom.xml` ファイルに適切な依存関係を追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:439
#, no-wrap
msgid ""
"<!-- bare API -->\n"
"<dependency>\n"
"  <groupId>io.vertx</groupId>\n"
"  <artifactId>vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:445
#, no-wrap
msgid ""
"<!-- Mutiny API -->\n"
"<dependency>\n"
"  <groupId>io.smallrye.reactive</groupId>\n"
"  <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:448
#, fuzzy
msgid "In this guide, we are going to use the Mutiny API, so:"
msgstr "このガイドでは、Mutiny APIを使うことになっていますので。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:455
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.smallrye.reactive</groupId>\n"
"  <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:458
#, fuzzy
msgid "Now, create a new resource in your project with the following content:"
msgstr "では、以下の内容でプロジェクトに新しいリソースを作成します。"

#. type: Block title
#: upstream/_guides/vertx.adoc:460
#, fuzzy, no-wrap
msgid "src/main/java/org/acme/vertx/ResourceUsingWebClient.java"
msgstr "src/main/java/org/acme/vertx/ResourceUsingWebClient.java"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:471
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:474
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:479
#, no-wrap
msgid ""
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:482
#, no-wrap
msgid ""
"@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:487
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:494
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\")\n"
"                    .setDefaultPort(443).setSsl(true).setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:511
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .onItem().transform(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:513
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:519
#, fuzzy
msgid "This resource creates a `WebClient` and upon request use this client to invoke the _fruityvice_ API.  Depending on the result the response is forwarded as it's received, or a new JSON object is created with the status and body.  The `WebClient` is obviously asynchronous (and non-blocking), to the endpoint returns a `Uni`."
msgstr "このリソースは `WebClient` を作成し、リクエスト時にこのクライアントを使用して _fruityvice_ API を呼び出します。結果に応じて、レスポンスは受信したときに転送されるか、ステータスとボディを持つ新しいJSONオブジェクトが作成されます。 `WebClient` は明らかに非同期(とノンブロッキング)で、エンドポイントに `Uni` を返します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:521
#, fuzzy
msgid "Run the application with:"
msgstr "でアプリケーションを実行します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:528
#, fuzzy
msgid "And then, open a browser to: `http://localhost:8080/fruit-data/pear`. You should get some details about pears."
msgstr "そして、ブラウザを開いて `http://localhost:8080/fruit-data/pear` .あなたは、梨についてのいくつかの詳細を取得する必要があります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:532
#, fuzzy
msgid "The application can also run as a native executable.  But, first, we need to instruct Quarkus to enable _ssl_.  Open the `src/main/resources/application.properties` and add:"
msgstr "アプリケーションはネイティブの実行ファイルとして実行することもできます。しかし、まず、Quarkusに _sslを_ 有効にするように指示する必要があります。 `src/main/resources/application.properties` を開いて、追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:536
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:539
#, fuzzy
msgid "Then, create the native executable with:"
msgstr "そして、ネイティブの実行ファイルを"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:543
#, no-wrap
msgid "./mvnw package -Pnative\n"
msgstr "./mvnw package -Pnative\n"

#. type: Title ==
#: upstream/_guides/vertx.adoc:545
#, fuzzy, no-wrap
msgid "Deploying verticles"
msgstr "頂点の配置"

#. type: Plain text
#: upstream/_guides/vertx.adoc:550
#, fuzzy
msgid "link:https://vertx.io/docs/vertx-core/java/#\\_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.  This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.  To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus."
msgstr "link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] は _Vert.x_ によって提供されている「シンプルでスケーラブルなアクターライクなデプロイメントと同時実行モデル」です。このモデルは厳密なアクターモデルの実装であるとは主張しませんが、特に同時実行、スケーリング、デプロイメントに関しては類似性を共有しています。このモデルを使用するには、イベントバス上でメッセージを送信することでお互いに通信しながら、 頂点を書いて _展開し_ ます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:553
#, fuzzy
msgid "You can deploy _verticles_ in Quarkus.  It supports:"
msgstr "Quarkusでバーティカル _を_ 展開することができます。サポートしています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:555
#, fuzzy
msgid "_bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`"
msgstr "_裸の_ 頂点 - 拡張する Java クラス `io.vertx.core.AbstractVerticle`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:556
#, fuzzy
msgid "_Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`"
msgstr "_Mutiny_ verticle - 拡張するJavaクラス `io.smallrye.mutiny.vertx.core.AbstractVerticle`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:558
#, fuzzy
msgid "To deploy verticles, use the regular Vert.x API:"
msgstr "頂点を展開するには、通常の Vert.x API を使用します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:566
#, no-wrap
msgid ""
"// ...\n"
"vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n"
"vertx.deployVerticle(new MyVerticle(), ar -> { });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:569
#, fuzzy
msgid "You can also pass deployment options to configure the verticle as well as set the number of instances."
msgstr "インスタンスの数を設定するだけでなく、デプロイメントオプションを渡してバーティクルを設定することもできます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:572
#, fuzzy
msgid "Verticles are not _beans_ by default.  However, you can implement them as _ApplicationScoped_ beans and get injection support:"
msgstr "バーチクルはデフォルトでは _ビーンで_ はありません。しかし、 _ApplicationScoped_ ビーンズとして実装し、インジェクションのサポートを得ることができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:576 upstream/_guides/vertx.adoc:604
#, no-wrap
msgid "package io.quarkus.vertx.verticles;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:580
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:582
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr "import javax.enterprise.context.ApplicationScoped;\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:585
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyBeanVerticle extends AbstractVerticle {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:587
#, no-wrap
msgid "    @ConfigProperty(name = \"address\") String address;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:595
#, no-wrap
msgid ""
"    @Override\n"
"    public Uni<Void> asyncStart() {\n"
"        return vertx.eventBus().consumer(address)\n"
"                .handler(m -> m.replyAndForget(\"hello\"))\n"
"                .completionHandler();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:598
#, fuzzy
msgid "You don't have to inject the `vertx` instance but instead leverage the instance stored in the protected field of `AbstractVerticle`."
msgstr "`vertx` インスタンスを注入する必要はなく、代わりに `AbstractVerticle` の保護されたフィールドに保存されているインスタンスを活用します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:600
#, fuzzy
msgid "Then, deploy the verticle instance with:"
msgstr "そして、verticleインスタンスを使ってデプロイします。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:607
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:610
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:613
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class VerticleDeployer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:618
#, no-wrap
msgid ""
"    public void init(@Observes StartupEvent e, Vertx vertx, MyBeanVerticle verticle) {\n"
"         vertx.deployVerticle(verticle).await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:621
#, fuzzy
msgid "If you want to deploy every exposed `AbstractVerticle`, you can use:"
msgstr "もしあなたが公開された `AbstractVerticle` をすべてデプロイしたいのであれば、あなたは使用することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:629
#, no-wrap
msgid ""
"public void init(@Observes StartupEvent e, Vertx vertx, Instance<AbstractVerticle> verticles) {\n"
"    for (AbstractVerticle verticle : verticles) {\n"
"        vertx.deployVerticle(verticle).await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vertx.adoc:631
#, fuzzy, no-wrap
msgid "Listening to a Unix Domain Socket"
msgstr "Unix ドメインソケットのリスニング"

#. type: Plain text
#: upstream/_guides/vertx.adoc:637
#, fuzzy
msgid "Listening on a unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host. This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy."
msgstr "unix ドメインソケットでリスンすることで、同じホストから quarkus サービスへの接続が確立されている場合、TCP のオーバーヘッドを省くことができます。これはサービスへのアクセスがプロキシーを経由している場合に起こる可能性があり、Envoyのようなプロキシーでサービスメッシュを設定している場合によく起こります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:639
#, fuzzy
msgid "This will only work on platforms that support <<native-transport>>."
msgstr "これは、 link:#native-transport[[native-transport]] をサポートするプラットフォームでのみ動作します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:642
#, fuzzy
msgid "To setup please enable the appropriate <<native-transport>> and set the following environment property:"
msgstr "設定するには、適切な link:#native-transport[[native-transport]を] 有効にし、以下の環境プロパティーを設定してください。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:646
#, no-wrap
msgid ""
"quarkus.http.domain-socket=/var/run/io.quarkus.app.socket\n"
"quarkus.http.domain-socket-enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:650
#, fuzzy
msgid "By itself this will not disable the tcp socket which by default will open on `0.0.0.0:8080`. It can be explicitly disabled:"
msgstr "これだけでは、デフォルトで `0.0.0.0:8080` で開かれる TCP ソケットを無効にすることはできません。明示的に無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:653
#, no-wrap
msgid "quarkus.http.host-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:657
#, fuzzy
msgid "These properties can be set through Java's `-D` command line parameter or on `application.properties`."
msgstr "これらのプロパティーは、Java の `-D` コマンドライン・パラメーターまたは `application.properties` ."

#. type: Title ==
#: upstream/_guides/vertx.adoc:658
#, fuzzy, no-wrap
msgid "Read only deployment environments"
msgstr "読み込み専用の展開環境"

#. type: Plain text
#: upstream/_guides/vertx.adoc:661
#, fuzzy
msgid "In environments with read only file systems you may receive errors of the form:"
msgstr "読み取り専用のファイルシステムを使用している環境では、このような形式のエラーが発生することがあります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:665
#, no-wrap
msgid "java.lang.IllegalStateException: Failed to create cache dir\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:668
#, fuzzy
msgid "Assuming `/tmp/` is writable this can be fixed by setting the `vertx.cacheDirBase` property to point to a directory in `/tmp/` for instance in OpenShift by creating an environment variable `JAVA_OPTS` with the value `-Dvertx.cacheDirBase=/tmp/vertx`."
msgstr "`/tmp/` が書き込み可能であると仮定して、 `vertx.cacheDirBase` プロパティーを設定して `/tmp/` のディレクトリーを指すように設定し、例えば OpenShift の場合は `JAVA_OPTS` に `-Dvertx.cacheDirBase=/tmp/vertx` の値を持つ環境変数を作成することで修正できます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:670
#, fuzzy, no-wrap
msgid "Running behind a reverse proxy"
msgstr "リバースプロキシーの背後での実行"

#. type: Plain text
#: upstream/_guides/vertx.adoc:676
#, fuzzy
msgid "Quarkus could be accessed through proxies that additionally generate headers (e.g. `X-Forwarded-Host`) to keep information from the client-facing side of the proxy servers that is altered or lost when they are involved.  In those scenarios, Quarkus can be configured to automatically update information like protocol, host, port and URI reflecting the values in these headers."
msgstr "Quarkusは、プロキシーサーバーが関与したときに変更されたり失われたりする情報を、プロキシーサーバーのクライアント側から保持するために、追加でヘッダー(例: `X-Forwarded-Host` )を生成するプロキシーを介してアクセスすることができます。このような場合、Quarkusは、これらのヘッダーの値を反映して、プロトコル、ホスト、ポート、URIなどの情報を自動的に更新するように設定することができます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:679
#, fuzzy
msgid "Activating this feature makes the server exposed to several security issues (i.e. information spoofing).  Consider activate it only when running behind a reverse proxy."
msgstr "この機能を有効にすると、サーバーはいくつかのセキュリティー上の問題(情報の詐称など)にさらされることになります。リバースプロキシーの後ろで実行している場合にのみ有効にすることを検討してください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:681
#, fuzzy
msgid "To setup this feature, please include the following lines in `src/main/resources/application.properties`:"
msgstr "この機能を設定するには、 `src/main/resources/application.properties` ."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:684
#, no-wrap
msgid "quarkus.http.proxy-address-forwarding=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:687
#, fuzzy
msgid "To consider only de-facto standard header (`Forwarded` header), please include the following lines in `src/main/resources/application.properties`:"
msgstr "デファクトの標準ヘッダ( `Forwarded` ヘッダ)のみを考慮する場合は、 `src/main/resources/application.properties` ."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:690
#, no-wrap
msgid "quarkus.http.proxy.allow-forwarded=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:693
#, fuzzy
msgid "To consider only non-standard headers, please include the following lines instead in `src/main/resources/application.properties`:"
msgstr "標準以外のヘッダのみを考慮するために、代わりに以下の行を `src/main/resources/application.properties` に含めてください。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:699
#, no-wrap
msgid ""
"quarkus.http.proxy.proxy-address-forwarding=true\n"
"quarkus.http.proxy.enable-forwarded-host=true\n"
"quarkus.http.proxy.enable-forwarded-prefix=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:702
#, fuzzy
msgid "Both configurations related to standard and non-standard headers can be combined, although the standard headers configuration will have precedence."
msgstr "標準ヘッダと非標準ヘッダに関連する両方の設定を組み合わせることができますが、標準ヘッダの設定が優先されます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:704
#, fuzzy
msgid "Supported forwarding address headers are:"
msgstr "サポートされている転送アドレスヘッダは以下の通りです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:706
#, fuzzy
msgid "`Forwarded`"
msgstr "`Forwarded`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:707
#, fuzzy
msgid "`X-Forwarded-Proto`"
msgstr "`X-Forwarded-Proto`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:708
#, fuzzy
msgid "`X-Forwarded-Host`"
msgstr "`X-Forwarded-Host`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:709
#, fuzzy
msgid "`X-Forwarded-Port`"
msgstr "`X-Forwarded-Port`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:710
#, fuzzy
msgid "`X-Forwarded-Ssl`"
msgstr "`X-Forwarded-Ssl`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:711
#, fuzzy
msgid "`X-Forwarded-Prefix`"
msgstr "`X-Forwarded-Prefix`"

#. type: Title ==
#: upstream/_guides/vertx.adoc:713
#, fuzzy, no-wrap
msgid "SameSite cookies"
msgstr "同サイトのクッキー"

#. type: Plain text
#: upstream/_guides/vertx.adoc:716
#, fuzzy
msgid "One can easily add a https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie property to any of the cookies set by a Quarkus endpoint by listing a cookie name and a `SameSite` attribute, for example:"
msgstr "例えば、クッキー名と `SameSite` 属性をリストアップすることで、Quarkusエンドポイントで設定されたクッキーに link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] クッキープロパティーを簡単に追加することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:721
#, no-wrap
msgid ""
"quarkus.http.same-site-cookie.jwt.value=Lax\n"
"quarkus.http.same-site-cookie.session.value=Strict\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:724
#, fuzzy
msgid "Given this configuration, the `jwt` cookie will have a `SameSite=Lax` attribute and the `session` cookie will have a `SameSite=Strict` attribute."
msgstr "この設定を考えると、 `jwt` クッキーは `SameSite=Lax` 属性を持ち、 `session` クッキーは `SameSite=Strict` 属性を持つことになります。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:725
#, no-wrap
msgid "Going further"
msgstr "さらに詳しく"

#. type: Plain text
#: upstream/_guides/vertx.adoc:728
#, fuzzy
msgid "There are many other facets of Quarkus using Vert.x underneath:"
msgstr "下にVert.xを使ったQuarkusの他の面もたくさんあります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:732
#, fuzzy
msgid "The event bus is the connecting tissue of Vert.x applications.  Quarkus integrates it so different beans can interact with asynchronous messages.  This part is covered in the link:reactive-event-bus[event bus documentation]."
msgstr "イベントバスは、Vert.xアプリケーションの接続組織です。Quarkusはこれを統合して、異なるビーンが非同期メッセージと対話できるようにしています。この部分は、 link:reactive-event-bus[イベントバスのドキュメント] でカバーされています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:736
#, fuzzy
msgid "Data streaming and Apache Kafka are an important part of modern systems.  Quarkus integrates data streaming using Reactive Messaging.  More details on link:kafka[Interacting with Kafka]."
msgstr "データストリーミングとApache Kafkaは、現代のシステムの重要な部分です。Quarkusは、Reactive Messagingを使用してデータストリーミングを統合しています。詳細は、 link:kafka[Kafkaとのインタラクション] を参照してください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:737
#, fuzzy
msgid "Learn how to implement highly performant, low-overhead database applications on Quarkus with the link:reactive-sql-clients[Reactive SQL Clients]."
msgstr "link:reactive-sql-clients[Reactive SQLクライアントを] 使用して、Quarkus上に高パフォーマンスで低オーバーヘッドのデータベースアプリケーションを実装する方法をご紹介します。"

#, fuzzy
#~ msgid "RX Java 2"
#~ msgstr "RX Java 2"

#, fuzzy
#~ msgid "`@Inject io.vertx.reactivex.core.Vertx vertx`"
#~ msgstr "`@Inject io.vertx.reactivex.core.Vertx vertx`"

#, fuzzy
#~ msgid "RX Java 2 Vert.x, the API uses RX Java 2 types (deprecated)."
#~ msgstr "RX Java 2 Vert.x、APIはRX Java 2の型を使用しています(非推奨)。"

#, fuzzy
#~ msgid "_Axle_"
#~ msgstr "_アクスル_"

#, fuzzy
#~ msgid "`@Inject io.vertx.axle.core.Vertx vertx`"
#~ msgstr "`@Inject io.vertx.axle.core.Vertx vertx`"

#, fuzzy
#~ msgid "Axle Vert.x, the API uses `CompletionStage` and `Reactive Streams` (deprecated)."
#~ msgstr "Axle Vert.x、APIは `CompletionStage` 、 `Reactive Streams` (非推奨)を使用しています。"

#, fuzzy
#~ msgid "`Axle`: works well with Quarkus and MicroProfile APIs (`CompletionStage` for single results and `Publisher` for streams) - deprecated, it is recommended to switch to Mutiny"
#~ msgstr "`Axle` : QuarkusとMicroProfile APIでうまく動作します (単一の結果については `CompletionStage` 、ストリームについては `Publisher` ) - 非推奨、Mutinyに切り替えることを推奨します。"

#, fuzzy
#~ msgid "`Rx Java 2`: when you need support for a wide range of data transformation operators on your streams - deprecated, it is recommended to switch to Mutiny"
#~ msgstr "`Rx Java 2` : ストリーム上で幅広いデータ変換演算子のサポートが必要な場合 - 非推奨、Mutinyへの切り替えが推奨されます。"

#, fuzzy
#~ msgid "The `vertx-rx-java2` provides the RX Java 2 API for the whole Vert.x stack, not only the web client."
#~ msgstr "`vertx-rx-java2` は Web クライアントだけでなく、Vert.x スタック全体の RX Java 2 API を提供しています。"
