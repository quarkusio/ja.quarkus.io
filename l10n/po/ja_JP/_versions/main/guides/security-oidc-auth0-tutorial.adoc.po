msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit\n"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Protect a Quarkus web application by using an Auth0 OpenID Connect provider"
msgstr "Auth0 OpenID Connectプロバイダーを使用したQuarkus Webアプリケーションの保護"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "xref:security-architecture.adoc[Quarkus Security] provides comprehensive OpenId Connect (OIDC) and OAuth2 support with its `quarkus-oidc` extension, supporting both xref:security-oidc-code-flow-authentication.adoc[Authorization code flow] and xref:security-oidc-bearer-token-authentication.adoc[Bearer token] authentication mechanisms."
msgstr "xref:security-architecture.adoc[Quarkus Security] は、 `quarkus-oidc` エクステンションを使用して包括的な OpenId Connect (OIDC) および OAuth2 のサポートを提供し、xref:security-oidc-code-flow-authentication.adoc[認可コードフロー] と xref:security-oidc-bearer-token-authentication.adoc[ベアラートークン] の認証メカニズムをサポートします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "With Quarkus, you can easily configure OIDC providers such as link:https://www.keycloak.org/documentation[Keycloak], link:https://developer.okta.com/[Okta], link:https://auth0.com/docs/[Auth0], and other xref:security-openid-connect-providers.adoc[well-known social OIDC and OAuth2 providers]."
msgstr "Quarkusを使用すると、link:https://www.keycloak.org/documentation[Keycloak]、link:https://developer.okta.com/[Okta]、link:https://auth0.com/docs/[Auth0]、およびその他の xref:security-openid-connect-providers.adoc[有名なソーシャル OIDC や OAuth2 プロバイダー] などの OIDC プロバイダーを簡単に設定できます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Learn how to use the Quarkus OpenID Connect extension (`quarkus-oidc`) together with the https://auth0.com/docs/[Auth0] OIDC provider to protect your API endpoints."
msgstr "Quarkus OpenID Connect エクステンション (`quarkus-oidc`) と https://auth0.com/docs/[Auth0] OIDC プロバイダーを使用して、API エンドポイントを保護する方法について説明します。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Review the following documentation before you begin:"
msgstr "作業を始める前に、次のドキュメントを確認してください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "link:https://auth0.com/docs/[Auth0 docs site]"
msgstr "link:https://auth0.com/docs/[Auth0 のドキュメントサイト]"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "xref:security-oidc-code-flow-authentication.adoc[Quarkus OpenID Connect Authorization code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[Web アプリケーションの保護に使用する Quarkus OpenID Connect 認可コードフローメカニズム]"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "xref:security-oidc-bearer-token-authentication.adoc[Quarkus OpenID Connect (OIDC) Bearer token authentication]"
msgstr "xref:security-oidc-bearer-token-authentication.adoc[Quarkus OpenID Connect (OIDC) ベアラートークン認証]"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Create an Auth0 application"
msgstr "Auth0 アプリケーションの作成"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Go to the Auth0 dashboard and create a regular web application.\n"
"For example, create an Auth0 application called `QuarkusAuth0`."
msgstr ""
"Auth0 ダッシュボードに移動し、通常の Web アプリケーションを作成します。\n"
"例えば、 `QuarkusAuth0` という Auth0 アプリケーションを作成します。"

#. type: Block title
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Result"
msgstr "結果"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Your Auth0 application gets created with a client ID, secret, and HTTPS-based domain.\n"
"Make a note of these properties because you will need them to complete the Quarkus configuration in the next step."
msgstr ""
"Auth0 アプリケーションは、クライアント ID、シークレット、HTTPS ベースのドメインを使用して作成されます。\n"
"次の手順で Quarkus 設定を完了するために必要となるため、これらのプロパティーをメモしておいてください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Next, while still in the Auth0 dashboard, add some users to your application."
msgstr "次に、そのまま Auth0 ダッシュボードでアプリケーションにユーザーを追加します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Now that you have successfully created and configured your Auth0 application, you are ready to start creating and configuring a Quarkus endpoint.\n"
"In the steps that follow, you will continue to configure and update the Auth0 application as well."
msgstr ""
"これで Auth0 アプリケーションの作成と設定が完了しました。次は、Quarkus エンドポイントの作成と設定を行います。\n"
"その後、Auth0 アプリケーションの設定と更新を行います。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Create a Quarkus application"
msgstr "Quarkus アプリケーションの作成"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Use the following Maven command to create a Quarkus REST (formerly RESTEasy Reactive) application that can be secured with the Quarkus OIDC extension."
msgstr "次の Maven コマンドを使用して、Quarkus OIDC エクステンションを使用して保護できる Quarkus REST (旧称 RESTEasy Reactive) アプリケーションを作成します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Create the application workspace and import it into your favorite IDE.\n"
"Let's add a Jakarta REST endpoint that can only be accessed by authenticated users:"
msgstr ""
"アプリケーションワークスペースを作成し、お気に入りの IDE にインポートします。\n"
"ここでは、認証されたユーザーのみアクセス可能な Jakarta REST エンドポイントを追加します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"The injected `JsonWebToken` (JWT) bean has an `@IdToken` qualifier, which means it represents not an access token but OIDC `ID token`.\n"
"`IdToken` provides information in the form of claims about the current user authenticated during the OIDC authorization code flow and you can use `JsonWebToken` API to access these claims."
msgstr ""
"注入された `JsonWebToken` (JWT) Bean には `@IdToken` 修飾子があります。これは、アクセストークンではなく OIDC `ID トークン` であることを意味します。\n"
"`IdToken` は、OIDC 認可コードフローで認証された現行ユーザーに関する情報をクレームの形式で提供します。これらのクレームには、 `JsonWebToken` API を使用してアクセスできます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The `io.quarkus.security.Authenticated` annotation is added to the `hello()` method, which means that only authenticated users can access it."
msgstr "`io.quarkus.security.Authenticated` アノテーションが `hello()` メソッドに追加されました。これにより、認証されたユーザーのみアクセス可能になります。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"The access token acquired during the authorization code flow, alongside the ID token, is not used directly by the endpoint but is used only to access downstream services on behalf of the currently authenticated user.\n"
"More to come on the topic of \"access tokens\", later in this tutorial."
msgstr ""
"認可コードフロー中に取得したアクセストークンは、ID トークンとともに直接エンドポイントにより使用されるのではなく、現在認証されているユーザーに代わってダウンストリームサービスにアクセスする場合にのみ使用されます。\n"
"アクセストークンについては、このチュートリアルの後半で詳しく説明します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Configure OIDC in the Quarkus `application.properties` file  by using the properties from the Auth0 application that you created earlier."
msgstr "前の手順で作成した Auth0 アプリケーションのプロパティーを使用して、Quarkus の `application.properties` ファイルで OIDC を設定します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"In completing this step, you have just configured Quarkus to use the domain, client ID, and secret of your Auth0 application.\n"
"Setting the property `quarkus.oidc.application-type=web-app` instructs Quarkus to use the OIDC authorization code flow, but there are also other methods, which are discussed later on in the tutorial."
msgstr ""
"この手順を完了すると、Auth0 アプリケーションのドメイン、クライアント ID、シークレットを使用するように Quarkus が設定されます。\n"
"`quarkus.oidc.application-type=web-app` プロパティーを設定することで、OIDC 認可コードフローを使用するように Quarkus に指示が出されますが、他の方法を使用することもできます。これについてはチュートリアルの後半で説明します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The endpoint address will be  \\http://localhost:8080/hello, which must also be registered as an allowed callback URL in your Auth0 application."
msgstr "エンドポイントアドレスは \\http://localhost:8080/hello になります。これは、Auth0 アプリケーションで許可されたコールバック URL として登録する必要があります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "After completing this step, when you access the Quarkus \\http://localhost:8080/hello endpoint from a browser, Auth0 redirects you back to the same address after the authentication is completed."
msgstr "この手順を完了すると、ブラウザーから Quarkus \\http://localhost:8080/hello エンドポイントにアクセスすると、認証が完了した後に Auth0 によって同じアドレスにリダイレクトされます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"By default, Quarkus automatically uses the current request path as the callback path.\n"
"But you can override the default behavior and configure a specific callback path by setting the Quarkus `quarkus.oidc.authentication.redirect-path` property."
msgstr ""
"デフォルトでは、Quarkus は現在のリクエストパスをコールバックパスとして自動的に使用します。\n"
"ただし、Quarkus の `quarkus.oidc.authentication.redirect-path` プロパティーを設定することで、デフォルトの動作をオーバーライドし、特定のコールバックパスを設定できます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"In production, your application will most likely have a larger URL space, with multiple endpoint addresses available.\n"
"In such cases, you can set a dedicated callback (redirect) path and register this URL in the provider's dashboard, as outlined in the following configuration example:"
msgstr ""
"ほとんどの実稼働環境では、アプリケーションの URL 空間が大きくなり、複数のエンドポイントアドレスが利用可能になります。\n"
"その場合は、次の設定例のように、専用のコールバック (リダイレクト) パスを設定し、この URL をプロバイダーのダッシュボードに登録できます。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "`quarkus.oidc.authentication.redirect-path=/authenticated-welcome`"
msgstr "`quarkus.oidc.authentication.redirect-path=/authenticated-welcome`"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"In the example scenario, Quarkus calls `/authenticated-welcome` after accepting a redirect from Auth0, completing the authorization code flow,  and creating the session cookie.\n"
"Successfully authenticated users are also allowed to access other parts of the secured application space, without needing to authenticate again. For example, the endpoint callback method can use a JAX-RS API to redirect users to other parts of the secured application where a session cookie will be verified."
msgstr ""
"この例では、Quarkus は Auth0 からのリダイレクトを受け入れ、認可コードフローを完了し、セッション Cookie を作成した後、 `/authenticated-welcome` を呼び出します。\n"
"認証に成功したユーザーは、再度認証することなく、保護されたアプリケーションスペースの他の部分にもアクセスできます。たとえば、エンドポイントコールバックメソッドは、JAX-RS API を使用して、セッション Cookie が検証される保護されたアプリケーションの他の部分にユーザーをリダイレクトできます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now you are ready to start testing the endpoint."
msgstr "これで、エンドポイントのテストを開始する準備が完了しました。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Test the Quarkus endpoint"
msgstr "Quarkus エンドポイントのテスト"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Start Quarkus in dev mode:"
msgstr "Quarkus を開発モードで起動します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"This is the only time during this tutorial when you are expected to manually start Quarkus in dev mode.\n"
"The configuration and code update steps in the remaining sections of this tutorial are automatically observed and processed by Quarkus without you needing to restart the application manually."
msgstr ""
"このチュートリアルの中で、手動で Quarkus を開発モードで起動する必要があるのはこの手順のみです。\n"
"このチュートリアルの他のセクションでは、設定とコード更新の手順は Quarkus により自動的に監視および処理され、アプリケーションを手動で再起動する必要はありません。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Open the browser and access http://localhost:8080/hello."
msgstr "ブラウザーを開き、 http://localhost:8080/hello にアクセスします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "You will be redirected to Auth0 and prompted to log in:"
msgstr "Auth0 にリダイレクトされ、ログインするように求められます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "and authorize the `QuarkusAuth0` application to access your account:"
msgstr "次に、 `QuarkusAuth0` アプリケーションによるアカウントへのアクセスを認可します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Finally, you will be redirected back to the Quarkus endpoint which will return the following response:\n"
"`Hello, auth0|60e5a305e8da5a006aef5471`"
msgstr ""
"最後に、Quarkus エンドポイントにリダイレクトされ、次のレスポンスが返されます。\n"
"`Hello, auth0|60e5a305e8da5a006aef5471`"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Notice that the current username does not get returned.\n"
"To learn more about why this behavior occurs, you can use OIDC Dev UI as explained in the xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[Dev UI for all OpenID Connect Providers] section of the \"Dev Services and UI for OpenID Connect (OIDC)\" guide and the following section."
msgstr ""
"現行のユーザー名は返されないことに注意してください。\n"
"この動作が発生する理由は、\"OpenID Connect (OIDC) の開発サービスと UI\" ガイドの xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[すべての OpenID Connect プロバイダーの Dev UI] セクションと次のセクションで説明されているとおり、OIDC Dev UI を使用して確認できます。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Looking at Auth0 tokens in the OIDC Dev UI"
msgstr "OIDC Dev UI で Auth0 トークンを確認する"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Quarkus provides a great xref:dev-ui.adoc[Dev UI] experience.\n"
"Specifically, Quarkus offers built-in support for developing and testing OIDC endpoints with a Keycloak container.\n"
"xref:security-openid-connect-dev-services.adoc#dev-services-for-keycloak[DevService for Keycloak] is automatically started and used if the address of the OIDC provider is not specified for the Quarkus `quarkus.oidc.auth-server-url` configuration property."
msgstr ""
"Quarkus は優れた xref:dev-ui.adoc[Dev UI] エクスペリエンスを提供します。\n"
"具体的には、Quarkus は、Keycloak コンテナーを使用して OIDC エンドポイントを開発およびテストするための組込サポートを提供します。\n"
"Quarkus の `quarkus.oidc.auth-server-url` 設定プロパティーに OIDC プロバイダーのアドレスが指定されていない場合、xref:security-openid-connect-dev-services.adoc#dev-services-for-keycloak[DevService for Keycloak] が自動的に起動され、使用されます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"You can continue using the Quarkus OIDC Dev UI when the provider is already configured.\n"
"Use the following instructions to update your configuration:"
msgstr ""
"プロバイダーがすでに設定されている場合は、引き続き Quarkus OIDC Dev UI を使用できます。\n"
"設定を更新するには、次の手順を実行します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "First, change your Quarkus application type from `web-app` to `hybrid`, as follows:"
msgstr "まず、次のように Quarkus アプリケーションタイプを `web-app` から `hybrid` に変更します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Application type is changed to `hybrid` because OIDC Dev UI currently supports `SPA` (single-page application) mode only.\n"
"OIDC Dev UI single-page application, using its own Java Script, authenticates users to the OIDC provider and uses the access token as a Bearer token to access the Quarkus endpoint as a service."
msgstr ""
"現在 OIDC Dev UI は、 `SPA` (シングルページアプリケーション) モードのみサポートしています。そのため、アプリケーションタイプは `hybrid` に変更されます。\n"
"OIDC Dev UI シングルページアプリケーションは、独自の Java Script を使用して、OIDC プロバイダーに対してユーザーを認証し、アクセストークンをベアラートークンとして使用して、Quarkus エンドポイントにサービスとしてアクセスします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Typically, Quarkus must be configured with `quarkus.oidc.application-type=service` to support `Bearer` token authentication, but it also supports a `hybrid` application type, which means it can support both the authorization code and bearer token flows at the same time."
msgstr "通常、Quarkus は `ベアラー` トークン認証をサポートするために `quarkus.oidc.application-type=service` で設定する必要がありますが、 `hybrid` アプリケーションタイプもサポートしているため、認可コードとベアラートークンの両方のフローを同時にサポートできます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"You also need to configure the Auth0 application to allow the callbacks to the OIDC Dev UI.\n"
"Use the following URL format:"
msgstr ""
"また、OIDC Dev UI へのコールバックを許可するように Auth0 アプリケーションを設定する必要もあります。\n"
"次の URL 形式を使用します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "`http://localhost:8080/q/dev-ui/quarkus-oidc/${provider-name}-provider`"
msgstr "`http://localhost:8080/q/dev-ui/quarkus-oidc/${provider-name}-provider`"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Where in this example, the `${provider-name}` is `auth0`"
msgstr "この例では、 `${provider -name}` は `auth0` です"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now you are ready to use OIDC Dev UI with Auth0."
msgstr "これでAuth0でOIDC Dev UIを使う準備ができました。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Open http://localhost:8080/q/dev/ in a browser session. An OpenId Connect card that links to an Auth0 provider SPA displays, as follows:"
msgstr "ブラウザセッションで http://localhost:8080/q/dev/ を開きます。以下のように、Auth0 プロバイダ SPA にリンクする OpenId Connect カードが表示されます："

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Click *Auth0 provider* followed by *Login into Single Page Application*:"
msgstr "*Auth0 provider*、*Login into Single Page Application* の順にクリックします。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"You will be redirected to Auth0 to log in.\n"
"You will then be redirected to the OIDC Dev UI dashboard, as follows:"
msgstr ""
"ログインのために Auth0 にリダイレクトされます。\n"
"その後、次のように、OIDC Dev UI ダッシュボードにリダイレクトされます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Here, you can look at both ID and access tokens in the encoded and decoded formats, copy them to the clipboard or use them to test the service endpoint. We will test the endpoint later but for now let's check the ID token:"
msgstr "ここでは、エンコードおよびデコードされた ID トークンとアクセストークンを確認し、それをクリップボードにコピーしたり、サービスエンドポイントのテストに使用したりできます。後でエンドポイントをテストしますが、ここではまず ID トークンを確認します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "As you can see it does not have any claim representing a user name but if you check its `sub` (subject) claim you will see its value matches what you got in the response when you accessed the Quarkus endpoint directly from the browser, `auth0|60e5a305e8da5a006aef5471`."
msgstr "ご覧のとおりユーザー名を表すクレームはありませんが、 `sub` (subject) クレームを確認すると、その値が、ブラウザーから直接 Quarkus エンドポイントにアクセスした際にレスポンスとして取得した値 (`auth0|60e5a305e8da5a006aef5471`) と一致することがわかります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Fix it by configuring Quarkus to request a standard OIDC `profile` scope during the authentication process which should result in the ID token including more information:"
msgstr "これを修正するには、認証プロセス中に標準の OIDC `profile` スコープを要求するように Quarkus を設定します。これにより、ID トークンにさらに多くの情報が含まれるようになります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Request `profile` scope in addition to the default `openid` scope."
msgstr "デフォルトの `openid` スコープに加え、 `profile` スコープを要求します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Go back to http://localhost:8080/q/dev/, repeat the process of logging in to `Auth0` and check the ID token again, now you should see the ID token containing the `name` claim:"
msgstr "http://localhost:8080/q/dev/ に戻り、 `Auth0` へのログインプロセスを繰り返して ID トークンを再度確認すると、 `name` クレームを含む ID トークンが表示されるはずです。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "You should get the name when you access the Quarkus endpoint directly from the browser. Clear the browser cookie cache, access http://localhost:8080/hello and yet again, you get `Hello, auth0|60e5a305e8da5a006aef5471` returned. Hmm, what is wrong ?"
msgstr "ブラウザーから Quarkus エンドポイントに直接アクセスすると、名前が返されるはずです。しかし、ブラウザーの Cookie キャッシュをクリアして http://localhost:8080/hello にアクセスしても、再度 `Hello, auth0|60e5a305e8da5a006aef5471` が返されます。何が間違っているのでしょうか?"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The answer lies with the specifics of the `org.eclipse.microprofile.jwt.JsonWebToken#getName()` implementation, which, according to the https://github.com/eclipse/microprofile-jwt-auth[MicroProfile MP JWT RBAC  specification], checks an MP JWT specific `upn` claim, trying `preferred_username` next and finally `sub` which explains why you get the `Hello, auth0|60e5a305e8da5a006aef5471` answer even with the ID token containing the `name` claim. We can fix it easily by changing the endpoint `hello()` method's implementation to return a specific claim value:"
msgstr "答えは、 `org.eclipse.microprofile.jwt.JsonWebToken#getName()` 実装の詳細にあります。 https://github.com/eclipse/microprofile-jwt-auth[MicroProfile MP JWT RBAC の仕様] によると、この実装は MP JWT 固有の `upn` クレームをチェックし、次に `preferred_username` を試行し、最後に `sub` を試行します。これが、ID トークンに `name` クレームが含まれていても、レスポンスとして `Hello, auth0|60e5a305e8da5a006aef5471` が返される理由です。これは、エンドポイント `hello()` メソッドの実装を、特定のクレーム値を返すように変更することで、簡単に修正できます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now clear the browser cache, access http://localhost:8080/hello and finally the user name is returned."
msgstr "次にブラウザーのキャッシュをクリアして http://localhost:8080/hello にアクセスすると、ユーザー名が返されます。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Logout support"
msgstr "ログアウトのサポート"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now that you have the users signing in to Quarkus with the help of Auth0, you probably want to support a user-initiated logout. Quarkus supports https://quarkus.io/guides/security-oidc-code-flow-authentication#logout-and-expiration[RP-initiated and other standard OIDC logout mechanisms, as well as the local session logout]."
msgstr "Auth0を使用してQuarkusにサインインしたユーザーは、ユーザーによるログアウトをサポートしたいと思うでしょう。Quarkusでは、 link:https://quarkus.io/guides/security-oidc-code-flow-authentication#logout-and-expiration[ローカルセッションのログアウトだけでなく、RP-initiated Logoutやその他の標準的なOIDCログアウトメカニズム] もサポートしています。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Currently, Auth0 does not support the standard OIDC RP-initiated logout and does not provide an end session endpoint URL in its discoverable metadata, but it provides its own logout mechanism which works nearly exactly the same as the standard one."
msgstr "現在のところ、Auth0は標準化されたOIDC RP-initiated logoutをサポートしておらず、発見可能なメタデータにセッション終了エンドポイントURLを提供していないが、標準的なものとほぼ同じ動作をする独自のログアウトメカニズムを提供しています。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "It is easy to support it with Quarkus OIDC. You must configure an Auth0 end session endpoint URL and have Quarkus include both the `client-id` query parameter and the post logout URL as the `returnTo` query parameter in the RP-initated logout redirect request to Auth0:"
msgstr "Quarkus OIDC を使用するとこれを簡単にサポートできます。Auth0 のセッション終了エンドポイント URL を設定し、Quarkus で、 `client-id` クエリーパラメーターとログアウト後の URL の両方を、 `returnTo` クエリーパラメーターとしてAuth0 への RRP-initated logoutリダイレクトリクエストに含める必要があります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Auth0 does not include the end session URL in its metadata, so complement it with manually configuring the Auth0 end session endpoint URL."
msgstr "Auth0 はメタデータにセッション終了 URL を含めないため、Auth0 セッション終了エンドポイント URL を手動で設定して補完します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Auth0 will not recognize a standard `post_logout_redirect_uri` query parameter and expects a parameter `returnTo` instead."
msgstr "Auth0 は標準の `post_logout_redirect_uri` クエリーパラメーターを認識せず、代わりに `returnTo` パラメーターを期待します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Auth0 expects `client-id` in the logout request."
msgstr "Auth0 はログアウトリクエストで `client-id` を期待します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Authenticated requests to `/logout` path will be treated as RP-inititated logout requests."
msgstr "`/logout` パスへの認証済みリクエストは、RP 主導型ログアウトリクエストとして処理されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "This is a public resource to where the logged out user should be returned to."
msgstr "これは、ログアウトしたユーザーが返されるパブリックリソースです。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Make sure the `/logout` path is protected."
msgstr "`/logout` パスが保護されているようにして下さい。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Here we have customized the Auth0 end session endpoint URL and indicated to Quarkus that an `http://localhost:8080/logout` request must trigger a logout of the currently authenticated user. An interesting thing about the `/logout` path is that it is `virtual`, it is not supported by any method in the JAX-RS endpoint, so for Quarkus OIDC to be able to react to `/logout` requests we attach an `authenticated` https://quarkus.io/guides/security-authorize-web-endpoints-reference#authorization-using-configuration[HTTP security policy] to this path directly in the configuration."
msgstr "ここでは、Auth0 セッション終了エンドポイント URL をカスタマイズし、Quarkus に対して、 `http://localhost:8080/logout` リクエストが現在認証されているユーザーのログアウトをトリガーする必要があることを示しました。 `/logout` パスについては、それが `virtual` であり、JAX-RS エンドポイントのどのメソッドでもサポートされていないことに留意する必要があります。これが理由で、Quarkus OIDC が `/logout` リクエストに反応するためには、設定でこのパスに直接 `authenticated` https://quarkus.io/guides/security-authorize-web-endpoints-reference#authorization-using-configuration[HTTP セキュリティーポリシー] をアタッチする必要があります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "We also have configured Quarkus to return the logged out user to the public `/hello/post-logout` resource, and this path is included in the logout request as the Auth0 specific `returnTo` query parameter. Finally, the Quarkus application's `client-id` is included in the logout URL as well."
msgstr "また、ログアウトしたユーザーをパブリック `/hello/post-logout` リソースに返すように Quarkus を設定しました。このパスは、Auth0 固有の `returnTo` クエリーパラメーターとしてログアウトリクエストに含まれています。Quarkus アプリケーションの `client-id` もログアウト URL に含まれています。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Update the endpoint to accept the post logout redirects:"
msgstr "ログアウト後のリダイレクトを受け入れるようにエンドポイントを更新します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Note the addition of the public `/hello/post-logout` resource method."
msgstr "パブリック `/hello/post-logout` リソースメソッドが追加されたことに注意してください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Before we test the logout, make sure the `Auth0` application is configured to allow this post logout redirect back to Quarkus after the user has been logged out:"
msgstr "ログアウトをテストする前に、ユーザーがログアウトした後の Quarkus へのリダイレクトを許可するように、 `Auth0` アプリケーションが設定されていることを確認します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now, clear the browser cookie cache, access http://localhost:8080/hello, login to Quarkus with Auth0, get the user name returned, and go to `http://localhost:8080/logout`. You'll see the `You were logged out` message displayed in the browser."
msgstr "ここで、ブラウザーの Cookie キャッシュをクリアし、 http://localhost:8080/hello にアクセスし、Auth0 で Quarkus にログインしてユーザー名を取得し、 `http://localhost:8080/logout` に移動します。ブラウザーには、 `You were logged out` というメッセージが表示されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Next, go to the http://localhost:8080/q/dev/, login to Auth0 from the Dev UI SPA and notice you can now logout from the OIDC Dev UI too, see the symbol representing the logout next to the `Logged in as Sergey Beryozkin` text:"
msgstr "次に、 http://localhost:8080/q/dev/ に移動し、Dev UI SPA から Auth0 にログインします。 `Logged in as Sergey Beryozkin` というテキストの横に、ログアウトを表す記号が表示され、OIDC Dev UI からもログアウトが可能になったことがわかります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "For the logout to work from OIDC DevUI, the Auth0 application's list of allowed logout callbacks has to be updated to include the OIDC DevUI endpoint:"
msgstr "OIDC DevUI からのログアウトが機能するためには、Auth0 アプリケーションの許可されたログアウトコールバックのリストを更新して、OIDC DevUI エンドポイントを含める必要があります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now logout directly from OIDC Dev UI and login as a new user - add more users to the registered Auth0 application if required."
msgstr "次に、OIDC Dev UI から直接ログアウトし、新しいユーザーとしてログインします。必要に応じて、登録済みの Auth0 アプリケーションにさらにユーザーを追加します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Role-based access control"
msgstr "ロールベースのアクセスコントロール"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "We have confirmed that the Quarkus endpoint can be accessed by users who have authenticated with the help of `Auth0`."
msgstr "`Auth0` を使用して認証されたユーザーが Quarkus エンドポイントにアクセスできることを確認しました。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The next step is to introduce role-based access control (RBAC) to have users in a specific role only, such as `admin`, be able to access the endpoint."
msgstr "次の手順では、ロールベースのアクセス制御 (RBAC) を導入して、 `admin` など特定のロールを持つユーザーのみがエンドポイントにアクセスできるようにします。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "See also the <<permission-based-access-control>> section below."
msgstr "以下の <<permission-based-access-control>> セクションも参照してください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Auth0 tokens do not include any claims containing roles by default, so, first, you must customize the `Login` flow of the `Auth0` application with a custom action which will add the roles to tokens. Select `Actions/Flows/Login` in the `Auth0` dashboard, choose `Add Action/Build Custom`, name it as `AddRoleClaim`:"
msgstr "デフォルトで、Auth0 トークンにはロールを含むクレームは含まれていないため、まず、トークンにロールを追加するカスタムアクションを使用して、 `Auth0` アプリケーションの `Login` フローをカスタマイズする必要があります。 `Auth0` ダッシュボードで `Actions/Flows/Login` を選択し、 `Add Action/Build Custom` を選択し、 `AddRoleClaim` という名前を付けます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Add the following action script to it:"
msgstr "そこに次のアクションスクリプトを追加します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Note a custom Auth0 claim has to be namespace qualified, so the claim which will contain roles will be named as \"https://quarkus-security.com/roles\". Have a look at the ID token content we analyzed in the previous sections and you will see how this claim is represented, for example:"
msgstr "カスタム Auth0 クレームは namespace で修飾される必要があるため、ロールを含むクレームの名前は https://quarkus-security.com/roles になります。前のセクションで分析した ID トークンのコンテンツを確認すると、このクレームがどのように表現されているかがわかります。以下はその例です。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The `Auth0` Login Flow diagram should look like this now:"
msgstr "`Auth0` ログインフロー図は次のようになります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "You must add a role such as `admin` to the users registered in the `Auth0` application."
msgstr "`Auth0` アプリケーションに登録されているユーザーに、 `admin` などのロールを追加する必要があります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Create an `admin` role:"
msgstr "`admin` ロールを作成します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "and add it to the registered user:"
msgstr "それを登録済みユーザーに追加します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Next, update the Quarkus endpoint to require that only users with the `admin` role can access the endpoint:"
msgstr "次に、Quarkus エンドポイントを更新して、 `admin` ロールを持つユーザーのみがエンドポイントにアクセスできるようにします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Open http://localhost:8080/hello, authenticate to Auth0 and get `403`. The reason you get `403` is because Quarkus OIDC does not know which claim in the `Auth0` tokens represents the roles information, by default a `groups` claim is checked, while Auth0 tokens are now expected to have an \"https://quarkus-security.com/roles\" claim."
msgstr "http://localhost:8080/hello を開き、Auth0 に対して認証すると `403` が発生します。ここでは、Quarkus OIDC が `Auth0` トークンのどのクレームがロール情報を表しているか認識していないため、 `403` が発生します。デフォルトでは `groups` クレームがチェックされますが、ここでは Auth0 トークンに \"https://quarkus-security.com/roles\" クレームがあることが期待されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Fix it by telling Quarkus OIDC which claim must be checked to enforce RBAC:"
msgstr "RBAC を適用するためにどのクレームをチェックする必要があるかを Quarkus OIDC に指示して修正します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Point to the custom roles claim. The path to the roles claim is in double quotes because the claim is namespace qualified."
msgstr "カスタムロールクレームを指します。クレームは namespace で修飾されているため、ロールクレームへのパスは二重引用符で囲まれます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now, clear the browser cookie cache, access http://localhost:8080/hello again, authenticate to Auth0 and get an expected user name."
msgstr "ブラウザーの Cookie キャッシュをクリアし、再度 http://localhost:8080/hello にアクセスし、Auth0 に対して認証して期待されるユーザー名を取得します。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Access Quarkus with opaque Auth0 access tokens"
msgstr "不透明 Auth0 アクセストークンを使用して Quarkus にアクセスする"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The main goal of this section is to explain how Quarkus can be tuned to accept `opaque` bearer Auth0 access tokens as opposed to Auth0 JWT access tokens because Auth0 access tokens issued during the authorization code flow are opaque by default and they can only be used to request `UserInfo` in addition to the information about the current user which is already available in ID token. Learning how to verify opaque tokens can be useful because many OIDC and OAuth2 providers will issue opaque access tokens only."
msgstr "このセクションでは主に、Auth0 JWT アクセストークンではなく、 `不透明` ベアラー Auth0 アクセストークンを受け入れるように Quarkus を調整する方法を説明します。なぜなら、認可コードフローで発行される Auth0 アクセストークンはデフォルトで不透明であり、すでに ID トークンで提供されている現行ユーザーの情報に加え、 `UserInfo` をリクエストするためにしか使用できないためです。多くの OIDC および OAuth2 プロバイダーは不透明アクセストークンしか発行しないため、不透明トークンの検証方法を理解すると役立ちます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "For more information on how to configure Auth0 and Quarkus to have authorization code access tokens issued in the JWT format and propagated to service endpoints, see the following <<token-propagation>> and <<jwt-access-tokens>> sections."
msgstr "Auth0 と Quarkus を設定して認可コードアクセストークンを JWT フォーマットで発行し、サービスエンドポイントに伝播させる方法の詳細は、<<token-propagation>> セクションと<<jwt-access-tokens>> セクションを参照してください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "So far we have only tested the Quarkus endpoint using OIDC authorization code flow. In this flow you use the browser to access the Quarkus endpoint, Quarkus itself manages the authorization code flow, a user is redirected to Auth0, logs in, is redirected back to Quarkus, Quarkus completes the flow by exchanging the code for the ID, access, and refresh tokens, and works with the ID token representing the successful user authentication. The access token is not relevant at the moment. As mentioned earlier, in the authorization code flow, Quarkus will only use the access token to access downstream services on behalf of the currently authenticated user."
msgstr "これまで、OIDC 認可コードフローを使用して Quarkus エンドポイントのみをテストしてきました。このフローでは、ブラウザーを使用して Quarkus エンドポイントにアクセスし、Quarkus 自体が認可コードフローを管理します。ユーザーは Auth0 にリダイレクトされてログインし、Quarkus に再度リダイレクトされます。その後 Quarkus が ID トークン、アクセストークン、およびリフレッシュトークンのコードを交換してフローを完了し、ユーザー認証の成功を表す ID トークンを処理します。この時点でアクセストークンは使用されません。前述のとおり、Quarkus が認可コードフローでアクセストークンを使用するのは、認証済の現行ユーザーに代わってダウンストリームサービスにアクセスする場合に限られます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Let's imagine though that the Quarkus endpoint we have developed has to accept `Bearer` access tokens too: it may be that the other Quarkus endpoint which is propagating it to this endpoint or it can be SPA which uses the access token to access the Quarkus endpoint. And Quarkus OIDC DevUI SPA which we already used to analyze the ID token fits perfectly for using the access token available to SPA to test the Quarkus endpoint."
msgstr "しかし、開発した Quarkus エンドポイントも `ベアラー` アクセストークンを受け入れる必要があると想像してみてください。このエンドポイントにそれを伝播している他の Quarkus エンドポイントかもしれませんし、アクセストークンを使用して Quarkus エンドポイントにアクセスする SPA かもしれません。その場合、すでに ID トークンの分析に使用した Quarkus OIDC DevUI SPA は、SPA が使用できるアクセストークンを使用して Quarkus エンドポイントをテストするのに最適です。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Let's go again to http://localhost:8080/q/dev-ui, select the `OpenId Connect` card, login to Auth0, and check the Access token content:"
msgstr "再度 http://localhost:8080/q/dev-ui にアクセスし、 `OpenId Connect` カードを選択して Auth0 にログインし、アクセストークンの内容を確認します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "This access token, as opposed to the ID token we looked at earlier, cannot be verified by Quarkus directly. This is because the access token is in `JWE` (encrypted) as opposed to `JWS` (signed) format. You can see from the decoded token headers that it has been encrypted directly with a secret key known to Auth0 only, and therefore its content cannot be decrypted by Quarkus. From the Quarkus's perspective this access token is an `opaque` one, Quarkus cannot use public Auth0 asymmetric verification keys to verify it."
msgstr "このアクセストークンは、 `JWS` (署名済み) フォーマットではなく `JWE` (暗号化済み) フォーマットであるため、前述の ID トークンとは異なり Quarkus が直接検証することはできません。デコードされたトークンヘッダーを見ると、Auth0 のみが知る秘密鍵で直接暗号化されているため、Quakus はその内容を復号化できないことがわかります。このアクセストークンは Quarkus から見ると `不透明` であり、Quarkus は Auth0 の公開非対称検証キーを使用してこれを検証することはできません。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "To confirm it, enter `/hello` as the `Service Address` in the `Test Service` area and press `With Access Token` and you will get the HTTP `401` status:"
msgstr "確認するには、 `Test Service` 領域の `Service Address` として `/hello` を入力して `With Access Token` を押すと、HTTP `401` ステータスが表示されます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"For Quarkus be able to accept such access tokens, one of the two options should be available.\n"
"The first option is to introspect the opaque token remotely using a provider's introspection endpoint. Token introspection is typically supported at the `OAuth2` level, and since `OIDC` is built on top of `OAuth2`, some OIDC providers such as Keycloak support the token introspection as well. However, Auth0 does not support the token introspection, you can check it by looking at the publicly available Auth0 metadata, add `/.well-known/openid-configuration` to the address of your configured Auth0 provider, and open the resulting URL, `https://dev-3ve0cgn7.us.auth0.com/.well-known/openid-configuration`. You will see that Auth0 does not have an introspection endpoint:"
msgstr ""
"Quarkus がこのようなアクセストークンを受け入れるには、2 つのオプションのいずれかを使用できなければなりません。\n"
"最初のオプションは、プロバイダーのイントロスペクションエンドポイントを使用して、不透明トークンをリモートでイントロスペクトします。通常、トークンイントロスペクションは `OAuth2` レベルでサポートされ、 `OIDC` は `OAuth2` 上に構築されているため、Keycloak などの一部の OIDC プロバイダーもトークンイントロスペクションをサポートします。ただし、Auth0 はトークンイントロスペクションをサポートしません。確認するには、公開されている Auth0 メタデータを確認し、設定済みの Auth0 プロバイダーのアドレスに `/.well-known/openid-configuration` を追加し、その結果として得られる URL `https://dev-3ve0cgn7.us.auth0.com/.well-known/openid-configuration` を開きます。これにより、Auth0 にイントロスペクションエンドポイントがないことがわかります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Therefore the other option, indirect access token verification, where the access token is used to acquire `UserInfo` from Auth0 can be used to accept and verify opaque Auth0 tokens. This option works because OIDC providers have to verify access tokens before they can issue `UserInfo` and Auth0 has a `UserInfo` endpoint."
msgstr "この場合は、別のオプションを使用できます。つまり、アクセストークンを使用して Auth0 から `UserInfo` を取得し、間接的にアクセストークンを検証するというもう 1 つのオプションを使用して、不透明な Auth0 トークンを受け入れ、検証できます。OIDC プロバイダーは `UserInfo` を発行する前にアクセストークンを検証する必要があり、Auth0 には `UserInfo` エンドポイントがあるため、このオプションが機能します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "So lets configure Quarkus to request that the access tokens must be verified by using them to acquire `UserInfo`:"
msgstr "ここで、アクセストークンを使用して `UserInfo` を取得することでアクセストークンの検証行うことをリクエストするように、Quarkus を設定してみましょう。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Verify access tokens indirectly by using them to request `UserInfo`."
msgstr "アクセストークンを使用して `UserInfo` をリクエストすることで、アクセストークンを間接的に検証します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Update the endpoint code to expect `UserInfo` as opposed to `ID token`:"
msgstr "`ID token` ではなく `UserInfo` を期待するように、エンドポイントコードを更新します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "This code will now work both for the authorization code and bearer access token flows."
msgstr "このコードは、認可コードフローとベアラーアクセストークンフローの両方で機能するようになります。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Let's go to the OIDC Dev UI where we looked at the access token, enter `/hello` as the `Service Address` in the `Test Service` area and press `With Access Token` and you will get `200`:"
msgstr "アクセストークンを確認した OIDC Dev UI に移動し、 `Test Service` 領域の `Service Address` として `/hello` を入力し、 `With Access Token` を押すと `200` が返されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "To confirm that it really does work, update the test endpoint to allow a `user` role only with `@RolesAllowed(\"user\")`. Try to access the endpoint from OIDC Dev UI again, and you will get the HTTP `403` error. Revert the code back to `@RolesAllowed(\"admin\")` to get the reassuring HTTP `200` status again."
msgstr "実際に動作することを確認するには、 `@RolesAllowed(\"user\")` でのみ `user` ロールを許可するようにテストエンドポイントを更新します。その後、OIDC Dev UI からエンドポイントに再度アクセスすると、HTTP `403` エラーが発生します。コードを `@RolesAllowed (\"admin\")` に戻すと、HTTP `200` ステータスが再び表示されます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "When verifying the opaque access token indirectly, by using it to request `UserInfo`, Quarkus will use `UserInfo` as the source of the roles information, if any. As it happens, Auth0 includes the custom role claim which was created earlier in the `UserInfo` response as well."
msgstr "不透明アクセストークンを間接的に検証する場合、それを使用して `UserInfo` をリクエストすると、Quarkus はロール情報のソースとして `UserInfo` を使用します (存在する場合)。その結果、Auth0 は `UserInfo` レスポンスに以前に作成されたカスタムロールクレームも含めます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "As has already been mentioned in the introduction to this section, the main goal of this section is to explain how Quarkus can verify opaque access tokens. In general, propagating access tokens whose only purpose is to allow retrieving `UserInfo` to services should be avoided unless the front-end JAX-RS endpoint or SPA prefers to delegate UserInfo retrieval to the trusted service."
msgstr "このセクションの冒頭で言及したとおり、このセクションの主な目的は、Quarkus による不透明アクセストークンの検証方法を説明することです。一般的には、フロントエンドの JAX-RS エンドポイントまたは SPA が UserInfo の取得を信頼できるサービスに委譲することを望まない限り、 `UserInfo` の取得を許可することのみを目的とするアクセストークンをサービスに伝播することは回避するべきです。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "For a recommended approach of working with Auth0 access tokens, see the following <<token-propagation>> and <<jwt-access-tokens>> sections."
msgstr "Auth0 アクセストークンの推奨される使用方法については、次の <<token-propagation>> セクションと<<jwt-access-tokens>> セクション を参照してください。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Typically one uses access tokens to access remote services but OIDC DevUI SPA dashboard also offers an option to test with the ID token. This option is only available to emulate the cases where SPA delegates to the endpoint to verify and retrieve some information from the ID token for SPA to use - but ID token will still be sent to the endpoint as Bearer token by OIDC DevUI. Prefer testing with the access token in most cases."
msgstr "通常、リモートサービスにアクセスするにはアクセストークンを使用しますが、OIDC DevUI SPA ダッシュボードには ID トークンを使用してテストするオプションもあります。このオプションは、SPA がエンドポイントに委譲して、SPA が使用するために ID トークンからいくつかの情報を検証および取得するケースをエミュレートするためにのみ使用できます。その場合も、ID トークンは OIDC DevUI によってベアラートークンとしてエンドポイントに送信されます。ほとんどの場合は、アクセストークンを使用してテストすることが推奨されます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"You can use SwaggerUI or GraphQL from OIDC DevUI for testing the service, instead of manually entering the service path to test.\n"
"For example, if you add"
msgstr ""
"テストするサービスパスを手動で入力する代わりに、OIDC DevUI の SwaggerUI または GraphQL を使用してサービスをテストできます。\n"
"たとえば以下をアプリケーションの pom に追加します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "to your application's pom then you will see a Swagger link in OIDC Dev UI:"
msgstr "OIDC Dev UI に Swagger リンクが表示されます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Click the Swagger link and start testing the service."
msgstr "Swagger リンクをクリックして、サービスのテストを開始します。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Propagate access tokens to microservices"
msgstr "アクセストークンのマイクロサービスへの伝搬"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now that we have managed to use OIDC authorization code flow and used both ID token and UserInfo to access the user information, the next typical task is to propagate the current Auth0 access token to access the downstream service on behalf of the currently authenticated user."
msgstr "OIDC 認可コードフローを使用し、ID トークンと UserInfo の両方を使用してユーザー情報にアクセスできるようになりました。一般的な次のタスクは、現在の Auth0 アクセストークンを伝播して、現行の認証済みユーザー代わってダウンストリームサービスにアクセスすることです。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "In fact, the last code example, showing the injected `UserInfo`, is a concrete example of the access token propagation, in this case, Quarkus propagates the Auth0 access token to the Auth0 `UserInfo` endpoint to acquire `UserInfo`. Quarkus does it without users having to do anything themselves."
msgstr "実際、注入された `UserInfo` を示す最後のサンプルコードは、具体的なアクセストークンを伝播した例です。この場合、Quarkus は Auth0 アクセストークンを Auth0 `UserInfo` エンドポイントに伝播して `UserInfo` を取得します。Quarkus は、ユーザーが何もしなくてもこれを実行します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "But what about propagating access tokens to some custom services ? It is very easy to achieve in Quarkus, both for the authorization code and bearer token flows. All you need to do is to create a REST Client interface for calling the service requiring a Bearer token access and annotate it with `@AccessToken` and the access token arriving to the front-end endpoint as the Auth0 Bearer access token or acquired by Quarkus after completing the Auth0 authorization code flow, will be propagated to the target microservice. This is as easy as it can get."
msgstr "しかし、アクセストークンを一部のカスタムサービスに伝播させる場合はどうでしょうか。Quarkus では、認可コードフローとベアラートークンフローの両方で非常に簡単にこれを実現できます。ベアラートークンアクセスを必要とするサービスを呼び出すための REST クライアントインターフェイスを作成し、それにアノテーション `@AccessToken` を付けるだけで、Auth0 ベアラーアクセストークンとしてフロントエンドエンドポイントに到着するアクセストークン、または Auth0 認可コードフローの完了後に Quarkus が取得したアクセストークンが、ターゲットマイクロサービスに伝播されます。これ以上簡単にはならないぐらい簡単です。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"For examples of propagating access tokens, see the following sections in this tutorial.\n"
"For more information about token propagation, see xref:security-openid-connect-client-reference.adoc#token-propagation-rest[OIDC token propagation]."
msgstr ""
"アクセストークンの伝播の例については、このチュートリアルの以下のセクションを参照してください。\n"
"トークンの伝播の詳細については、 xref:security-openid-connect-client-reference.adoc#token-propagation-rest[OIDC トークンの伝播] を参照してください。"

#. type: Title ===
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Access tokens in JWT format"
msgstr "JWT形式のアクセストークン"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "We have already looked in detail at how Quarkus OIDC can handle <<opaque-access-tokens>>, but we don't want to propagate Auth0 opaque tokens to micro services which do something useful on behalf on the currently authenticated user, beyond checking its UserInfo."
msgstr "Quarkus OIDC による <<opaque-access-tokens>> の処理方法を詳しく見てきました。しかし、UserInfo の確認以外の操作を現行の認証済みユーザーに代わって実行するマイクロサービスに、Auth0 の不透明トークンを伝播することは回避する必要があります。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "A microservice which the front-end Quarkus application will access by propagating authorization code flow access tokens to it is represented in the Auth0 dashboard as an `API`. Let's add it in the `Applications/APIs`:"
msgstr "フロントエンドの Quarkus アプリケーションが認可コードフローのアクセストークンを伝播してアクセスするマイクロサービスは、Auth0 ダッシュボードでは `API` として表されます。これを `Applications/APIs` に追加してみましょう。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The `https://quarkus-auth0` identifier of the created `QuarkusAuth0API` will serve as this API's `audience`. Providing this audience as a query parameter in the authorization code flow redirect to Auth0 will ensure that Auth0 issues access tokens in the JWT format."
msgstr "作成された `QuarkusAuth0API` の `https://quarkus-auth0` 識別子は、この API の `audience` として機能します。Auth0 への認可コードフローリダイレクトでこのオーディエンスをクエリーパラメーターとして提供すると、Auth0 は必ず JWT フォーマットでアクセストークンを発行するようになります。"

#. type: Title ===
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "API microservice"
msgstr "APIマイクロサービス"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Add the following dependencies to the project to support OIDC token propagation and REST clients:"
msgstr "OIDC トークンの伝播と REST クライアントをサポートするために、以下の依存関係をプロジェクトに追加します："

#. type: Block title
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Create `ApiEchoService` service class:"
msgstr "`ApiEchoService` サービスクラスを作成する："

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"And configure it as an OIDC `service` application which will only fetch public verification keys from Auth0.\n"
"The configuration for this microservice should only have a single line:"
msgstr ""
"これを、Auth0 から公開検証キーのみを取得する OIDC `service` アプリケーションとして設定します。\n"
"このマイクロサービスの設定は、次の 1 行のみとなるはずです。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "which is all what is needed for the OIDC `service` application to fetch Auth0 public verification keys and use them to verify Auth0 access tokens in JWT format."
msgstr "これだけで、OIDC `service` アプリケーションは Auth0 公開検証キーを取得し、それを使用して JWT フォーマットの Auth0 アクセストークンを検証できます。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "In this tutorial you have already configured the OIDC `hybrid` application which can handle both authorization code and bearer token authentication flows. In production you will run microservices as separate servers but for the sake of simplicity `ApiEchoService` will not have to be started as a second server with its own configuration containing `quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com` only, and therefore the current configuration which already has the Auth0 dev tenant address configured will be reused."
msgstr "このチュートリアルでは、認可コードとベアラートークン認証フローの両方を処理できる OIDC `hybrid` アプリケーションをすでに設定しています。実稼働環境ではマイクロサービスを別のサーバーとして実行しますが、ここではわかりやすくするために、 `ApiEchoService` を `quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com` のみを含む独自の設定を持つ 2 番目のサーバーとして起動する必要はありません。そのため、Auth0 開発テナントアドレスがすでに設定されている現行の設定が再利用されます。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The `hybrid` OIDC application type will ensure that `http://localhost:8080/hello` requests to `GreetingResource` initiate an Authorization code flow while `http://localhost:8080/echo` requests to `ApiEchoService`, initiated by `GreetingResource`, will lead to the authorization code flow tokens being propagated and accepted by `ApiEchoService` as bearer JWT access tokens."
msgstr "`hybrid` OIDC アプリケーションタイプでは、 `GreetingResource` への `http://localhost:8080/hello` リクエストによって認可コードフローが開始されます。一方で、、 `GreetingResource` によって開始された `ApiEchoService` への `http://localhost:8080/echo` リクエストによって、認可コードフロートークンが伝播され、ベアラー JWT アクセストークンとして `ApiEchoService` によって受け入れられます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Next, add a REST client interface representing `ApiEchoService`:"
msgstr "次に、 `ApiEchoService` を表す REST クライアントインターフェイスを追加します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Propagate access token as an HTTP `Authorization: Bearer accesstoken` header"
msgstr "アクセストークンを HTTP `Authorization: Bearer accesstoken` ヘッダーとして伝播します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "And update the configuration for the Quarkus front-end application, `GreetingResource`, which has been created earlier, to request that an authorization code flow access token (as opposed to ID token) includes an `aud` (audience) claim targeting `ApiEchoService`, as well as configure the base URL for the `ApiEchoService` REST client:"
msgstr "さらに、前に作成した Quarkus フロントエンドアプリケーション `GreetingResource` の設定を更新して、認可コードフローの (ID トークンではなく) アクセストークンに `ApiEchoService` をターゲットとする `aud` (オーディエンス) クレームを組み込むようにリクエストし、 `ApiEchoService` REST クライアントのベース URL を設定します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"Pass an extra `audience` query parameter to the Auth0 authorization endpoint during the authorization code flow redirect from Quarkus to Auth0.\n"
"It will ensure that the access token is issued in the JWT format and includes an `aud` (audience) claim which will contain `https://quarkus-auth0`."
msgstr ""
"Quarkus から Auth0 への認可コードフローのリダイレクト中に、追加の `audience` クエリーパラメーターを Auth0 認可エンドポイントに渡します。\n"
"これにより、アクセストークンが JWT フォーマットで発行され、 `https://quarkus-auth0` を含む `aud` (オーディエンス) クレームが確実に組み込まれます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Point `ApiEchoServiceClient` to the `ApiEchoService` endpoint. HTTP port in the `org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port}` property is parameterized to ensure the correct URL is built while using the dev, test and prod modes."
msgstr "`ApiEchoServiceClient` が `ApiEchoService` エンドポイントを指すようにします。 `org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port}` プロパティーは、開発モード、テストモード、本番モードの使用中に正しい URL が構築されるようにパラメーター化されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Finally update `GreetingResource` to request that `ApiEchoService` echoes a user name:"
msgstr "最後に、 `ApiEchoService` がユーザー名をエコーするようにリクエストするように、 `GreetingResource` を更新します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Inject `ApiEchoServiceClient` REST client"
msgstr "`ApiEchoServiceClient` REST クライアントを注入します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Use `ApiEchoServiceClient` to echo the user name."
msgstr "`ApiEchoServiceClient` を使用してユーザー名をエコーします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Open a browser, access http://localhost:8080/hello and get your name displayed in the browser."
msgstr "ブラウザーを開いて http://localhost:8080/hello にアクセスし、ブラウザーに自分の名前を表示します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Let's go to http://localhost:8080/q/dev-ui, select the `OpenId Connect` card, login to Auth0, and check the Access token content:"
msgstr "http://localhost:8080/q/dev-ui に移動して `OpenId Connect` カードを選択し、Auth0 にログインし、アクセストークンの内容を確認します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "As you can see, the access token is no longer encrypted as shown in the <<opaque-access-tokens>> section and indeed it is in the JWT format now."
msgstr "<<opaque-access-tokens>> セクションに示されているとおりアクセストークンは暗号化されなくなり、JWT フォーマットになります。"

#. type: Title ===
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Permission Based Access Control"
msgstr "権限ベースのアクセス制御"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "We have discussed in the <<role-based-access-control>> section how to get Quarkus to check a namespace qualified claim containing user roles and use this information to enforce role-based access control. You have configured Auth0 to add the custom roles claim to both ID and access tokens."
msgstr "<<role-based-access-control>> セクションでは、Quarkus でユーザーロールを含む namespace で修飾されたクレームをチェックする方法と、その情報を使用してロールベースのアクセス制御を適用する方法について説明しました。Auth0 はすでに、ID トークンとアクセストークンの両方にカスタムロールクレームを追加するように設定されています。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "However, Permission Based Access Control is better suited to the case where an access token is propagated by the front-end endpoint to a microservice which will check if a given access token has been authorized for this service to perform a concrete action, as opposed to this token vouching for a user be in a specific role. For example, being in the admin role does not necessarily mean the user is allowed to have a read and write access to some of this microservice's content."
msgstr "ただし、フロントエンドのエンドポイントからマイクロサービスにアクセストークンを伝播する場合は、権限ベースのアクセス制御が適しています。これは、ユーザーが特定のロールを持つことをトークンが保証するのではなく、特定のアクセストークンがこのサービスに対してそのアクションを実行するために承認されているか確認します。たとえば、管理者ロールを持つからといって、必ずしもそのユーザーがこのマイクロサービスのコンテンツの一部に対する読み取りおよび書き込みを許可されるわけではありません。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Let's see how Permission Based Access Control constraints can be applied to `ApiEchoService`."
msgstr "権限ベースのアクセス制御の制約を `ApiEchoService` に適用する方法を見てみましょう。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Go to the Auth0 dashboard, add an `echo:name` permission to the `QuarkusAuth0API` API:"
msgstr "Auth0 ダッシュボードに移動し、 `QuarkusAuth0API` API に `echo:name` 権限を追加します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The `echo:name` permission will be included in the access token as a standard OAuth2 `scope` claim value if this scope will also be requested during the authorization code flow. Update the configuration as follows:"
msgstr "`echo:name` 権限は、認可コードフロー中に標準 Oauth2 `scope` もリクエストされた場合、 `echo:name` 権限が標準の OAuth2 `scope` クレーム値としてアクセストークンに含まれます。次のように設定を更新します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "An extra `echo:name` scope will be requested during the authorization code flow."
msgstr "認可コードフロー中に、追加の `echo:name` スコープがリクエストされます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now update `ApiEchoService` to enforce Permission Based Access Control:"
msgstr "ここで、権限ベースのアクセス制御を適用するように、 `ApiEchoService` を更新します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "This is all what is needed as Quarkus OIDC automatically associates `scope` claim values as permissions with the current security identity."
msgstr "以上を実行することで、Quarkus OIDC は `scope` クレーム値を現行のセキュリティーアイデンティティーの権限として自動的に関連付けます。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "You can enforce both Role Based and Permission Based Access Controls in Quarkus by combining `@RolesAllowed` and `@PermissionsAllowed` annotations."
msgstr "`@RolesAllowed` アノテーションと `@PermissionsAllowed` アノテーションを組み合わせることで、Quarkus でロールベースおよび権限ベースのアクセス制御を適用できます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Open a browser, access http://localhost:8080/hello and get the name displayed in the browser."
msgstr "ブラウザーを開いて http://localhost:8080/hello にアクセスし、ブラウザーに表示される名前を取得します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "To confirm the permission is correctly enforced, change it to `echo.name`: `@PermissionsAllowed(\"echo.name\")`. Clear the browser cache, access http://localhost:8080/hello again and you will get `403` reported by `ApiEchoService`. Now revert it back to `@PermissionsAllowed(\"echo:name\")`."
msgstr "権限が正しく適用されていることを確認するには、これを `echo.name`: `@PermissionsAllowed(\"echo.name\")` に変更します。ブラウザーのキャッシュをクリアし、 http://localhost:8080/hello に再度アクセスすると、 `ApiEchoService` によって `403` が報告されます。ここで、権限を `@PermissionsAllowed (\"echo:name\")` に戻します。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Integration testing"
msgstr "統合テスト"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "You have already used OIDC DevUI SPA to login to Auth0 and test the Quarkus endpoint with the access token, updating the endpoint code along the way."
msgstr "すでに OIDC DevUI SPA を使用して Auth0 にログインし、アクセストークンを使用して Quarkus エンドポイントをテストし、その過程でエンドポイントコードを更新しています。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "However, running tests is also essential, lets see how we can test the endpoint and configuration which you have developed during the course of this tutorial, using xref:continuous-testing.adoc[Quarkus Continuous Testing] feature."
msgstr "しかし、テストの実行も重要です。ここでは、xref:continuous-testing.adoc[Quarkus 継続的テスト] 機能を使用して、このチュートリアルを実施する中で開発したエンドポイントと設定をテストする方法を説明します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Start with the following test code :"
msgstr "次のテストコードから始めます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "If you recall, when the application was started in dev mode, the following could be seen in the CLI window:"
msgstr "アプリケーションを開発モードで起動すると、CLI ウィンドウに次のように表示されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Press `r` and notice this test failing with `403` which is expected because the test does not send a token to the endpoint:"
msgstr "`r` を押すと、このテストが `403` で失敗していることがわかります。テストはエンドポイントにトークンを送信しないため、これは想定された結果です。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Before fixing the test, let's review the options available for testing Quarkus endpoints secured by OIDC. These options might vary, depending on which flow your application supports and how you prefer to test. Endpoints which use OIDC authorization code flow can be tested using xref:security-oidc-code-flow-authentication.adoc#code-flow-integration-testing[one of these options] and endpoints which use Bearer token authentication can be tested using xref:security-oidc-bearer-token-authentication.adoc#bearer-token-integration-testing[one of these options]."
msgstr "テストを修正する前に、OIDCによって保護されたQuarkusエンドポイントをテストするために利用可能なオプションを確認しましょう。これらのオプションは、アプリケーションがどのフローをサポートしているか、またどのようにテストを行うかによって異なります。OIDC 認証コードフローを使用するエンドポイントは、 xref:security-oidc-code-flow-authentication.adoc#code-flow-integration-testing[これらのオプションのいずれか] を使用してテストすることができ、ベアラートークン認証を使用するエンドポイントは、 xref:security-oidc-bearer-token-authentication.adoc#bearer-token-integration-testing[これらのオプションのいずれか] を使用してテストすることができます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "As you can see, testing of the endpoints secured with Auth0 can be done with the help of `Wiremock`, or `@TestSecurity` annotation. Experiment with writing such tests on your own and reach out if you encounter any problems."
msgstr "このように、Auth0 で保護されたエンドポイントは、 `Wiremock` または `@TestSecurity` アノテーションを使用してテストできます。このようなテストを自分で書いてみて、問題が発生した場合はご連絡ください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "In this tutorial though, we will use a recently added `OidcTestClient` to support testing endpoints which use live Auth0 development tenants."
msgstr "ただしこのチュートリアルでは、最近追加された `OidcTestClient` を使用して、ライブ Auth0 開発テナントを使用するエンドポイントのテストをサポートします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Here is a related fragment of the configuration:"
msgstr "関連する設定フラグメントを次に示します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "In production, you will distinguish between prod and test level configuration with `%prod.` and `%test.` qualifiers. Let's assume that the above configuration will indeed be prefixed with `%test.` in your real application, with this configuration also including the `%prod.` qualified Auth0 production tenant configuration."
msgstr "実稼働環境では、 `%prod.` および `%test.` 修飾子を使用して本番レベルとテストレベルの設定を区別します。ここでは、実際のアプリケーションで上記の設定が `%test.` から始まり、この設定に `%prod.` で修飾された Auth0 実稼働テナント設定が含まれると仮定します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Using `OidcTestClient` to test such configuration requires acquiring a token from the Auth0 dev tenant, using either OAuth2 `password` or `client_credentials` grant, we will try a `password` grant. Make sure the application registered in the Auth0 dashboard allows the `password` grant:"
msgstr "`OidcTestClient` を使用してこのような設定をテストするには、OAuth2 `password` または `client_credentials` グラントのいずれかを使用して、Auth0 開発テナントからトークンを取得する必要があります。ここでは `password` グラントを使用します。Auth0 ダッシュボードに登録されているアプリケーションが `password` グラントを許可していることを確認してください。"

#. type: delimited block =
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "It is important to clarify that we do not recommend using the deprecated OAuth2 `password` token grant in production. However using it can help testing the endpoint with tokens acquired from the live dev Auth0 tenant."
msgstr "ここで明確にする必要があるのですが、実稼働環境で非推奨の OAuth2 `password` トークングラントを使用することは推奨されません。ただし、それの使用は、ライブ開発 Auth0 テナントから取得したトークンを使用してエンドポイントをテストする場合に役立ちます。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "`OidcTestClient` should be used to test applications accepting bearer tokens which will work for the endpoint developed in this tutorial as it supports both authorization code flow and bearer token authentication. You would need to use OIDC WireMock or `HtmlUnit` directly against the Auth0 dev tenant if only the authorization code flow was supported - in the latter case `HtmlUnit` test code would have to be aligned with how Auth0 challenges users to enter their credentials. If you like, you can copy the xref:security-oidc-code-flow-authentication.adoc#code-flow-integration-testing-wiremock[HtmlUnit test fragment] from the documentation and experiment with it."
msgstr "`OidcTestClient` は、認可コードフローとベアラートークン認証の両方をサポートしているため、このチュートリアルで開発したエンドポイントで動作するベアラートークンを受け入れるアプリケーションのテストに使用する必要があります。認証コードフローのみをサポートする場合は、OIDC WireMock を使用するか、 を Auth0 dev テナントに対して直接使用する必要があります。後者の場合、 のテストコードを Auth0 がユーザーに認証情報の入力を要求する方法に合わせる必要があります。もしよろしければ、ドキュメントにある `HtmlUnit` `HtmlUnit` xref:security-oidc-code-flow-authentication.adoc#code-flow-integration-testing-wiremock[HtmlUnit テスト] をコピーして試してみてください。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "In meantime we will now proceed with fixing the currently failing test using `OidcTestClient`."
msgstr "ここでは `OidcTestClient` を使用して、現時点で失敗しているテストを修正します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "First you must add the following dependency:"
msgstr "まず、次の依存関係を追加する必要があります。"

#. type: Block title
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "which provides a utility class `io.quarkus.test.oidc.client.OidcTestClient` which can be used in tests for acquiring access tokens (This dependency also offers an OIDC WireMock support - review the documentation how to use it for testing if you want)."
msgstr "これは、アクセストークンの取得テストに使用できるユーティリティークラス `io.quarkus.test.oidc.client.OidcTestClient` を提供します (この依存関係は OIDC WireMock サポートも提供しますので、必要に応じてドキュメントでテストに使用する方法を確認してください)。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Now update the test code like this:"
msgstr "次に、テストコードを以下のように更新します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "`OidcTestClient` is used to acquire an access token, using one of the registered user's name and password, as well as the `audience` and `scope` parameters."
msgstr "`OidcTestClient` は、登録済みユーザーの名前とパスワードのいずれかと、 `audience` および `scope` パラメーターを使用して、アクセストークンを取得するために使用されます。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "`OidcTestClient` will itself find out the `Auth0` token endpoint address, client id and secret."
msgstr "`OidcTestClient` は、 `Auth0` トークンのエンドポイントのアドレス、クライアント id、およびシークレットを検出します。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Press `r` again and have the test passing:"
msgstr "もう一度 `r` を押すと、テストが合格します。"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "By the way, if you like, you can run the tests in Continuous mode directly from DevUI:"
msgstr "ちなみに、必要に応じて DevUI から直接、連続モードでテストを実行することもできます。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Production mode"
msgstr "プロダクションモード"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"You have developed and tested the Quarkus endpoint secured with Auth0 in the development mode.\n"
"The next step is to run your application in the production mode.\n"
"Choose between JVM and native modes."
msgstr ""
"Auth0 で保護された Quarkus エンドポイントを開発モードで開発およびテストしました。\n"
"次のステップでは、アプリケーションを本番モードで実行します。\n"
"JVM モードとネイティブモードを選択します。"

#. type: Title ===
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Run the Application in JVM mode"
msgstr "JVMモードでアプリケーションを実行"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Compile the application:"
msgstr "アプリケーションをコンパイルします:"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Run the application:"
msgstr "アプリケーションの実行:"

#. type: Title ===
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Run the application in native mode"
msgstr "ネイティブ・モードでアプリケーションを実行"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"You can compile this same demo into native mode without needing any modifications.\n"
"This implies that you no longer need to install a JVM on your production environment.\n"
"The runtime technology is included in the produced binary and optimized to run with minimal resources required."
msgstr ""
"この同じデモを、変更を加えることなくネイティブモードにコンパイルできます。\n"
"つまり、実稼働環境に JVM をインストールする必要はありません。\n"
"ランタイムテクノロジーは生成されたバイナリーに組み込まれ、最小限のリソースで実行できるように最適化されています。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Compilation takes a bit longer, so this step is disabled by default."
msgstr "コンパイルには少し時間がかかるため、この手順はデフォルトで無効になっています。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Build your application again by enabling the `native` profile:"
msgstr "`native` プロファイルを有効にして、アプリケーションを再度ビルドします。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Next run the following binary directly:"
msgstr "次に、以下のバイナリーを直接実行します。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Troubleshooting"
msgstr "トラブルシューティング"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "The steps described in this tutorial should work exactly as the tutorial describes. You might have to clear the browser cookies when accessing the updated Quarkus endpoint if you have already completed the authentication. You might need to restart the Quarkus application manually in dev mode but it is not expected. If you need help completing this tutorial, you can get in touch with the Quarkus team."
msgstr "このチュートリアルで説明された手順は、チュートリアルで説明されたとおりに動作するはずです。すでに認証を完了している場合は、更新後の Quarkus エンドポイントにアクセスする際にブラウザーの Cookie をクリアする必要があることもあります。開発モードで Quarkus アプリケーションを手動で再起動する必要がある可能性もありますが、これhら想定されていません。このチュートリアルを完了するのにサポートが必要な場合は、Quarkus チームにお問い合わせください。"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid ""
"This tutorial demonstrated how Quarkus endpoints can be secured with the `quarkus-oidc` extension and Auth0 using Authorization code and Bearer token authentication flows, with both flows being supported by the same endpoint code.\n"
"Without writing a single line of code, you have added support for the custom Auth0 logout flow and enabled role-based access control with a custom Auth0 namespace qualified claim.\n"
"Token propagation from the front-end endpoint to the microservice endpoint has been achieved by adding the `@AccessToken` annotation to the microservice REST client.\n"
"Microservice endpoint activated the permission-based access control with the `@PermissionsAllowed` annotation.\n"
"You used Quarkus dev mode to update the code and configuration without restarting the endpoint, and you also used the OIDC Dev UI to visualize and test Auth0 tokens.\n"
"You used the continuous testing feature of Quarkus to complement OIDC Dev UI tests with integration tests against the live Auth0 development tenant.\n"
"Finally, you have run the application in JVM and native modes."
msgstr ""
"このチュートリアルでは、同じエンドポイントコードでサポートされている認可コードフローとベアラートークン認証フローを使用して、Quarkus エンドポイントを `quarkus-oidc` エクステンションと Auth0 で保護する方法を実演しました。\n"
"コードを 1 行も書くことなく、カスタム Auth0 ログアウトフローのサポートを追加し、namespace で修飾されたカスタム Auth0 クレームを使用してロールベースのアクセス制御を有効にしました。\n"
"マイクロサービス REST クライアントに `@AccessToken` アノテーションを追加することで、フロントエンドエンドポイントからマイクロサービスエンドポイントにトークンを伝播しました。\n"
"マイクロサービスエンドポイントは、 `@PermissionsAllowed` アノテーションを使用して権限ベースのアクセス制御を有効にしました。\n"
"Quarkus 開発モードを使用して、エンドポイントを再起動せずにコードと設定を更新し、OIDC Dev UI を使用して Auth0 トークンを視覚化およびテストしました。\n"
"Quarkus の継続的テスト機能を使用して、OIDC Dev UI テストをライブ Auth0 開発テナントに対する統合テストで補完しました。\n"
"最後に、アプリケーションを JVM モードとネイティブモードで実行しました。"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "Enjoy!"
msgstr "楽しんで!"

#. type: Title ==
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
#, no-wrap
msgid "References"
msgstr "参照"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "xref:security-overview.adoc[Quarkus Securityの概要]"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "xref:security-oidc-code-flow-authentication.adoc[OIDC code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[ウェブアプリケーションを保護するOIDCコードフローメカニズム]"

#. type: Plain text
#: _versions/main/guides/security-oidc-auth0-tutorial.adoc
msgid "xref:security-openid-connect-providers.adoc[Configuring well-known OpenID Connect providers]"
msgstr "xref:security-openid-connect-providers.adoc[よく知られたOpenID Connectプロバイダーの設定]"
