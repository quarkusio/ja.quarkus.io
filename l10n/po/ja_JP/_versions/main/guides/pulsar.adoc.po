# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-07-09 08:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/pulsar.adoc:6
#, no-wrap
msgid "Apache Pulsar Reference Guide"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:15
msgid "This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Pulsar."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:16
#, no-wrap
msgid "Introduction"
msgstr "はじめに"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:20
msgid "https://pulsar.apache.org[Apache Pulsar] is an open-source, distributed messaging and streaming platform built for the cloud.  It provides a multi-tenant, high-performance solution to server messaging with tiered storage capabilities."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:22
msgid "Pulsar implements the publish-subscribe pattern:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:24
msgid "Producers publish messages to _topics_."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:25
msgid "Consumers create _subscriptions_ to those topics to receive and process incoming messages, and send _acknowledgments_ to the broker when processing is finished."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:27
msgid "When a subscription is created, Pulsar retains all messages, even if the consumer is disconnected.  The retained messages are discarded only when a consumer acknowledges that all these messages are processed successfully."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:29
msgid "A Pulsar cluster consists of"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:31
msgid "One or more _brokers_, which are stateless components."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:32
msgid "A _metadata store_ for maintaining topic metadata, schema, coordination and cluster configuration."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:33
msgid "A set of _bookies_ used for persistent storage of messages."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:34
#, no-wrap
msgid "Quarkus Extension for Apache Pulsar"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:38
msgid "Quarkus provides support for Apache Pulsar through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 3.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:43
msgid "This guide provides an in-depth look on Apache Pulsar and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:pulsar-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Pulsar]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:46
msgid "You can add the `smallrye-reactive-messaging-pulsar` extensions to your project by running the following command in your project base directory:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:51
msgid "This will add the following to your build file:"
msgstr "これにより、 `pom.xml` に以下が追加されます:"

#. type: Block title
#: upstream/_versions/main/guides/pulsar.adoc:53
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:59
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-pulsar</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/pulsar.adoc:62
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:65
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-smallrye-reactive-messaging-pulsar\")\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:70
msgid "The extension includes `pulsar-clients-original` version 3.0.0 as a transitive dependency and is compatible with Pulsar brokers version 2.10.x."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:72
#, no-wrap
msgid "Configuring Smallrye Pulsar Connector"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:75
msgid "Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, Apache Pulsar, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:79
msgid "Applications send and receive *messages*. https://javadoc.io/doc/io.smallrye.reactive/smallrye-reactive-messaging-api/latest/org/eclipse/microprofile/reactive/messaging/Message.html[`Message`] wraps a _payload_ and can be extended with some _metadata_.  This should not be confused with a Pulsar https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/client/api/Message.html[`Message`], which consists of value, key With the Pulsar connector, a Reactive Messaging _message_ corresponds to a Pulsar _message_."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:80
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Pulsar connector maps _channels_ to Pulsar _topics_."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:84
msgid "Channels are connected to message backends using *connectors*.  Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel.  Each connector is dedicated to a specific messaging technology.  For example, the connector dealing with Pulsar is named `smallrye-pulsar`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:86
msgid "A minimal configuration for the Pulsar connector with an incoming channel looks like the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:91
#, no-wrap
msgid ""
"%prod.pulsar.client.serviceUrl=pulsar:6650 <1>\n"
"mp.messaging.incoming.prices.connector=smallrye-pulsar <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:95
msgid "Configure the Pulsar broker service url for the production profile.  You can configure it globally or per channel using `mp.messaging.incoming.$channel.serviceUrl` property.  In dev mode and when running tests, xref:pulsar-dev-services[Dev Services for Pulsar] automatically starts a Pulsar broker."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:98
msgid "Configure the connector to manage the prices channel.  By default, the _topic_ name is same as the channel name."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:100
msgid "You can configure the topic attribute to override it."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:102
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "`%prod` 接頭辞は、アプリケーションが prod モードで実行されている場合にのみプロパティーが使用されることを示します (つまり、dev または test モードでは使用されません)。詳細は、xref:config-reference.adoc#profiles[プロファイルに関するドキュメント] を参照してください。"

#. type: Block title
#: upstream/_versions/main/guides/pulsar.adoc:104
#, no-wrap
msgid "Connector auto-attachment"
msgstr "コネクターの自動アタッチ"

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:109
msgid "If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphan_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:111
msgid "This auto-attachment can be disabled using:"
msgstr "この自動アタッチは、以下を使用して無効にできます。"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:115
#, no-wrap
msgid "quarkus.reactive-messaging.auto-connector-attachment=false\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:119
msgid "For more configuration options see xref:configuring-pulsar-clients[Configuring Pulsar clients]."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:121
#, no-wrap
msgid "Receiving messages from Pulsar"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:125
msgid "The Pulsar Connector connects to a Pulsar broker using a Pulsar client and creates consumers to receive messages from Pulsar brokers, and it maps each Pulsar `Message` into Reactive Messaging `Message`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:126
#: upstream/_versions/main/guides/pulsar.adoc:399
#, no-wrap
msgid "Example"
msgstr "例"

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:130
msgid "Let’s imagine you have a Pulsar broker running, and accessible using the `pulsar:6650` address.  Configure your application to receive Pulsar messages on the `prices` channel as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:135
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.serviceUrl=pulsar://pulsar:6650 # <1>\n"
"mp.messaging.incoming.prices.subscriptionInitialPosition=Earliest # <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:138
#: upstream/_versions/main/guides/pulsar.adoc:410
msgid "Configure the Pulsar broker service url."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:139
msgid "Make sure consumer subscription starts receiving messages from the `Earliest` position."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:145
msgid "You don’t need to set the Pulsar topic, nor the consumer name.  By default, the connector uses the channel name (`prices`).  You can configure the `topic` and `consumerName` attributes to override them."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:151
msgid "In Pulsar, consumers need to provide a `subscriptionName` for topic subscriptions.  If not provided the connector generates a unique **subscription name**."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:154
msgid "Then, your application can receive the `double` payload directly:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:158
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:160
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:163
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:168
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public void consume(double price) {\n"
"        // process your price.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:170
#: upstream/_versions/main/guides/pulsar.adoc:444
#: upstream/_versions/main/guides/pulsar.adoc:534
#: upstream/_versions/main/guides/pulsar.adoc:638
#: upstream/_versions/main/guides/pulsar.adoc:705
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:173
msgid "Or, you can retrieve the Reactive Messaging type `Message<Double>`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:185
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consume(Message<Double> msg) {\n"
"    // access record metadata\n"
"    var metadata = msg.getMetadata(PulsarIncomingMessageMetadata.class).orElseThrow();\n"
"    // process the message payload.\n"
"    double price = msg.getPayload();\n"
"    // Acknowledge the incoming message (acknowledge the Pulsar message back to the broker)\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:188
msgid "The Reactive Messaging `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:190
msgid "If you want to access the Pulsar message objects directly, use:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:200
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(org.apache.pulsar.client.api.Message<Double> msg) {\n"
"    String key = msg.getKey();\n"
"    String value = msg.getValue();\n"
"    String topic = msg.topicName();\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:203
msgid "`org.apache.pulsar.client.api.Message` is provided by the underlying Pulsar client and can be used directly with the consumer method."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:206
msgid "Alternatively, your application can inject a `Multi` in your bean, identified with the channel name and subscribe to its events as the following example:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:211
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:218
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.reactive.RestStreamElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:221
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:225
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"prices\")\n"
"    Multi<Double> prices;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:233
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/prices\")\n"
"    @RestStreamElementType(MediaType.TEXT_PLAIN)\n"
"    public Multi<Double> stream() {\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:239
msgid "When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, the RESTEasy Reactive endpoint handles that for you."
msgstr "`@Channel` でメッセージを消費する場合、アプリケーションコードがサブスクリプションを行います。上記の例では、RESTEasy Reactive エンドポイントが処理します。"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:242
msgid "Following types can be injected as channels:"
msgstr "チャンネルとして注入できるのは、以下のタイプです。"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:246
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Double> streamOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:248
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Message<Double>> streamOfMessages;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:250
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Double> publisherOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:252
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Message<Double>> publisherOfMessages;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:256
msgid "As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.  If your injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:257
#, no-wrap
msgid "Pulsar Subscription Types"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:260
msgid "Pulsar *subscriptionType* consumer configuration can be used flexibly to achieve different messaging scenarios, such as publish-subscribe or queuing."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:262
#, no-wrap
msgid "*Exclusive* subscription type allows specifying a _unique subscription name_ for \"fan-out pub-sub messaging\". This is the default subscription type.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:263
#, no-wrap
msgid "*Shared*, *Key_Shared* or *Failover* subscription types allow multiple consumers to share the _same subscription name_, to achieve \"message queuing\" among consumers.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:265
msgid "If a subscription name is not provided Quarkus generates a unique id."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:266
#, no-wrap
msgid "Deserialization and Pulsar Schema"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:270
msgid "The Pulsar Connector allows configuring Schema configuration for the underlying Pulsar consumer.  See the xref:pulsar-schema-configuration[Pulsar Schema Configuration & Auto Schema Discovery] for more information."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:271
#, no-wrap
msgid "Acknowledgement Strategies"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:276
msgid "When a message produced from a Pulsar Message is *acknowledged*, the connector sends an https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#acknowledgment[acknowledgement request] to the Pulsar broker.  All Reactive Messaging messages need to be *acknowledged*, which is handled automatically in most cases.  Acknowledgement requests can be sent to the Pulsar broker using the following two strategies:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:278
#, no-wrap
msgid "**Individual acknowledgement** is the default strategy, an acknowledgement request is to the broker for each message.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:280
#, no-wrap
msgid ""
"**Cumulative acknowledgement**, configured using `ack-strategy=cumulative`, the consumer only acknowledges the last message it received.\n"
"All messages in the stream up to (and including) the provided message are not redelivered to that consumer.\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:285
msgid "By default, the Pulsar consumer does not wait for the acknowledgement confirmation from the broker to validate an acknowledgement.  You can enable this using `ackReceiptEnabled=true`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:287
#, no-wrap
msgid "Failure Handling Strategies"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:291
msgid "If a message produced from a Pulsar message is *nacked*, a failure strategy is applied.  The Quarkus Pulsar extension supports 4 strategies:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:294
msgid "`nack` *(default)* sends https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#negative-acknowledgment[negative acknowledgment] to the broker, triggering the broker to redeliver this message to the consumer.  The negative acknowledgment can be further configured using `negativeAckRedeliveryDelayMicros` and `negativeAck.redeliveryBackoff` properties."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:295
msgid "`fail` fail the application, no more messages will be processed."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:296
msgid "`ignore` the failure is logged, but the acknowledgement strategy will be applied and the processing will continue."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:299
msgid "`reconsume-later` sends the message to the https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#retry-letter-topic[retry letter topic] using the `reconsumeLater` API to be reconsumed with a delay.  The delay can be configured using the `reconsumeLater.delay` property and defaults to 3 seconds.  Custom delay or properties per message can be configured by adding an instance of `io.smallrye.reactive.messaging.pulsar.PulsarReconsumeLaterMetadata` to the failure metadata."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/pulsar.adoc:300
#, no-wrap
msgid "Acknowledgement timeout"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:304
msgid "Similar to the negative acknowledgement, with the https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#acknowledgment-timeout[acknowledgement timeout] mechanism, the Pulsar client tracks the unacknowledged messages, for the given *ackTimeout* period and sends *redeliver unacknowledged messages request* to the broker, thus the broker resends the unacknowledged messages to the consumer."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:307
msgid "To configure the timeout and redelivery backoff mechanism you can set `ackTimeoutMillis` and `ackTimeout.redeliveryBackoff` properties.  The `ackTimeout.redeliveryBackoff` value accepts comma separated values of min delay in milliseconds, max delay in milliseconds and multiplier respectively:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:313
#, no-wrap
msgid ""
"mp.messaging.incoming.out.failure-strategy=ignore\n"
"mp.messaging.incoming.out.ackTimeoutMillis=10000\n"
"mp.messaging.incoming.out.ackTimeout.redeliveryBackoff=1000,60000,2\n"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/pulsar.adoc:315
#, no-wrap
msgid "Reconsume later and retry letter topic"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:319
msgid "The https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#retry-letter-topic[retry letter topic] pushes messages that are not consumed successfully to a dead letter topic and continue message consumption.  Note that dead letter topic can be used in different message redelivery methods, such as acknowledgment timeout, negative acknowledgment or retry letter topic."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:326
#, no-wrap
msgid ""
"mp.messaging.incoming.data.failure-strategy=reconsume-later\n"
"mp.messaging.incoming.data.reconsumeLater.delay=5000\n"
"mp.messaging.incoming.data.enableRetry=true\n"
"mp.messaging.incoming.data.negativeAck.redeliveryBackoff=1000,60000,2\n"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/pulsar.adoc:328
#, no-wrap
msgid "Dead-letter topic"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:332
msgid "The https://pulsar.apache.org/docs/3.0.x/concepts-messaging/#dead-letter-topic[dead letter topic] pushes messages that are not consumed successfully to a dead letter topic an continue message consumption.  Note that dead letter topic can be used in different message redelivery methods, such as acknowledgment timeout, negative acknowledgment or retry letter topic."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:340
#, no-wrap
msgid ""
"mp.messaging.incoming.data.failure-strategy=nack\n"
"mp.messaging.incoming.data.deadLetterPolicy.maxRedeliverCount=2\n"
"mp.messaging.incoming.data.deadLetterPolicy.deadLetterTopic=my-dead-letter-topic\n"
"mp.messaging.incoming.data.deadLetterPolicy.initialSubscriptionName=my-dlq-subscription\n"
"mp.messaging.incoming.data.subscriptionType=Shared\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:346
#, no-wrap
msgid ""
"*Negative acknowledgment* or *acknowledgment timeout* methods for redelivery will redeliver the whole batch of messages containing at least an unprocessed message.\n"
"See xref:producer-batching[Producer Batching] for more information.\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:348
#, no-wrap
msgid "Receiving Pulsar Messages in Batches"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:352
msgid "By default, incoming methods receive each Pulsar message individually.  You can enable batch mode using `batchReceive=true` property, or setting a `batchReceivePolicy` in consumer configuration."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:368
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consumeMessage(PulsarIncomingBatchMessage<Double> messages) {\n"
"    for (PulsarMessage<Double> msg : messages) {\n"
"        msg.getMetadata(PulsarIncomingMessageMetadata.class).ifPresent(metadata -> {\n"
"            String key = metadata.getKey();\n"
"            String topic = metadata.getTopicName();\n"
"            long timestamp = metadata.getEventTime();\n"
"            //... process messages\n"
"        });\n"
"    }\n"
"    // ack will commit the latest offsets (per partition) of the batch.\n"
"    return messages.ack();\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:375
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consumeRecords(Messages<Double> messages) {\n"
"    for (Message<Double> msg : messages) {\n"
"        //... process messages\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:378
msgid "Or you can directly receive the list of payloads to the consume method:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:387
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(List<Double> prices) {\n"
"    for (double price : prices) {\n"
"        // process price\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:393
msgid "Quarkus auto-detects batch types for incoming channels and sets batch configuration automatically.  You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batchReceive` property."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:395
#, no-wrap
msgid "Sending messages to Pulsar"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:398
msgid "The Pulsar Connector can write Reactive Messaging Messages as Pulsar Message."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:403
msgid "Let’s imagine you have a Pulsar broker running, and accessible using the `pulsar:6650` address.  Configure your application to write the messages from the `prices` channel into a Pulsar Messages as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:407
#, no-wrap
msgid "mp.messaging.outgoing.prices.serviceUrl=pulsar://pulsar:6650 # <1>\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:416
msgid "You don’t need to set the Pulsar topic, nor the producer name.  By default, the connector uses the channel name (`prices`).  You can configure the `topic` and `producerName` attributes to override them."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:420
msgid "Then, your application must send `Message<Double>` to the `prices` channel. It can use `double` payloads as in the following snippet:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:425
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:429
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:432
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PulsarPriceProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:434
#, no-wrap
msgid "    private final Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:442
#, no-wrap
msgid ""
"    @Outgoing(\"prices-out\")\n"
"    public Multi<Double> generate() {\n"
"        // Build an infinite stream of random prices\n"
"        // It emits a price every second\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> random.nextDouble());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:448
msgid "Note that the generate method returns a `Multi<Double>`, which implements the `Flow.Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Pulsar topic."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:450
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.pulsar.OutgoingMessage` to send Pulsar messages:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:458
#, no-wrap
msgid ""
"@Outgoing(\"out\")\n"
"public Multi<OutgoingMessage<Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .map(x -> OutgoingMessage.of(\"my-key\", random.nextDouble()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:461
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "ペイロードを `org.eclipse.microprofile.reactive.messaging.Message` 内にラップして、書き込まれたレコードをより詳細に制御できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:473
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Message<Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> Message.of(random.nextDouble())\n"
"                    .addMetadata(PulsarOutgoingMessageMetadata.builder()\n"
"                            .withKey(\"my-key\")\n"
"                            .withProperties(Map.of(\"property-key\", \"value\"))\n"
"                            .build()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:477
msgid "When sending `Messages`, you can add an instance of `io.smallrye.reactive.messaging.pulsar.PulsarOutgoingMessageMetadata` to influence how the message is going to be written to Pulsar."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:480
msgid "Other than method signatures returning a `Flow.Publisher`, outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:484
#, no-wrap
msgid "@Outgoing(\"prices-out\") T generate(); // T excluding void\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:486
#, no-wrap
msgid "@Outgoing(\"prices-out\") Message<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:488
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:490
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<Message<T>> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:492
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:494
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<Message<T>> generate();\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:496
#, no-wrap
msgid "Serialization and Pulsar Schema"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:500
msgid "The Pulsar Connector allows configuring Schema configuration for the underlying Pulsar producer.  See the xref:pulsar-schema-configuration[Pulsar Schema Configuration & Auto Schema Discovery] for more information."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:501
#, no-wrap
msgid "Sending key/value pairs"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:505
msgid "In order to send Kev/Value pairs to Pulsar, you can configure the Pulsar producer Schema with a https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/common/schema/KeyValue.html[KeyValue] schema."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:509
#: upstream/_versions/main/guides/pulsar.adoc:601
#: upstream/_versions/main/guides/pulsar.adoc:675
#, no-wrap
msgid "package pulsar.outbound;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:512
#: upstream/_versions/main/guides/pulsar.adoc:775
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.inject.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:517
#, no-wrap
msgid ""
"import org.apache.pulsar.client.api.Schema;\n"
"import org.apache.pulsar.common.schema.KeyValue;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:519
#: upstream/_versions/main/guides/pulsar.adoc:781
#, no-wrap
msgid "import io.smallrye.common.annotation.Identifier;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:522
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PulsarKeyValueExample {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:526
#, no-wrap
msgid ""
"    @Identifier(\"out\")\n"
"    @Produces\n"
"    Schema<KeyValue<String, Long>> schema = Schema.KeyValue(Schema.STRING, Schema.INT64);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:532
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out\")\n"
"    public KeyValue<String, Long> process(long in) {\n"
"        return new KeyValue<>(\"my-key\", in);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:537
msgid "If you need more control on the written records, use `PulsarOutgoingMessageMetadata`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:538
#, no-wrap
msgid "Acknowledgement"
msgstr "確認"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:542
msgid "Upon receiving a message from a Producer, a Pulsar broker assigns a `MessageId` to the message and sends it back to the producer, confirming that the message is published."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:546
msgid "By default, the connector does wait for Pulsar to acknowledge the record to continue the processing (acknowledging the received `Message`).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:548
msgid "If a record cannot be written, the message is `nacked`."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:553
msgid "The Pulsar client automatically retries sending messages in case of failure, until the *send timeout* is reached.  The *send timeout* is configurable with `sendTimeoutMs` attribute and by default is 30 seconds."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:555
#, no-wrap
msgid "Back-pressure and inflight records"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:559
msgid "The Pulsar outbound connector handles back-pressure, monitoring the number of pending messages waiting to be written to the Pulsar broker.  The number of pending messages is configured using the `maxPendingMessages` attribute and defaults to 1000."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:563
msgid "The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one pending message gets acknowledged by the broker.  Then, the connector writes a new message to Pulsar when one of the broker’s pending messages get acknowledged."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:566
msgid "You can also remove the limit of pending messages by setting `maxPendingMessages` to `0`.  Note that Pulsar also enables to configure the number of pending messages per partition using `maxPendingMessagesAcrossPartitions`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:568
#, no-wrap
msgid "Producer Batching"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:573
msgid "By default, the Pulsar producer batches individual messages together to be published to the broker.  You can configure batching parameters using `batchingMaxPublishDelayMicros`, `batchingPartitionSwitchFrequencyByPublishDelay`, `batchingMaxMessages`, `batchingMaxBytes` configuration properties, or disable it completely with `batchingEnabled=false`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:575
msgid "When using `Key_Shared` consumer subscriptions, the `batcherBuilder` can be configured to `BatcherBuilder.KEY_BASED`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:576
#, no-wrap
msgid "Pulsar Transactions and Exactly-Once Processing"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:579
msgid "https://pulsar.apache.org/docs/3.0.x/txn-why/[Pulsar transactions] enable event streaming applications to consume, process, and produce messages in one atomic operation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:581
msgid "Transactions allow one or multiple producers to send batch of messages to multiple topics where all messages in the batch are eventually visible to any consumer, or none is ever visible to consumers."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:585
msgid "In order to be used, transaction support needs to be activated on the broker configuration, using `transactionCoordinatorEnabled=true` and `systemTopicEnabled=true` broker configuration."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:588
msgid "On the client side, the transaction support also needs to be enabled on `PulsarClient` configuration:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:592
#, no-wrap
msgid "mp.messaging.outgoing.tx-producer.enableTransaction=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:595
msgid "Pulsar connector provides `PulsarTransactions` custom emitter for writing records inside a transaction."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:597
msgid "It can be used as a regular emitter `@Channel`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:604
#: upstream/_versions/main/guides/pulsar.adoc:678
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:608
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:612
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.pulsar.OutgoingMessage;\n"
"import io.smallrye.reactive.messaging.pulsar.transactions.PulsarTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:615
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PulsarTransactionalProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:619
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"tx-out-example\")\n"
"    PulsarTransactions<OutgoingMessage<Integer>> txProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:623
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"other-producer\")\n"
"    PulsarTransactions<String> producer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:636
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    public Uni<Void> emitInTransaction(Message<Integer> in) {\n"
"        return txProducer.withTransaction(emitter -> {\n"
"            emitter.send(OutgoingMessage.of(\"a\", 1));\n"
"            emitter.send(OutgoingMessage.of(\"b\", 2));\n"
"            emitter.send(OutgoingMessage.of(\"c\", 3));\n"
"            producer.send(emitter, \"4\");\n"
"            producer.send(emitter, \"5\");\n"
"            producer.send(emitter, \"6\");\n"
"            return Uni.createFrom().completionStage(in::ack);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:643
msgid "The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction.  If the processing completes successfully, the producer is flushed and the transaction is committed.  If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:648
msgid "Multiple transactional producers can participate in a single transaction.  This ensures all messages are sent using the started transaction and before the transaction is committed, all participating producers are flushed."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:652
msgid "If this method is called on a Vert.x context, the processing function is also called on that context.  Otherwise, it is called on the sending thread of the producer."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:653
#, no-wrap
msgid "Exactly-Once Processing"
msgstr "Exactly-Once 処理"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:659
msgid "Pulsar Transactions API also allows managing consumer offsets inside a transaction, together with produced messages.  This in turn enables coupling a consumer with a transactional producer in a consume-transform-produce pattern, also known as exactly-once processing.  It means that an application consumes messages, processes them, publishes the results to a topic, and commits offsets of the consumed messages in a transaction."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:661
msgid "The `PulsarTransactions` emitter also provides a way to apply exactly-once processing to an incoming Pulsar message inside a transaction."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:663
msgid "The following example includes a batch of Pulsar messages inside a transaction."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:670
#, no-wrap
msgid ""
"mp.messaging.outgoing.tx-out-example.enableTransaction=true\n"
"# ...\n"
"mp.messaging.incoming.in-channel.enableTransaction=true\n"
"mp.messaging.incoming.in-channel.batchReceive=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:681
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:686
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.pulsar.PulsarIncomingBatchMessage;\n"
"import io.smallrye.reactive.messaging.pulsar.PulsarMessage;\n"
"import io.smallrye.reactive.messaging.pulsar.transactions.PulsarTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:689
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PulsarExactlyOnceProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:693
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"tx-out-example\")\n"
"    PulsarTransactions<Integer> txProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:703
#, no-wrap
msgid ""
"    @Incoming(\"in-channel\")\n"
"    public Uni<Void> emitInTransaction(PulsarIncomingBatchMessage<Integer> batch) {\n"
"        return txProducer.withTransactionAndAck(batch, emitter -> {\n"
"            for (PulsarMessage<Integer> record : batch) {\n"
"                emitter.send(PulsarMessage.of(record.getPayload() + 1, record.getKey()));\n"
"            }\n"
"            return Uni.createFrom().voidItem();\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:708
msgid "If the processing completes successfully, the message is acknowledged inside the transaction and the transaction is committed."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:712
msgid "When using exactly-once processing, messages can only be acked individually rather than cumulatively."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:716
msgid "If the processing needs to abort, the message is nack'ed. One of the failure strategies can be employed in order to retry the processing or simply fail-stop.  Note that the `Uni` returned from the `withTransaction` will yield a failure if the transaction fails and is aborted."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:720
msgid "The application can choose to handle the error case, but for the message consumption to continue, `Uni` returned from the `@Incoming` method must not result in failure.  `PulsarTransactions#withTransactionAndAck` method will ack and nack the message but will not stop the reactive stream.  Ignoring the failure simply resets the consumer to the last committed offsets and resumes the processing from there."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:724
msgid "In order to avoid duplicates in case of failure, it is recommended to enable message deduplication and batch index level acknowledgment on the broker side:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:730
#, no-wrap
msgid ""
"quarkus.pulsar.devservices.broker-config.brokerDeduplicationEnabled=true\n"
"quarkus.pulsar.devservices.broker-config.brokerDeduplicationEntriesInterval=1000\n"
"quarkus.pulsar.devservices.broker-config.brokerDeduplicationSnapshotIntervalSeconds=3000\n"
"quarkus.pulsar.devservices.broker-config.acknowledgmentAtBatchIndexLevelEnabled=3000\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:732
#, no-wrap
msgid "mp.messaging.incoming.data.batchIndexAckEnabled=true\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:736
#, no-wrap
msgid "Pulsar Schema Configuration & Auto Schema Discovery"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:742
msgid "Pulsar messages are stored with payloads as unstructured byte array.  A Pulsar **schema** defines how to serialize structured data to the raw message bytes.  The **schema** is applied in producers and consumers to write and read with an enforced data structure.  It serializes data into raw bytes before they are published to a topic and deserializes the raw bytes before they are delivered to consumers."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:746
msgid "Pulsar uses a schema registry as a central repository to store the registered schema information, which enables producers/consumers to coordinate the schema of a topic's messages through brokers.  By default the Apache BookKeeper is used to store schemas."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:750
msgid "Pulsar API provides built-in schema information for a number of https://pulsar.apache.org/docs/3.0.x/schema-understand#primitive-type[primitive types] and https://pulsar.apache.org/docs/3.0.x/schema-understand#complex-type[complex types] such as Key/Value, Avro and Protobuf."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:752
msgid "The Pulsar Connector allows specifying the schema as a primitive type using the `schema` property:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:757
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.connector=smallrye-pulsar\n"
"mp.messaging.incoming.prices.schema=INT32\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:760
#, no-wrap
msgid ""
"mp.messaging.outgoing.prices-out.connector=smallrye-pulsar\n"
"mp.messaging.outgoing.prices-out.schema=DOUBLE\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:764
msgid "If the value for the `schema` property matches a https://javadoc.io/doc/org.apache.pulsar/pulsar-client-api/latest/org/apache/pulsar/common/schema/SchemaType.html[Schema Type] a simple schema will be created with that type and will be used for that channel."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:766
msgid "The Pulsar Connector allows configuring complex schema types by providing `Schema` beans through CDI, identified with the `@Identifier` qualifier."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:768
msgid "For example the following bean provides an JSON schema and a Key/Value schema:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:772
#, no-wrap
msgid "package pulsar.configuration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:779
#, no-wrap
msgid ""
"import org.apache.pulsar.client.api.Schema;\n"
"import org.apache.pulsar.common.schema.KeyValue;\n"
"import org.apache.pulsar.common.schema.KeyValueEncodingType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:784
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PulsarSchemaProvider {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:788
#, no-wrap
msgid ""
"    @Produces\n"
"    @Identifier(\"user-schema\")\n"
"    Schema<User> userSchema = Schema.JSON(User.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:794
#, no-wrap
msgid ""
"    @Produces\n"
"    @Identifier(\"a-channel\")\n"
"    Schema<KeyValue<Integer, User>> keyValueSchema() {\n"
"        return Schema.KeyValue(Schema.INT32, Schema.JSON(User.class), KeyValueEncodingType.SEPARATED);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:798
#, no-wrap
msgid ""
"    public static class User {\n"
"        String name;\n"
"        int age;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:801
#, no-wrap
msgid ""
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:804
msgid "To configure the incoming channel `users` with defined schema, you need to set the `schema` property to the identifier of the schema `user-schema`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:809
#, no-wrap
msgid ""
"mp.messaging.incoming.users.connector=smallrye-pulsar\n"
"mp.messaging.incoming.users.schema=user-schema\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:813
msgid "If no `schema` property is found, the connector looks for `Schema` beans identified with the channel name.  For example, the outgoing channel `a-channel` will use the key/value schema."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:817
#, no-wrap
msgid "mp.messaging.outgoing.a-channel.connector=smallrye-pulsar\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:820
msgid "If no schema information is provided incoming channels will use `Schema.AUTO_CONSUME()`, whereas outgoing channels will use `Schema.AUTO_PRODUCE_BYTES()` schemas."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:821
#, no-wrap
msgid "Auto Schema Discovery"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:825
msgid "When using SmallRye Reactive Messaging Pulsar (`io.quarkus:quarkus-smallrye-reactive-messaging-pulsar`), Quarkus can often automatically detect the correct Pulsar Schema to configure.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:827
msgid "For example, if you declare"
msgstr "たとえば、以下のように宣言した場合"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:834
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Integer> generate() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:837
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-pulsar` connector, then Quarkus will automatically set the `schema` attribute of the `generated-price` channel to Pulsar Schema `INT32`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:839
msgid "Similarly, if you declare"
msgstr "同様に、以下を宣言した場合"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:846
#, no-wrap
msgid ""
"@Incoming(\"my-pulsar-consumer\")\n"
"public void consume(org.apache.pulsar.api.client.Message<byte[]> record) {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:849
msgid "and your configuration indicates that the `my-pulsar-consumer` channel uses the `smallrye-pulsar` connector, then Quarkus will automatically set the `schema` attribute to Pulsar `BYTES` Schema."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:851
msgid "Finally, if you declare"
msgstr "最後に、以下を宣言した場合"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:857
#, no-wrap
msgid ""
"@Inject\n"
"@Channel(\"price-create\")\n"
"Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:860
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-pulsar` connector, then Quarkus will automatically set the `schema` to Pulsar `INT64` Schema."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:862
msgid "The full set of types supported by the Pulsar Schema autodetection is:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:864
msgid "`short` and `java.lang.Short`"
msgstr "`short` および `java.lang.Short`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:865
msgid "`int` and `java.lang.Integer`"
msgstr "`int` および `java.lang.Integer`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:866
msgid "`long` and `java.lang.Long`"
msgstr "`long` および `java.lang.Long`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:867
msgid "`float` and `java.lang.Float`"
msgstr "`float` および `java.lang.Float`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:868
msgid "`double` and `java.lang.Double`"
msgstr "`double` および`java.lang.Double`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:869
msgid "`byte[]`"
msgstr "`byte[]`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:870
msgid "`java.time.Instant`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:871
msgid "`java.sql.Timestamp`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:872
msgid "`java.time.LocalDate`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:873
msgid "`java.time.LocalTime`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:874
msgid "`java.time.LocalDateTime`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:875
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:876
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, will be configured with `AVRO` schema type"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:877
msgid "classes generated from Protobuf schemas, will be configured with `PROTOBUF` schema type"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:878
msgid "other classes will automatically be configured with `JSON` schema type"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:882
msgid "Note that `JSON` schema type enforces schema validation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:885
msgid "In addition to those Pulsar-provided schemas, Quarkus provides following schema implementations _without enforcing validation_ :"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:887
msgid "`io.vertx.core.buffer.Buffer` will be configured with `io.quarkus.pulsar.schema.BufferSchema` schema"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:888
msgid "`io.vertx.core.json.JsonObject` will be configured with `io.quarkus.pulsar.schema.JsonObjectSchema` schema"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:889
msgid "`io.vertx.core.json.JsonArray` will be configured with `io.quarkus.pulsar.schema.JsonArraySchema` schema"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:892
msgid "For schema-less Json serialization, if the `schema` configuration is set to `ObjectMapper<fully_qualified_name_of_the_bean>`, a Schema will be generated using the Jackson `ObjectMapper`, without enforcing a Pulsar Schema validation.  `io.quarkus.pulsar.schema.ObjectMapperSchema` can be used to explicitly configure JSON schema without validation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:894
msgid "If a `schema` is set by configuration, it won't be replaced by the auto-detection."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:897
msgid "In case you have any issues with serializer auto-detection, you can switch it off completely by setting `quarkus.reactive-messaging.pulsar.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:902
#, no-wrap
msgid "Configuring Pulsar clients"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:904
msgid "Pulsar clients, consumers and producers are very customizable to configure how a Pulsar client application behaves."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:907
msgid "The Pulsar connector creates a Pulsar client and, a consumer or a producer per channel, each with sensible defaults to ease their configuration.  Although the creation is handled, all available configuration options remain configurable through Pulsar channels."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:913
msgid "While idiomatic way of creating `PulsarClient`, `PulsarConsumer` or `PulsarProducer` are through builder APIs, in its essence those APIs build each time a configuration object, to pass onto the implementation.  Those are https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ClientConfigurationData.html[ClientConfigurationData], https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ConsumerConfigurationData.html[ConsumerConfigurationData] and https://javadoc.io/doc/org.apache.pulsar/pulsar-client-original/latest/org/apache/pulsar/client/impl/conf/ProducerConfigurationData.html[ProducerConfigurationData]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:917
msgid "Pulsar Connector allows receiving properties for those configuration objects directly.  For example, the broker authentication information for `PulsarClient` is received using `authPluginClassName` and `authParams` properties.  In order to configure the authentication for the incoming channel `data` :"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:927
#, no-wrap
msgid ""
"mp.messaging.incoming.data.connector=smallrye-pulsar\n"
"mp.messaging.incoming.data.serviceUrl=pulsar://localhost:6650\n"
"mp.messaging.incoming.data.topic=topic\n"
"mp.messaging.incoming.data.subscriptionInitialPosition=Earliest\n"
"mp.messaging.incoming.data.schema=INT32\n"
"mp.messaging.incoming.data.authPluginClassName=org.apache.pulsar.client.impl.auth.AuthenticationBasic\n"
"mp.messaging.incoming.data.authParams={\"userId\":\"superuser\",\"password\":\"admin\"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:930
msgid "Note that the Pulsar consumer property `subscriptionInitialPosition` is also configured with the `Earliest` value which represents with enum value `SubscriptionInitialPosition.Earliest`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:935
msgid "This approach covers most of the configuration cases.  However, non-serializable objects such as `CryptoKeyReader`, `ServiceUrlProvider` etc. cannot be configured this way.  The Pulsar Connector allows taking into account instances of Pulsar configuration data objects – `ClientConfigurationData`, `ConsumerConfigurationData`, `ProducerConfigurationData`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:941
#, no-wrap
msgid ""
"import jakarta.enterprise.inject.Produces;\n"
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.pulsar.client.impl.conf.ConsumerConfigurationData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:943
#: upstream/_versions/main/guides/pulsar.adoc:975
#: upstream/_versions/main/guides/pulsar.adoc:1001
#: upstream/_versions/main/guides/pulsar.adoc:1047
#, no-wrap
msgid "class PulsarConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:955
#, no-wrap
msgid ""
"    @Produces\n"
"    @Identifier(\"my-consumer-options\")\n"
"    public ConsumerConfigurationData<String> getConsumerConfig() {\n"
"        ConsumerConfigurationData<String> data = new ConsumerConfigurationData<>();\n"
"        data.setAckReceiptEnabled(true);\n"
"        data.setCryptoKeyReader(DefaultCryptoKeyReader.builder()\n"
"                //...\n"
"                .build());\n"
"        return data;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:959
msgid "This instance is retrieved and used to configure the client used by the connector.  You need to indicate the name of the client using the `client-configuration`, `consumer-configuration` or `producer-configuration` attributes:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:963
#, no-wrap
msgid "mp.messaging.incoming.prices.consumer-configuration=my-consumer-options\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:966
msgid "If no `[client|consumer|producer]-configuration` is configured, the connector will look for instances identified with the channel name:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:973
#, no-wrap
msgid ""
"import jakarta.enterprise.inject.Produces;\n"
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.pulsar.client.impl.AutoClusterFailover;\n"
"import org.apache.pulsar.client.impl.conf.ClientConfigurationData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:987
#, no-wrap
msgid ""
"    @Produces\n"
"    @Identifier(\"prices\")\n"
"    public ClientConfigurationData getClientConfig() {\n"
"        ClientConfigurationData data = new ClientConfigurationData();\n"
"        data.setEnableTransaction(true);\n"
"        data.setServiceUrlProvider(AutoClusterFailover.builder()\n"
"                // ...\n"
"                .build());\n"
"        return data;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:990
msgid "You also can provide a `Map<String, Object>` containing configuration values by key:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:999
#, no-wrap
msgid ""
"import jakarta.enterprise.inject.Produces;\n"
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.pulsar.client.api.BatcherBuilder;\n"
"import org.apache.pulsar.client.impl.conf.ClientConfigurationData;\n"
"import org.apache.pulsar.client.impl.customroute.PartialRoundRobinMessageRouterImpl;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1011
#, no-wrap
msgid ""
"    @Produces\n"
"    @Identifier(\"prices\")\n"
"    public Map<String, Object> getProducerConfig() {\n"
"        return Map.of(\n"
"                \"batcherBuilder\", BatcherBuilder.KEY_BASED,\n"
"                \"sendTimeoutMs\", 3000,\n"
"                \"customMessageRouter\", new PartialRoundRobinMessageRouterImpl(4));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1014
msgid "Different configuration sources are loaded in the following order of precedence, from the least important to the highest:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1016
msgid "`Map<String, Object>` config map produced with default config identifier, `default-pulsar-client`, `default-pulsar-consumer`, `default-pulsar-producer`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1017
msgid "`Map<String, Object>` config map produced with identifier in the configuration or channel name"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1018
msgid "`[Client|Producer|Consuemr]ConfigurationData` object produced with identifier in the channel configuration or the channel name"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1019
msgid "Channel configuration properties named with `[Client|Producer|Consuemr]ConfigurationData` field names."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1021
msgid "See xref:configuration-reference[Configuration Reference] for the exhaustive list of configuration options."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:1022
#, no-wrap
msgid "Configuring Pulsar Authentication"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1025
msgid "Pulsar provides a pluggable authentication framework, and Pulsar brokers/proxies use this mechanism to authenticate clients."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1027
msgid "Clients can be configured in `application.properties` file using `authPluginClassName` and `authParams` attributes:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1033
#, no-wrap
msgid ""
"pulsar.client.serviceUrl=pulsar://pulsar:6650\n"
"pulsar.client.authPluginClassName=org.apache.pulsar.client.impl.auth.AuthenticationBasic\n"
"pulsar.client.authParams={\"userId\":\"superuser\",\"password\":\"admin\"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1036
msgid "Or programmatically:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1040
#, no-wrap
msgid "import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1045
#, no-wrap
msgid ""
"import jakarta.enterprise.inject.Produces;\n"
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.pulsar.client.impl.conf.ClientConfigurationData;\n"
"import org.apache.pulsar.client.impl.auth.AuthenticationBasic;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1058
#, no-wrap
msgid ""
"    @Produces\n"
"    @Identifier(\"prices\")\n"
"    public ClientConfigurationData config() {\n"
"        var data = new ClientConfigurationData();\n"
"        var auth = new AuthenticationBasic();\n"
"        auth.configure(Map.of(\"userId\", \"superuser\", \"password\", \"admin\"));\n"
"        data.setAuthentication(auth);\n"
"        return data;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/pulsar.adoc:1060
#, no-wrap
msgid "Configuring access to Datastax Luna Streaming"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1064
msgid "Luna Streaming is a production-ready distribution of Apache Pulsar, with tools and support from DataStax.  After creating your DataStax Luna Pulsar tenant, note the auto generated token, and configure the token authentication:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1070
#, no-wrap
msgid ""
"pulsar.client.serviceUrl=pulsar+ssl://pulsar-aws-eucentral1.streaming.datastax.com:6651\n"
"pulsar.client.authPluginClassName=org.apache.pulsar.client.impl.auth.AuthenticationToken\n"
"pulsar.client.authParams=token:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2ODY4MTc4MzQsImlzcyI6ImRhdGFzdGF4Iiwic3ViIjoiY2xpZW50OzA3NGZhOTI4LThiODktNDBhNC04MDEzLWNlNjVkN2JmZWIwZTtjSEpwWTJWejsyMDI5ODdlOGUyIiwidG9rZW5pZCI6IjIwMjk4N2U4ZTIifQ....\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1073
msgid "Make sure to create topics beforehand, or enable the _Auto Topic Creation_ in the namespace configuration."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1075
msgid "Note that the topic configuration needs to reference full name of topics:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1079
#, no-wrap
msgid "mp.messaging.incoming.prices.topic=persistent://my-tenant/default/prices\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:1082
#, no-wrap
msgid "Health Checks"
msgstr "ヘルスチェック"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1086
msgid "The Quarkus extension reports startup, readiness and liveness of each channel managed by the Pulsar connector.  Health checks rely on the Pulsar client to verify that a connection is established with the broker."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1089
#, no-wrap
msgid ""
"**Startup** and **Readiness** probes for both inbound and outbound channels report *OK* when the\n"
"connection with the broker is established.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1092
msgid "The **Liveness** probe for both inbound and outbound channels reports *OK* when the connection is established with the broker **AND** that no failures have been caught."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1098
msgid "Note that a message processing failures *nacks* the message which is then handled by the failure-strategy. It is the responsibility of the failure-strategy to report the failure and influence the outcome of the liveness checks. The `fail` failure strategy reports the failure and so the liveness check will report the failure."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:1100
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1104
msgid "Following are the list of configuration attributes for the Pulsar connector channels, consumers, producers and clients.  See the xref:pulsar-client-configuration[Pulsar Client Configuration] for more information on how the Pulsar clients are configured."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:1105
#, no-wrap
msgid "Incoming channel configuration (receiving from Pulsar)"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1108
msgid "The following attributes are configured using:"
msgstr "以下の属性は以下のように設定します:"

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1112
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1117
msgid "You can also configure properties supported by the underlying Pulsar consumer."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1119
msgid "These properties can also be globally configured using `pulsar.consumer` prefix:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1123
#, no-wrap
msgid "pulsar.consumer.subscriptionInitialPosition=Earliest\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:1127
#, no-wrap
msgid "Outgoing channel configuration (publishing to Pulsar)"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1132
msgid "You can also configure properties supported by the underlying Pulsar producer."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1134
msgid "These properties can also be globally configured using `pulsar.producer` prefix:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1138
#, no-wrap
msgid "pulsar.producer.batchingEnabled=false\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/pulsar.adoc:1143
#, no-wrap
msgid "Pulsar Client Configuration"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1147
msgid "Following is the configuration reference for the underlying `PulsarClient`.  These options can be configured using the channel attribute:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1151
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.numIoThreads=4\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1154
msgid "Or configured globally using `pulsar.client` prefix:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/pulsar.adoc:1158
#, no-wrap
msgid "pulsar.client.serviceUrl=pulsar://pulsar:6650\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/pulsar.adoc:1165
msgid "Configuration properties not configurable in configuration files (non-serializable) is noted in the column `Config file`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/pulsar.adoc:1167
#, no-wrap
msgid "Going further"
msgstr "さらに詳しく"

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1171
msgid "This guide has shown how you can interact with Pulsar using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/pulsar.adoc:1172
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "さらに詳しく知りたい場合は、Quarkusで使用されている実装、 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] のドキュメントを確認してください。"
