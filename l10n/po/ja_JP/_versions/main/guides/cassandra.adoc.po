# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-05-07 17:34+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/cassandra.adoc:6
#, no-wrap
msgid "Quarkus - Using the Cassandra Client"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:13
msgid "Apache Cassandra® is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:15
msgid "In this guide, we will see how you can get your REST services to use a Cassandra database."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:18
#, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:21
msgid "To complete this quickstart guide, you need:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:23
msgid "an IDE;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:24
msgid "JDK 11+ installed with `JAVA_HOME` configured appropriately;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:27
msgid "link:https://www.graalvm.org/[GraalVM] installed with the `GRAALVM_HOME` environment variable configured appropriately, if you want to link:https://quarkus.io/guides/building-native-image[use the native mode];"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:28
msgid "Apache Maven {maven-version}"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:32
msgid "A running link:https://cassandra.apache.org[Apache Cassandra], link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) or link:https://astra.datastax.com[DataStax Astra] database; or alternatively, a fresh Docker installation."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:33
#, no-wrap
msgid "Architecture"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:39
msgid "This quickstart guide shows how to build a REST application using the link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus extension], which allows you to connect to an Apache Cassandra, DataStax Enterprise (DSE) or DataStax Astra database, using the link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java driver]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:44
msgid "This guide will also use the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] – a powerful Java-to-CQL mapping framework that greatly simplifies your application's data access layer code by sparing you the hassle of writing your CQL queries by hand."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:48
msgid "The application built in this quickstart guide is quite simple: the user can add elements in a list using a form, and the items list is updated. All the information between the browser and the server is formatted as JSON, and the elements are stored in the Cassandra database."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:49
#, no-wrap
msgid "Solution"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:53
msgid "We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:57
msgid "The solution is located in the link:https://github.com/datastax/cassandra-quarkus/tree/master/quickstart[quickstart directory] of the Cassandra Quarkus extension GitHub repository."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:58
#, no-wrap
msgid "Creating a Blank Maven Project"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:62
msgid "First, create a new Maven project and copy the `pom.xml` file that is present in the `quickstart` directory."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:64
msgid "The `pom.xml` is importing all the Quarkus extensions and dependencies you need."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:65
#, no-wrap
msgid "Creating the Data Model and Data Access Objects"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:68
msgid "In this example, we will create an application to manage a list of fruits."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:70
msgid "First, let's create our data model – represented by the `Fruit` class – as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:76
#, no-wrap
msgid ""
"@Entity\n"
"@PropertyStrategy(mutable = false)\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:79
#, no-wrap
msgid ""
"    @PartitionKey\n"
"    private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:81
#, no-wrap
msgid "    private final String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:88
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"      this.name = name;\n"
"      this.description = description;\n"
"    }\n"
"  // getters, hashCode, equals, toString methods omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:93
msgid "As stated above, we are using the DataStax Object Mapper. In other words, we are not going to write our CQL queries manually; instead, we will annotate our data model with a few annotations, and the mapper will generate proper CQL queries underneath."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:98
msgid "This is why the `Fruit` class is annotated with `@Entity`: this annotation marks it as an _entity class_ that is mapped to a Cassandra table. Its instances are meant to be automatically persisted into, and retrieved from, the Cassandra database. Here, the table name will be inferred from the class name: `fruit`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:101
msgid "Also, the `name` field represents a Cassandra partition key, and so we are annotating it with `@PartitionKey` – another annotation from the Object Mapper library."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:104
msgid "Entity classes are normally required to have a default no-arg constructor, unless they are annotated with `@PropertyStrategy(mutable = false)`, which is the case here."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:107
msgid "The next step is to create a DAO (Data Access Object) interface that will manage instances of `Fruit` entities:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:114
#, no-wrap
msgid ""
"@Dao\n"
"public interface FruitDao {\n"
"  @Update\n"
"  void update(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:118
#, no-wrap
msgid ""
"  @Select\n"
"  PagingIterable<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:123
msgid "This interface exposes operations that will be used in our REST service. Again, the annotation `@Dao` comes from the DataStax Object Mapper, which will also automatically generate an implementation of this interface for you."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:127
msgid "Note also the special return type of the `findAll` method, link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]: it's the base type of result sets returned by the driver."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:129
msgid "Finally, let's create the a Mapper interface:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:137
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  @DaoFactory\n"
"  FruitDao fruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:142
msgid "The `@Mapper` annotation is yet another annotation recognized by the DataStax Object Mapper. A mapper is responsible for constructing instances of DAOs – in this case, out mapper is constructing an instance of our only DAO, `FruitDao`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:143
#, no-wrap
msgid "Creating a Service & JSON REST Endpoint"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:147
msgid "Now let's create a `FruitService` that will be the business layer of our application and store/load the fruits from the Cassandra database."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:152
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:154
#, no-wrap
msgid "  @Inject FruitDao dao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:158
#, no-wrap
msgid ""
"  public void save(Fruit fruit) {\n"
"    dao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:163
#, no-wrap
msgid ""
"  public List<Fruit> getAll() {\n"
"    return dao.findAll().all();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:167
msgid "Note how the service is being injected a `FruitDao` instance. This DAO instance is injected automatically."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:170
msgid "The Cassandra Quarkus extension allows you to inject any of the following beans in your own components:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:172
msgid "All `@Mapper`-annotated interfaces in your project."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:174
msgid "All `@Dao`-annotated interfaces in your project, as long as they are produced by a corresponding `@DaoFactory`-annotated method declared in a mapper interface from your project."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:179
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] bean: this application-scoped, singleton bean is your main entry point to the Cassandra client; it is a specialized Cassandra driver session instance with a few methods tailored especially for Quarkus. Read its javadocs carefully!"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:182
msgid "In our example, both `FruitMapper` and `FruitDao` could be injected anywhere. We chose to inject `FruitDao` in `FruitService`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:184
msgid "The last missing piece is the REST API that will expose GET and POST methods:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:191
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:193
#, no-wrap
msgid "  @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:198
#, no-wrap
msgid ""
"  @GET\n"
"  public List<FruitDto> getAll() {\n"
"    return fruitService.getAll().stream().map(this::convertToDto).collect(Collectors.toList());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:203
#, no-wrap
msgid ""
"  @POST\n"
"  public void add(FruitDto fruit) {\n"
"    fruitService.save(convertFromDto(fruit));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:207
#: upstream/_versions/main/guides/cassandra.adoc:510
#, no-wrap
msgid ""
"  private FruitDto convertToDto(Fruit fruit) {\n"
"    return new FruitDto(fruit.getName(), fruit.getDescription());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:212
#: upstream/_versions/main/guides/cassandra.adoc:515
#, no-wrap
msgid ""
"  private Fruit convertFromDto(FruitDto fruitDto) {\n"
"    return new Fruit(fruitDto.getName(), fruitDto.getDescription());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:215
msgid "Notice how `FruitResource` is being injected a `FruitService` instance automatically."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:221
msgid "It is generally not recommended using the same entity object between the REST API and the data access layer. These layers should indeed be decoupled and use distinct APIs in order to allow each API to evolve independently of the other. This is the reason why our REST API is using a different object: the `FruitDto` class – the word DTO stands for \"Data Transfer Object\". This DTO object will be automatically converted to and from JSON in HTTP messages:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:225
#, no-wrap
msgid "public class FruitDto {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:228
#, no-wrap
msgid ""
"  private String name;\n"
"  private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:230
#, no-wrap
msgid "  public FruitDto() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:237
#, no-wrap
msgid ""
"  public FruitDto(String name, String description) {\n"
"    this.name = name;\n"
"    this.description = description;\n"
"  }\n"
"  // getters and setters omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:242
msgid "The translation to and from JSON is done automatically by the Quarkus RestEasy extension, which is included in this guide's pom.xml file. If you want to add it manually to your application, add the below snippet to your application's ppm.xml file:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:253
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:257
msgid "DTO classes used by the JSON serialization layer are required to have a default no-arg constructor."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:261
msgid "The conversion from DTO to JSON is handled automatically for us, but we still must convert from `Fruit` to `FruitDto` and vice versa. This must be done manually, which is why we have two conversion methods declared in `FruitResource`: `convertToDto` and `convertFromDto`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:265
msgid "In our example, `Fruit` and `FruitDto` are very similar, so you might wonder why not use `Fruit` everywhere. In real life cases though, it's not uncommon to see DTOs and entities having very different structures."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:266
#, no-wrap
msgid "Connecting to the Cassandra Database"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:268
#, no-wrap
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:272
msgid "The main properties to configure are: `contact-points`, to access the Cassandra database; `local-datacenter`, which is required by the driver; and – optionally – the keyspace to bind to."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:274
msgid "A sample configuration should look like this:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:280
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points={cassandra_ip}:9042\n"
"quarkus.cassandra.local-datacenter={dc_name}\n"
"quarkus.cassandra.keyspace={keyspace}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:284
msgid "In this example, we are using a single instance running on localhost, and the keyspace containing our data is `k1`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:290
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points=127.0.0.1:9042\n"
"quarkus.cassandra.local-datacenter=datacenter1\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:294
msgid "If your cluster requires plain text authentication, you must also provide two more settings: `username` and `password`."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:299
#, no-wrap
msgid ""
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:301
#, no-wrap
msgid "Connecting to a DataStax Astra Cloud Database"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:307
msgid "When connecting to link:https://astra.datastax.com[DataStax Astra], instead of providing a contact point and a datacenter, you should provide a so-called _secure connect bundle_, which should point to a valid path to an Astra secure connect bundle file. You can download your secure connect bundle from the Astra web console."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:310
msgid "You will also need to provide a username and password, since authentication is always required on Astra clusters."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:312
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:319
#, no-wrap
msgid ""
"quarkus.cassandra.cloud.secure-connect-bundle=/path/to/secure-connect-bundle.zip\n"
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:321
#, no-wrap
msgid "Advanced Driver Configuration"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:328
msgid "You can configure other Java driver settings using `application.conf` or `application.json` files.  They need to be located in the classpath of your application. All settings will be passed automatically to the underlying driver configuration mechanism. Settings defined in `application.properties` with the `quarkus.cassandra` prefix will have priority over settings defined in `application.conf` or `application.json`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:332
msgid "To see the full list of settings, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference]."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:333
#, no-wrap
msgid "Running a Local Cassandra Database"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:337
msgid "By default, the Cassandra client is configured to access a local Cassandra database on port 9042 (the default Cassandra port)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:340
msgid "Make sure that the setting `quarkus.cassandra.local-datacenter` matches the datacenter of your Cassandra cluster."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:343
msgid "If you don't know the name of your local datacenter, this value can be found by running the following CQL query: `SELECT data_center FROM system.local`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:346
msgid "If you want to use Docker to run a Cassandra database, you can use the following command to launch one in the background:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:350
#, no-wrap
msgid "docker run --name local-cassandra-instance -p 9042:9042 -d cassandra\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:354
msgid "Next you need to create the keyspace and table that will be used by your application. If you are using Docker, run the following commands:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:359
#, no-wrap
msgid ""
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE KEYSPACE IF NOT EXISTS k1 WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}\"\n"
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE TABLE IF NOT EXISTS k1.fruit(name text PRIMARY KEY, description text)\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:362
msgid "You can also use the CQLSH utility to interactively interrogate your database:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:366
#, no-wrap
msgid "docker exec -it local-cassandra-instance cqlsh\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:368
#, no-wrap
msgid "Testing the REST API"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:371
msgid "In the project root directory:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:373
msgid "Run `mvn clean package` and then `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` to start the application;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:374
msgid "Or better yet, run the application in dev mode: `mvn clean quarkus:dev`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:376
msgid "Now you can use curl commands to interact with the underlying REST API."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:378
msgid "To create a fruit:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:385
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"apple\",\"description\":\"red and tasty\"}' \\\n"
"  http://localhost:8080/fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:388
msgid "To retrieve fruits:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:392
#, no-wrap
msgid "curl -X GET http://localhost:8080/fruits\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:394
#, no-wrap
msgid "Creating a Frontend"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:397
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:401
msgid "Quarkus automatically serves static resources located under the `META-INF/resources` directory. In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the contents from link:src/main/resources/META-INF/resources/fruits.html[this file] in it."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:403
msgid "You can now interact with your REST service:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:405
#: upstream/_versions/main/guides/cassandra.adoc:570
msgid "If you haven't done yet, start your application with `mvn clean quarkus:dev`;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:406
msgid "Point your browser to `http://localhost:8080/fruits.html`;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:407
#: upstream/_versions/main/guides/cassandra.adoc:572
msgid "Add new fruits to the list via the form."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:409
#, no-wrap
msgid "Reactive Programming with the Cassandra Client"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:415
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession` interface] gives you access to a series of reactive methods that integrate seamlessly with Quarkus and its reactive framework, Mutiny."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:418
msgid "If you're not familiar with Mutiny, read the link:https://quarkus.io/guides/getting-started-reactive[Getting Started with Reactive guide] first."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:420
msgid "Let's rewrite our application using reactive programming with Mutiny."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:422
msgid "First, let's to declare another DAO interface that works in a reactive way:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:427
#, no-wrap
msgid ""
"@Dao\n"
"public interface ReactiveFruitDao {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:430
#, no-wrap
msgid ""
"  @Update\n"
"  Uni<Void> updateAsync(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:434
#, no-wrap
msgid ""
"  @Select\n"
"  MutinyMappedReactiveResultSet<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:441
msgid "Note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to obtain the query execution info. If you don't need anything in that interface, you can also simply declare your method to return `Multi`: `Multi<Fruit> findAll()`,"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:444
msgid "Similarly, the method `updateAsync` returns a `Uni` - it is automatically converted from the original result set returned by the driver."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:452
msgid "The Cassandra driver uses the Reactive Streams `Publisher` API for reactive calls. The Quarkus framework however uses Mutiny. Because of that, the `CqlQuarkusSession` interface transparently converts the `Publisher` instances returned by the driver into the reactive type `Multi`.  `CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` – in this case, the publisher is expected to emit at most one row, then complete. This is suitable for write queries (they return no rows), or for read queries guaranteed to return one row at most (count queries, for example)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:454
msgid "Next, we need to adapt the `FruitMapper` to construct a `ReactiveFruitDao` instance:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:460
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  // the existing method omitted\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:464
#, no-wrap
msgid ""
"  @DaoFactory\n"
"  ReactiveFruitDao reactiveFruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:468
msgid "Now, we can create a `ReactiveFruitService` that leverages our reactive DAO:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:473
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveFruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:475
#, no-wrap
msgid "  @Inject ReactiveFruitDao fruitDao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:479
#, no-wrap
msgid ""
"  public Uni<Void> add(Fruit fruit) {\n"
"    return fruitDao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:484
#, no-wrap
msgid ""
"  public Multi<Fruit> getAll() {\n"
"    return fruitDao.findAll();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:487
msgid "Finally, we can create a `ReactiveFruitResource`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:494
#, no-wrap
msgid ""
"@Path(\"/reactive-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class ReactiveFruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:496
#, no-wrap
msgid "  @Inject ReactiveFruitService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:501
#, no-wrap
msgid ""
"  @GET\n"
"  public Multi<FruitDto> getAll() {\n"
"    return service.getAll().map(this::convertToDto);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:506
#, no-wrap
msgid ""
"  @POST\n"
"  public Uni<Void> add(FruitDto fruitDto) {\n"
"    return service.add(convertFromDto(fruitDto));\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:520
msgid "The above resource is exposing a new endpoint, `reactive-fruits`. Its capabilities are identical to the ones that we created before with `FruitResource`, but everything is handled in a reactive fashion, without any blocking operation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:524
msgid "The `getAll()` method above returns `Multi`, and the `add()` method returns `Uni`. These types are the same Mutiny types that we met before; they are automatically recognized by the Quarkus reactive REST API, so we don't need to convert them into JSON ourselves."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:527
msgid "To effectively integrate the reactive logic with the REST API, your application needs to declare a dependency to the Quarkus RestEasy Mutiny extension:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:534
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:538
msgid "This dependency is already included in this guide's pom.xml, but if you are starting a new project from scratch, make sure to include it."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:539
#, no-wrap
msgid "Testing the Reactive REST API"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:543
msgid "Run the application in dev mode as explained above, then you can use curl commands to interact with the underlying REST API."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:545
msgid "To create a fruit using the reactive REST endpoint:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:552
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"banana\",\"description\":\"yellow and sweet\"}' \\\n"
"  http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:555
msgid "To retrieve fruits with the reactive REST endpoint:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:559
#, no-wrap
msgid "curl -X GET http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:561
#, no-wrap
msgid "Creating a Reactive Frontend"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:566
msgid "Now let's add a simple web page to interact with our `ReactiveFruitResource`. In the `src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the contents from link:src/main/resources/META-INF/resources/reactive-fruits.html[this file] in it."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:568
msgid "You can now interact with your reactive REST service:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:571
msgid "Point your browser to `http://localhost:8080/reactive-fruits.html`;"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:573
#, no-wrap
msgid "Health Checks"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:579
msgid "If you are using the Quarkus SmallRye Health extension, then the Cassandra client will automatically add a readiness health check to validate the connection to the Cassandra cluster. This extension is already included in this guide's pom.xml, but if you need to include it manually in your application, add the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:586
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-health</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:590
msgid "When health checks are available, you can access the `/health/ready` endpoint of your application and have information about the connection validation status."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:593
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to http://localhost:8080/health/ready you should see an output similar to the following one:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:612
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"UP\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"DataStax Apache Cassandra Driver health check\",\n"
"            \"status\": \"UP\",\n"
"            \"data\": {\n"
"                \"cqlVersion\": \"3.4.4\",\n"
"                \"releaseVersion\": \"3.11.7\",\n"
"                \"clusterName\": \"Test Cluster\",\n"
"                \"datacenter\": \"datacenter1\",\n"
"                \"numberOfNodes\": 1\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:617
msgid "If you need health checks globally enabled in your application, but don't want to activate Cassandra health checks, you can disable Cassandra health checks by setting the `quarkus.cassandra.health.enabled` property to `false` in your `application.properties`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:618
#, no-wrap
msgid "Metrics"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:622
msgid "The Cassandra Quarkus client can provide metrics about the Cassandra session and about individual Cassandra nodes. It supports both Micrometer and MicroProfile."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:625
msgid "The first step to enable metrics is to add a few additional dependencies depending on the metrics framework you plan to use."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:626
#, no-wrap
msgid "Enabling Metrics with Micrometer"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:629
msgid "Micrometer is the recommended metrics framework in Quarkus applications since Quarkus 1.9."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:631
msgid "To enable Micrometer metrics in your application, you need to add the following to your pom.xml."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:633
msgid "For Quarkus 1.11+:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:644
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:647
msgid "For Quarkus < 1.11:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:662
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.micrometer</groupId>\n"
"  <artifactId>micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:665
msgid "This guide uses Micrometer, so the above dependencies are already included in this guide's pom.xml."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:666
#, no-wrap
msgid "Enabling Metrics with MicroProfile Metrics"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:669
msgid "Remove any dependency to Micrometer from your pom.xml, then add the following ones instead:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:680
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-microprofile</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-metrics</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:682
#, no-wrap
msgid "Enabling Cassandra Metrics"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:687
msgid "Even when metrics are enabled in your application, the Cassandra client will not report any metrics, unless you opt-in for this feature. So your next step is to enable Cassandra metrics in your `application.properties` file."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:691
#, no-wrap
msgid "quarkus.cassandra.metrics.enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:694
msgid "That's it!"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:698
msgid "The final (and optional) step is to customize which specific Cassandra metrics you would like the Cassandra client to track. Several metrics can be tracked; if you skip this step, a default set of useful metrics will be automatically tracked."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:704
msgid "For the full list of available metric names, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference] page; search for the `advanced.metrics` section.  Also, Cassandra driver metrics are covered in detail in the https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[driver manual]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:706
msgid "If you do wish to customize which metrics to track, you should use the following properties:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:709
msgid "`quarkus.cassandra.metrics.session.enabled` should contain the session-level metrics to enable (metrics that are global to the session)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:711
msgid "`quarkus.cassandra.metrics.node.enabled` should contain the node-level metrics to enable (metrics for which each node contacted by the Cassandra client gets its own metric value)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:713
msgid "Both properties accept a comma-separated list of valid metric names."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:715
msgid "For example, let's assume that you wish to enable the following three Cassandra metrics:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:717
msgid "Session-level: `session.connected-nodes` and `session.bytes-sent`;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:718
msgid "Node-level: `node.pool.open-connections`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:720
msgid "Then you should add the following settings to your `application.properties`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:726
#, no-wrap
msgid ""
"quarkus.cassandra.metrics.enabled=true\n"
"quarkus.cassandra.metrics.session.enabled=connected-nodes,bytes-sent\n"
"quarkus.cassandra.metrics.node.enabled=pool.open-connections\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:730
msgid "This guide's `application.properties` file has already many metrics enabled; you can use its metrics list as a good starting point for exposing useful Cassandra metrics in your application."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:733
msgid "When metrics are properly enabled, metric reports for all enabled metrics are available at the `/metrics` REST endpoint of your application."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:737
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to `http://localhost:8080/metrics` you should see a list of metrics; search for metrics whose names contain `cassandra`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:741
msgid "For Cassandra metrics to show up, the Cassandra client needs to be initialized and connected; if you are using lazy initialization (see below), you won't see any Cassandra metrics until your application actually connects and hits the database for the first time."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:742
#, no-wrap
msgid "Running in native mode"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:746
msgid "If you installed GraalVM, you can link:https://quarkus.io/guides/building-native-image[build a native image] using:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:750
#, no-wrap
msgid "mvn clean package -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:754
msgid "Beware that native compilation can take a significant amount of time! Once the compilation is done, you can run the native executable as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:758
#, no-wrap
msgid "./target/cassandra-quarkus-quickstart-*-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:761
msgid "You can then point your browser to `http://localhost:8080/fruits.html` and use your application."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:762
#, no-wrap
msgid "Eager vs Lazy Initialization"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:765
msgid "This extension allows you to inject either:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:767
msgid "a `QuarkusCqlSession` bean;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:768
msgid "or the asynchronous version of this bean, that is, `CompletionStage<QuarkusCqlSession>`;"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:769
msgid "or the reactive version of this bean, that is, `Uni<QuarkusCqlSession>`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:773
msgid "The most straightforward approach is obviously to inject `QuarkusCqlSession` directly. This should work just fine for most applications; however, the `QuarkusCqlSession` bean needs to be initialized before it can be used, and this process is blocking."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:780
msgid "Fortunately, it is possible to control when the initialization should happen: the `quarkus.cassandra.init.eager-init` parameter determines if the `QuarkusCqlSession` bean should be initialized on its first access (lazy) or when the application is starting (eager). The default value of this parameter is `false`, meaning the init process is lazy: the `QuarkusCqlSession` bean will be initialized lazily on its first access – for example, when there is a first REST request that needs to interact with the Cassandra database."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:787
msgid "Using lazy initialization speeds up your application startup time, and avoids startup failures if the Cassandra database is not available. However, it could also prove dangerous if your code is fully asynchronous, e.g. if you are using https://quarkus.io/guides/reactive-routes[reactive routes]: indeed, the lazy initialization could accidentally happen on a thread that is not allowed to block, such as a Vert.x event loop thread. Therefore, setting `quarkus.cassandra.init.eager-init` to `false` and injecting `QuarkusCqlSession` should be avoided in these contexts."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:793
msgid "If you want to use Vert.x (or any other reactive framework) and keep the lazy initialization behavior, you should instead inject only `CompletionStage<QuarkusCqlSession>` or `Uni<QuarkusCqlSession>`. When injecting these beans, the initialization process will be triggered lazily, but it will happen in the background, in a non-blocking way, leveraging the Vert.x event loop. This way you don't risk blocking the Vert.x thread."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:798
msgid "Alternatively, you can set `quarkus.cassandra.init.eager-init` to true: in this case the session bean will be initialized eagerly during application startup, on the Quarkus main thread. This would eliminate any risk of blocking a Vert.x thread, at the cost of making your startup time (much)  longer."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:799
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:803
msgid "Accessing a Cassandra database from a client application is easy with Quarkus and the Cassandra extension, which provides configuration and native support for the DataStax Java driver for Apache Cassandra."
msgstr ""
