msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "コンテキストと依存性インジェクション"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html[Jakarta Contexts and Dependency Injection 4.1, window=\"_blank\"] specification.\n"
"It implements the CDI Lite specification, with selected improvements on top, and passes the CDI Lite TCK.\n"
"It does not implement CDI Full.\n"
"See also <<supported_features_and_limitations,the list of supported features and limitations>>.\n"
"Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals."
msgstr ""
"Quarkus DI ソリューション (ArC とも呼ばれる) は、 https://jakarta.ee/specifications/cdi/4.1/jakarta -cdi-spec-4.1.html[Jakarta コンテキストと依存性の注入 4.1、window=\"_blank\"] 仕様に基づいています。\n"
"CDI Lite 仕様を実装し、その上に厳選された改良を加え、CDI Lite TCK に合格しました。\n"
"CDI Full は実装されていません。\n"
"<<supported_features_and_limitations,the list of supported features and limitations>> も参照してください。\n"
"既存の CDI コードのほとんどは問題なく動作するはずですが、Quarkus のアーキテクチャーと目標に起因する小さな違いがいくつかあります。"

#: _versions/main/guides/cdi-reference.adoc
msgid "If you're new to CDI we recommend you to read the xref:cdi.adoc[Introduction to CDI] first."
msgstr "CDI が初めての方は、最初に xref:cdi.adoc[コンテキストと依存性注入(CDI)の紹介] を読むことを推奨します。"

#: _versions/main/guides/cdi-reference.adoc
msgid "The xref:cdi-integration.adoc[CDI integration guide] has more detail on common CDI-related integration use cases, and example code for solutions."
msgstr "xref:cdi-integration.adoc[CDI インテグレーションガイド] には、一般的な CDI 関連のインテグレーションのユースケースとソリューションのサンプルコードの詳細が記載されています。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Bean Discovery"
msgstr "Bean の検出"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.\n"
"However, Quarkus is using a *simplified bean discovery*.\n"
"There is only single bean archive with the https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"] and no visibility boundaries."
msgstr ""
"CDI での Bean 検出は、従来のデプロイメント構造と、基盤となるモジュールアーキテクチャーのアクセシビリティー要件が関係する複雑なプロセスです。\n"
"ただし、Quarkus は *簡略化された Bean 検出* を使用しています。\n"
"https://jakarta.ee/specifications/cdi/4.1/jakarta -cdi-spec-4.1.html#default_bean_discovery[bean 検出モード `annotated`、window=\"_blank\"] および可視性境界のない単一の Bean アーカイブのみが存在します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The bean archive is synthesized from:"
msgstr "Bean のアーカイブは、次のものから合成されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "the application classes,"
msgstr "アプリケーションクラス"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "dependencies that contain a `beans.xml` descriptor (content is ignored),"
msgstr "`beans.xml` 記述子を含む依存関係 (内容は無視される)"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "dependencies that contain a Jandex index - `META-INF/jandex.idx`,"
msgstr "Jandex インデックスを含む依存関係 (`META-INF/jandex.idx`)"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "dependencies referenced by `quarkus.index-dependency` in `application.properties`,"
msgstr "`application.properties` の `quarkus.index-dependency` で参照される依存関係"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "and Quarkus integration code."
msgstr "Quarkus の統合コード"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Bean classes that don't have a https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are not discovered.\n"
"This behavior is defined by CDI.\n"
"But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).\n"
"In fact, the declaring bean classes are considered annotated with `@Dependent`."
msgstr ""
"https://jakarta.ee/specifications/cdi/4.1/jakarta -cdi-spec-4.1.html#bean_defining_annotations[bean 定義アノテーション、window=\"_blank\"] のない Bean クラスは検出されません。\n"
"この動作は CDI によって定義されます。\n"
"ただし、宣言クラスに Bean 定義アノテーションが付けられていない場合でも、プロデューサーメソッドとフィールドおよびオブザーバーメソッドは検出されます (この動作は CDI で定義されているものと異なります)。\n"
"実際、宣言する Bean クラスは `@Dependent` でアノテーションが付けられていると見なされます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation."
msgstr "Quarkus エクステンションは、追加のディスカバリールールを宣言することができます。たとえば、 `@Scheduled` ビジネスメソッドは、宣言するクラスが Bean 定義アノテーションでアノテーションされていなくても登録されます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "How to Generate a Jandex Index"
msgstr "Jandex インデックスを生成する方法"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"A dependency with a Jandex index is automatically scanned for beans.\n"
"To generate the index, just add the following plugin to your build file:"
msgstr ""

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Gradle (Groovy DSL)"
msgstr "Gradle (Groovy DSL)"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "You can find the latest plugin version in the https://plugins.gradle.org/plugin/org.kordamp.gradle.jandex[Gradle Plugin Portal]"
msgstr "最新のプラグインバージョンは、 https://plugins.gradle.org/plugin/org.kordamp.gradle.jandex[Gradle プラグインポータル] で確認できます。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Gradle (Kotlin DSL)"
msgstr "Gradle (Kotlin DSL)"

#. type: delimited block *
#: _versions/main/guides/cdi-reference.adoc
msgid "If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:"
msgstr "依存関係を変更できなくても、 `quarkus.index-dependency` エントリーを `application.properties` に追加することでインデックスを作成できます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "If no `artifact-id` is specified then all dependencies with the specified `group-id` are indexed."
msgstr "`artifact-id` が指定されていない場合は、 `group-id` が指定された依存関係はすべてインデックス化されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:"
msgstr "たとえば、次のエントリーは、 `org.acme:acme-api` 依存関係が確実にインデックス化されるようにします。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Example application.properties"
msgstr "application.properties の例"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Value is a group id for a dependency identified by name `acme`."
msgstr "値 `acme` は、名前で識別される依存関係のグループ ID です。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Value is an artifact id for a dependency identified by name `acme`."
msgstr "値は、名前 `acme` で識別される依存関係のアーティファクト ID です。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "How To Exclude Types and Dependencies from Discovery"
msgstr "ディスカバリーから型と依存関係を除外する方法"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"It may happen that some beans from third-party libraries do not work correctly in Quarkus.\n"
"A typical example is a bean injecting a portable extension.\n"
"In such case, it's possible to exclude types and dependencies from the bean discovery.\n"
"The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded."
msgstr "サードパーティーのライブラリーからのいくつかの Bean が Quarkus で正しく動作しないことがあります。典型的な例は、ポータブルエクステンションを注入する Bean です。このような場合は、型や依存関係を Bean の検出から除外することができます。 `quarkus.arc.exclude-types` プロパティーは、除外すべきクラスに一致するために使用される文字列値のリストを受け入れます。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Value Examples"
msgstr "値の例"

#: _versions/main/guides/cdi-reference.adoc
msgid "Value"
msgstr "値"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Description"
msgstr "説明"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`org.acme.Foo`"
msgstr "`org.acme.Foo`"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match the fully qualified name of the class"
msgstr "クラスの完全修飾名と一致させる"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`org.acme.*`"
msgstr "`org.acme.*`"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match classes with package `org.acme`"
msgstr "`org.acme` パッケージとクラスを一致させる"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`org.acme.**`"
msgstr "`org.acme.**`"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match classes where the package starts with `org.acme`"
msgstr "パッケージが `org.acme` で始まるクラスを一致させる"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`Bar`"
msgstr "`Bar`"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match the simple name of the class"
msgstr "クラスのシンプルな名前に一致する"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Exclude the type `org.acme.Foo`."
msgstr "タイプ `org.acme.Foo` を除外します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Exclude all types from the `org.acme` package."
msgstr "`org.acme` パッケージからすべてのタイプを除外します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Exclude all types whose simple name is `Bar`"
msgstr "シンプルな名前が `Bar` であるすべてのタイプを除外します。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.\n"
"For example, because it contains a `beans.xml` descriptor."
msgstr "また、除外しなければ Bean をスキャンする、依存関係のあるアーティファクトを除外することも可能です。たとえば、 `beans.xml` 記述子を含んでいる場合です。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "String-Based Qualifiers"
msgstr "文字列ベースの修飾子"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"The `@Named` qualifier, which you might be familiar with, is a _string-based qualifier_.\n"
"That is, it's the string value of the qualifier annotation who determines whether the qualifier matches or not.\n"
"This is not type-safe and should not be the norm in CDI applications.\n"
"Specific qualifier types should be preferred."
msgstr "`@Named` 、これは _文字列ベースの修飾子_ です。つまり、修飾子がマッチするかどうかを決定するのは、修飾子アノテーションの文字列値です。これは型安全ではないので、CDIアプリケーションでは一般的ではありません。特定の修飾子型が望ましいでしょう。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"However, sometimes string-based qualifiers are necessary.\n"
"In that case, avoid the `@Named` qualifier, because in CDI, it works differently to all other qualifiers."
msgstr "しかし、文字列ベースの修飾子が必要な場合もあります。CDIでは、 `@Named` 修飾子は他の修飾子とは異なる動作をするので、そのような場合は避けてください。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Specifically: if the only qualifier a bean has is `@Named`, it also automatically gets `@Default`.\n"
"This means that if multiple beans of the same type exist, one of them without qualifiers and the others with `@Named`, they _all_ get the `@Default` qualifier and bean resolution will error with ambiguity.\n"
"For example:"
msgstr "具体的には: ビーンが持つ唯一の修飾子が `@Named` の場合、自動的に `@Default` も取得します。これは，同じ型の複数のBeanが存在し，そのうちの一つが修飾子なしで，他の一つが `@Named` ，それらは _すべて_ `@Default` 修飾子を得て，Bean解決は曖昧さでエラーになることを意味します。例えば"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "In this case, the `Consumer#bean` injection point will cause ambiguity error, because both `MyBean` producers will have the `@Default` qualifier."
msgstr "この場合、 `Consumer#bean` 注入ポイントは、 `MyBean` プロデューサーの両方が `@Default` 修飾子を持つため、あいまい性エラーを引き起こします。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Instead of `@Named`, use `@io.smallrye.common.annotation.Identifier`.\n"
"This is a regular qualifier that works like all others.\n"
"So if we rewrite the example to use `@Identifier`:"
msgstr "`@Named` の代わりに `@io.smallrye.common.annotation.Identifier` を使ってください。これは他の修飾子と同じように機能します。ですから、この例を `@Identifier` を使うように書き直すと、次のようになります："

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Only the first producer will get the `@Default` qualifier, the second will not.\n"
"Hence, there will be no error, and everything will work as expected."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "When To Use `@Named`?"
msgstr "`@Named` をいつ使うべきか？"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "There is one case where `@Named` is the right thing to use: specifying an external identifier for a different language that doesn't support dependency injection directly."
msgstr "`@Named` 、依存性注入を直接サポートしていない別の言語の外部識別子を指定する場合です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "For example:"
msgstr "例えば、以下のようになります。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"As you can see, in the application code, the bean is injected without a qualifier.\n"
"The bean name is only used to refer to the bean in the other language."
msgstr "ご覧のように、アプリケーションコードでは、Beanは修飾子なしで注入されます。Bean名は、他言語でBeanを参照するためにのみ使用されます。"

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid ""
"Historically, the most common external language that used bean names was JSF.\n"
"In Quarkus, we have xref:qute-reference.adoc#injecting-beans-directly-in-templates[Qute].\n"
"In a Qute template, one would refer to the bean using its name:"
msgstr "歴史的に、ビーン名を使用する最も一般的な外部言語はJSFでした。Quarkusには xref:qute-reference.adoc#injecting-beans-directly-in-templates[Quteが] あります。Quteテンプレートでは、その名前を使用してBeanを参照します："

#: _versions/main/guides/cdi-reference.adoc
#, fuzzy
msgid "Outside of this use-case, just use `@Identifier`."
msgstr "この使用例以外では、 `@Identifier` を使用してください。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Native Executables and Private Members"
msgstr "ネイティブ実行可能ファイルとプライベートメンバー"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus is using GraalVM to build a native executable.\n"
"One of the limitations of GraalVM is the usage of link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/Reflection/[Reflection, window=\"_blank\"].\n"
"Reflective operations are supported, but all relevant members must be registered for reflection explicitly.\n"
"Those registrations result in a bigger native executable."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"And if Quarkus DI needs to access a private member it, *has to use reflection*.\n"
"That's why Quarkus users are encouraged __not to use private members__ in their beans.\n"
"This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers, and interceptor methods."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"How to avoid using private members?\n"
"You can use package-private modifiers:"
msgstr "プライベートメンバーの使用を回避するには、package-private 修飾子を使うことができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "A package-private injection field."
msgstr "package-private injection フィールド。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "A package-private observer method."
msgstr "package-private observer メソッド。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Or constructor injection:"
msgstr "あるいはコンストラクターの注入。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "A package-private constructor injection. `@Inject` is optional in this particular case."
msgstr "パッケージプライベートコンストラクター挿入。この特定の場合、 `@Inject` は任意です。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "[[supported_features]][[limitations]] Supported Features and Limitations"
msgstr "[[supported_features]][[limitations]] サポートされている機能と制限"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The CDI Lite specification is fully supported.\n"
"The following features from CDI Full are also supported:"
msgstr ""
"CDI Lite 仕様は完全にサポートされています。\n"
"CDI Full の次の機能もサポートされています。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Decorators"
msgstr "デコレーター"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Decoration of built-in beans, such as `Event`, is not supported"
msgstr "`Event` などのビルトイン Bean の装飾はサポートされていません"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`BeanManager`"
msgstr "`BeanManager`"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "In addition to the `BeanContainer` methods, the following methods are supported: `getInjectableReference()`, `resolveDecorators()`"
msgstr "`BeanContainer` メソッドに加えて、 `getInjectableReference()`、 `resolveDecorators()` のメソッドがサポートされています。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`@SessionScoped`"
msgstr "`@SessionScoped`"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Only with the Undertow extension; see xref:cdi.adoc#bean-scope-available[here] for details"
msgstr "Undertow エクステンションのみ。詳細は xref:cdi.adoc#bean-scope-available[こちら] を参照してください。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The _method invokers_ implementation supports asynchronous methods.\n"
"The following methods are considered asynchronous and `@Dependent` instances are only destroyed when the asynchronous action completes:"
msgstr ""
"_メソッド呼び出し_ 実装は非同期メソッドをサポートします。\n"
"次のメソッドは非同期とみなされ、 `@Dependent` インスタンスは非同期アクションが完了したときにのみ破棄されます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "methods that declare a return type of `CompletionStage`, `Uni`, or `Multi`"
msgstr "戻り値の型として `CompletionStage`、 `Uni`、または `Multi` を宣言するメソッド"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "These additional features are not covered by the CDI Lite TCK."
msgstr "これらの追加機能は、CDI Lite TCK では対応していません。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Non-standard Features"
msgstr "標準外の機能"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Eager Instantiation of Beans"
msgstr "Bean の即時インスタンス化"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Lazy By Default"
msgstr "デフォルトではレイジー"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"By default, CDI beans are created lazily, when needed.\n"
"What exactly \"needed\" means depends on the scope of a bean."
msgstr "デフォルトでは、CDI Bean は必要なときに作成されます。何を正確に「必要とされる」かは、Bean のスコープに依存します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification)."
msgstr "挿入されたインスタンス (仕様による文脈参照) からメソッドが呼び出される場合は、*通常のスコープ付き Bean* (`@ApplicationScoped`、 `@RequestScoped` など) が必要になります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean."
msgstr "言い換えれば、通常のスコープ付き Bean を挿入しても、Bean のコンテキストインスタンスの代わりに _クライアントプロキシー_ が挿入されるため、十分ではありません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected."
msgstr "挿入時に *疑似スコープを持つ Bean* (`@Dependent` および `@Singleton`) が作成されます。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Lazy Instantiation Example"
msgstr "遅延インスタンス化の例"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Injection triggers the instantiation of `AmazingService`."
msgstr "挿入は、 `AmazingService` のインスタンス化をトリガーします。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected."
msgstr "インジェクション自体は、 `CoolService` のインスタンス化にはなりません。クライアントプロキシーが挿入されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The first invocation upon the injected proxy triggers the instantiation of `CoolService`."
msgstr "挿入されたプロキシーに対する最初の呼び出しは、 `CoolService` のインスタンス化をトリガーします。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Startup Event"
msgstr "スタートアップイベント"

#: _versions/main/guides/cdi-reference.adoc
msgid "However, if you really need to instantiate a bean eagerly, you can:"
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:"
msgstr "`StartupEvent` のオブザーバーを宣言します。この場合、Bean のスコープは重要ではありません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "A `CoolService` is created during startup to service the observer method invocation."
msgstr "`CoolService` は、起動時に作成され、オブザーバーメソッドの呼び出しを処理します。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in <<lazy_by_default>>:"
msgstr "`StartupEvent` のオブザーバーで Bean を使用します - <<lazy_by_default>> で説明されているように、通常のスコープの Bean を使用する必要があります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The `AmazingService` is created during injection."
msgstr "`AmazingService` は注入時に作成されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The `CoolService` is a normal scoped bean, so we have to invoke a method upon the injected proxy to force the instantiation."
msgstr "`CoolService` は通常のスコープ付き Bean であるため、強制的にインスタンス化するために挿入されたプロキシーにメソッドを呼び出さなければなりません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Annotate the bean with `@io.quarkus.runtime.Startup` as described in xref:lifecycle.adoc#startup_annotation[Startup annotation]:"
msgstr "xref:lifecycle.adoc#startup_annotation[Startup annotation]: で説明したように、 `@io.quarkus.runtime.Startup` で Bean をアノテーションします。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used."
msgstr "`@Startup`  でアノテーションされた各Beanに対して、 `StartupEvent`  の合成オブザーバが生成されます。デフォルトの優先度が使用されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context."
msgstr "Beanのコンストラクタは、アプリケーションの起動時に呼び出され、結果として得られるコンテキストインスタンスがアプリケーションのコンテキストに格納されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the xref:lifecycle.adoc[Application Initialization and Termination] guide."
msgstr "Quarkus ユーザーは、xref:lifecycle.adoc[Application Initialization and Termination] のガイドで説明されているように、常に `@Initialized(ApplicationScoped.class)` よりも `@Observes StartupEvent` を選択することが推奨されます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Request Context Lifecycle"
msgstr "リクエストコンテキストのライフサイクル"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The request context is also active:"
msgstr "リクエストコンテキストもアクティブになっています。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "during notification of a synchronous observer method."
msgstr "同期オブザーバメソッドの通知中に"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The request context is destroyed:"
msgstr "リクエストコンテキストは破棄されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "after the observer notification completes for an event, if it was not already active when the notification started."
msgstr "通知が開始したときにまだアクティブではなかった場合はイベントのオブザーバー通知が完了した後"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed."
msgstr "オブザーバー通知のためにリクエストコンテキストが初期化されると、修飾子 `@Initialized(RequestScoped.class)` を持つイベントが発生します。さらに、修飾子 `@BeforeDestroyed(RequestScoped.class)` および `@Destroyed(RequestScoped.class)` を持つイベントは、リクエストコンテキストが破棄されたときに発生します。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "How to Enable Trace Logging for Request Context Activation"
msgstr "リクエストコンテキストのアクティブ化のトレースログを有効にする方法"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "You can set the `TRACE` level for the logger `io.quarkus.arc.requestContext` and try to analyze the log output afterwards."
msgstr "ロガー `io.quarkus.arc.requestContext` の `TRACE` レベルを設定し、後でログ出力の分析を試みることができます。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`application.properties` Example"
msgstr "`application.properties` の例"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "また、関連するカテゴリーの最小ログレベルを調整する必要があります。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Qualified Injected Fields"
msgstr "修飾された注入フィールド"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers."
msgstr "CDI では、フィールド注入ポイントを宣言する場合は `@Inject` と任意で修飾子のセットを使用する必要があります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier."
msgstr "Quarkus では、注入されたフィールドが少なくとも 1 つの修飾子を宣言している場合は、 `@Inject` アノテーションを完全にスキップすることができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection."
msgstr "後述する特別なケースを除いて、コンストラクターとメソッドの注入には `@Inject` が必要です。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Simplified Constructor Injection"
msgstr "簡略化されたコンストラクター注入"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).\n"
"However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI."
msgstr "CDI では、通常のスコープ付き Bean は常に no-args コンストラクターを宣言しなければなりません (このコンストラクターは、他のコンストラクターを宣言しない限り、通常はコンパイラーによって生成されます)。しかし、この要件はコンストラクターの注入を複雑にします。CDI で動作させるためにはダミーの no-args コンストラクターを提供する必要があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.\n"
"Also, if there's only one constructor there is no need for `@Inject`."
msgstr "Quarkus では、通常のスコープ付き Bean のためにダミーのコンストラクターを宣言する必要はありません。自動的に生成されます。また、コンストラクターが 1 つしかない場合は、 `@Inject` の必要性はありません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor."
msgstr "no-args コンストラクターを宣言していないクラスを Bean クラスが継承している場合は、no-args コンストラクターは自動的に生成されません。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Removing Unused Beans"
msgstr "未使用の Bean の削除"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The container attempts to remove all unused beans, interceptors and decorators during build by default.\n"
"This optimization helps to minimize the amount of generated classes, thus conserving memory.\n"
"However, Quarkus can't detect the programmatic lookup performed via the `CDI.current()` static method.\n"
"Therefore, it is possible that a removal results in a false positive error, i.e. a bean is removed although it's actually used.\n"
"In such cases, you'll notice a big warning in the log.\n"
"Users and extension authors have several options <<eliminate_false_positives,how to eliminate false positives>>."
msgstr "コンテナーは、デフォルトでビルド中に未使用の Bean、インターセプター、デコレーターをすべて削除しようとします。この最適化は、生成されるクラスの量を最小限に抑え、メモリーを節約するのに役立ちます。ただし、Quarkus は、 `CDI.current()` staticメソッドを介して実行されたプログラムによるルックアップを検出できません。したがって、削除すると誤検知エラーが発生する可能性があります。つまり、Bean は実際に使用されていても、削除されます。このような場合、ログに大きな警告が表示されます。ユーザーとエクステンションの作成者にはいくつかのオプションがあります: <<eliminate_false_positives,how to eliminate false positives>>。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.\n"
"Quarkus also provides a middle ground where application beans are never removed, whether or not they are unused, while the optimization proceeds normally for non application classes.\n"
"To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`."
msgstr ""

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "What's Removed?"
msgstr "何が削除されましたか?"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus first identifies so-called _unremovable_ beans that form the roots in the dependency tree.\n"
"A good example is a Jakarta REST resource class or a bean which declares a `@Scheduled` method."
msgstr "Quarkusはまず、依存関係ツリーのルートを形成する、いわゆる _削除不可能な_ Beanを特定します。良い例は、Jakarta RESTリソースクラスや、 `@Scheduled` メソッドを宣言している Bean です。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "An _unremovable_ bean:"
msgstr "_unremovable_ Bean:"

#: _versions/main/guides/cdi-reference.adoc
msgid "is <<eliminate_false_positives,excluded from removal>>, or"
msgstr "<<eliminate_false_positives,excluded from removal>>、または"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "has a name designated via `@Named`, or"
msgstr "`@Named` を通して指定された名前を持っているか、"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "declares an observer method."
msgstr "オブザーバーメソッドを宣言している場合。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "An _unused_ bean:"
msgstr "_未使用の_Bean:"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "is not _unremovable_, and"
msgstr "_unremovable_ ではなく、"

#: _versions/main/guides/cdi-reference.adoc
msgid "is not eligible for injection to any injection point in the dependency tree of _unremovable_ beans, and"
msgstr "_削除不可能_ な Bean の依存ツリー内のどの注入ポイントにも注入できない。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "does not declare any producer which is eligible for injection to any injection point in the dependency tree, and"
msgstr "依存関係ツリー内の挿入ポイントへの挿入に適格なプロデューサーを宣言していません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "is not eligible for injection into any `jakarta.enterprise.inject.Instance` or `jakarta.inject.Provider` injection point, and"
msgstr "`jakarta.enterprise.inject.Instance` または `jakarta.inject.Provider` 注入ポイントへの注入には適格ではない。"

#: _versions/main/guides/cdi-reference.adoc
msgid "is not eligible for injection into any <<injecting-multiple-bean-instances-intuitively,`@Inject @All List<>`>> injection point."
msgstr "<<injecting-multiple-bean-instances-intuitively,`@Inject @All List<>`>> 注入ポイントに注入する資格がない。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Unused interceptors and decorators are not associated with any bean."
msgstr "未使用のインターセプターとデコレーターは、どの Bean とも関連付けられていません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "When using the dev mode (running `./mvnw quarkus:dev`), you can see more information about which beans are being removed:"
msgstr "開発モード (`./mvnw quarkus:dev` を実行) を使用すると、削除される Bean に関する詳細情報を確認できます。"

#. type: delimited block =
#: _versions/main/guides/cdi-reference.adoc
msgid "In the console - just enable the DEBUG level in your `application.properties`, i.e. `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"
msgstr "コンソールで - `application.properties` で DEBUG レベルを有効にするだけです。例:　`quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"

#. type: delimited block =
#: _versions/main/guides/cdi-reference.adoc
msgid "In the relevant Dev UI page"
msgstr "関連する開発 UI ページ"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "How To Eliminate False Positives"
msgstr "誤検知を排除する方法"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `@io.quarkus.arc.Unremovable`.\n"
"This annotation can be declared on a class, a producer method or field."
msgstr "ユーザーは、コンテナーに `@io.quarkus.arc.Unremovable` をアノテーションすることで、(上で指定したルールをすべて満たしていても) 特定の Bean を削除しないように指示することができます。このアノテーションは、クラス、producer メソッド、producer フィールドに置くことができます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Since this is not always possible, there is an option to achieve the same via `application.properties`.\n"
"The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package."
msgstr "これは常に可能ではないので、 `application.properties` を通して同じことを実現するオプションがあります。 `quarkus.arc.unremovable-types` プロパティーは、Bean の名前やパッケージに基づいて一致させるための文字列値のリストを受け付けます。"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match the fully qualified name of the bean class"
msgstr "bean クラスの完全修飾名と一致させる"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match beans where the package of the bean class is `org.acme`"
msgstr "Bean クラスのパッケージが `org.acme` である Bean に一致します。"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match beans where the package of the bean class starts with `org.acme`"
msgstr "Bean クラスのパッケージが `org.acme` で開始する Bean に一致します。"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match the simple name of the bean class"
msgstr "Bean クラスのシンプルな名前に一致します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Furthermore, extensions can eliminate false positives by producing an `UnremovableBeanBuildItem`."
msgstr "さらに、エクステンションは `UnremovableBeanBuildItem` を生成することで、可能性のある誤検出を排除することができます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Default Beans"
msgstr "デフォルトの Bean"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)\n"
"This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example."
msgstr "Quarkus は、CDI が現在サポートしていない機能を追加します。これは、利用可能な手段 (Beanクラス、producer、合成 Bean など) で同等の型と修飾子を持つ他の Bean が宣言されていない場合に、条件付きで Bean を宣言することです。これは、 `@io .quarkus.Arc.DefaultBean` アノテーションを使用して行われ、例を挙げて説明するのが最善です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Say there is a Quarkus extension that, among other things, declares a few CDI beans like the following code does:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The idea is that the extension autoconfigures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.\n"
"Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.\n"
"The only thing that would be needed in our application would be something like the following:"
msgstr "アイデアは、エクステンションがユーザーのために自動設定を行い、多くのボイラープレートを排除するということです。必要な場所であれば、 `@Inject` を `Tracer` にすることができます。私たちのアプリケーションで、設定された `Tracer` を利用しようとする場合は、、カスタムの `Reporter` を提供するなど、少しカスタマイズする必要があります。アプリケーションで必要になるのは、次のようなものだけです。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any\n"
"way Quarkus supports."
msgstr "`@DefaultBean` では、エクステンション (またはそのための他のコード) が Quarkus がサポートする何らかの方法でその型の Bean が提供されている場合、バックオフ中にデフォルトを提供することができます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Default beans can optionally declare `@jakarta.annotation.Priority`.\n"
"If there is no priority defined, `@Priority(0)` is assumed.\n"
"Priority value is used for bean ordering and during typesafe resolution to disambiguate multiple matching default beans."
msgstr ""
"デフォルトの Bean はオプションで `@jakarta.annotation.Priority` を宣言できます。\n"
"優先度が定義されていない場合は、 `@Priority (0)` が想定されます。\n"
"優先度の値は、Bean の順序付けと、複数の一致するデフォルト Bean の曖昧さを解消するための型安全な解決に使用されます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Enabling Beans for Quarkus Build Profile"
msgstr "Quarkus ビルドプロファイルの Bean の有効化"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus adds a capability that CDI currently does not support, which is to conditionally enable a bean when a Quarkus build time profile is enabled,\n"
"via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.\n"
"When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Imagine, for instance that an application contains a bean named `Tracer`, which needs to do nothing when in tests or in dev mode, but works in its normal capacity for the production artifact.\n"
"An elegant way to create such beans is the following:"
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "If instead, it is required that the `Tracer` bean also works in dev mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:"
msgstr "代わりに、 `Tracer` Bean も開発モードで動作し、デフォルトではテストのために何もしないことが要求される場合は、 `@UnlessBuildProfile` が理想的です。コードは次のようになります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`."
msgstr "実行時プロファイルは、 `@IfBuildProfile` および `@UnlessBuildProfile` を使用した Bean 解決には影響を及ぼしません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "It is also possible to use `@IfBuildProfile` and `@UnlessBuildProfile` on stereotypes."
msgstr "ステレオタイプで `@IfBuildProfile` と `@UnlessBuildProfile` を使用することもできます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Enabling Beans for Quarkus Build Properties"
msgstr "Quarkus ビルドプロパティーの Bean を有効にする"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has or does not have a specific value,\n"
"via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotations.\n"
"When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build properties."
msgstr ""
"Quarkus は、CDI が現在サポートしていない機能を追加します。これは、Quarkus のビルド時のプロパティーに特定の値がある場合とない場合に、 `@io.quarkus.arc.properties.IfBuildProperty` および `@io.quarkus.arc.properties.UnlessBuildProperty` アノテーションを介して\n"
"条件付きで Bean を有効にする機能です。\n"
"これらのアノテーションを `@io.quarkus.arc.DefaultBean` と組み合わせて使用すると、異なるビルドプロパティーに対して異なる Bean 設定を作成できます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The scenario we mentioned above with `Tracer` could also be implemented in the following way:"
msgstr "`Tracer` を使用して上で述べたシナリオも、以下のように実装することができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations, i.e. a bean will only be enabled if **all** the conditions defined by these annotations are satisfied."
msgstr "`@IfBuildProperty` と `@UnlessBuildProperty` は繰り返し可能なアノテーションです。つまり、これらのアノテーションで定義された条件の **すべて** が満たされた場合にのみBeanが有効になります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:"
msgstr "代わりに、 `some.tracer.enabled` プロパティーが `false` でない場合にのみ `RealTracer` Bean が使用されることが要求される場合は、 `@UnlessBuildProperty` が理想的です。コードは以下のようになります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`."
msgstr "実行時に設定されたプロパティーは、 `@IfBuildProperty` を使用しても Bean の解決に全く影響しません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "It is also possible to use `@IfBuildProperty` and `@UnlessBuildProperty` on stereotypes."
msgstr "ステレオタイプで `@IfBuildProperty` と `@UnlessBuildProperty` を使用することもできます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Declaring Selected Alternatives"
msgstr "選択された代替の宣言"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.\n"
"Quarkus has a simplified bean discovery, and the content of `beans.xml` is ignored."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"However, it is also possible to select alternatives for an application using the unified configuration.\n"
"The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.\n"
"If any value matches, then the priority of `Integer#MAX_VALUE` is used for the relevant bean.\n"
"The priority declared via `@Priority` or inherited from a stereotype is overridden."
msgstr ""

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match the fully qualified name of the bean class or the bean class of the bean that declares the producer"
msgstr "Bean クラス、または producer を宣言する Bean の Bean クラスの完全修飾名に一致します。"

#. type: Table
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Match the simple name of the bean class or the bean class of the bean that declares the producer"
msgstr "Bean クラス、または producer を宣言する Bean の Bean クラスの単純名に一致します。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Simplified Producer Method Declaration"
msgstr "簡略化された Producer メソッドの宣言"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "In CDI, a producer method must be always annotated with `@Produces`."
msgstr "CDI では、producer メソッドは常に `@Produces` とアノテーションされていなければなりません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier."
msgstr "Quarkus では、producer メソッドにスコープアノテーション、ステレオタイプ、または修飾子が付いている場合は、 `@Produces` アノテーションを完全に省略できます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Interception of Static Methods"
msgstr "静的メソッドのインターセプション"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The Interceptors specification is clear that _around-invoke_ methods must not be declared static.\n"
"However, this restriction was driven mostly by technical limitations.\n"
"And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.\n"
"It's possible to annotate a non-private static method with an interceptor binding:"
msgstr "インターセプターの仕様は、_around-invoke_ メソッドを静的宣言してはならないことは明らかです。しかし、この制限は、主に技術的な制限によって設定されました。Quarkus は追加のクラス変換を可能にするビルド時指向のスタックであるため、この制限は適用されなくなりました。インターセプタ―バインディングで非プライベートの静的メソッドにアノテーションを付けることができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`Logged` is an interceptor binding."
msgstr "`Logged` はインターセプターバインディングです。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Each method invocation is intercepted if there is an interceptor associated with `Logged`."
msgstr "各メソッドの呼び出しは、 `Logged` に関連付けられたインターセプターがある場合に傍受されます。"

#. type: Title ====
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Limitations"
msgstr "制約事項"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)"
msgstr "下位互換性の理由から *メソッドレベルのバインディング* のみが考慮されます (そうでないとクラスレベルのバインディングを宣言している Bean クラスの静的メソッドが突然傍受されてしまいます)。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Private static methods are never intercepted"
msgstr "プライベートなスタティックメソッドは決して傍受されません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore, not all existing interceptors may behave correctly when intercepting static methods"
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly."
msgstr "インターセプターは `InvocationContext.getMethod()` を使用して静的メソッドを検出し、それに応じて動作を調整することができます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Ability to handle 'final' classes and methods"
msgstr "final クラスとメソッドを処理する能力"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation,\n"
"which in turn means that interceptors and normal scoped beans don't work properly.\n"
"This situation is very common when trying to use CDI with alternative JVM languages like Kotlin, where classes and methods are `final` by default."
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value)."
msgstr "しかし、Quarkus では、 `quarkus.arc.transform-unproxyable-classes` を `true` (デフォルト値) に設定すると、これらの制限を抑制することができます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Container-managed Concurrency"
msgstr "コンテナー管理型の並行処理"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"There is no standard concurrency control mechanism for CDI beans.\n"
"Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.\n"
"In that case, it should be thread-safe.\n"
"You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.\n"
"Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.\n"
"Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy."
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for \"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`."
msgstr "`io.quarkus.arc.Lock` は通常のインターセプターバインディングであるため、任意のスコープを持つ任意の Bean に使用することができます。しかし、特に「共有」スコープ、たとえば `@Singleton` や `@ApplicationScoped` に有益です。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Container-managed Concurrency Example"
msgstr "コンテナー管理された並行処理の例"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed."
msgstr "クラスで宣言された (`@Lock (Lock.type.Write)` にマッピングされる) `@Lock` は、任意のビジネスメソッドの呼び出しに対して Bean インスタンスをロックするようにコンテナーに指示します。つまり、クライアントには「排他アクセス」があり、同時呼び出しは許可されません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`."
msgstr "`@Lock(Lock.Type.READ)` は、クラスレベルで指定された値を上書きします。これは、Bean のインスタンスが `@Lock(Lock.Type.WRITE)` によってロックされていない限り、任意の数のクライアントが同時にメソッドを呼び出すことができることを意味します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown."
msgstr "また、「待ち時間」を指定することもできます。指定した時間内にロックを取得できない場合は `LockException` が発生します。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Repeatable interceptor bindings"
msgstr "反復可能なインターセプターバインディング"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Quarkus has limited support for `@Repeatable` interceptor binding annotations."
msgstr "Quarkusでは、 `@Repeatable` インターセプター結合アノテーションのサポートが制限されています。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.\n"
"Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.\n"
"This might be added in the future."
msgstr "インターセプタ―をコンポーネントにバインドする場合は、メソッドに対して複数の `@Repeatable` アノテーションを宣言できます。インターセプター仕様との相互作用に関する未解決の質問があるため、クラスとステレオタイプで宣言された反復可能なインターセプターバインディングはサポートされていません。これは将来追加される可能性があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"As an example, suppose we have an interceptor that clears a cache.\n"
"The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.\n"
"If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:"
msgstr "たとえば、キャッシュをクリアするインターセプタ―があるとします。対応するインターセプタ―バインディングは `@CacheInvalidateAll` と呼ばれ、 `@Repeatable` として宣言されます。同時に 2 つのキャッシュをクリアしたい場合は、 `@CacheInvalidateAll` を 2 回追加します。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"This is how interceptors are used.\n"
"What about creating an interceptor?"
msgstr "ここまで、インターセプタ―がどのように使用されるかを説明しました。では、インターセプターを作成するにはどうすれば良いでしょうか。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.\n"
"This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise."
msgstr "インターセプタ―のインターセプタ―バインディングを宣言する場合は、通常どおり、インターセプタ―クラスに複数の `@Repeatable` アノテーションを追加できます。 `@Cached` アノテーションの場合と同様に、アノテーションメンバーが `@Nonbinding` の場合は役に立ちませんが、それ以外の場合は重要になります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"For example, suppose we have an interceptor that can automatically log method invocations to certain targets.\n"
"The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.\n"
"Our implementation could be restricted to console logging and file logging:"
msgstr "たとえば、メソッド呼び出しを特定のターゲットに自動的に記録できるインターセプタ―があるとします。インターセプタ―バインディングアノテーション `@Logged` には、ログを保存する場所を指定する `target` というメンバーがあります。この実装は、コンソールログとファイルロギングに制限することができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Other interceptors could be provided to log method invocations to different targets."
msgstr "他にも、異なるターゲットへのメソッド呼び出しをログに記録するためのインターセプターを提供することができます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Caching the Result of Programmatic Lookup"
msgstr "プログラムによるルックアップの結果をキャッシュする"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In certain situations, it is practical to obtain a bean instance programmatically via an injected `jakarta.enterprise.inject.Instance` and `Instance.get()`.\n"
"However, according to the specification, the `get()` method must identify the matching bean and obtain a contextual reference.\n"
"As a consequence, a new instance of a  `@Dependent` bean is returned from each invocation of `get()`.\n"
"Moreover, this instance is a dependent object of the injected `Instance`.\n"
"This behavior is well-defined, but it may lead to unexpected errors and memory leaks.\n"
"Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.\n"
"An injected `Instance` annotated with this annotation will cache the result of the `Instance#get()` operation.\n"
"The result is computed on the first call, and the same value is returned for all subsequent calls, even for `@Dependent` beans."
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "It is also possible to clear the cached value via `io.quarkus.arc.InjectableInstance.clearCache()`. In this case, you'll need to inject the Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `jakarta.enterprise.inject.Instance`."
msgstr "`io.quarkus.arc.InjectableInstance.clearCache()` を使って、キャッシュされた値をクリアすることも可能です。この場合、 `jakarta.enterprise.inject.Instance` の代わりに Quarkus 固有の `io.quarkus.arc.InjectableInstance` を注入する必要があります。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Declaratively Choose Beans That Can Be Obtained by Programmatic Lookup"
msgstr "プログラムによるルックアップで取得できる Bean を宣言的に選択する"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"It is sometimes useful to narrow down the set of beans that can be obtained by programmatic lookup via `jakarta.enterprise.inject.Instance`.\n"
"Typically, a user needs to choose the appropriate implementation of an interface based on a runtime configuration property."
msgstr "`jakarta.enterprise.inject.Instance` を介したプログラムによる検索で取得できる Bean の集合を絞り込むことが有用な場合があります。典型的には，ユーザは，実行時設定プロパティに基づいて，インタフェースの適切な実装を選択する必要があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Imagine that we have two beans implementing the interface `org.acme.Service`.\n"
"You can't inject the `org.acme.Service` directly unless your implementations declare a CDI qualifier.\n"
"However, you can inject the `Instance<Service>` instead, then iterate over all implementations and choose the correct one manually.\n"
"Alternatively, you can use the `@LookupIfProperty` and `@LookupUnlessProperty` annotations.\n"
"`@LookupIfProperty` indicates that a bean should only be obtained if a runtime configuration property matches the provided value.\n"
"`@LookupUnlessProperty`, on the other hand, indicates that a bean should only be obtained if a runtime configuration property does not match the provided value."
msgstr "インターフェイス `org.acme.Service` を実装した 2 つの Bean があるとします。実装が CDI 修飾子を宣言していない限り、 `org.acme.Service` を直接注入することはできません。しかし、代わりに `Instance<Service>` を注入して、すべての実装を繰り返し、正しいものを手動で選択することができます。また、 `@LookupIfProperty` と `@LookupUnlessProperty` アノテーションを利用することもできます。 `@LookupIfProperty` は、実行時設定プロパティーが提供された値と一致する場合にのみ、Bean を取得する必要があることを示します。一方、 `@LookupUnlessProperty` は、実行時設定プロパティーが提供された値と一致しない場合にのみ、Bean を取得する必要があることを示します。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`@LookupIfProperty` Example"
msgstr "`@LookupIfProperty` Example"

#: _versions/main/guides/cdi-reference.adoc
msgid "Sorting beans obtained with programmatic lookup"
msgstr "プログラムによる検索で取得した Bean のソート"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"If there is more than one bean that matches the required type and qualifiers and is eligible for injection, it is possible to iterate (or stream) available bean instances.\n"
"Beans returned by both stream and iterator methods are sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first.\n"
"If no priority is explicitly declared, 0 is assumed."
msgstr ""
"必要なタイプと修飾子に一致し、注入の対象となる Bean が複数ある場合は、使用可能な Bean インスタンスを反復処理 (またはストリーム処理) できます。\n"
"ストリームメソッドとイテレーターメソッドの両方で返される Bean は、 `io.quarkus.arc.InjectableBean#getPriority()` で定義された優先順位でソートされます。優先度の高いものが最初に来ます。\n"
"優先度が明示的に宣言されていない場合は、0 が想定されます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Injecting Multiple Bean Instances Intuitively"
msgstr "複数の Bean インスタンスを直感的に注入する"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In CDI, it's possible to inject multiple bean instances (aka contextual references) via the `jakarta.enterprise.inject.Instance` which implements `java.lang.Iterable`.\n"
"However, it's not exactly intuitive.\n"
"Therefore, a new way was introduced in Quarkus - you can inject a `java.util.List` annotated with the `io.quarkus.arc.All` qualifier.\n"
"The type of elements in the list is used as the required type when performing the lookup."
msgstr "CDIでは、 `java.lang.Iterable` を実装した `jakarta.enterprise.inject.Instance` を介して、複数のBeanインスタンス（別名：コンテキスト参照）を注入することが可能です。しかし、これは直感的に理解できるものではありません。そこで、Quarkusでは新しい方法を導入しました。 `io.quarkus.arc.All` 修飾子でアノテーションされた `java.util.List` を注入することができます。リスト内の要素の型は、検索を実行する際に必要な型として使用されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The injected instance is an _immutable list_ of the contextual references of the _disambiguated_ beans."
msgstr "注入されたインスタンスは、_disambiguated_ bean のコンテキスト参照の _immutable list_ です。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "For this injection point the required type is `Service` and no additional qualifiers are declared."
msgstr "このインジェクションポイントに必要なタイプは `Service` であり、追加の修飾子は宣言されていません。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "The list is sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first. In general, the `@jakarta.annotation.Priority` annotation can be used to assign the priority to a class bean, producer method or producer field."
msgstr "リストは、 `io.quarkus.arc.InjectableBean#getPriority()` で定義された優先度でソートされます。優先度の高いものが最初に来ます。一般に、 `@jakarta.annotation.Priority` アノテーションを使用して、クラス Bean、プロデューサーメソッド、またはプロデューサーフィールドに優先度を割り当てることができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "If an injection point declares no other qualifier than `@All` then `@Any` is used, i.e. the behavior is equivalent to `@Inject @Any Instance<Service>`."
msgstr "インジェクションポイントが `@All` 以外の修飾子を宣言していない場合、 `@Any` が使用されます。つまり、動作は `@Inject @Any Instance<Service>` と同等です。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"You can also inject a list of bean instances wrapped in `io.quarkus.arc.InstanceHandle`.\n"
"This can be useful if you need to inspect the related bean metadata."
msgstr "`io.quarkus.arc.InstanceHandle` でラップされた Bean インスタンスのリストを注入することもできます。これは、関連する Bean メタデータを検査する必要がある場合に役立ちます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Neither a type variable nor a wildcard is a legal type parameter for an `@All List<>` injection point, i.e. `@Inject @All List<?> all` is not supported and results in a deployment error."
msgstr "型変数もワイルドカードも `@All List<>` インジェクションポイントのタイプパラメーターとしては有効ではありません。つまり、 `@Inject @All List<?> all` はサポートされておらず、デプロイメントエラーになります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "It is also possible to obtain the list of all bean instance handles programmatically via the `Arc.container().listAll()` methods."
msgstr "`Arc.container().listAll()` メソッドを使用して、プログラムですべての Bean インスタンスハンドルのリストを取得することもできます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Ignoring Class-Level Interceptor Bindings for Methods and Constructors"
msgstr "メソッドとコンストラクターのクラスレベルのインターセプターバインディングを無視する"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"If a managed bean declares interceptor binding annotations on the class level, the corresponding `@AroundInvoke` interceptors will apply to all business methods.\n"
"Similarly, the corresponding `@AroundConstruct` interceptors will apply to the bean constructor."
msgstr "マネージド Bean がクラスレベルでインターセプターバインディングアノテーションを宣言する場合、対応する `@AroundInvoke` インターセプターがすべてのビジネスメソッドに適用されます。同様に、対応する `@AroundConstruct` インターセプターが Bean コンストラクターに適用されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "For example, suppose we have a logging interceptor with the `@Logged` binding annotation and a tracing interceptor with the `@Traced` binding annotation:"
msgstr "たとえば、 `@Logged` バインディングアノテーションを持つロギングインターセプターと `@Traced` バインディングアノテーションを持つトレースインターセプターがあるとします。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In this example, both `doSomething` and `doSomethingElse` will be intercepted by the hypothetical logging interceptor.\n"
"Additionally, the `doSomethingElse` method will be intercepted by the hypothetical tracing interceptor."
msgstr "この例では、 `doSomething` と `doSomethingElse` の両方が架空のロギングインターセプターによってインターセプトされます。さらに、 `doSomethingElse` メソッドは、架空のトレースインターセプターによってインターセプトされます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Now, if that `@Traced` interceptor also performed all the necessary logging, we'd like to skip the `@Logged` interceptor for this method, but keep it for all other methods.\n"
"To achieve that, you can annotate the method with `@NoClassInterceptors`:"
msgstr "もし `@Traced` インターセプターが必要なロギングもすべて行っていた場合、このメソッドでは `@Logged` インターセプターを省略したいのですが、他のすべてのメソッドではそのままにしておきたいと思います。これを実現するには、メソッドに `@NoClassInterceptors` というアノテーションを付けます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The `@NoClassInterceptors` annotation may be put on methods and constructors, and means that all class-level interceptors are ignored for these methods and constructors.\n"
"In other words, if a method/constructor is annotated `@NoClassInterceptors`, then the only interceptors that will apply to this method/constructor are interceptors declared directly on the method/constructor."
msgstr ""

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "This annotation affects only business method interceptors (`@AroundInvoke`) and constructor lifecycle callback interceptors (`@AroundConstruct`)."
msgstr "このアノテーションは、ビジネスメソッドインターセプター (`@AroundInvoke`) とコンストラクターライフサイクルコールバックインターセプター (`@AroundConstruct`) にのみ影響します。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Exceptions Thrown By An Asynchronous Observer Method"
msgstr "非同期オブザーバーメソッドによって出力される例外"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"If an exception is thrown by an asynchronous observer then the `CompletionStage` returned by the `fireAsync()` method completes exceptionally so that the event producer may react appropriately.\n"
"However, if the event producer does not care then the exception is ignored silently.\n"
"Therefore, Quarkus logs an error message by default.\n"
"It is also possible to implement a custom `AsyncObserverExceptionHandler`.\n"
"A bean that implements this interface should be `@jakarta.inject.Singleton` or `@jakarta.enterprise.context.ApplicationScoped`."
msgstr ""
"非同期オブザーバーによって例外が発生した場合、 `fireAsync()` メソッドによって返される `CompletionStage` は例外的に完了し、イベントプロデューサーが適切に対応できるようになります。\n"
"ただし、イベントプロデューサーが気にしない場合は、例外は黙って無視されます。\n"
"したがって、Quarkus はデフォルトでエラーメッセージをログに記録します。\n"
"カスタムの `AsyncObserverExceptionHandler` を実装することも可能です。\n"
"このインターフェイスを実装する Bean は、 `@jakarta.inject.Singleton` または `@jakarta.enterprise.context.ApplicationScoped` である必要があります。"

#. type: Block title
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "`NoopAsyncObserverExceptionHandler`"
msgstr "`NoopAsyncObserverExceptionHandler`"

#: _versions/main/guides/cdi-reference.adoc
msgid "Intercepted self-invocation"
msgstr "インターセプトされた自己呼び出し"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus supports what is known as intercepted self-invocation or just self-interception - a scenario where CDI bean invokes its own intercepted method from within another method while triggering any associated interceptors.\n"
"This is a non-standard feature as CDI specification doesn't define whether self-interception should work or not."
msgstr ""
"Quarkus は、インターセプトされた自己呼び出し (または単に自己インターセプションと呼ぶ) をサポートしています。これは、CDI Bean が、関連付けられているインターセプターをトリガーしながら、別のメソッド内から独自のインターセプトされたメソッドを呼び出すシナリオです。\n"
"CDI 仕様では自己インターセプトが機能するかどうかが定義されていないため、これは非標準の機能です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Suppose we have a CDI bean with two methods, one of which has the `@Transactional` interceptor binding associated with it:"
msgstr "メソッドが 2 つある CDI Bean があり、そのうちの 1 つに `@Transactional` インターセプターバインディングが関連付けられているとします。"

#: _versions/main/guides/cdi-reference.adoc
msgid "One or more interceptor bindings; `@Transactional` is just an example."
msgstr "1 つ以上のインターセプターバインディング。 `@Transactional` は単なる例です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Non-intercepted method invoking another method from the same bean that has associated binding(s); this will trigger interception."
msgstr "インターセプトされないメソッドが、関連付けられたバインディングを持つ同じ Bean から別のメソッドを呼び出します。これにより、インターセプトがトリガーされます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In the above example, any code calling the `doSomething()` method triggers interception - in this case, the method becomes transactional.\n"
"This is regardless of whether the invocation originated directly from the `MyService` bean (such as `MyService#doSomethingElse`) or from some other bean."
msgstr ""
"上記の例では、 `doSomething()` メソッドを呼び出すすべてのコードがインターセプションをトリガーします。この場合、メソッドはトランザクションになります。\n"
"これは、呼び出しが `MyService` Bean (`MyService#doSomethingElse` など) から直接発生したか、他の Bean から発生したかには関係ありません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Intercepting Producer Methods and Synthetic Beans"
msgstr "インターセプトプロデューサーメソッドと合成 Bean"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"By default, interception is only supported for managed beans (also known as class-based beans).\n"
"To support interception of producer methods and synthetic beans, the CDI specification includes an `InterceptionFactory`, which is a runtime oriented concept and therefore cannot be supported in Quarkus."
msgstr ""
"デフォルトでは、インターセプションはマネージド Bean (クラスベース Bean とも呼ばれます) に対してのみサポートされます。\n"
"プロデューサーメソッドと合成 Bean のインターセプションをサポートするために、CDI 仕様には `InterceptionFactory` が含まれていますが、これはランタイム指向の概念であるため、Quarkus ではサポートできません。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Instead, Quarkus has its own API: `InterceptionProxy` and `@BindingsSource`.\n"
"The `InterceptionProxy` is very similar to `InterceptionFactory`: it creates a proxy that applies `@AroundInvoke` interceptors before forwarding the method call to the target instance.\n"
"The `@BindingsSource` annotation allows setting interceptor bindings in case the intercepted class is external and cannot be changed."
msgstr ""
"代わりに、Quarkus には独自の API: `InterceptionProxy` と `@BindingsSource` があります。\n"
"`InterceptionProxy` は `InterceptionFactory` と非常によく似ており、メソッド呼び出しをターゲットインスタンスに転送する前に `@AroundInvoke` インターセプターを適用するプロキシーを作成します。\n"
"`@BindingsSource` アノテーションを使用すると、インターセプトされたクラスが外部にあり、変更できない場合に、インターセプターバインディングを設定できます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Declares an injection point of type `InterceptionProxy<MyClass>`.\n"
"This means that at build time, a subclass of `MyClass` is generated that does the interception and forwarding.\n"
"Note that the type argument must be identical to the return type of the producer method."
msgstr ""
"`InterceptionProxy<MyClass>` 型の注入ポイントを宣言します。\n"
"つまり、ビルド時に、インターセプトと転送を行う `MyClass` のサブクラスが生成されます。\n"
"型引数はプロデューサーメソッドの戻り値の型と同じである必要があることに注意してください。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Creates an instance of the interception proxy for the given instance of `MyClass`.\n"
"The method calls will be forwarded to this target instance after all interceptors run."
msgstr ""
"指定された `MyClass` インスタンスのインターセプトプロキシーのインスタンスを作成します。\n"
"すべてのインターセプターが実行された後、メソッド呼び出しはこのターゲットインスタンスに転送されます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "In this example, interceptor bindings are read from the `MyClass` class."
msgstr "この例では、インターセプターバインディングは `MyClass` クラスから読み取られます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Note that `InterceptionProxy` only supports `@AroundInvoke` interceptors declared on interceptor classes.\n"
"Other kinds of interception, as well as `@AroundInvoke` interceptors declared on the target class and its superclasses, are not supported."
msgstr ""
"`InterceptionProxy` は、インターセプタークラスで宣言された `@AroundInvoke` インターセプターのみをサポートすることに注意してください。\n"
"他の種類のインターセプション、およびターゲットクラスとそのスーパークラスで宣言された `@AroundInvoke` インターセプターはサポートされていません。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The intercepted class should be https://jakarta.ee/specifications/cdi/4.1/jakarta-cdi-spec-4.1#unproxyable[proxyable] and therefore should not be `final`, should not have non-private `final` methods, and should have a non-private zero-parameter constructor.\n"
"If it isn't, a bytecode transformation will attempt to fix it if <<unproxyable_classes_transformation,enabled>>, but note that adding a zero-parameter constructor is not always possible."
msgstr ""
"インターセプトされたクラスは https://jakarta.ee/specifications/cdi/4.1/jakarta -cdi-spec-4.1#unproxyable[proxyable] である必要があるため、 `final` や、プライベート以外の `final` メソッドを指定できません。また、プライベート以外のゼロパラメーターのコンストラクターを指定する必要があります。\n"
"そうでなく、<<unproxyable_classes_transformation,enabled>> の場合は、バイトコード変換によって修正を試みます。ゼロパラメーターのコンストラクターを追加できない場合もあることに注意してください。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"It is often the case that the produced classes come from external libraries and don't contain interceptor binding annotations at all.\n"
"To support such cases, the `@BindingsSource` annotation may be declared on the `InterceptionProxy` parameter:"
msgstr ""
"生成されたクラスは外部ライブラリーからのものであり、インターセプターバインディングアノテーションがまったく含まれていないことがよくあります。\n"
"このようなケースをサポートするには、 `InterceptionProxy` パラメーターで `@BindingsSource` アノテーションを宣言します。"

#: _versions/main/guides/cdi-reference.adoc
msgid "A class that mirrors the `MyClass` structure and contains interceptor bindings."
msgstr "`MyClass` 構造をミラーリングし、インターセプターバインディングを含むクラス。"

#: _versions/main/guides/cdi-reference.adoc
msgid "The `@BindingsSource` annotation says that interceptor bindings for `MyClass` should be read from `MyClassBindings`."
msgstr "`@BindingsSource` アノテーションによると、 `MyClass` のインターセプターバインディングは `MyClassBindings` から読み取る必要があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid "The concept of _bindings source_ is a build-time friendly equivalent of `InterceptionFactory.configure()`."
msgstr "_bindings source_ の概念は、ビルド時に使いやすい `InterceptionFactory.configure()` と同等です。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Producer method interception and synthetic bean interception only works for instance methods.\n"
"<<interception_of_static_methods>> is not supported for producer methods and synthetic beans."
msgstr ""
"プロデューサーメソッドインターセプションと合成 Bean インターセプションは、インスタンスメソッドに対してのみ機能します。\n"
"<<interception_of_static_methods>> はプロデューサーメソッドと合成 Bean ではサポートされていません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Declaring `@BindingsSource`"
msgstr "`@BindingsSource` の宣言"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The `@BindingsSource` annotation specifies a class that mirrors the structure of the intercepted class.\n"
"Interceptor bindings are then read from that class and treated as if they were declared on the intercepted class."
msgstr ""
"`@BindingsSource` アノテーションは、インターセプトされたクラスの構造を反映するクラスを指定します。\n"
"その後、インターセプターバインディングはそのクラスから読み取られ、インターセプトされたクラスで宣言されているかのように扱われます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Specifically: class-level interceptor bindings declared on the bindings source class are treated as class-level bindings of the intercepted class.\n"
"Method-level interceptor bindings declared on the bindings source class are treated as method-level bindings of a method with the same name, return type, parameter types and `static` flag of the intercepted class."
msgstr ""
"具体的には、バインディングソースクラスで宣言されたクラスレベルのインターセプターバインディングは、インターセプトされたクラスのクラスレベルのバインディングとして扱われます。\n"
"バインディングソースクラスで宣言されたメソッドレベルのインターセプターバインディングは、インターセプトされたクラスと同じ名前、戻り値の型、パラメーターの型、および `static` フラグを持つメソッドのメソッドレベルのバインディングとして扱われます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "It is common to make the bindings source class and methods `abstract` so that you don't have to write method bodies:"
msgstr "メソッド本体を記述しなくて済むように、バインディングソースクラスとメソッドを `abstract` にするのが一般的です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Since this class is never instantiated and its method are never invoked, this is okay, but it's also possible to create a non-`abstract` class:"
msgstr "このクラスはインスタンス化されることはなく、そのメソッドが呼び出されることもないので、これで問題ありませんが、非 `abstract` クラスを作成することも可能です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "The method body does not matter."
msgstr "メソッド本体は重要ではありません。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Note that for generic classes, the type variable names must also be identical.\n"
"For example, for the following class:"
msgstr ""
"ジェネリッククラスの場合、型変数名も同一である必要があることに注意してください。\n"
"たとえば、次のクラスの場合:"

#: _versions/main/guides/cdi-reference.adoc
msgid "The bindings source class must also use `T` as the name of the type variable:"
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"You don't need to declare methods that are not annotated simply because they exist on the intercepted class.\n"
"If you want to add method-level bindings to a subset of methods, you only have to declare the methods that are supposed to have an interceptor binding.\n"
"If you only want to add class-level bindings, you don't have to declare any methods at all."
msgstr ""
"インターセプトされたクラスに存在するという理由だけで、アノテーションが付けられていないメソッドを宣言する必要はありません。\n"
"メソッドのサブセットにメソッドレベルのバインディングを追加する場合は、インターセプターバインディングを指定する予定のメソッドを宣言するだけで済みます。\n"
"クラスレベルのバインディングのみを追加する場合は、メソッドを宣言する必要はありません。"

#: _versions/main/guides/cdi-reference.adoc
msgid "These annotations can be present on a bindings source class:"
msgstr "バインディングソースクラスには次のアノテーションを配置できます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "_interceptor bindings_: on the class and on the methods"
msgstr "_インターセプターバインディング_: クラスとメソッド"

#: _versions/main/guides/cdi-reference.adoc
msgid "_stereotypes_: on the class"
msgstr "_ステレオタイプ_: クラスについて"

#: _versions/main/guides/cdi-reference.adoc
msgid "`@NoClassInterceptors`: on the methods"
msgstr "`@NoClassInterceptors`: メソッドについて"

#: _versions/main/guides/cdi-reference.adoc
msgid "Any other annotation present on a bindings source class is ignored."
msgstr "バインディングソースクラスに存在するその他のアノテーションは無視されます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Synthetic Beans"
msgstr "合成 Bean"

#: _versions/main/guides/cdi-reference.adoc
msgid "Using `InterceptionProxy` in synthetic beans is similar."
msgstr "合成 Bean で `InterceptionProxy` を使用する場合も同様です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "First, you have to declare that your synthetic bean injects the `InterceptionProxy`:"
msgstr "まず、合成 Bean が `InterceptionProxy` を注入することを宣言する必要があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Once again, this means that at build time, a subclass of `MyClass` is generated that does the interception and forwarding."
msgstr "つまり、これはビルド時に、インターセプトと転送を行う `MyClass` のサブクラスが生成されることを意味します。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Second, you have to obtain the `InterceptionProxy` from the `SyntheticCreationalContext` in the `BeanCreator` and use it:"
msgstr "次に、 `BeanCreator` の `SyntheticCreationalContext` から `InterceptionProxy` を取得して使用する必要があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Obtains the `InterceptionProxy` for `MyClass`, as declared above.\n"
"It would also be possible to use the `getInjectedReference()` method, passing a `TypeLiteral`, but `getInterceptionProxy()` is easier."
msgstr ""
"上記で宣言したように、 `MyClass` の `InterceptionProxy` を取得します。\n"
"`TypeLiteral` を渡して `getInjectedReference()` メソッドを使用することも可能ですが、 `getInterceptionProxy()` の方が簡単です。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"There's also an equivalent of `@BindingsSource`.\n"
"The `injectInterceptionProxy()` method has an overload with a parameter:"
msgstr ""
"`@BindingsSource` に相当するものもあります。\n"
"`injectInterceptionProxy()` メソッドには、パラメーターが １ つ指定されたオーバーロードがあります。"

#: _versions/main/guides/cdi-reference.adoc
msgid "The argument is the bindings source class."
msgstr "引数はバインディングソースクラスです。"

#: _versions/main/guides/cdi-reference.adoc
msgid "`Instance.Handle.close()` Behavior"
msgstr "`Instance.Handle.close()` の動作"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Per the CDI specification, the `Instance.Handle.close()` method always delegates to `destroy()`.\n"
"In ArC, this is only true in the <<strict_mode>>."
msgstr ""
"CDI 仕様によれば、 `Instance.Handle.close()` メソッドは常に `destroy()` に委任します。\n"
"ArC では、これは <<strict_mode>> では True のみです。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In the default mode, the `close()` method only delegates to `destroy()` when the bean is `@Dependent` (or when the instance handle does not represent a CDI contextual object).\n"
"When the instance handle represents a bean of any other scope, the `close()` method does nothing; the bean is left as is and will be destroyed whenever its context is destroyed."
msgstr ""
"デフォルトモードでは、Bean が `@Dependent` の場合 (またはインスタンスハンドルが CDI コンテキストオブジェクトを表していない場合)、 `close()` メソッドは `destroy()` に委任するだけです。\n"
"インスタンスハンドルが他のスコープの Bean を表す場合、 `close()` メソッドは何も行いません。Bean はそのまま残され、コンテキストが破棄されると、Bean も破棄されます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "This is to make the following code behave as one would naively expect:"
msgstr "これは、次のコードを単純に期待どおりに動作させるためです。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The `@Dependent` beans are destroyed immediately, while other beans are not destroyed at all.\n"
"This is important when multiple beans of different scopes might be returned by the `Instance`."
msgstr ""
"`@Dependent` Bean はすぐに破棄されますが、他の Bean は破棄されません。\n"
"これは、 `Instance` によって異なるスコープの複数の Bean が返される可能性がある場合に重要です。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Pitfalls with Reactive Programming"
msgstr "リアクティブプログラミングの落とし穴"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"CDI is a purely synchronous framework.\n"
"Its notion of asynchrony is very limited and based solely on thread pools and thread offloading.\n"
"Therefore, there is a number of pitfalls when using CDI together with reactive programming."
msgstr ""
"CDI は単なる同期フレームワークです。\n"
"非同期の概念は非常に限られており、スレッドプールとスレッドオフロードのみに基づいています。\n"
"したがって、CDI をリアクティブプログラミングと組み合わせて使用すると、いくつかの落とし穴が生じます。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Detecting When Blocking Is Allowed"
msgstr "ブロックが許可されているかどうかの検出"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The `io.quarkus.runtime.BlockingOperationControl#isBlockingAllowed()` method can be used to detect whether blocking is allowed on the current thread.\n"
"When it is not, and you need to perform a blocking operation, you have to offload it to another thread.\n"
"The easiest way is to use the `Vertx.executeBlocking()` method:"
msgstr ""
"`io.quarkus.runtime.BlockingOperationControl#isBlockingAllowed()` メソッドを使用すると、現在のスレッドでブロッキングが許可されているかどうかを検出できます。\n"
"そうでない場合、ブロッキング操作を実行する必要がある場合は、その操作を別のスレッドにオフロードする必要があります。\n"
"最も簡単な方法は、 `Vertx.executeBlocking()` メソッドを使用することです。"

#: _versions/main/guides/cdi-reference.adoc
msgid "Asynchronous Observers"
msgstr "非同期オブザーバー"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"CDI asynchronous observers (`@ObservesAsync`) are not aware of reactive programming and are not meant to be used as part of reactive pipelines.\n"
"The observer methods are meant to be synchronous, they are just offloaded to a thread pool."
msgstr ""
"CDI 非同期オブザーバー (`@ObservesAsync`) はリアクティブプログラミングを認識しないため、リアクティブパイプラインの一部として使用できません。\n"
"オブザーバーメソッドは同期されることを意図しており、スレッドプールにオフロードされるだけです。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The `Event.fireAsync()` method returns a `CompletionStage` that completes when all observers are notified.\n"
"If all observers were notified successfully, the `CompletionStage` completes with the event payload.\n"
"If some observers have thrown an exception, the `CompletionStage` completes exceptionally with a `CompletionException`."
msgstr ""
"`Event.fireAsync()` メソッドは、すべてのオブザーバーに通知されると完了する `CompletionStage` を返します。\n"
"すべてのオブザーバーに正常に通知された場合、 `CompletionStage` はイベントペイロードで完了します。\n"
"一部のオブザーバーで例外が発生した場合、 `CompletionStage` は `CompletionException` で例外的に完了します。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"The return type of the observer _does not matter_.\n"
"The return value of the observer is _ignored_."
msgstr ""
"オブザーバーの戻り値の型は重要ではありません。\n"
"オブザーバーの戻り値は無視されます。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"You may declare an observer method that has a return type of `CompletionStage<>` or `Uni<>`, but neither the return type nor the actual return value affects the result of `Event.fireAsync()`.\n"
"Further, if the observer declares a return type of `Uni<>`, the returned `Uni` will not be subscribed to, so it is quite possible that part of the observer logic will not even execute."
msgstr ""

#: _versions/main/guides/cdi-reference.adoc
msgid "Therefore, it is recommended that observer methods, both synchronous and asynchronous, are always declared `void`."
msgstr "したがって、同期と非同期の両方のオブザーバーメソッドは常に `void` として宣言することを推奨します。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Build Time Extensions"
msgstr "ビルド時間延長"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.\n"
"The downside of this approach is that CDI Portable Extensions cannot be supported.\n"
"Nevertheless, most of the functionality can be achieved using Quarkus xref:writing-extensions.adoc[extensions].\n"
"See the xref:cdi-integration.adoc[integration guide] for more information."
msgstr "Quarkus は、インスタント起動と低メモリフットプリントを提供するために、ビルド時の最適化を取り入れています。このアプローチの欠点は、CDI ポータブル・エクステンションをサポートできないことです。それにもかかわらず、ほとんどの機能は、Quarkus xref:writing-extensions.adoc[エクステンション] を使用して行うことができます。詳細は、xref:cdi-integration.adoc[integration guide] を参照してください。"

#: _versions/main/guides/cdi-reference.adoc
msgid "[[development-mode]] Dev mode"
msgstr "[[development-mode]] 開発モード"

#: _versions/main/guides/cdi-reference.adoc
msgid "In dev mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:"
msgstr "開発モードでは、JSON 形式で基本的なデバッグ情報を提供するために、2 つの特別なエンドポイントが自動的に登録されます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc."
msgstr "HTTP GET `/q/arc` - 要約、Bean の数、設定プロパティーなどを返します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "HTTP GET `/q/arc/beans` - returns the list of all beans"
msgstr "HTTP GET `/q/arc/beans` - すべての Bean のリストを返します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "You can use query params to filter the output:"
msgstr "クエリーパラメーターを使用して出力をフィルタリングすることができます。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`"
msgstr "`scope` - 指定した値で終わるスコープを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`)。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`"
msgstr "`beanClass` - 与えられた値で始まる Bean クラスを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`)。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`"
msgstr "`kind` - 指定された種類の Bean (`CLASS`、 `PRODUCER_FIELD`、 `PRODUCER_METHOD`、 `INTERCEPTOR`、または `SYNTHETIC`) を含みます (つまり `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`)。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build"
msgstr "HTTP GET `/q/arc/removed-beans` - ビルド中に削除された未使用の Bean のリストを返します。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "HTTP GET `/q/arc/observers` - returns the list of all observer methods"
msgstr "HTTP GET `/q/arc/observers` - すべてのオブザーバーメソッドのリストを返します。"

#: _versions/main/guides/cdi-reference.adoc
msgid "These endpoints are only available in dev mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`)."
msgstr "これらのエンドポイントは、開発モード、つまり `mvn quarkus:dev` (または `./gradlew quarkusDev`) 経由でアプリケーションを実行する場合にのみ使用できます。"

#. type: Title ===
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Monitoring Business Method Invocations and Events"
msgstr "ビジネスメソッドの呼び出しとイベントの監視"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"In dev mode, it is also possible to enable monitoring of business method invocations and fired events.\n"
"Simply set the `quarkus.arc.dev-mode.monitoring-enabled` configuration property to `true` and explore the relevant Dev UI pages."
msgstr ""
"開発モードでは、ビジネスメソッドの呼び出しと発生したイベントの監視を有効にすることもできます。\n"
"`quarkus.arc.dev-mode.monitoring-enabled` 設定プロパティーを `true` に設定し、関連する Dev UI ページを確認するだけです。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "Strict Mode"
msgstr "ストリクトモード"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"By default, ArC does not perform all validations required by the CDI specification.\n"
"It also improves CDI usability in many ways, some of them being directly against the specification."
msgstr "デフォルトでは、ArC は CDI 仕様で要求される全てのバリデーションを実行するわけではありません。また、多くの方法でCDIの使い勝手を向上させますが、その中には仕様に直接反するものもあります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"To pass the CDI Lite TCK, ArC also has a _strict_ mode.\n"
"This mode enables additional validations and disables certain improvements that conflict with the specification."
msgstr ""
"CDI Lite TCK に合格させるために、ArC には _strict_ モードもあります。\n"
"このモードでは、追加の検証が有効になり、仕様と競合する特定の改善機能が無効になります。"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "To enable the strict mode, use the following configuration:"
msgstr "ストリクトモードを有効にするには、次のように設定します:"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "Some other features affect specification compatibility as well:"
msgstr "その他にも、仕様の互換性に影響を与える機能があります:"

#: _versions/main/guides/cdi-reference.adoc
msgid "<<unproxyable_classes_transformation,Transformation of unproxyable classes>>"
msgstr "<<unproxyable_classes_transformation,Transformation of unproxyable classes>>"

#: _versions/main/guides/cdi-reference.adoc
msgid "<<remove_unused_beans,Unused beans removal>>"
msgstr "<<remove_unused_beans,Unused beans removal>>"

#. type: Plain text
#: _versions/main/guides/cdi-reference.adoc
msgid "To get a behavior closer to the specification, these features should be disabled."
msgstr "仕様に近い動作を得るには、これらの機能を無効にする必要があります。"

#: _versions/main/guides/cdi-reference.adoc
msgid ""
"Applications are recommended to use the default, non-strict mode, which makes CDI more convenient to use.\n"
"The \"strictness\" of the strict mode (the set of additional validations and the set of disabled improvements on top of the CDI specification) may change over time."
msgstr "アプリケーションは、CDIをより便利に使えるように、デフォルトの非厳密モードを使用することが推奨されます。厳密モードの「厳密さ」（CDI仕様の上に追加される検証のセットと無効にされる改良のセット）は、将来変化する可能性があります。"

#. type: Title ==
#: _versions/main/guides/cdi-reference.adoc
#, no-wrap
msgid "ArC Configuration Reference"
msgstr "ArC Configuration Reference"

#: _versions/main/guides/cdi-reference.adoc
msgid "<span class=\"icon\"><i class=\"fa fa-lock\" title=\"Fixed at build time\"></i></span> Configuration property fixed at build time - All other configuration properties are overridable at runtime <input type=\"search\" id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
msgstr "<span class=\"icon\"><i class=\"fa fa-lock\" title=\"ビルド時に固定\"></i></span>ビルド時に固定される設定プロパティ - 他のすべての設定プロパティは実行時にオーバーライド可能 <input type=\"search\" id=\"config-search-0\" placeholder=\"FILTER CONFIGURATION\" disabled>"
