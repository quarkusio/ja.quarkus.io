<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.3.2" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: security
title: Security
permalink: /security/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: security
title: セキュリティー
permalink: /security/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのチームとコミュニティは、すべてのセキュリティーバグを非常に深刻に受け止めています。ポリシーとセキュリティー開示に関するQuarkusのガイドラインはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー問題の報告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリストには誰でも投稿できます。このリストの購読者は、Quarkusコミュニティの信頼できる個人のみで、報告されたセキュリティー問題の解決を秘密を守って処理します。報告においては、問題を発見したことについてどのようにクレジットされたいか、またエンバーゴ処理を適用したい場合はその詳細を記載してください。現在、以下のディストリビューションのセキュリティー対応チームがこのリストに登録されており、あなたのレポートに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エコシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、多くのエクステンションと多くのライブラリ(Eclipse Vert.x、Hibernate、Apache Camelなど)からなるエコシステムであり、そのほとんどはQuarkusチームの直接の責任下にはありません。これらのライブラリに根ざしている可能性のあるセキュリティーバグを見つけた場合は、それらのライブラリに直接開示するか、Quarkusチームに開示することが出来(このプロセスに従ってください)、その場合、責任を持ってそれぞれのエクステンションまたはライブラリのメンテナに開示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロセスに従う理由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーバグは機密性が高いため、通常のバグよりも開示プロセスに制約があります。我々は、適切な修正のための時間を与え、攻撃の時間枠を制限する、業界で認められたこれらのガイドラインに従っていただけることに感謝します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コミュニティは、https://quarkus.io/get-started/ で公開されている最新の major.minor バージョンのセキュリティーバグを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We may fix the vulnerability to older versions depending on the severity of the issue and the age of the release, but we are only committing to the latest version released.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題の深刻度やリリースの経過時間によっては、古いバージョンへの脆弱性を修正する場合がありますが、コミットしているのは、リリースされた最新バージョンのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー問題への対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you represent a Quarkus extension or a Quarkus platform, you are welcome to subscribe to the security at quarkus.io mailing list. Your subscription will only be approved if you can demonstrate that you will handle issues in confidence and properly credit reporters for discovering issues (e.g. experience with embargoe process).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのエクステンションやQuarkusのプラットフォームを代表している場合は、security at quarkus.ioのメーリングリストを購読することを歓迎します。あなたの購読は、あなたが問題を秘密を守って処理し、問題を発見した報告者を適切にクレジット出来ると証明できる場合にのみ承認されます(例:エンバーゴ処理の経験)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migration Guide</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>移行ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's new?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ADOPTERS.md</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ADOPTERS.md</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus and would like to be interviewed on our blog or simply added to this file, please contact us and we will be happy to oblige.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusをご利用の方で、ブログで取材を受けたい方や、このファイルに単純に追加したい方は、ご連絡いただければ、喜んでお受けいたします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Come Join Us</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>参加のお誘い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We value your feedback a lot so please report bugs, ask for improvements... Let's build something great together!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私達は皆様からのフィードバックに重きを置いています。バグ報告、改善要望を是非お願いします。一緒に素晴らしいものを作り上げていきましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Quarkus user or just curious, don't be shy and join our welcoming community:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusユーザーの場合でも、単に興味を持っているだけの場合でも、恥ずかしがらずにコミュニティに参加して下さい!:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>provide feedback on https://github.com/quarkusio/quarkus/issues[GitHub];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/issues[GitHub] でフィードバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>craft some code and https://github.com/quarkusio/quarkus/pulls[push a PR];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードを作成し、 https://github.com/quarkusio/quarkus/pulls[プルリクエスト] を送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>discuss with us on https://quarkusio.zulipchat.com/[Zulip] and on the https://groups.google.com/d/forum/quarkus-dev[mailing list];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://quarkusio.zulipchat.com/[Zulip] や https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] でディスカッションに参加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ask your questions on https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow] で質問</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.4.0 release of Quarkus Tools for IntelliJ.  This release enhances codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Tools for IntelliJの1.4.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードのcodestartsのサポートが強化されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Codestarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard now highlights codestarts enabled extension with a specific icon (right to the extension name), similar to code.quarkus.io, allowing users to better identify codestarts enabled extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトウィザードでは、code.quarkus.ioと同様に、codestartsを有効にしたエクステンションを特定のアイコン（エクステンション名の右側）で強調表示するようになり、ユーザーはcodestartsを有効にしたエクステンションをよりよく識別できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-tools1.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-tools1.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving Forward</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>将来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have any questions, suggestions or feedback, by all means please https://github.com/redhat-developer/intellij-quarkus/issues[open an issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご質問、ご意見、ご感想などがありましたら、ぜひ link:https://github.com/redhat-developer/intellij-quarkus/issues[Issueを開いて]ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thank you for reading and stay tuned for the next release!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お読みいただきありがとうございました。次のリリースをお待ちください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Links</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リンク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What’s nice about Extension codestarts is that it’s useful for fresh Quarkus developers as well as experienced ones. This is because of the wide range (and growing) of Quarkus extensions, you simply can’t know them all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Extension codestartsの良い点は、新しくQuarkusを開発したばかりの開発者だけでなく、経験豊富な開発者にも役立つ点です。これは、Quarkusのエクステンションの範囲が広い(そして増え続けている)ため、すべてを知っていることが単純に不可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When I am comparing frameworks, I think that Doc is a very important factor, but I am also often pretty lazy when it comes to reading it... don't you?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フレームワークの比較をしていると、ドキュメントはとても重要な要素だと思うのですが、私もいざ読むとなるとかなり怠けてしまうとが多いです...あなたはどうですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By the way you can see that Quarkus is pretty well https://quarkus.io/guides/[documented,role=external,window=_blank].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちなみにQuarkusはかなり https://quarkus.io/guides/[ガイド, role=external, window=_blank]が充実しているのがわかるかと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this feature, we tried to take it a step further and transform that boring learning part to the thing we love most *CODING*..</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能では、さらに一歩進んで、退屈な学習の部分を、私たちが最も好きな *コーディング* に変えようとしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting now, when you wish to try some new extensions, you directly have the code showing you their true power, ready to run in your favorite IDE in a matter of seconds!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今から、いくつかの新しいエクステンションを試してみたいときには、その真の力を示すコードが直接表示され、お気に入りのIDEであっという間に実行できるようになります!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this, using your chosen build tool (Maven, Gradle or also Gradle with Kotlin DSL) and your chosen language (Java, Kotlin or Scala).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらはすべて、選択したビルドツール(Maven、Gradle、またはKotlin DSLによるGradle)と選択した言語(Java、Kotlin、またはScala)を使用して行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Existing Extension codestarts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のエクステンションのコードスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already prepared examples for a dozen of extensions, you may spot them on https://code.quarkus.io[code.quarkus.io,role=external,window=_blank] (with the jet fighter icon).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちはすでに沢山のエクステンションの例を用意しており、 https://code.quarkus.io[code.quarkus.io, role=external, window=_blank](ジェット戦闘機のアイコンが付いている)で見ることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also find them on most of our Quarkus tooling:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkusのほとんどのツールでも見つけることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI, it is still experimental, and we don't provide an installer yet. Still, you can easily try it using the amazing https://jbang.dev/[JBang,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLIは、まだ実験的なもので、インストーラーはまだ提供されていません。それでも、素晴らしい https://jbang.dev/[JBang, role=external, window=_blank]を使って簡単に試すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://quarkus.io/blog/march-of-ides/[IDE plugins,role=external,window=_blank] which support "Wizards w/code.quarkus.io"</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Wizards w/code.quarkus.io" をサポートする https://quarkus.io/blog/march-of-ides/[IDEプラグイン, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit of fun in some of our examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの例の中で、ちょっとした楽しみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>My favorite one is the new Qute example with a subatomic-particles generator :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私のお気に入りは、素粒子ジェネレーターを備えた新しいQuteのサンプルです :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;a=subatomic-particles-generator&amp;v=1.0.0-SNAPSHOT&amp;b=MAVEN&amp;s=xTN&amp;cn=code.quarkus.io[Here on code.quarkus.io,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;amp;a=subatomic-particles-generator&amp;amp;v=1.0.0-SNAPSHOT&amp;amp;b=MAVEN&amp;amp;s=xTN&amp;amp;cn=code.quarkus.io[code.quarkus.ioでは、以下のようになっています。, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>With the CLI:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need more Extension codestarts!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もっとエクステンションのcodestartsが必要です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts are designed to make it easy and quick to provide new examples for extensions. So whether you are an extension owner, or you are keen to create an example for an extension you like, contributions are very welcome!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードスタートは、エクステンションのための新しいサンプルを簡単かつ迅速に提供できるように設計されています。ですから、あなたがエクステンションの所有者の場合でも、あなたが好きなエクステンションの例を作りたい場合でも、貢献は大歓迎です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We provide https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[doc and tooling,role=external,window=_blank] for it, you may also https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[come and ping me (@ia3andy) on Zulip,role=external,window=_blank] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちはそれのための https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[ドキュメントとツール, role=external, window=_blank]を提供しています。 https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[チャットに来て、私(@ia3andy)にpingを打って, role=external, window=_blank] 詳細について聞くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, we focus on the https://github.com/quarkusio/quarkus/blob/master/extensions[core extensions,role=external,window=_blank], but we will make it available to the broader ecosystem soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところは https://github.com/quarkusio/quarkus/blob/master/extensions[コアなエクステンション, role=external, window=_blank]に焦点を当てていますが、近いうちにより広いエコシステムで利用できるようにする予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few months back, I blogged about https://quarkus.io/blog/kafka-avro/[Quarkus, Kafka, and Avro] (using the Apicurio schema registry).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数ヶ月前に、 https://quarkus.io/blog/kafka-avro/[QuarkusとKafka、Avro] (Apicurio schema registryを使用)についてブログを書きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We developed a simple application, receives HTTP requests, writes Kafka records, and reads them from Kafka.  It uses Avro to serialize and deserialize the records.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTPリクエストを受信し、Kafkaのレコードを書き込み、Kafkaからレコードを読み出すというシンプルなアプリケーションを開発しました。  Avroを使ってレコードのシリアライズとデシリアライズを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that time, the https://github.com/cescoffier/quarkus-kafka-and-avro[application] was **NOT** working in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その時は、 https://github.com/cescoffier/quarkus-kafka-and-avro[アプリケーション] はネイティブモードで動作して **いません** でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why didn't it work?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜうまくいかなかったのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native compiler does not support everything that is possible to do in Java.  There are cases not yet supported, and Avro is using some of these unsupported constructs.  Fortunately, we can implement _substitutions_ (to replace unsupported constructs in the code directly) and use Quarkus extensions to configure the compiler correctly.  As a result, your application does not have to configure anything, "it just works™️".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブコンパイラは、Javaでできることをすべてサポートしているわけではありません。  まだサポートされていないケースがあり、Avroではこれらのサポートされていない構文のいくつかを使用しています。幸いなことに、_substitutions_(コード内のサポートされていない構文を直接置き換える)を実装し、Quarkusのエクステンションを使用してコンパイラを正しく設定することができます。その結果、アプリケーションは何も設定する必要がなく、「it just works™️」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's come back to Avro.  Avro uses https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[method handles] that are not supported by the GraalVM native compiler.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Avro の話に戻りましょう。  Avro は GraalVM ネイティブコンパイラがサポートしていない https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[メソッドハンドル] を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To workaround the unsupported constructs used by Avro, we implemented a set of https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions].  We replaced method handles with reflection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Avro が使用するサポートされていない構文を回避するために、 https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions] のセットを実装しました。 メソッドハンドルをリフレクションに置き換えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GenericDatumReader` also needs a bit of work as it touches threads at build time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `GenericDatumReader` は、ビルド時にスレッドに触れるため、少し作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, in the Quarkus Avro Processor (part of the Quarkus extension), we register for reflection all the classes annotated with `@AvroGenerated`, as we are using reflection to create new instances of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Quarkus Avro Processor(Quarkusエクステンションの一部)で、 `@AvroGenerated` でアノテーションされたすべてのクラスをリフレクションの為に登録します。新しいインスタンスの生成にリフレクションを使用している為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>見せて!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the https://github.com/cescoffier/quarkus-kafka-and-avro[code] of the application, and make sure you have GraalVM installed.  Then, build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの https://github.com/cescoffier/quarkus-kafka-and-avro[コード] を取得し、GraalVMがインストールされていることを確認してください。そして、ネイティブ実行ファイルを次のようにビルドします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grab a coffee or tea, as it may take a few minutes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数分かかる場合がありますので、コーヒーや紅茶を淹れましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, run the application with `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner` でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send some movies to the application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの映画をアプリに送信します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check they are processed successfully in the application log output:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>正常に処理されていることをアプリケーションログ出力で確認してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Avro support in native is still experimental.  In the last Quarkus version, we made significant progress, but there may be some uncovered areas.  Let us know if you find anything https://github.com/quarkusio/quarkus/issues/new/choose[odd]!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブでのAvroサポートはまだ実験的なものです。前回のQuarkusバージョンでは、かなりの進歩を遂げましたが、いくつかの未発見の部分があるかもしれません。 https://github.com/quarkusio/quarkus/issues/new/choose[何かおかしな点を見つけましたら教えてください] !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org/[Apache] Kafka is a prevalent distributed streaming platform offering a unique set of characteristics such as message retention, replay capabilities, consumer groups, and so on.  Kafka is highly scalable, fault-tolerant, and is becoming the spine of many modern systems.  That being said, Kafka is not the only one out there, and choosing the right messaging technology for your application can be challenging.  There are many articles to help you drive your decision, such as https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[this one].  This post is about Kafka, and an equivalent post about AMQP will be published later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://kafka.apache.org/[Apache Kafka] は、メッセージの保持、再生機能、コンシューマーグループなどのユニークな特性を提供する分散型ストリーミングプラットフォームとして広く普及しています。Kafka は非常に拡張性が高く、耐障害性に優れており、多くの近代的なシステムの要になりつつあります。とはいえ、Kafka単体で存在するものではなく、アプリケーションに適したメッセージング技術を選択するのは難しいことです。 link:https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[このリンク先] のように、あなたの決定を後押しするために役立つ記事がたくさんあります。この記事は Kafka についてのもので、AMQP についての同等の記事は後日公開される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, you will learn how to get started with Apache Kafka in your Quarkus application in less than 10 steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] - a declarative approach to build event-driven microservices, but you can also use _bare_ Kafka APIs or Kafka Streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この投稿では、QuarkusアプリケーションでApache Kafkaを10ステップ未満で使い始める方法を学びます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] を使用しますが、 _ベア_ Kafka APIやKafka Streamsを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub]から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Generate your project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ 1 - プロジェクトの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the very beginning, getting a new project structure with the right dependencies.  Go to https://code.quarkus.io, enter your group id and artifact id.  Then in the extension list, select:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の一歩として、正しい依存関係を持つ新しいプロジェクト構造を取得してみましょう。 https://code.quarkus.io  にアクセスして、グループIDとアーティファクトIDを入力します。そして、エクステンションのリストで以下を選択します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project to contain examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Example Code"を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, click on __Generate your application__, download the project as a zip file, unzip it, and load it in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 _Generate your application_ をクリックして、プロジェクトをzipファイルとしてダウンロードし、解凍して、お気に入りのIDEにロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-kafka` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-kafka` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 2 - What are we going to exchange?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ2 - 何を交換するか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need something to exchange.  Without much originality, let's say we will send and receive `Movie` objects.  In your project, create the `org.acme.Movie` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>交換するものが必要です。あまりオリジナリティを持たずに、 `Movie` オブジェクトを送受信するとしましょう。プロジェクトの中で、以下の内容の `org.acme.Movie` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, we produce and consume records.  A record contains a key and a value.  Let's say we will use the movie's publication year as key and the title as value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka では、レコードを生成、消費します。レコードにはキーと値が含まれています。例えば、映画の公開年をキーにして、タイトルを値にするとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to decide on which topic we are going to send these records.  Let's keep things simple and name our topic __movies__.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、これらのレコードを送信するトピックを決める必要があります。単純化して、トピックを _movies_ としましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 3 - Configure the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ3 - アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  In our application, we must indicate that our reception and publication channels will use the __movies__ Kafka channel.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の通り、Reactive Messagingを使用します。Reactive Messagingを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、基礎となるメッセージング技術に設定によってマッピングされます。このアプリケーションでは、受信および配信チャンネルが _movies_ Kafkaチャンネルを使用することを指定する必要があります。 `src/main/resources/application.properties` で、以下の内容を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location with `kafka.bootstrap.servers`, we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーの場所を `kafka.bootstrap.servers` で設定した後、 `movies-in` (レコードを受信)と `movies-out` (レコードを配信)の 2 つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the Kafka connector.  We also need to configure the key and value deserializers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mp.messaging.incoming.movies-in` というプレフィックスを使ってチャネルを設定します。 `connector` 属性は、このチャネルを担当するコネクタ (ここでは Kafka コネクタ) を示しています。また、キーと値のデシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicate who's responsible for that channel, we also need to configure the key and value serializers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` のプレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、キーと値のシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ 4 - Kafkaにムービーを公開する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send a record to Kafka.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、いよいよKafkaにレコードを送信します。以下の内容で `org.acme.MovieProducer` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter`, i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and so will send messages to Kafka).  We are sending `Record` objects containing the movie's publication year as key and its title as value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスでは、 `Emitter` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (つまり、Kafka にメッセージを送信します)。映画の公開年をキーに、タイトルを値にして `Record` オブジェクトを送信しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can simply use the `sendMovieToKafka` method to send a movie to our Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、残りのアプリケーションは `sendMovieToKafka` メソッドを使って、Kafka トピックにムービーを送信するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 5 - Consuming movies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ5 - 映画を消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今度は反対側に目を向けて、Kafkaからムービーを取り出してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.enterprise.context.ApplicationScoped;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.enterprise.context.ApplicationScoped;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here, we use the `@Incoming` annotation to indicate to Quarkus to call the `receive` method for every received record.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、 `@Incoming` アノテーションを使用して、受信したレコードごとに `receive` メソッドを呼び出すようにQuarkusに指示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 6 - Sending movies from a REST endpoint</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ6 - RESTエンドポイントからのムービーの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to Kafka from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントから Kafka にメッセージを送信することはよくあることです。そのためには、以下のような内容の `org.acme.MovieResource` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 7 - Let's get this running!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ7 - これを実行してみましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need a Kafka broker.  You can follow the https://kafka.apache.org/quickstart[Apache Kafka quickstart], or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、まずはKafkaブローカーが必要です。 link:https://kafka.apache.org/quickstart[Apache Kafka のクイックスタート] に従うか、以下の `docker-compose.yaml` ファイルを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>version: '2'
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>version: '2'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>services:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>services:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します: `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、アプリケーションを次のように実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application runs in dev mode, meaning that you can still update the code.  It will reload it automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションはdevモードで動作します。つまり、コードをまだ変更することが出来、変更した場合、自動的にリロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, emit a few HTTP POST request such as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の端末で、次のようなHTTP POSTリクエストをいくつか送信します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the terminal running the application, you will see:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行しているターミナルでは、以下のように表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It works!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動いています!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 8 - Native packaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ8 - ネイティブパッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://quarkus.io/guides/building-native-image[GraalVM installed and configured correctly], you can package this application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/guides/building-native-image[GraalVMが正しくインストールされ、設定されている場合] 、このアプリケーションをネイティブの実行ファイルとしてパッケージ化することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw package -Pnative
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw package -Pnative
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using Kafka starting in a few milliseconds and consuming a ridiculous amount of memory: less than 30Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、Kafkaを使用したQuarkusアプリケーションが数ミリ秒で起動し、消費するメモリー量はとんでもない量:100レコードを取り込んでも30MB未満!になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using Apache Kafka.  If you want to go further, check the https://quarkus.io/guides/kafka[Kafka guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>10分もしないうちに、Apache Kafkaを使った新しいQuarkusアプリケーションができました。さらに進みたい場合は、 link:https://quarkus.io/guides/kafka[Kafkaガイド]をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It gives the Quarkus and RESTEasy teams great pleasure to announce that RESTEasy Reactive integration in Quarkus has landed in the main Quarkus repo footnote:disclaimer[Currently the main RESTEasy Reactive component resides at https://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactive in the main Quarkus repository; the plan is however that once things settle, this code will move to https://github.com/resteasy/resteasy-reactive. This move should not affect users of the quarkus-resteasy-reactive extensions in any way, just a heads up if anyone reads this blog post in the future and can’t find it.] and will be part of the next Quarkus release 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusとRESTEasyチームは、QuarkusにおけるRESTEasy Reactiveの統合がメインのQuarkusレポジトリに到着したことを発表することに大きな喜びを感じています。 footnote:disclaimer[現在、メインのRESTEasy Reactiveコンポーネントは、メインのQuarkusリポジトリのhttps://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactiveにあります。この移動は、quarkus-resteasy-reactive エクステンションのユーザーには何ら影響を与えないはずです。このブログポストを将来読んだ人が見つけられなかった場合に備えての追記。] 次のQuarkusリリース 1.11 に含まれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are looking forward to everyone testing it and providing us as much feedback as possible.  In typical Quarkus fashion, the project is consumable as a new set of extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>皆さまにテストしていただき、できるだけ多くのフィードバックを提供していただけると幸いです。 典型的なQuarkusのやり方で、このプロジェクトは新しいエクステンションのセットとして利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you probably guessed from the name, this work is a *new JAX-RS implementation* written from the ground up to work on our common *Vert.x* layer and is thus fully *reactive*, while also being very *tightly integrated with Quarkus* and consequently moving a lot of framework specific work (like annotation scanning and metamodel generation) to *build time*.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前からお察しの通り、この作品は共通の *Vert.x* レイヤー上で動作するように一から書かれた *新しいJAX-RSの実装* であり、完全に *リアクティブ* であると同時に、 *Quarkusと緊密に統合されて* いるため、フレームワーク固有の作業(アノテーションスキャンやメタモデル生成など)の多くを *ビルド時に* 移行させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why should I care?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ重要なのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest answer is that you can continue to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最も単純な答えは、アプリケーションの REST レイヤを公開する為に広く使われている非常に強力な JAX-RS API を活用し続けながら、アプリケーションが達成できる最大スループットを大幅に向上できるということです。また、アプリケーションは起動が少し速くなり、メモリーの消費量が少し減るはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our benchmarks reveal that the measurable performance with this new extension is almost identical to what we would achieve using Quarkus' Reactive Routes API (which is a very interesting API in its own right, but is generally more low level - not to mention the fact that it's a new API developers would need to learn).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベンチマークでは、この新しいエクステンションを使った測定可能なパフォーマンスは、QuarkusのReactive Routes API(それ自体は非常に興味深いAPIですが、一般的には低レベルなものです)とほぼ同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when comparing our results to other competing enterprise Java frameworks that provide annotation based REST layers, Quarkus provided as much as double the throughput depending on the benchmark.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、アノテーションベースのRESTレイヤーを提供する他の競合するエンタープライズJavaフレームワークと結果を比較すると、ベンチマークによっては、Quarkusは2倍ものスループットを提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What other benefits are there?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にはどんなメリットがあるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As if the familiar API and the much improved runtime characteristics of the new extension weren't enough, we have added some really exciting and convenient new features (which are not part of the JAX-RS spec) that have either been requested by the community, or are things we feel improve the developer experience and soften some of the spec’s rough edge.  These new features are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おなじみのAPIと、新しいエクステンションの大幅に改善されたランタイム特性だけでは十分ではないかのように、コミュニティからの要望に基づき、あるいは開発者の経験を向上させ、仕様の粗いエッジを和らげてくれると我々が考える、本当にエキサイティングで便利な新機能(JAX-RS仕様の一部ではありません)をいくつか追加しました。これらの新機能は以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-blocking by default</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでノンブロッキング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All endpoints are now running on the IO thread by default. You can use `@Blocking` to change that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトではすべてのエンドポイントが IO スレッド上で実行されます。 `@Blocking` を使えばこれを変更出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scoring system</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スコアリングシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On dev-mode startup, the application will show you a list of your endpoints, along with a performance score telling you why your endpoint is slower than an optimal version. This helps a lot in figuring out how to improve REST performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>devモードで起動すると、アプリケーションはエンドポイントのリストを表示し、エンドポイントが最適なバージョンよりも遅い理由を示すパフォーマンススコアを表示します。これは、REST のパフォーマンスを向上させる方法を見つけるのに非常に役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New request/response filter design</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエスト/レスポンスフィルターの新しい設計</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JAX-RS filters require implementing an interface and injecting context objects as fields, which is costly and inflexible. Based on our success in the Quarkus build system, filters are now simply annotated methods and any parameter is automatically injected:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSのフィルターは、インターフェースを実装し、コンテキストオブジェクトをフィールドとして注入する必要がありますが、これはコストがかかり、柔軟性に欠けます。Quarkus ビルドシステムでの成功に基づき、フィルタは単にアノテーション付きのメソッドになり、全てのパラメーターは自動的に注入されるようになりました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, if filters need to perform blocking operations, then they can return `Uni&lt;Void&gt;` and RESTEasy Reactive will not block the event-loop thread while executing the filter.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、フィルタがブロッキング操作を行う必要がある場合は `Uni&lt;Void&gt;` を返すことができ、RESTEasy Reactive はフィルタを実行している間はイベントループスレッドをブロックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, although we haven’t done it yet, this approach could easily be extended to other types of JAX-RS Providers thus completely forgoing the need to use `@Context` in their code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、まだ実施していませんが、このアプローチは他のタイプのJAX-RSプロバイダにも簡単に拡張でき、コード中で `@Context` を使用する必要が完全になくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New `*Param` annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい `*Param` アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These annotations are meant to be used instead of the JAX-RS `@PathParam`, `@QueryParam` etc. annotations, without having the need to specify a name.  The reason we chose not to reuse the same annotation names is to avoid conflicting with either JAX-RS or other EE specs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのアノテーションは、JAX-RSの `@PathParam`, `@QueryParam` などのアノテーションの代わりに、名前を指定することなく使用することを意図しています。  同じアノテーション名を再利用しないことにしたのは、JAX-RSや他のEE仕様との衝突を避けるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simpler parameter and context injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>よりシンプルなパラメーターとコンテキストインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With RESTEasy Reactive you don’t even need to use `@PathParam` or `@RestPath` if your parameter has the same name as a path parameter, and similarly you can skip `@Context` for all the known context types, which makes it even simpler:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive では、パラメーターがパスパラメーターと同じ名前であれば `@PathParam` や `@RestPath` を使用する必要はありませんし、同様に、既知のすべてのコンテキストタイプに対して `@Context` を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New optimal message body reader / writer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい最適なメッセージボディのリーダー/ライター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no filters and interceptors are invoked when an endpoint is serviced, you can use more efficient message body writers that directly write to vert.x and don’t require reflection and annotations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントがサービスされるときにフィルタやインターセプタが呼び出されない場合、 リフレクションやアノテーションを必要としない、vert.x に直接書き込む、更に効率的なメッセージボディライターを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default content types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのコンテンツタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Endpoints that return a String default to producing text/plain. We plan to do the same for JSON and other types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>String を返すエンドポイントは、デフォルトで text/plain を生成します。JSON やその他の型についても同様のことを行う予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All injections via JAX-RS’s @Context are delegated to Arc. This provides users with the benefits of build time injection that Arc brings to all other parts of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSの@Contextを介したインジェクションはすべてArcに委譲されます。これにより、ユーザーは、ArcがQuarkusの他のすべての部分にもたらすビルドタイムインジェクションのメリットを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Per-class Exception Mapper</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスごとの例外マッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JAX-RS specification there’s no way to handle exceptions differently for a specific JAX-RS Resource Class - all exception mapping is done in a global manner.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS仕様では、特定のJAX-RSリソースクラスに対して異なる例外を処理する方法はありません - すべての例外のマッピングはグローバルな方法で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In RESTEasy Reactive however you can simply do something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、RESTEasy Reactive では、次のようなことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to customize the exception handling of certain Resource Classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のリソースクラスの例外処理をカスタマイズする為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that `@ServerExceptionMapper` can be used to handle exceptions in a global manner, just as JAX-RS does with `ExceptionMapper`.  To do that, simply annotate a method that does not belong to a Resource class with `@ServerExceptionMapper`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、`@ServerExceptionMapper`は、JAX-RSが`ExceptionMapper`を使うのと同じように、グローバルな方法で例外を扱うことができることにも注意する必要があります。  そのためには、Resourceクラスに属さないメソッドに `@ServerExceptionMapper` をアノテーションするだけで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do other extensions work with it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のエクステンションでも動作しますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extensions that integrate with the existing quarkus-resteasy extension also integrate with quarkus-resteasy-reactive extensions. So you can continue to use _CDI_, _Security_, _Metrics_, _JSON_, _Qute_, _Bean Validation_, _OpenAPI_ and enjoy a great out of the box and complete development experience.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のquarkus-resteasyエクステンションと統合するエクステンションは、quarkus-resteasy-reactiveエクステンションとも統合されます。そのため、_CDI_、_Security_、_Metrics_、_JSON_、_Qute_、_Bean Validation_、_OpenAPI_を使い続けることができ、素晴らしいアウトオブボックスと完全な開発体験を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I try it out?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どうやって試してみたらいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project has landed in the Quarkus master branch, so if you’re eager to try it out, you'll have to build Quarkus from source by following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this] and use the proper BOM and version following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロジェクトはQuarkus masterブランチにありますので、試してみたい方は、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this]のようにソースからQuarkusをビルドし、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this]のように適切なBOMとバージョンを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, you can also use Maven Snapshots (as Quarkus snapshot builds are uploaded to Sonatype once a day), by specifying version `999-SNAPSHOT` as the Quarkus version and using `quarkus-bom` instead of `quarkus-universe-bom` as the BOM.  There are various ways to enable snapshot versions in Maven. https://stackoverflow.com/a/7717234/2504224[This] StackOverflow answer shows configuration that can be used either on a per project basis or globally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、バージョン `999-SNAPSHOT` をQuarkusのバージョンとして指定し、BOMとして `quarkus-universe-bom` の代わりに `quarkus-bom` を使用することで、Mavenのスナップショットを使用することもできます(Quarkusのスナップショットビルドは1日1回Sonatypeにアップロードされるため)。  Mavenでスナップショットバージョンを有効にするには、さまざまな方法があります。 https://stackoverflow.com/a/7717234/2504224[This] StackOverflowの回答では、プロジェクト単位でもグローバルでも使える設定が示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The available RESTEasy Reactive extensions are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能な RESTEasy Reactive エクステンションは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These extensions are the equivalent to the existing _quarkus-resteasy_* extensions, so simply switching from _quarkus-resteasy-jackson_ to _quarkus-resteasy-reactive-jackson_ in your application should allow you to try RESTEasy Reactive with Jackson integration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエクステンションは、既存の _quarkus-resteasy_* エクステンションと同等ですので、アプリケーション内で _quarkus-resteasy-jackson_ から _quarkus-resteasy-reactive-jackson_ に切り替えるだけで、Jackson 統合による RESTEasy Reactive を試すことができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the _quarkus-jaxrs-client_ extension can be used if you need to use the JAX-RS client (this is not the declarative MicroProfile REST Client, but the programmatic client specified by the JAX-RS spec).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、JAX-RSクライアントを使用する必要がある場合は、_quarkus-jaxrs-client_ エクステンションを使用することができます (これは宣言型MicroProfile RESTクライアントではなく、JAX-RS仕様で定義されたプログラマティッククライアントです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What should I be careful of?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どんなことに気をつければいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for the time being this set of extensions is currently considered experimental. Although the project passes almost the entirety of the JAX-RS TCK, it’s just the first release, so keep in mind that it might have more bugs than a typical battle hardened library, while some of the new APIs and SPIs might break.  Despite this being a first release, we do envision this work becoming the default REST layer for Quarkus in the near future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初に注意しなければならないのは、当面の間、この一連のエクステンションは実験的なものと考えられているということです。このプロジェクトはJAX-RS TCKのほぼ全体を通過していますが、まだ最初のリリースに過ぎませんので、典型的な実績のあるライブラリよりも多くのバグがあるかもしれないことを覚えておいてください。 これは最初のリリースですが、近い将来、このライブラリがQuarkusのデフォルトのRESTレイヤーになることを見通しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the new features section, requests are served on the event-loop threads by default. This ensures maximum throughput, but also means that no blocking work should be performed on these threads. If you use Blocking IO (for example by accessing a database with Hibernate Panache), be sure to use the `@Blocking` annotation on either the method or the class.  This will ensure that the request will be served on a worker thread. It goes without saying that we are also very interested in hearing your feedback about this default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新機能のセクションで述べたように、デフォルトではリクエストはイベントループスレッド上で処理されます。これは最大のスループットを保証しますが、これらのスレッドでブロッキング作業を行うべきではないことも意味します。ブロッキング IO を使用する場合 (例えば、Hibernate Panache でデータベースにアクセスするなど)、メソッドまたはクラスのいずれかで `@Blocking` アノテーションを必ず使用してください。  これにより、リクエストがワーカースレッドで処理されるようになります。言うまでもなく、このデフォルトについてのフィードバックも非常に興味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no docs yet. Docs will be added before the formal 1.11 release and will be progressively enhanced.  This email should contain all the information you need to get started, but should you run into any trouble, we are available to help on any of the usual channels (Zulip chat, mailing list, GitHub Issues, StackOverflow).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントはまだありません。ドキュメントは正式な1.11リリースの前に追加され、徐々に強化されていく予定です。  このメールには開始に必要な情報がすべて含まれているはずですが、何か問題が発生した場合は、通常のチャネル(Zulip チャット、メーリングリスト、GitHub Issues、StackOverflow)のいずれかで支援を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What JAX-RS features are missing?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どのJAX-RSの機能が欠けていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We decided to focus on what most users need from a modern REST layer instead of implementing every single feature required by the JAX-RS TCK.  So in that vein, there is no XML support in RESTEasy Reactive, while various arcane features of the spec are also not supported (like _javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、JAX-RS TCK が必要とする機能をすべて実装するのではなく、ほとんどのユーザーが最新の REST レイヤから必要とするものに焦点を当てることにしました。  そのため、RESTEasy Reactive には XML サポートがなく、仕様の様々な難解な機能もサポートされていません(_javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_ のようなもの)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, worth noting is that the first release will not contain an implementation of the MicroProfile REST Client based on the new JAX-RS Client (for which there is a dedicated extension). This will most likely change in the near future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、最初のリリースには、 (専用のエクステンションが存在する) 新しい JAX-RS Clientをベースにした MicroProfile REST Client の実装が含まれていないことも注目に値する。これは近い将来に変更される可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new extensions will be available with the regular _1.11_ release, we are considering doing a `1.11.0.Alpha1` release to make it as easy as possible for you to try out the new extensions and provide early feedback.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいエクステンションは通常の _1.11_ リリースで利用可能になりますが、新しいエクステンションを出来る限り簡単に試せるように、そしてフィードバックを簡単に出来るように、私たちは `1.11.0.Alpha1` リリースを行うことを検討しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very much looking forward to hearing your thoughts about and experience using RESTEasy Reactive in Quarkus and plan to put it to good use to further improve the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのさらなる改善の為に、RESTEasy ReactiveをQuarkusで使用した感想や経験を是非お聞かせ下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.9.2.Final released - Bugfixes'
date: 2020-11-05
tags: release
synopsis: 1.9.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.9.2.Finalリリース - バグフィックス
date: 2020-11-05
tags: release
synopsis: 1.9.2.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just a week after 1.9.1.Final, here comes 1.9.2.Final with some bugfixes and documentation improvements.  Thanks a lot to everyone providing feedback and pull requests!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.9.1.Finalからちょうど一週間後、バグフィックスとドキュメントの改善を加えた1.9.2.Finalがやってきました。フィードバックとプルリクエストを提供してくださった皆様、ありがとうございました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.9.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.9を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.9 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.9を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリリースはメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[the full changelog of 1.9.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[1.9.2.Finalの完全な変更履歴はGitHub]で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.3.Final mainly fixes a regression introduced in 1.11.2.Final that makes it impossible to build native executables while using both the RESTEasy and OpenTracing extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.3.Finalは主に1.11.2.Finalで導入された、RESTEasy と OpenTracing の両方のエクステンションを使用している場合にネイティブの実行ファイルをビルドできないようにするリグレッションを修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.11 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.11を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11移行ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[the full changelog of 1.11.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[GitHubで1.11.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Stylish API'
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: Swagger UI configuration and custom styling
author: phillipkruger
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: スタイリッシュAPI
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: SwaggerのUI設定とカスタムスタイリング
author: phillipkruger
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stylish API</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイリッシュAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this blog post we are going to look at the new styling and other new options available in OpenAPI and Swagger UI Quarkus extensions (version 1.10+).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のブログ記事では、OpenAPIとSwagger UIのQuarkusエクステンション(バージョン1.10+)で利用できる新しいスタイリングやその他の新しいオプションについて見ていきたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the source code for the examples below is https://github.com/phillip-kruger/openapi-example[available here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例のすべてのソースコードは、 https://github.com/phillip-kruger/openapi-example[ここ]にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Styling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default style</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトスタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default style for Swagger UI has changed from the vanilla Swagger UI to a Quarkus branded page:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger UIのデフォルトスタイルがバニラのSwagger UIからQuarkusブランドのページに変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post we mostly focus on Swagger UI, but the styling options also apply to the https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI] and the https://quarkus.io/guides/microprofile-health#health-ui[Health UI].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この記事では主に Swagger UI に焦点を当てていますが、スタイリングオプションは https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI]と https://quarkus.io/guides/microprofile-health#health-ui[Health UI] にも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーマ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://ostranme.github.io/swagger-ui-themes/[Swagger UI Themes] are now available in configuration, with the default theme being 'feeling blue'.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://ostranme.github.io/swagger-ui-themes/[SwaggerのUIテーマ]が設定で利用できるようになり、デフォルトのテーマは「フィーリングブルー」になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the theme by setting the `quarkus.swagger-ui.theme` property, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `quarkus.swagger-ui.theme` プロパティーを設定することでテーマを変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also go back to the original (vanilla) Swagger UI theme:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、元の(バニラの)Swagger UIテーマに戻すこともできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme options available:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーマのオプションが用意されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>feeling-blue (default)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>feeling-blue (default)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>flattop</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>flattop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>material</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>material</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>monokai</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>monokai</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>muted</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>muted</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>newspaper</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>newspaper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>outline</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>outline</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロゴマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As part of the custom branding, you can supply your own logo to replace the Quarkus logo. For example, let's say you own a company that makes everything, ACME, and you are using REST Services for your online store, and wants to brand the Swagger UI Page:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムブランディングの一環として、Quarkusのロゴの代わりに独自のロゴを付与することができます。例えば、なんでも屋のACMEという会社を経営していて、オンラインストアにRESTサービスを利用していて、Swagger UIページをブランディングしたいとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme logo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme logo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot reload is not working for logo changes, and remember browser cache, you might need to https://refreshyourcache.com/en/cache/[force refresh] your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロードは、ロゴ変更には動作しません。とブラウザのキャッシュを覚えておいてください。ブラウザを https://refreshyourcache.com/en/cache/[強制的にリフレッシュする]必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To supply your own logo, you need to place a file called `logo.png` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自のロゴを提供するには、 `logo.png`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Style</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go further, and supply your own `style.css`, to fine-tune the branding. As an example, to change the `topbar` of the Swagger UI screen to fit the corporate colors of ACME:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、独自の `style.css`  を提供して、ブランディングを微調整することもできます。例として、Swagger UI画面の `topbar`  を ACME のコーポレートカラーに合わせて変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>here set the `topbar` background color.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは `topbar`  の背景色を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme css</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme css</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change any styling element in this css file, you need to place this file called `style.css` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このCSSファイルの中で、任意のスタイル要素を変更することができます。 `style.css`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other styling options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のスタイリングオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Along with other OpenAPI Header fields that can be set via configuration properties (as discussed in link:/blog/openapi-for-everyone/[this post]):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーを介して設定できる他の OpenAPI Header フィールドと一緒に( /blog/openapi-for-everyone/[この記事]で説明しています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme footer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme footer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Swagger UI Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のスワガーUIオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another new feature available in Quarkus (version 1.10+) is the ability to set any of the https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[configuration options] available in Swagger UI. As an example, we can set the `urls` and add the petstore (as the default selected option) to Swagger UI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus(バージョン1.10+)で利用できるもう一つの新機能は、Swagger UIで利用できる https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[設定オプション]を任意に設定できることです。例えば、 `urls`  を設定して、Swagger UI にペットストア(デフォルトで選択されているオプションとして)を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will change the `topbar` to have a dropdown box with the urls provided:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `topbar`  は、提供されたURLのドロップダウンボックスを持つように変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>petstore</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>petstore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example, `supportedSubmitMethods` can hide the `Try it out` button for certain HTTP Method Types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の例として、 `supportedSubmitMethods`  は特定の HTTP メソッドタイプに対して `Try it out`  ボタンを非表示にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note below the missing `Try it out` button on the `POST`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`POST` の `Try it out`  ボタンがなくなっていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try it out</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>try it out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the other Swagger UI options are now available to configure the UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のSwagger UIオプションはすべてUIの設定が可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other small new features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の小さな新機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let me present you two small new features in OpenAPI and Swagger UI: the ability to add the Health Endpoints and the ability to disable the UI and/or Schema at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenAPIとSwagger UIの2つの小さな新機能を紹介します。Health Endpointsを追加する機能と、実行時にUIやSchemaを無効にする機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `smallrye-health` extension, you can add the Health Endpoints to OpenAPI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`smallrye-health`  エクステンションを使用している場合は、OpenAPI にヘルスエンドポイントを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable at Runtime</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時に無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you included the UI in your app (`quarkus.swagger-ui.always-include=true`), you can now disable it when starting the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリにUIが含まれている場合( `quarkus.swagger-ui.always-include=true` )、アプリ起動時にUIを無効にできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will return a *HTTP 404 (Not Found)* on the Swagger UI page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは Swagger UI ページで *HTTP 404 (Not Found) を* 返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly you can disable the schema (usually under `/openapi`) by doing:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同様に、以下のようにしてスキーマを無効にすることができます (通常は `/openapi`  の下にあります):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.amqp.org/[AMQP 1.0] is a standard for passing messages between applications or organizations.  It connects systems, feeds business processes with the information they need, and reliably handles communication between systems.  AMQP is a robust and mature protocol widely used in event-driven applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://www.amqp.org/[AMQP 1.0] は、アプリケーションや組織間でメッセージを渡すための標準規格です。AMQP はシステムを接続し、ビジネスプロセスに必要な情報を供給し、システム間の通信を確実に処理します。AMQP は、イベント駆動型のアプリケーションで広く使用されている堅牢で成熟したプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post is the equivalent of the https://quarkus.io/blog/getting-started-kafka/[Kafka getting started post], but focuses on the usage of AMQP.  You will learn how to get started with AMQP in your Quarkus application in less than ten steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] - a declarative approach to building event-driven microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この投稿は、 link:https://quarkus.io/blog/getting-started-kafka/[Kafkaの入門記事] と同等の内容を説明しますが、AMQPの使用方法に焦点を当てています。QuarkusアプリケーションでAMQPを使い始める方法を10ステップ以内で学ぶことができます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub] から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project containing examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Example Code" を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-amqp` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-amqp` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。なのでコードを書く準備が出来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With AMQP, we exchange http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[messages], which can have multiple _data_ sections (or multiple AMQP sequences, or a single AMQP value section).  In our application, as we are exchanging `Movie` object, it encodes the instances as JSON and transfers it in a single _data_ section.  The `content-type` header is set to `application/json`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AMQPでは、複数の _データ_ セクション(または複数のAMQPシーケンス、または単一のAMQP値セクション)を持つことができる link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[メッセージ] を交換します。私たちのアプリケーションでは、 `Movie` オブジェクトを交換しているので、インスタンスを JSON としてエンコードし、単一の _データ_ セクションで転送しています。 `content-type` ヘッダは `application/json` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP messages are sent to a destination.  To keep things simple, let's name it __movies__.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AMQPメッセージを送信先に送信します。簡単にするために、 __movies__ という名前にしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  We must indicate that our reception and publication channels will use the __movies__ address in our application.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の通り、Reactive Messagingを使用します。リアクティブメッセージングを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、設定によって基礎となるメッセージング技術にマッピングされます。受信および公開チャンネルがアプリケーションで __movies__ アドレスを使用することを示す必要があります。 `src/main/resources/application.properties` で、次の内容を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location and credentials (`amqp-` properties), we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーの場所と資格情報( `amqp-` プロパティー)を設定した後、 `movies-in` (レコードを受信)と `movies-out` (レコードを公開)の2つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the AMQP connector.  We also need to specify the consumed destination using the `address` attribute.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>チャンネルの設定には、 `mp.messaging.incoming.movies-in` というプレフィックスを使用します。 `connector` 属性は、このチャネルの責任者(ここでは AMQP コネクタ)を示します。また、 `address` 属性を使用して、消費先を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicating who's responsible for that channel, we also need to configure the address.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` プレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、アドレスも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to AMQP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ4 - AMQPへのムービーの公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send messages.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、いよいよメッセージを送信する時が来ました。以下の内容で `org.acme.MovieProducer` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter,` i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and will send messages to AMQP).  The connector automatically encoded the content as JSON and set the `content-type` header.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスでは、 `Emitter,` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (AMQP にメッセージを送信します)。コネクタは自動的にコンテンツを JSON としてエンコードし、 `content-type` ヘッダを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to make sure your payload can be encoded to JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ペイロードが JSON にエンコードできることを確認する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can use the `send` method to send a movie to our AMQP destination.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、私たちのアプリケーションの残りの部分は、 `send` メソッドを使用して、AMQP の宛先にムービーを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今度は反対側に目を向けて、AMQPからムービーを取得してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, the movie is encoded into JSON, so we need to help the connector produce a `Movie` from the received JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ムービーは JSON にエンコードされていることを思い出してください。コネクタが受信した JSON から `Movie` を生成するのを支援する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `org.acme.JsonToObjectConverter` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `org.acme.JsonToObjectConverter` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class is a _converter_.  It maps the content of a `Message` to another type.  In the `canConvert` method, we verify that the incoming message is coming from AMQP (so contain the `IncomingAmqpMetadata` metadata) and that the content-type is set to `application/json`.  The `convert` method maps the received `JsonObject` into the target type (`Movie` in our case).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは _converter_ です。 `Message` の内容を別の型にマッピングします。 `canConvert` メソッドでは、受信メッセージが AMQP からのものであること (つまり `IncomingAmqpMetadata` メタデータを含むこと) と、content-type が `application/json` に設定されていることを確認します。 `convert` メソッドは、受信した `JsonObject` をターゲット型 (私たちの場合は `Movie` ) にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this converter, our `consume` method will receive the `Movie` objects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコンバータにより、 `consume` メソッドは `Movie` オブジェクトを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to AMQP from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントからAMQPにメッセージを送信することはよくあることです。これを行うには、以下の内容で `org.acme.MovieResource` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class uses the `MovieProducer` we implemented above to send the `movies`.  You could also use an `Emitter` directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは、上で実装した `MovieProducer` を使用して `movies` を送信します。 `Emitter` を直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need an AMQP broker, for example http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis].  You can follow the http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] documentation, or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、AMQPブローカー、例えば link:http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis] が必要です。 link:http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] のドキュメントに従うか、以下の `docker-compose.yaml` ファイルを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d'</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します: `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using AMQP starting in a few milliseconds and consuming a ridiculous amount of memory: only 33Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、AMQPを使用したQuarkusアプリケーションが数ミリ秒で起動し、とんでもない量:100レコードを取り込んでもたったの33MB!になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using AMQP.  If you want to go further, check the https://quarkus.io/guides/amqp[AMQP guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>10分もしないうちに、AMQPを使った新しいQuarkusアプリケーションができました。もっと詳しく知りたい方は、 link:https://quarkus.io/guides/amqp[AMQPガイド] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conclusion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>結論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven Reactive Programming library.  Like other reactive programming libraries, it uses streams as the primary construct.  These streams convey events, and your code processes these events.  Most of the time, your code is only interested in item and failure events.  But there are other kinds of events such as cancellation, request, completion, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。他のリアクティブ・プログラミング・ライブラリと同様に、主要な構成要素としてストリームを使用します。これらのストリームはイベントを伝え、あなたのコードはこれらのイベントを処理します。ほとんどの場合、あなたのコードはアイテムイベントと失敗イベントにしか興味がありません。しかし、キャンセル、リクエスト、完了などの他の種類のイベントもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not rare that you need to look at these various events to understand better what's going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何が起こっているのかをよりよく理解したり、特定の副作用を実装したりするために、これらの様々なイベントを見る必要があることは稀ではありません。例えば、完了イベントの後にリソースを閉じたり、失敗やキャンセル時にメッセージをログに記録したりする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each kind of event, there is an associated _group_ providing the methods to handle that specific event: `onItem()`, `onFailure()`, `onCompletion()` and so on.  These groups provide two methods to peek at the various events without impacting its distribution: `invoke` and `call`.  It does not transform the received event; it notifies you that something happened and let you react.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントの種類ごとに、その特定のイベントを処理するための方法を提供する関連 _グループ_ があります: `onItem()`, `onFailure()`, `onCompletion()` など。これらのグループは、配信に影響を与えずに様々なイベントを覗くための 2 つの方法を提供しています: `invoke` と `call` 。これらのグループは、受信したイベントを変換するのではなく、何かが起こったことを通知して反応させてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The invoke method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>invoke メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method is synchronous and does not return anything.  Mutiny invokes the configured callback when the observed stream dispatches the event:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` メソッドは同期で、何も戻りません。Mutinyは、観測されたストリームがイベントをディスパッチするときに、設定されたコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, `invoke` is synchronous.  Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上で述べたように、 `invoke` は同期です。Mutinyはコールバックを呼び出し、コールバックが戻ってきたらイベントを下流に伝播させます。ディスパッチをブロックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, we highly recommend you not to block.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん、ブロックしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippets show how you can log the different types of events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のスニペットは、さまざまな種類のイベントをログに記録する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のコードスニペットの矢印は、イベントが上流(ソース)から来るのか、下流(コンシューマ)から来るのかを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method does not change the event, except in one case.  If the `invoke` callback throws an exception, the downstream does not get the actual event but get a failure event instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` メソッドは、1 つのケースを除いて、イベントを変更しません。 `invoke` コールバックが例外をスローした場合、ダウンストリームは実際のイベントを取得せず、代わりに失敗イベントを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When observing the failure event, if the callback throws an exception, Mutiny propagates a `CompositeException` aggregating the original failure and the callback failure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>失敗イベントを観測しているときに、コールバックが例外を投げると、Mutinyは元の失敗とコールバックの失敗を集約した `CompositeException` を伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The call method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>呼び出し方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike `invoke`, `call` is asynchronous, and the callback returns a `Uni&lt;?&gt;` object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` とは異なり、 `call` は非同期で、コールバックは `Uni&lt;?&gt;` オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call` is often used when you need to implement asynchronous side-effects, such as closing resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`call` リソースを閉じるなど、非同期の副作用を実装する必要がある場合によく使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyは、コールバックによって返されたUniがアイテムを放出するまで、元のイベントを下流にディスパッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As shown in the previous snippet, you can use this approach to delay items. 
But the primary use case is about completing asynchronous actions:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のスニペットが示すように、このアプローチを使用してアイテムを遅らせることもできます。
ただし、主なユースケースは非同期アクションの完了に関するものです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Under the hood, Mutiny gets the `Uni` (by invoking the callback) and subscribes to it. 
It observes the item or failure event from that `Uni`. 
It discards the item value as only the emission matters in this case.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>内部的には、Mutinyは `Uni` を(コールバックを呼び出すことによって)取得し、サブスクライブします。 
`Uni`からアイテムまたは障害イベントを監視します。
この場合、排出のみが重要であるため、アイテムの値は破棄されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the callback throws an exception or the produced `Uni` produces a failure, Mutiny propagates that failure (or a `CompositeException`) downstream, replacing the original event. 
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コールバックが例外をスローするか、生成された `Uni` が失敗を生成した場合、Mutinyはその失敗(または `CompositeException` )をダウンストリームに伝播し、元のイベントを置き換えます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` and `call` methods are handy when you need to observe a stream without changing the transiting events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` と `call` メソッドはストリームをイベントを変更せずに観察するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `invoke` for implementing synchronous side-effects or logging events.  The asynchronous nature of `call` makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke`を同期の副作用操作やイベントのロギングの実装の為に使用してください。 `call`の非同期性は、非同期副作用操作、例えばリソースのクローズ、データのフラッシュ、アイテムの遅延などを実装するのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table highlights the key differences:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のテーブルが主な違いを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`invoke`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`call`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nature</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>戻り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`void`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`void`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Main Use cases</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>主なユースケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are available for every kind of event in the associated group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのメソッドは、関連するグループ内のあらゆる種類のイベントに対して利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a https://quarkus.io/blog/kafka-failure-strategy/[previous blog post], we have looked at failure strategies provided by the Reactive Messaging Kafka connector.  But, imagine it's our lucky day, and for once it worked.  We should inform Kafka that the processing succeeded.  In Kafka terminology, we call this: _offset commit_.  This post covers the different strategies to commit offsets with the Reactive Messaging Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/blog/kafka-failure-strategy/[以前のブログ記事]では、Reactive Messaging Kafkaコネクタが提供する失敗戦略を見てきました。しかし、想像してみてください、それは幸運な日で、一度だけ成功しました。処理が成功したことをKafkaに知らせなければなりません。Kafkaの用語では、これを _オフセットコミット_ と呼びます。この記事では、Reactive Messaging Kafka コネクタを使ったオフセットコミットのさまざまな戦略について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Kafka Consumer Group and Offsets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafkaコンシューマーグループとオフセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka organizes records (_i.e._ messages) around _topics_.  Each topic has a name, and applications send records to topics and poll records from topics.  So far, nothing out of the ordinary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka は、 _トピックを_ 中心にレコード ( _即ち_ メッセージ) を整理します。各トピックには名前があり、アプリケーションはトピックにレコードを送り、トピックからレコードをポーリングします。今のところ、特別なことは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Topics are divided into partitions.  Each partition is an ordered, immutable sequence of records.  Sending a message to a topic appends it to the selected partition.  Each message from a partition gets a sequential id number called _offset_.  It uniquely identifies each message within the partition.  So, with Kafka, you can identify an individual record using a `&lt;topic, partition, offset&gt;` tuple.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トピックはパーティションに分割されます。各パーティションは、順序立てられた不変のレコードのシーケンスです。トピックにメッセージを送信すると、選択したパーティションにメッセージが追加されます。パーティションからの各メッセージは、 _offset_ と呼ばれる連続した ID 番号を取得します。これはパーティション内の各メッセージを一意に識別します。つまり、Kafka を使うと、 `&lt;topic, partition, offset&gt;` タプルを使って個々のレコードを識別することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an application consumes messages from Kafka, it uses a Kafka consumer.  With this consumer, it polls batches of messages from a specific topic, for example, `movies` or `actors`.  Retrieved messages belong to partitions assigned to this consumer.  And that aspect is essential.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが Kafka からのメッセージを消費するとき、アプリケーションは Kafka コンシューマを使用します。このコンシューマでは、特定のトピック、例えば `movies` や `actors` などからのメッセージのバッチをポーリングします。取得したメッセージは、このコンシューマに割り当てられたパーティションに属します。そして、この点が重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumers belong to a consumer group, identified with a name (`A` and `B` in the picture above).  A group contains one or more consumers.  In general, when you scale up your application, it creates a consumer joining the same group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンシューマーは、名前(上の図では `A` と `B` )で識別されるコンシューマーグループに属しています。1 つのグループには 1 つ以上のコンシューマーが含まれます。一般的に、アプリケーションをスケールアップすると、同じグループに参加するコンシューマーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each consumer group receives each record from a topic once.  To achieve this, it assigns each consumer from a group to a set of partitions.  For example, in the above picture, the consumer from the application A1 receives the records from the partitions 0 and 1.  A2 receives the records from the partition 2.  App B is the only consumer from its consumer group.  So, it gets the records from all three partitions.  Consequently (ignore rebalance or other subtilities for now), each record from a topic is only received once per consumer group, by a specific consumer from that group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各コンシューマーグループは、トピックから各レコードを一度だけ受け取ります。これを実現するために、グループからの各コンシューマーをパーティションのセットに割り当てます。例えば、上の図では、アプリケーションA1のコンシューマーはパーティション0と1からレコードを受信し、A2はパーティション2からレコードを受信します。アプリBは、そのコンシューマグループからの唯一のコンシューマーです。したがって、3つのパーティションすべてからレコードを取得します。したがって、(今のところリバランスや他のサブユーティリティーは無視して)あるトピックの各レコードは、そのグループの特定のコンシューマーによって、コンシューマーグループごとに 1 回だけ受信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To orchestrate each consumer group's progress, each consumer periodically informs the broker of its current position - the last processed offset.  It commits the offset, indicating that all the previous records from that partition have been processed.  So, if a consumer stops and comes back later, it restarts from the last committed position (if assigned to that partition again).  Note that this behavior is configurable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各コンシューマーグループの進捗を調整するために、各コンシューマーは定期的に現在の位置、つまり最後に処理されたオフセットをブローカに通知します。コンシューマは、そのパーティションの以前のレコードがすべて処理されたことを示すオフセットをコミットします。つまり、あるコンシューマーが停止して後で戻ってきた場合、最後にコミットされた位置から再スタートします(再びそのパーティションに割り当てられた場合)。この動作は設定可能であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's important to notice is the periodic aspect of the commit.  Offset commit is expensive, and to enhance performance, we should not commit the offset after each processed record.  In this regard, Kafka behaves differently from traditional messaging solutions, such as JMS, which acknowledges each message individually.  Another important characteristic is the positional aspect of the commit.  You commit the position indicating that all the records located before that position are processed.  But is it really the case?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注目すべきは、コミットの周期的な側面です。オフセットコミットはコストがかかるので、パフォーマンスを向上させるためには、処理された各レコードの後にオフセットをコミットするべきではありません。この点で、Kafkaは、JMSのような従来のメッセージングソリューションとは異なる振る舞いをしており、各メッセージを個別に認識します。もう一つの重要な特徴は、コミットの位置的な側面です。位置をコミットすると、その位置より前にあるすべてのレコードが処理されることを示します。しかし、本当にそうなのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>### The Kafka default behavior</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka のデフォルトの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Apache Kafka consumer uses an auto-commit approach by default.  Applications using such a consumer are structured around a polling loop:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Kafka のコンシューマーはデフォルトで自動コミットアプローチを使用しています。このようなコンシューマを使うアプリケーションはポーリングループを中心に構成されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a program polls a batch of records, processes them, and then polls the next set.  While calling the `poll` method, the consumer periodically commits the last offset of the previous batches transparently.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなプログラムは、レコードのバッチをポーリングして処理し、次のセットをポーリングします。 `poll` メソッドを呼び出している間、コンシューマーは定期的に前のバッチの最後のオフセットを透過的にコミットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite nice, right? If the application fails to process a message, it throws an exception, which either interrupts the while loop or is handled gracefully (within the `processRetrievedRecords` method).  In the first case, it means that it won't commit anymore (as it happens in the `poll` method, not called anymore).  If the application restarts, it resumes from the last committed offset (or apply the `auto.offset.reset` strategy, defaulting to `latest`, if there are no offsets for this group yet).  It may re-process a set of messages (it's the application's responsibility to handle duplicates), but at least nothing is lost.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なかなかいいですよね?アプリケーションがメッセージの処理に失敗した場合、アプリケーションは例外をスローし、while ループを中断するか、( `processRetrievedRecords` メソッド内で) 優雅に処理されます。最初のケースでは、それはもうコミットしないことを意味します( `poll` メソッド内で発生するので、もう呼ばれません)。アプリケーションが再起動した場合、最後にコミットされたオフセットから再開します (または `auto.offset.reset` ストラテジーを適用し、このグループのオフセットがまだない場合は `latest` をデフォルトとして使用します)。一連のメッセージを再処理するかもしれませんが(重複を処理するのはアプリケーションの責任です)、少なくとも何も失われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, is there anything wrong with this? Looks wonderful... until you add a pinch of asynchrony.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それで、これに何か問題があるの?見た目は素晴らしい...非同期のピンチを追加するまでは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What if the message's processing is asynchronous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## メッセージの処理が非同期の場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the message processing is asynchronous (offloaded to another thread, use non-blocking I/O...), failures may not interrupt the while loop from above.  Failure happens asynchronously, outside the polling thread.  If the `poll` method gets called again despite a failed processing, and _auto-commit_ is still enabled, we may commit offsets while something wrong happened.  If some processing of previously retrieved records is not completed yet, while this auto commit happens, it may consider the record as processed correctly, but the outcome is unknown at that point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージ処理が非同期(他のスレッドにオフロードされている、ノンブロッキングI/Oを使用している...)であれば、失敗は上からwhileループを中断しないかもしれません。失敗はポーリングスレッドの外で非同期に起こります。処理に失敗したにもかかわらず `poll` メソッドが再び呼び出され、 _オートコミット_ がまだ有効になっている場合、何か間違ったことが起こっている間にオフセットをコミットすることがあります。このオートコミットが発生している間に、以前に取得したレコードの処理がまだ完了していない場合、そのレコードは正しく処理されたとみなされるかもしれませんが、その時点では結果はわかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So to handle these case, we can disable the auto-commit and switch to manual commit.  In this case, it's the application's responsibility to commit the offsets regularly.  So, the application needs to track the polled records, their processing, failures, and periodically commits the offsets.  It might not look too tricky, but actually, it can become quite challenging.  Again, in asynchronous scenarios, you may complete the processing of messages in various orders.  For example, if you call a remote service for each record, the responses may not come in the same orders as the records.  You need to track messages individually and only commit the offsets if all the previous messages are processed successfully.  Without this, you may commit offsets while there is processing from previous records still in progress or even failed processing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、これらのケースを処理するために、自動コミットを無効にして手動コミットに切り替えることができます。この場合、定期的にオフセットをコミットするのはアプリケーションの責任です。したがって、アプリケーションはポーリングされたレコード、その処理、失敗を追跡し、定期的にオフセットをコミットする必要があります。これはそれほどトリッキーには見えないかもしれませんが、実際には非常に困難になることがあります。繰り返しになりますが、非同期のシナリオでは、様々な順序でメッセージの処理を完了させることができます。例えば、各レコードに対してリモートサービスを呼び出した場合、レスポンスはレコードと同じ順番で来るとは限りません。メッセージを個別に追跡し、前のすべてのメッセージが正常に処理された場合にのみオフセットをコミットする必要があります。これがないと、前のレコードからの処理がまだ進行中であったり、処理に失敗した場合にオフセットをコミットすることになるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What can we do about this?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはどうしたらいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, you entered an asynchronous world.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Messaging と Kafka コネクタを使用すると、非同期の世界に入りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message processing may not happen synchronously and sequentially.  When a Reactive Messaging `Message` processing completes, it acknowledges the message.  In the case of processing failures, it sends a negative acknowledgment.  The Kafka connector receives these acknowledgments and can decide what needs to be done, basically: to commit or not to commit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージ処理は、同期的・逐次的に行われるとは限りません。リアクティブメッセージング `Message` 処理が完了すると、メッセージを確認します。処理に失敗した場合は、否定的な確認応答を送信します。Kafka コネクタはこれらの確認応答を受信して、コミットするかしないかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can choose among three strategies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>3つの戦略から選択することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ignore (default if `enabled.auto.commit=true` is set)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>無視 ( `enabled.auto.commit=true` が設定されている場合のデフォルト)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is configured using the `commit-strategy` attribute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `commit-strategy` 属性を使用して設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The throttled strategy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## スロットル化された戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The throttled strategy can be seen as an asynchronous variant of the default "auto-commit" behavior described above.  When enabled, the connector tracks each received message and monitors their acknowledgment.  When the connector finds out that all messages before a position are processed successfully, it commits that position.  This commit happens periodically to avoid committing too often.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スロットル戦略は、上述のデフォルトの「オートコミット」動作の非同期的な変形として見ることができます。有効にすると、コネクタは受信した各メッセージを追跡し、その確認応答を監視します。コネクタは、あるポジションの前のすべてのメッセージが正常に処理されたことを確認すると、そのポジションをコミットします。このコミットは、頻繁にコミットしないように定期的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy provides very good throughput and can handle asynchronous processing.  To enable this strategy configures the channel with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このストラテジーは非常に優れたスループットを提供し、非同期処理を処理することができます。このストラテジーを有効にするには、チャネルを以下のように設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one detail to mention.  If an old message is neither acked nor nacked, the strategy cannot commit the position anymore.  It will enqueue messages forever, waiting for that missing ack to happen.  It can lead to out of memory, as the connector would never be able to commit a position and to clear the queue.  Fortunately, the strategy detects this situation and reports a failure to the connector, marking the application unhealthy.  The `throttled.unprocessed-record-max-age.ms` attribute configures the deadline for each message to be acked or nacked before being considered as a poison pill (Default is 1 minute).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一つだけ注意すべき点があります。古いメッセージが ack されず、nack されない場合、ストラテジーはもうポジションをコミットすることができません。それは永遠にメッセージをエンキューし、その欠落したアックが起こるのを待ちます。これは、コネクタがポジションをコミットしてキューをクリアすることができなくなるため、メモリー不足につながる可能性があります。幸いなことに、このストラテジーはこの状況を検出してコネクタに失敗を報告し、アプリケーションが不健全であることをマークします。 `throttled.unprocessed-record-max-age.ms` 属性は、ポイズンピルとみなされる前に、各メッセージが ack されるか nacked されるかの期限を設定します (デフォルトは 1 分です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses this strategy by default if you explicitly enabled Kafka's auto-commit (with the `enable.auto.commit` attribute set to `true`).  In this case, the connector ignores acknowledgment and won't commit the offsets.  The Kafka consumer commits the offset periodically when polling batches, as described above.  This strategy works well if the message processing is synchronous and failures handled gracefully.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka の自動コミットを明示的に有効にした場合 ( `enable.auto.commit` 属性を `true` に設定した場合)、コネクタはデフォルトでこのストラテジーを使用します。この場合、コネクタは確認応答を無視してオフセットをコミットしません。Kafka コンシューマは、前述のように、バッチをポーリングする際に定期的にオフセットをコミットします。この方法は、メッセージ処理が同期的で、失敗があっても潔く処理される場合に有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable this strategy by configured enabled-auto-commit to true:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>enabled-auto-commitをtrueに設定することで、このストラテジーを有効にすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that starting Quarkus 1.9, auto commit is disabled by default. So you need to explicitly enable it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.9からは、オートコミットがデフォルトで無効になっていることに注意してください。そのため、明示的に有効にする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't enable auto-commit, using this strategy is still possible but will never commit the offsets.  In other words, you would restart from the oldest stored records every time.  While there are use cases for this, double-check that's what you want. In this case, enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オートコミットを有効にしていない場合、この戦略を使用することは可能ですが、オフセットをコミットすることはありません。言い換えれば、保存されている最も古いレコードから毎回再起動することになります。これにはユースケースがありますが、あなたが望むものであることを再確認してください。当てはまる場合、以下のようにこのストラテジーを有効にします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The latest strategy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 最新の戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy commits the offset every time a message is acknowledged.
This strategy tends to commit often, and so decrease the throughput.   
However, it also reduces the risk of duplicates if the messages are processed synchronously. 
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このストラテジーは、メッセージが確認されるたびにオフセットをコミットします。
このストラテジーは頻繁にコミットする傾向があるため、スループットが低下します。
しかし、メッセージが同期的に処理されている場合には、重複のリスクを減らすことができます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この戦略を有効にするのは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Conclusion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 結論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, use the `throttled` strategy.  It provides high-throughput and handles the asynchronous use cases.  This strategy is becoming the default strategy in Quarkus 1.10.  You can also switch to the `ignore` strategy if the Kafka auto-commit is acceptable for you, or if you want to skip offset commit altogether.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的には、 `throttled` 戦略を使用します。これはハイスループットを提供し、非同期のユースケースを処理します。このストラテジーは、Quarkus 1.10ではデフォルトのストラテジーになっています。また、Kafkaのオートコミットが許容できる場合や、オフセットコミットを完全にスキップしたい場合は、 `ignore` 戦略に切り替えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That concludes this blog post.  The next one will discuss how to receive and produce Cloud Events using the Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以上でこのブログ記事は終了です。次回は、Kafkaコネクタを使ってクラウドイベントを受信して生成する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is my pleasure to announce the release of Quarkus 1.12.0.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.12.0.Finalのリリースを発表できることを嬉しく思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It comes with some significant changes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それはいくつかの重要な変更を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fast jar is now the default packaging when you build a jar.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Fast jar は、jar をビルドする際のデフォルトのパッケージングになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive keeps improving and it now has support for multipart.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactiveは改善を続け、multipartをサポートするようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x Axle and RX Java managed instances have been dropped.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x AxleとRX Javaのマネージドインスタンスを削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to GraalVM 21.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 21.0にアップグレードしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[our migration guide for 1.12].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか？ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12の移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has always offered several types of jar packaging.  Historically, we had either a standard jar packaging (the one with the `-runner.jar` and the `lib/` directory) or an uber jar.  In Quarkus 1.5, we introduced a new packaging type called Fast jar, which main objective was to further improve our boot time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、常にいくつかのタイプのjarパッケージを提供してきました。歴史的には、標準のjarパッケージ（ `-runner.jar` と `lib/` ディレクトリのあるもの）か、uber jarがありました。Quarkus 1.5では、Fast jarと呼ばれる新しいパッケージタイプを導入しました。その主な目的は、ブート時間の更なる改善でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus time, 1.5 means a century ago and we think Fast jar is now ready for prime time and brings enough improvements to justify the change.  Thus the decision to make it the default starting with 1.12.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの時間軸では、1.5は100年前のことを意味し、Fast jarはもうゴールデンアワーの準備ができており、変更を正当化するのに十分な改善をもたらしていると考えています。そのため、1.12からデフォルトにすることを決定しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This change will have consequences on your workflow as the produced artifacts are now under a `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この変更は、生成された成果物が `quarkus-app` ディレクトリの下に置かれるようになったため、ワークフローに影響を及ぼします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So instead of starting your application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを以下で起動するのではなく、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now start it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これからは以下で起動します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When deploying your application, you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをデプロイする際には、 `quarkus-app` ディレクトリ全体をデプロイする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your Dockerfiles will also need to be adjusted to take this into account.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Dockerfilesもこれを考慮して調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more details in our https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12#fast-jar-as-default[Migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12#fast-jar-as-default[移行ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's not the right time for you to change your workflow, you can easily go back to the previous packaging by adding the following property to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ワークフローを変更するタイミングではない場合は、 `application.properties`に以下のプロパティを追加することで、簡単に以前のパッケージングに戻ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We continue improving RESTEasy Reactive at a steady pace, and this time, we introduced Multipart support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactiveの改善を着実に続けており、今回はMultipart対応を導入しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very similar to the Multipart support of RESTEasy and looks like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyのMultipart対応に非常に似ていて、以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in the updated https://quarkus.io/guides/resteasy-reactive#handling-multipart-form-data[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それについての詳細は、更新された link:https://quarkus.io/guides/resteasy-reactive#handling-multipart-form-data[RESTEasy Reactiveガイド]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 21</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.12 is GraalVM 21.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.12のGraalVMの推奨バージョンはGraalVM 21.0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They had been deprecated for quite a while, they are now gone.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>かなり前から非推奨になっていましたが、今はもうありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either use the raw Vert.x instance of the Mutiny one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生のVert.xインスタンスを使用するか、Munityのを利用してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Changelog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.12.0.CR1[1.12.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.12.0.Final[1.12.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.0.CR1[1.12.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.12.0.Final[1.12.0.Final]の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To share stories about Quarkus usage, we added https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[an `ADOPTERS.md` file] at the root of the repository.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの使用に関する情報を共有するために、リポジトリのルートに https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[ADOPTERS.mdファイル]を追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>貢献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[445 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[445人の貢献者]がいます。一人ひとりの貢献者に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.12 release, thanks to Alex Soto, Alexey Loubyansky, Andy Damevin, artsemstones, Auri Munoz, Bernhard Lutzmann, Bill Burke, Clement Escoffier, Erin Schnabel, Ertunc Aybars, essobedo, Falko Modler, Florian Heubeck, Foivos Zakkak, Galder Zamarreño, Gaétan Collaud, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Henrique Prange, Ioannis Canellos, Jaikiran Pai, James Netherton, Jan Martiška, JiriOndrusek, Johnnes Souza, Joost Baas, Jose, Jose Ignacio Gil Jaldo, Josef Smrcka, Julien Ponge, Katia Aresti, Ken Finnigan, Knut Wannheden, kstrempel, Ladislav Thon, Loïc Mathieu, Lucas Reeh, Maciej Walkowiak, Mahieddine Cherif, Maik Möwes, manusa, Manyanda Chitimbo, Martin Kouba, Martin Panzer, Matej Novotny, Matej Vasek, Maxime DAVID, Mayank Kunwar, Michał Szynkiewicz, Moritz Becker, mrizzi, Nuno Alves, Oscar, PAPADOPOULOS Nikolaos, Peter Palaga, Petr Široký, Phillip Krüger, René Grob, Robert Stupp, Roberto Cortez, Rostislav Svoboda, Sanne Grinovero, SaumyaSingh1, sebthom, Sergey Beryozkin, S.H, Stuart Douglas, Stéphane Épardaud, Suleimenov Yelzhas, Ted Won, Thomas McWork, Thomas Pfaff, Thomas Segismont, Timothy Power, Tobias Stadler, Vasilis Andritsoudis, Vincent Sevel, xstefank, and Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に1.12リリースについては、以下の皆様に感謝します: Alex Soto, Alexey Loubyansky, Andy Damevin, artsemstones, Auri Munoz, Bernhard Lutzmann, Bill Burke, Clement Escoffier, Erin Schnabel, Ertunc Aybars, essobedo, Falko Modler, Florian Heubeck, Foivos Zakkak, Galder Zamarreño, Gaétan Collaud, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Henrique Prange, Ioannis Canellos, Jaikiran Pai, James Netherton, Jan Martiška, JiriOndrusek, Johnnes Souza, Joost Baas, Jose, Jose Ignacio Gil Jaldo, Josef Smrcka, Julien Ponge, Katia Aresti, Ken Finnigan, Knut Wannheden, kstrempel, Ladislav Thon, Loïc Mathieu, Lucas Reeh, Maciej Walkowiak, Mahieddine Cherif, Maik Möwes, manusa, Manyanda Chitimbo, Martin Kouba, Martin Panzer, Matej Novotny, Matej Vasek, Maxime DAVID, Mayank Kunwar, Michał Szynkiewicz, Moritz Becker, mrizzi, Nuno Alves, Oscar, PAPADOPOULOS Nikolaos, Peter Palaga, Petr Široký, Phillip Krüger, René Grob, Robert Stupp, Roberto Cortez, Rostislav Svoboda, Sanne Grinovero, SaumyaSingh1, sebthom, Sergey Beryozkin, S.H, Stuart Douglas, Stéphane Épardaud, Suleimenov Yelzhas, Ted Won, Thomas McWork, Thomas Pfaff, Thomas Segismont, Timothy Power, Tobias Stadler, Vasilis Andritsoudis, Vincent Sevel, xstefank, and Yoann Rodière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.5.Final released - Bugfixes'
date: 2020-12-16
tags: release
synopsis: 1.10.5.Final fixes several important issues in Quarkus 1.10.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.10.5.Finalリリース - バグフィックス
date: 2020-12-16
tags: release
synopsis: 1.10.5.Finalでは、Quarkus 1.10のいくつかの重要な問題が修正されました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.5.Final is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.5.Final はメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.10.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.10を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.10 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.10をお使いでない方は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10移行ガイド] をご参照ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It fixes some important issues in Quarkus, most notably in the Hibernate ORM extension which got Hibernate ORM upgraded to 5.4.26.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの幾つかの重要な課題を修正します。特に注目すべき点として、Hibernate ORMエクステンションにおいて、Hibernate ORMが5.4.26.Finalにアップグレードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[the full changelog of 1.10.4.Final] and the https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[full changelog for 1.10.5.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[1.10.4.Finalの完全な変更履歴]と https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[1.10.5.Finalの完全な変更履歴] をGitHubで取得出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just before my PTO, someone told me: '_I don't like magic._' In this context, _magic_ refers to the amount of hidden _stuff_ done by Quarkus under the hood for the sake of simplicity.  It includes dependency injection, annotations, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>有休の直前に 誰かに言われました _"私はマジックが好きじゃない"_ って。この文脈では、 _マジック_ とは、シンプルにするためにQuarkusが裏側で行っている隠れた _作業_ のことを指します。これには依存性注入やアノテーションなどが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not the first time that I get that kind of comment, and coming from the Vert.x project, it makes sense.  Vert.x has (almost) no magic, and for a good reason: too much magic can be terrible and make production tuning utterly expensive.  Sometimes you want to have more control and avoid unexpected behaviors: execute the code you wrote, and nothing else.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなコメントを受けるのは初めてではないし、Vert.xプロジェクトから来ているので、それは理にかなっています。Vert.x には(ほとんど)マジックがありませんが、それには正当な理由があります: マジックが多すぎるとひどいことになり、プロダクションチューニングが全く大変になります。時には、より多くの制御をして予期せぬ動作を避けたい場合があります: ただ書いたコードだけが実行され、それ以外は何もしないで欲しい、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But magic is not inherently bad.  Magic is power that can be used for good or for bad.  After all, your application runs on a silicon with microcode magic powering an Operating System with abstraction magic powering the Java Virtual Machine with Just In Time magic.  There is magic, it's just magic you have enough knowledge (or trust) of vs magic you don't.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、マジックは本質的に悪いものではありません。マジックは良いことにも悪いことにも使えるパワーなのです。結局のところ、あなたのアプリケーションは、マイクロコードで力を与えられた半導体上で実行される、抽象化のマジックで力を与えられたオペレーティングシステム上の、JITのマジックで力を与えられたJava仮想マシンで動いています。マジックはありますが、それはあなたが十分な知識を持っている(または信頼している)マジックと、そうでないマジックのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may think that Quarkus has a lot of magic tricks.  It is true in some sense but it is easily understood and comes with strong benefits in either memory optimization, startup time optimization or last but not least developer experience improvements.  You can decide the amount of magic that you want and the amount of control you feel comfortable with.  You don't have to use dependency injection or managed clients if you prefer doing things yourself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusにはたくさんのマジックのトリックがあると思うかもしれません。ある意味ではそうなのですが、簡単に理解でき、メモリーの最適化、起動時間の最適化、または開発者の経験の向上のいずれかにおいて強力なメリットがあります。あなたが望むマジックの量と、あなたが快適に感じるコントロールの量を決めることができます。もし自分でやりたいのであれば、依存性注入や管理クライアントを使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, we will cover three different approaches to reducing the amount of magic.  We will go from almost no magic to just enough to get a good developer experience.  Examples from this blog post are available on https://github.com/cescoffier/quarkus-magic-control[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回の記事では、マジックの量を減らすための3つの異なるアプローチを取り上げます。マジックをほとんど使わない状態から、良い開発者体験を得るために必要なだけの状態にしていきます。このブログ記事の例は link:https://github.com/cescoffier/quarkus-magic-control[GitHub]で公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _almost no magic_ approach</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_ほとんどマジックがない_ アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are Java applications.  So, somewhere there is a `public static void main(String... args)`.  While you don't need to write that method when using Quarkus, it can still be convenient and give you more control about your application startup.  It's also a good trick to start your Quarkus application directly from your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのアプリケーションはJavaアプリケーションです。そのため、どこかに `public static void main(String…​ args)` が存在します。Quarkusを使用する際にそのメソッドを記述する必要はありませんが、それでも便利で、アプリケーションの起動についてより多くのコントロールが可能になります。また、IDEから直接Quarkusアプリケーションを起動するのも良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, we will implement a straightforward HTTP application. Nothing fancy:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例として、簡単な HTTP アプリケーションを実装します。派手なものは何もありません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete source code is available https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[here].  Don't expect much more; the application had only one Java class, but let's look into it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なソースコードは link:https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[ここ]にあります。アプリケーションにはJavaクラスが1つしかありませんが、それを調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@QuarkusMain` indicates that Quarkus should use this class as the _main entry point_ of the application.  The `run` method contains your application logic.  We will come back to this logic later.  First, look at the `public static void main(String... args)` method.  It just starts the application.  You can use this entry point directly from your IDE.  Yes, there is still a bit of magic behind `Quarkus.run`; that's where the extension initialization happens - not unlike _any_ framework initialization including Vert.x.  As this application does not use any extension, nothing much will happen.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusMain` は、Quarkusがこのクラスをアプリケーションの _メインエントリーポイント_ として使用することを示しています。 `run` メソッドには、アプリケーションのロジックが含まれています。このロジックについては後ほど説明します。まず、 `public static void main(String…​ args)` メソッドを見てください。これはアプリケーションを起動するだけです。このエントリーポイントは、IDE から直接使用できます。そう、 `Quarkus.run` の背後にはまだちょっとしたマジックがあります。エクステンションの初期化が行われるのは、 Vert.x を含む _どの_ フレームワークの初期化とも異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[depends] directly on Vert.x Web and Vert.x Core.  The only Quarkus dependency is Arc (not used directly but required):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションは Vert.x Web と Vert.x Core に直接 link:https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[依存します]。Quarkusの依存関係はArcだけです(直接は使用しませんが必須です):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go back to the `run` method.  It contains the application logic, here, a dummy Vert.x application.  It creates the `Vertx` instance, a `Router`, registers a few routes, and starts the HTTP server.  Because we don't want the application to stop immediately, we _wait for exit_.  The `/bye` request handler illustrates how you can programmatically trigger the application shutdown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`run` メソッドに戻りましょう。これにはアプリケーション・ロジックが含まれており、ここではダミーの Vert.x アプリケーションを使用しています。 `Vertx` インスタンス、 `Router` を作成し、いくつかのルートを登録し、HTTP サーバーを起動します。アプリケーションをすぐに停止させたくないので、 _終了を待ちます_。 `/bye` リクエスト・ハンドラーは、アプリケーションのシャットダウンをプログラムでトリガーする方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application has almost no magic, just a single annotation, and a regular Java entry point.  You may wonder why not using a bare Java program? Even used that way, Quarkus provides benefits. For example, you can access the built-in configuration support as illustrated in the snippet:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションにはマジックはほとんどなく、ただのアノテーション1つと、普通のJavaのエントリーポイントがあるだけです。なぜむき出しのJavaプログラムを使わないのかと疑問に思うかもしれません。そのように使用しても、Quarkusには利点があります。例えば、スニペットに示されているように、組み込みの設定サポートにアクセスすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is located in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定は、 `application.properties` ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This first approach has a few drawbacks.  It does not benefit from the built-time processing of Quarkus.  The logic executed at build time is packaged inside extensions, and in this case, we don't use extensions (except Arc).  Another issue is that compiling this application to native will fail because extensions are also involved during the native compilation.  Finally, the hot reload won't work, but you can directly restart the application from your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最初のアプローチには、いくつかの欠点があります。これはQuarkusのビルド時処理の恩恵を受けていません。ビルド時に実行されるロジックはエクステンションの中にパッケージ化されており、この場合はエクステンションは使用されません(Arcを除く)。もう一つの問題は、このアプリケーションをネイティブにコンパイルすると、ネイティブのコンパイル時にエクステンションも絡んでくるので失敗するということです。最後に、ホットリロードはうまくいきませんが、IDEから直接アプリケーションを再起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses Vert.x heavily.  The `quarkus-vertx-core` extension manages the Vert.x instance used by Quarkus.  You can use that instance directly and avoid creating the Vert.x instance.  If you need to configure the instance, you can configure it from https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[the `application.properties`].  It also enables native packaging (as that extension contains the directive to compile Vert.x applications to native).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはVert.xを多用しています。 `quarkus-vertx-core` エクステンションは、Quarkusが使用するVert.xインスタンスを管理します。そのインスタンスを直接使用することができ、Vert.xインスタンスを作成する必要はありません。インスタンスを設定する必要がある場合は、 link:https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[`application.properties`] から設定することができます。また、ネイティブパッケージングも可能になります(このエクステンションには Vert.x アプリケーションをネイティブにコンパイルするためのディレクティブが含まれているため)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your pom.xml file, just add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pom.xmlファイルに以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, the _run_ method becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 _run_ メソッドは以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how it retrieves the managed Vert.x instance.  While you can use `@Inject`, you can also retrieve it programmatically, the rest of the code does not change.  See? No magic for you! We can still start it from the IDE using the _main_ method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されている Vert.x インスタンスを取得する方法に注目してください。 `@Inject` を使用することができますが、プログラムで取得することも出来、残りのコードは変更しません。ご覧になりましたか?魔法はありません! _メイン_ メソッドを使用して、IDE から起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't include the `quarkus-vertx-core` extension (or any extension depending on it), Quarkus won't create the Vert.x instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-vertx-core` エクステンション(またはそれに依存するエクステンション)を含まない場合、QuarkusはVert.xインスタンスを作成しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using extensions gives you some property wiring as well as the build time optimisations and native image compilation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを使用すると、プロパティーの設定や、ビルド時間の最適化、ネイティブイメージのコンパイルも行うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, still no hot reload 😿.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、やはりホットリロードはダメですね😿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of using only the `quarkus-vertx-core` extension, we can choose to delegate the HTTP server to Quarkus.  You may see that as a loss of control, but actually, we rarely do much around it, and again, you can configure it from the `application.properties` file if needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-vertx-core` のエクステンションだけを使用するのではなく、HTTPサーバーをQuarkusに委任することもできます。 これは制御できないと思われるかもしれませんが、実際には、そのようなことは滅多にしませんが、必要なら、 `application.properties` ファイルから設定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of ``quarkus-vertx-core`, use `quarkus-vertx-http`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>``quarkus-vertx-core` の代わりに、 `quarkus-vertx-http` を使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No need to depend on Vert.x Web directly, it's included.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x Webに直接依存する必要はなく、含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will still register your routes, but using a managed `Router`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートの登録は引き続き行いますが、管理されている `Router` を使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That approach enables the Quarkus hot reload as it intercepts the HTTP requests.  You are still in control of everything related to your application logic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチでは、HTTPリクエストをインターセプトするため、Quarkusのホットリロードが可能になります。アプリケーションロジックに関連するすべてのことを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start the hot reload using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次を使ってホットリロードを開始することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final _magic touch_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後の _マジックタッチ_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The question, now, is how far are we from a _regular_ Quarkus application? Quite close, actually.  The equivalent application using RESTEasy Reactive would be something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題は、Quarkusの _通常の_アプリケーションからどれくらい離れているかということです。実際には、かなり近いです。RESTEasy Reactiveを使った同等のアプリケーションは、次のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the previous approaches, this one leverages a declarative (annotation-based) model.  Under the hood, it's not that different from the last approach.  Quarkus registers a route (on the router), which then calls the `hello` method when a matching request is received.  The router gets initialized during the `Quarkus.run` method.  No need for the _main_ endpoint, but you can still use one, often convenient in IDEs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでのアプローチとは異なり、このアプローチは宣言的な(アノテーションベースの)モデルを活用しています。内部では、前のアプローチとそれほど違いはありません。Quarkusは(ルーター上で)ルートを登録し、一致するリクエストを受信すると `hello` メソッドを呼び出します。ルータは、 `Quarkus.run` メソッドの間に初期化されます。 _メインエンドポイント_ は必要ありませんが、1つのエンドポイントを使用することができ、IDEでは便利なことが多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our relation to magic depends on our background and experience.  Quarkus lets you decide how much magic you accept.  This post presented fours configurations, going from almost no magic to the _regular_ Quarkus code.  Each approach has pros and cons:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのマジックとの関係は、私たちのバックグラウンドや経験によって異なります。Quarkusでは、どの程度のマジックを受け入れるかを決めることができます。この記事では、ほとんど魔法を使わない状態から _通常の_ Quarkusコードまで、4つの設定を紹介しました。それぞれのアプローチには長所と短所があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Control</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コントロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build time optimizations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot Reload</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Almost no magic_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_殆どマジックなし_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Regular_ Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_通常の_ Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pick the approach that fits your needs.  Besides, most of Quarkus services are also available using a programmatic approach, as we have seen for configuration.  So, if you prefer avoiding managed objects, feel free just to use the available APIs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ニーズに合ったアプローチを選びましょう。また、設定について見てきたように、Quarkusのサービスのほとんどは、プログラム的なアプローチを使用して利用することもできます。管理されたオブジェクトを避けたい場合は、利用可能なAPIを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vault</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The just released Quarkus 1.10.2.Final comes with a lot of improvements and new features:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リリースされたばかりのQuarkus 1.10.2.Finalには、多くの改善と新機能が搭載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default media type is now JSON</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのメディアタイプがJSONになりました</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts is now the default project generation tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CodeStarts はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Qute error pages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい Qute のエラーページ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Part of the Hibernate ORM configuration is now overridable at runtime</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HibernateのORM設定の一部が実行時にオーバーライド可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients support multiple datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ SQL クライアントが複数のデータソースをサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Amazon IAM extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいAmazon IAMの拡張機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, it also comes with its fair share of bugfixes and usability and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、バグ修正や使い勝手の改善、ドキュメントの改善なども行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[our migration guide for 1.10].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか?ここに  https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10への移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is still the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 対応の GraalVM 20.2 は、まだ推奨の GraalVM のバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where is my 1.10.0.Final (and my 1.10.1.Final)?!?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.0.Final(と1.10.1.Final)はどこにあるの!?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We spotted a regression in the Caffeine extension and decided to skip the announcement of 1.10.0.Final altogether.  And then we spotted an issue with the Platform BOM and had to release a 1.10.2.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Caffeine 拡張機能のリグレッションを発見しました。そのため 1.10.0.Final の発表をスキップしました。そして、Platform BOM の問題を発見しました。なので 1.10.2.Final をリリースしなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All in all, we managed to fix a few more issues in the meantime so that makes 1.10.2.Final a greater release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その間にいくつかの問題を修正することができたので、1.10.2.Final はより大きなリリースとなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON as the Default Content Type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのコンテンツタイプとしての JSON</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In an effort to make your REST resources less verbose and considering nowadays JSON is the most widely used content type for REST services, it is now the default in Quarkus for your REST resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST リソースを冗長にならないようにするための努力と、最近では JSON が REST サービスで最も広く使用されているコンテンツタイプであることを考慮して、Quarkus では REST リソースのデフォルトとして JSON が使用されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It means that, if you are using JSON, you don't need to add `@Produces` and `@Consumes` annotations anymore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、JSON を使用している場合は、`@Produces` と `@Consumes` のアノテーションを追加する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also means that if you were relying on content type negotiation, you will have to add these annotations with the content types you support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コンテンツタイプネゴシエーションに頼っていた場合、サポートしているコンテンツタイプでこれらのアノテーションを追加しなければいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts as Default Project Generation Tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのプロジェクト生成ツールとしてのCodeStarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CodeStarts project has been a long and steady effort.  Good news: it is now the default project generation tool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CodeStarts プロジェクトは、長い間地道な努力を続けてきました。朗報:今はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From an end user perspective, it brings a better UI, more flexibility and code examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドユーザーの視点から見ると、より良い UI、より柔軟性のあるコード例をもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two new registries were added:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新たに2つのレジストリーが追加されました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StatsD</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>StatsD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SignalFX</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SignalFX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also added more metrics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらにメトリクスを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of work has been done to make the Swagger/GraphQL/Health/OpenAPI UIs consistent and Quarkus-themed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger/GraphQL/Health/OpenAPI UI を一貫して Quarkus をテーマにしたものにするために、多くの作業が行われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also now disable them at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、実行時にそれらを無効にすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More specifically on the Swagger UI front, all the Swagger UI configuration knobs have been exposed as Quarkus configuration properties.  You can learn more about it in link:/blog/stylish-api/[the just published Stylish API blog post].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より具体的には、Swagger UI の前面では、すべての Swagger UI 設定のつまみが Quarkus の設定プロパティーとして公開されています。それについては、  https://quarkus.io/blog/stylish-api/[先日公開されたばかりの Stylish API のブログ記事]で紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Qute, our template engine, you will be pleased to see our shiny new error pages, which points you to the error and makes you even more productive:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートエンジンのQuteをお使いの方は、ピカピカのエラーページをご覧になって喜んでいただけると思います。これがエラーを指摘し、さらに生産性を高めてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before 1.10, all of the Hibernate ORM configuration properties were fixed at build time.  Mostly for optimization purposes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10 以前では、すべての Hibernate ORM 構成プロパティーがビルド時に修正されていました。主に最適化のためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With 1.10, we started to relax this rule for some carefully chosen properties and you can now override the following properties at runtime:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10 では、慎重に選択したいくつかのプロパティーについてこのルールを緩和しました。以下のプロパティーを実行時にオーバーライドできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Reactive Changes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>更なるリアクティブの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.5.0 which includes several improvements and Mutiny to 0.11.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging  が 2.5.0 にアップグレードされました。これにより、いくつかの改善と Mutiny が 0.11.0 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive SQL Clients now support multiple datasources: you can connect to several databases, exactly in the same way as for JDBC datasources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive SQL クライアントは複数のデータソースをサポートするようになりました。これによって複数のデータベースに接続できるようになりました。JDBC データソースの場合と全く同じ方法で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Amazon Services extensions got a new friend: a brand new Amazon IAM extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon サービスの拡張機能に新しい友人ができました。真新しい Amazon IAM 拡張機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More on this one in link:/guides/amazon-iam[the Amazon IAM guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これについては、 https://quarkus.io/guides/amazon-iam[Amazon IAM ガイド]で詳しく紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of Google Cloud-related work is taking place in the https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud 関連の仕事の多くは https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse] で行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And if you wonder how you will deploy your Quarkus application to Google Cloud, we have a link:/guides/deploying-to-google-cloud[new guide] for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkus アプリケーションをどのように Google Cloud にデプロイするのか疑問に思っている方のために、 https://quarkus.io/guides/deploying-to-google-cloud[新しいガイド]をご用意しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Changes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.24.Final</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM が 5.4.24.Final にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1], https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final], https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final] and https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] の完全な変更ログはGitHubで入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[395 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには現在 https://github.com/quarkusio/quarkus/graphs/contributors[395人の貢献者]がいます。皆様、本当にありがとうございました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.10 release, thanks to Alexey Loubyansky, Andrea Cosentino, Andreas Eberle, Andrej Petras, Andrew Hatch, Andy Damevin, Anton Fagerberg, Antonio Goncalves, antonwiens, Arne Mejlholm, Auri Munoz, Bill Burke, Bobby Alex Philip, Bobby Philip, Cem Nura, Clement Escoffier, Daniel Platz, David M. Lloyd, Denis Fuenzalida, Dheeraj Nalluri, Dmitry Telegin, Dominik Henneke, Dušan Križan, Erin Schnabel, Falko Modler, Felix Wong, Foivos Zakkak, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Gytis Trikleris, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Antosik, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, jyemin, jzuriaga, Jérôme TAMA, Jörg von Frantzius, kdnakt, Kevin Viet, Knut Wannheden, Kuba Antosik, Ladislav Thon, Libor Krzyzanek, Lovekesh Garg, Loïc Mathieu, luneo7, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Martin Kouba, Matej Novotny, Matej Vasek, Matthias Harter, Michal Szynkiewicz, Nathan Erwin, osaka-svg, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Kruger, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Samuel Le Berrigaud, Sanne Grinovero, seregamorph, Sergey Beryozkin, Simon Bengtsson, Stefan Hacker, Stephane Epardaud, Stuart Douglas, Thorasine, Vincent Sevel, Vincent Sourin, Vinod Anandan, xstefank, Xumk, Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に1.10リリースについてはみなさんのおかげです: Alexey Loubyansky, Andrea Cosentino, Andreas Eberle, Andrej Petras, Andrew Hatch, Andy Damevin, Anton Fagerberg, Antonio Goncalves, antonwiens, Arne Mejlholm, Auri Munoz, Bill Burke, Bobby Alex Philip, Bobby Philip, Cem Nura, Clement Escoffier, Daniel Platz, David M. Lloyd, Denis Fuenzalida, Dheeraj Nalluri, Dmitry Telegin, Dominik Henneke, Dušan Križan, Erin Schnabel, Falko Modler, Felix Wong, Foivos Zakkak, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Gytis Trikleris, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Antosik, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, jyemin, jzuriaga, Jérôme TAMA, Jörg von Frantzius, kdnakt, Kevin Viet, Knut Wannheden, Kuba Antosik, Ladislav Thon, Libor Krzyzanek, Lovekesh Garg, Loïc Mathieu, luneo7, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Martin Kouba, Matej Novotny, Matej Vasek, Matthias Harter, Michal Szynkiewicz, Nathan Erwin, osaka-svg, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Kruger, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Samuel Le Berrigaud, Sanne Grinovero, seregamorph, Sergey Beryozkin, Simon Bengtsson, Stefan Hacker, Stephane Epardaud, Stuart Douglas, Thorasine, Vincent Sevel, Vincent Sourin, Vinod Anandan, xstefank, Xumk, Yoann Rodière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.9 comes with a lot of improvements on top of our existing feature set:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.9 では、既存の機能セットに対して多くの改良が加えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis clients are supported (as well as Sentinel connections)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の Redis クライアントのサポート (Sentinel 接続も同様)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, we also started &lt;&lt;quarkiverse,the Quarkiverse initiative&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後ですが重要なことに、 link:#quarkiverse[Quarkiverseの取組] も開始しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[our migration guide for 1.9].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか?ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9の移行ガイド] があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The biggest change is that the old datasource (JDBC and reactive) configuration that was deprecated in 1.3 is now gone.  So if your datasources don't work anymore, that's probably because you haven't migrated to the new configuration yet.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最大の変更点は、1.3 で非推奨となった古いデータソース (JDBC とリアクティブ) の設定がなくなったことです。ですから、もしあなたのデータソースが動作しなくなった場合、それはおそらくあなたがまだ新しい設定に移行していないことが原因です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 のフレーバーの GraalVM 20.2 が、推奨される GraalVM のバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.8 introduced a new Micrometer extension.  During the 1.9 development cycle, it matured a lot and is now the recommended way to collect metrics in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.8 では、新しく Micrometer エクステンションが導入されました。1.9 の開発サイクルの間に、このエクステンションは大きく発展し、現在では Quarkus でメトリクスを収集するための推奨される方法となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, you now get metrics for Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Kafka のメトリクスを取得できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Validation constraints are now taken into account for parameters and return values (`Uni` is supported but not `Multi`) of Reactive Routes methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean Validation 制約が Reactive Routes メソッドのパラメーターと戻り値 ( `Uni` はサポートされていますが、 `Multi` はサポートされていません) で考慮されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.4.0 which includes several improvements - including Cloud Event support for Kafka - and bugfixes and Mutiny to 0.9.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging は 2.4.0 にアップグレードされました。KafkaのCloud Event サポートを含むいくつかの改善、バグ修正などが含まれています。Mutinyは 0.9.0 へアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/quarkusio/quarkus/pull/12470[pull request description] lists the main changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/pull/12470[プルリクエストの説明] に主な変更点が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is now easier than ever to use Mutiny with the REST Client thanks to the `quarkus-rest-client-mutiny` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-rest-client-mutiny` エクステンションのおかげで、REST クライアントで Mutiny を使用することがこれまで以上に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation is our response to a recurring request from the community: having the ability to rollback changes made in a test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、コミュニティからの繰り返し要望のあった、テストで行われた変更をロールバックする機能への対応です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of annotating your test with `@Transactional` (which will persist the changes), annotate your test with `@TestTransaction` and the changes will be automatically rolled back at the end of the test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを (変更を持続させる) `@Transactional` でアノテーションするのではなく、テストを `@TestTransaction` でアノテーションすると、テストの最後に変更が自動的にロールバックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis Clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の Redis クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, you could only connect to one Redis instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは 1 つの Redis インスタンスにしか接続できませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with 1.9, you can connect to multiple instances.  Also Sentinel is now supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.9 からは、複数のインスタンスに接続できるようになりました。また、Sentinel にも対応しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now have a separate JAXP extension. Until now, it was intertwined with the JAXB extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAXP のエクステンションを別に用意するようになりました。今までは JAXB エクステンションと絡み合っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.22.Final and Hibernate Reactive to 1.0.0.Alpha10</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM が 5.4.22.Final に、Hibernate Reactive が 1.0.0.Alpha10 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] and https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus wouldn't be as successful if it weren't for its extension ecosystem.  In the beginning, we were adding all extensions to the core Quarkus repository, but eventually it became too much of an overhead or just not always sensible to include an extension into the core.  Some have since then created their own repositories external to Quarkus, but others just never happened because not everyone wants the overhead of maintaining a build setup while in other cases we actually had an idea for an extension but not solidified enough yet to be included in core (and consequently failed to find other community members interested and eager to help).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのエコシステムがなければ、Quarkus はこれほどの成功を収められなかったでしょう。当初は、すべてのエクステンションを Quarkus のコアリポジトリーに追加していました。しかし、最終的にはオーバーヘッドが大きすぎたり、エクステンションをコアに含めることが必ずしも賢明とは限らなくなってしまいました。それ以来、Quarkus の外部に独自のリポジトリーを作成した人もいますが、誰もがビルドセットアップを維持するためのオーバーヘッドを望んでいるわけではないので、それが実現しなかった人もいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse is a separate GitHub organization (https://github.com/quarkiverse) that offers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse は GitHub とは別の組織 (https://github.com/quarkiverse) で、以下を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inclusion in registry used by Quarkus tooling to browse extensions (i.e. code.quarkus.io, command line and IDE tools).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション (code.quarkus.io、コマンドライン、IDEツールなど) を参照するための Quarkus ツールで使用されるレジストリーへの収録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consistent formatting and release of projects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトの一貫したフォーマットとリリース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bigger Community outreach and a great place to collaborate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より大きなコミュニティのアウトリーチと素晴らしいコラボレーションの場</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to lead the development of an extension, see if it wasn't already https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[proposed on GitHub] or https://github.com/quarkusio/quarkus/issues/new/choose[create an Extension Proposal issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの開発をリードしたい場合は、 link:https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[GitHub でまだ提案されていないかどうか] を確認したり、 link:https://github.com/quarkusio/quarkus/issues/new/choose[エクステンションの提案課題を作成] してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A blog post is in the works and should give more details.  In the meantime, check out https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[the extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブログ記事を作成中ですので、そちらで詳細をお知らせします。それまでは、 link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[すでにある拡張機能] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[378 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus コミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[378人のコントリビューター] がいます。一人一人に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today we're proud to announce link:https://github.com/quarkiverse[Quarkiverse Hub], a GitHub organization where any contributor can host their Quarkus extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今日は、コントリビューターが誰でもQuarkusのエクステンションをホストできるGitHub Organizationである https://github.com/quarkiverse[Quarkiverse Hub]を発表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hosting your extension in the Quarkiverse Hub makes it available to all Quarkus users through the Quarkus tooling.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをQuarkiverse Hubでホスティングすると、Quarkusツールを介してすべてのQuarkusユーザーが利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So read on to discover more and find out how you can make your extension available to all Quarkus developers today!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細をお読みになり、すべてのQuarkus開発者が今すぐエクステンションを利用できるようにする方法をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特徴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering and publishing artifacts to Maven central can become a daunting task. In Quarkiverse that is automated by GitHub Actions, requiring no manual interaction with any command line tools.  Releasing an artifact is as simple as opening a pull-request changing the https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[`.github/project.yml`] file in the extension's repository.  Once the pull-request is merged, a GitHub action is triggered invoking `mvn release:prepare release:perform` and the extension is deployed to Maven central.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven centralに成果物を登録して公開するのは、大変な作業になることがあります。Quarkiverseでは、GitHub Actionsによって自動化されており、コマンドラインツールを使って手動で操作する必要はありません。アーティファクトのリリースは、プルリクエストを開いて  https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[.github/project.yml]ファイルを作成します。プルリクエストがマージされると、GitHub アクションがトリガーされて `mvn release:prepare release:perform` が呼び出され、エクステンションが Maven セントラルにデプロイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Core releases happen constantly and keeping up with the latest changes before a release is performed is crucial. Quarkiverse extensions are built daily against the latest https://github.com/quarkusio/quarkus[Quarkus core] using the https://github.com/quarkusio/quarkus-ecosystem-ci[Quarkus Ecosystem CI] and listed in the https://status.quarkus.io/[Quarkus Status] page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコアのリリースは常に行われており、リリースを実行する前に最新の変更点を把握しておくことは非常に重要です。Quarkiverseのエクステンションは、Quark https://github.com/quarkusio/quarkus-ecosystem-ci[us Ecosystem CI]を使用して最新の https://github.com/quarkusio/quarkus[Quarkusコア]に対して毎日ビルドされ、Quark https://status.quarkus.io/[usのステータス]ページに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkiverse-parent` artifact (inherited by each extension in Quarkiverse) enables plugins that will format your source code to the same format used in Quarkus core.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkiverse-parent` アーティファクト(Quarkiverseの各エクステンションに継承されています)は、プラグインがソースコードをQuarkusコアで使用されているのと同じフォーマットにフォーマットすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation aggregation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントの集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get your versioned extension documentation automatically published (including guides)! Quarkiverse Hub uses https://antora.org[Antora] to aggregate each extension documentation in the Quarkiverse docs website.  Although the layout is still a work in progress, you can check it out at https://quarkiverse.github.io/quarkiverse-docs/</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バージョン管理されたエクステンションドキュメント(ガイドを含む)を自動的に公開しましょう!Quarkiverse Hubでは、 https://antora.org[Antora]を使用して、Quarkiverse docsのウェブサイト内の各エクステンションドキュメントを集約しています。レイアウトはまだ作業中ですが、 https://quarkiverse.github.io/quarkiverse-docs/ で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automated inclusion in the upcoming Extension registry</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今後のエクステンションレジストリーへの自動インクルード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Extension registry is still a work in progress (https://registry.quarkus.io), but the gist of it is to have a single place to browse for extensions (including https://code.quarkus.io, command line and IDE plugins).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Extension レジストリーはまだ作業中ですが( https://registry.quarkus.io )、その要旨は、エクステンション ( https://code.quarkus.io 、コマンドライン、IDE プラグインを含む) を単一の場所で閲覧できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requirements</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to automate extension releases and publication of docs, there are some rules that need to be followed for projects under the Quarkiverse organization:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのリリースやドキュメントの公開を自動化するために、Quarkiverseの組織の下にあるプロジェクトでは、いくつかのルールに従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension repository should be named `quarkiverse-&lt;project&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのリポジトリの名前は `quarkiverse-&lt;project&amp;amp&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkiverse extension MUST belong to the `io.quarkiverse.&lt;project&gt;` groupId</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverseのエクステンションは、 `io.quarkiverse.&lt;project&gt;` groupIdに属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The root pom.xml MUST inherit from `io.quarkiverse:quarkiverse-parent`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルート pom.xml は `io.quarkiverse:quarkiverse-parent` を継承しなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *deployment*, *runtime* and *integration-test* directories containing the extension classes. See link:https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[How to create new extension modules using Maven] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*デプロイメント* 、 *ランタイム* 、および *統合テスト* のディレクトリーがエクステンションクラスを含みます。詳細は「 https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[Mavenを使って新しい拡張モジュールを作成する方法]」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*docs* (optional): The docs should follow the link:https://docs.antora.org/antora/2.3/standard-directories/[Antora's Standard File and Directory Set]. See an example link:https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[here].
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*docs* (オプション)。docsは https://docs.antora.org/antora/2.3/standard-directories/[Antoraの標準ファイルとディレクトリーセット]に従ってください。サンプルは https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[ここ] を参照して下さい。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, look at the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I sign-up?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どうやったら申し込めますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an *Extension Proposal* ticket in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] (first check if the extension you're proposing is not created yet) and let us know if you want to lead the development of this extension by commenting on the issue.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/issues[Quarkusの課題管理]で *エクステンション提案の* チケットを作成し(まず、提案しているエクステンションがまだ作成されていないかどうかを確認してください)、このエクステンションの開発をリードしたい場合は、イシューにコメントをつけてお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team will get you started with the boring stuff of setting up a brand new repository and deployment scripts, so you'll have fun coding it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusチームは、ブランドの新しいリポジトリやデプロイメントスクリプトを設定するという退屈な作業すませるので、あなたは楽しくコーディングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, we're always improving, so take a look at link:https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse] for the process we are currently using.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他と同様に、我々は常に改善していますので、現在使用しているプロセスについては、 https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What extensions are in Quarkiverse already?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkiverseにはどのようなエクステンションがあるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;amp;type=Repositories[すでにあるエクステンション]をチェックしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stay tuned for the latest info about Quarkiverse in the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]では、Quarkiverseの最新情報をご確認いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I reuse this setup for an extension outside the Quarkiverse organization?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をQuarkiverseの組織外のエクステンションに再利用することはできますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, right now we're in the process of documenting the extra steps to make your extension releases visible to our tooling in this case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、現在、外部のエクステンションのリリースを我々のツールから見えるようにするための追加のステップを文書化しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each Quarkus release, it's the same story: it comes with a ton of exciting new features and enhancements... But believe it or not, it's true.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのリリースのたびに、同じことが起きています:沢山の刺激的な新機能や機能強化が行われています、、信じられないかもしれませんが、本当です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Dev UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it also comes with many other enhancements be it for Micrometer, for jbang or for our Spring compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Micrometer、jbang、スプリング互換性レイヤーなどに対しても、他にも多くの機能強化が施されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And this release wouldn't be so great without all the people who tested our Betas and CR so a big thanks to everyone who participated in testing this release!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、このリリースはBetaとCRをテストしてくれた全ての人がいなければ、ここまで素晴らしいものにはならなかったでしょう。このリリースのテストに参加したすべての人に感謝します!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[our migration guide for 1.11].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか? link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11の移行ガイド]はこちらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3 in its Java 11 flavor is the newly recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11のフレーバーのGraalVM 20.3は、新たに推奨されているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive allows you to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、広く使用されている非常に強力な JAX-RS API を活用してアプリケーションの REST レイヤーを公開し、アプリケーションが達成できる最大スループットを大幅に向上させることができます。また、アプリケーションの起動がわずかに速くなり、メモリーの消費量が少し減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It got presented in great details by Georgios in https://quarkus.io/blog/resteasy-reactive/[the RESTEasy Reactive announcement].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは link:https://quarkus.io/blog/resteasy-reactive/[RESTEasy Reactiveの発表] の中で、Georgios氏によって非常に詳細に紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A detailed documentation is available in the link:/guides/resteasy-reactive[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細なドキュメントは、 link:/guides/resteasy-reactive[RESTEasy Reactiveガイド] にございます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the beginning of a great story: Quarkus 1.11 offers a UI dedicated to development to make it easier than ever.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは素晴らしい物語の始まりです。Quarkus 1.11では、開発をこれまで以上に簡単にする為に、特化したUIが提供されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each extension can expose features in this Dev UI, be it to list the CDI beans, list your endpoints, replay your Flyway migrations, deploy to OpenShift... Sky is the limit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各エクステンションは、CDI Beanのリスト、エンドポイントのリスト、Flywayマイグレーションのリプレイ、OpenShiftへのデプロイなど、このDev UIで機能を公開することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.11 introduces the infrastructure of this Dev UI and some features already.  If you are an extension developer or wants to do some frontend work, additions and improvements are very welcome.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.11では、このDev UIのインフラと、すでにいくつかの機能が提供されています。もしあなたがエクステンションの開発者であったり、フロントエンドの仕事をしたいと思っているなら、追加や改善は大歓迎です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Dev UI is available in dev mode only (e.g. `mvn quarkus:dev`) and accessible at the `/q/dev` endpoint by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI は開発モードでのみ利用可能で(例: `mvn quarkus:dev` )、デフォルトでは `/q/dev` エンドポイントからアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to add a feature to the Dev UI? Just have a look at link:/guides/dev-ui[our Dev UI guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI に機能を追加したいですか? link:/guides/dev-ui[Dev UI ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Micrometer support is continuously improving:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当社のMicrometer対応は常に改善しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Streams metrics are now exposed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams のメトリクスが公開されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registries were moved to extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーはエクステンションに移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for registries, the one for **Prometheus** is part of our Core extensions: `io.quarkus:quarkus-micrometer-registry-prometheus`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーに関しては、 **Prometheus** 用のものはCoreエクステンション: `io.quarkus:quarkus-micrometer-registry-prometheus` の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the registries are hosted in the Quarkiverse (our home for additional extensions):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>残りのレジストリーはQuarkiverseでホストされています(追加のエクステンションのためのホーム):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Monitor</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Monitor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datadog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Datadog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stackdriver</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Stackdriver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you feel like contributing to these registries or creating new ones, the https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registry project] is the place you are looking for.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのレジストリーに貢献したい、または新しいレジストリーを作成したいとお考えの方は、 link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registryプロジェクト] をご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Spring Data REST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using our Spring Data compatibility layer, you can now benefit from the Spring Data REST extension to simplify writing a CRUD REST layer.  It is very similar to our REST with Panache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>弊社のSpring Data互換レイヤーを使用している場合、Spring Data RESTエクステンションの恩恵を受けて、CRUD RESTレイヤーの記述を簡単にすることができます。これはREST with Panacheエクステンションと非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in link:/guides/spring-data-rest[the dedicated guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:/guides/spring-data-rest[専用のガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non application endpoints moved to `/q/`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のエンドポイントは `/q/` に移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes some technical endpoints that are not part of your application (for example, the Health endpoints).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、アプリケーションの一部ではない技術的なエンドポイント(Healthエンドポイントなど)をいくつか公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid conflicts with your application endpoints, they have all been moved to the `/q/` namespace.  Redirects have been added to redirect the old URLs to the new ones.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのエンドポイントとの衝突を避けるために、これらはすべて `/q/` 名前空間に移動されました。古い URL を新しい URL にリダイレクトするためのリダイレクトが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This root path can be customized with `quarkus.http.non-application-root-path`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このルートパスは、 `quarkus.http.non-application-root-path`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, it was only possible to inject the JPA `EntityManagerFactory` and `EntityManager` in your applications.  Starting with 1.11, you can inject the Hibernate ORM-specific `SessionFactory` and `Session` if you need to access their specific methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、JPA `EntityManagerFactory` と `EntityManager` をアプリケーションに注入することしかできませんでした。1.11 からは、Hibernate ORM 固有の `SessionFactory` と `Session` の特定のメソッドにアクセスする必要がある場合は、注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`FAIL_ON_UNKNOWN_PROPERTIES` is now disabled by default for the default CDI-enabled `ObjectMapper`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトで CDI で有効になっている `ObjectMapper` で `FAIL_ON_UNKNOWN_PROPERTIES` が無効になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See https://quarkus.io/guides/rest-json#jackson for more details about how to go back to the previous behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の動作に戻す方法については、 https://quarkus.io/guides/rest-json#jackson を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The integration with https://jbang.dev[jbang] now supports enabling development mode and can use Quarkus platforms (BOM) for version management.  For this you need to use jbang v0.62+.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://jbang.dev[jbang]との統合は、開発モードの有効化をサポートするようになり、バージョン管理にQuarkusプラットフォーム(BOM)を使用できるようになりました。このためには、jbang v0.62+を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run it, just pass in `-Dquarkus.dev`, i.e.:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行するには、 `-Dquarkus.dev` を渡すだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of `@pom` in the first line; that instructs jbang to load the pom for the platform and use it for version management and the other dependency versions can be left out.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の行で `@pom` を使用していることに注意してください。これは jbang にプラットフォーム用の pom をロードしてバージョン管理に使用するように指示しており、他のバージョン指定をしないで済むようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then with dev mode you can edit that file and save it again and Quarkus live reload feature will take care of applying the changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、開発モードでファイルを編集して再度保存すると、Quarkusのライブリロード機能が変更の適用の世話をしてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other dev mode features like `https://localhost:8080/q/dev` and `https://localhost:8080/q/swagger-ui` are also available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも `https://localhost:8080/q/dev` や `https://localhost:8080/q/swagger-ui` のような開発モードの機能が用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now this only works for single file jbang scripts, future releases will enable it to work for multiple files too.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、これは単一ファイルのjbangスクリプトに対してのみ動作しますが、将来のリリースでは複数のファイルに対しても動作するようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 20.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.11 is GraalVM 20.3.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.11に対するGraalVMの推奨バージョンはGraalVM 20.3です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final]の全変更履歴は GitHub で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[417 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[417人の貢献者] がいます。一人ひとりに多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.11 release, thanks to Alex Soto, Alexey Loubyansky, Amos Feng, Andy Damevin, Auri Munoz, Bill Burke, Bruno Gonçalves, Cem Nura, Chin Huang, Chris Laprun, Christian von Atzigen, Christoph Hermann, Clement Escoffier, cristhiank, David M. Lloyd, Davide D'Alto, Dejan Bosanac, Dennis Kieselhorst, Erin Schnabel, essobedo, Falko Modler, Foivos Zakkak, Galder Zamarreño, Geoffrey De Smet, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Henrique Prange, Ioannis Canellos, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, Jérôme TAMA, Kai Hudalla, Katia Aresti, kdnakt, Ken Finnigan, Ken Kwan, Kevin Viet, Knut Wannheden, Ladislav Thon, Loïc Mathieu, Lucca Biagi de Paula Prado, luneo7, Manyanda Chitimbo, Mark Little, Martin Kouba, Martin Panzer, Masafumi Miura, Matej Vasek, Max Rydahl Andersen, Mayank Kunwar, Michael Edgar, Michał Szynkiewicz, mrizzi, Nicolas Gimenez, nragon, Oscar, Peter Palaga, Phillip Kruger, Pierre Smeyers, Piotr Delert, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Rustam Sultansoy, Samuel Le Berrigaud, Sanne Grinovero, Saumya Singh, Sergey Beryozkin, Simon Bengtsson, Slava, Stuart Douglas, Stéphane Épardaud, Timothy Power, Viacheslav Medvediev, Vincent Sevel, Willem Jan Glerum, Yoann Rodière, Zach Kimberg, and Àngel Ollé Blázquez.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に 1.11 のリリースについては、以下の方々に感謝します: Alex Soto, Alexey Loubyansky, Amos Feng, Andy Damevin, Auri Munoz, Bill Burke, Bruno Gonçalves, Cem Nura, Chin Huang, Chris Laprun, Christian von Atzigen, Christoph Hermann, Clement Escoffier, cristhiank, David M. Lloyd, Davide D'Alto, Dejan Bosanac, Dennis Kieselhorst, Erin Schnabel, essobedo, Falko Modler, Foivos Zakkak, Galder Zamarreño, Geoffrey De Smet, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Henrique Prange, Ioannis Canellos, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, Jérôme TAMA, Kai Hudalla, Katia Aresti, kdnakt, Ken Finnigan, Ken Kwan, Kevin Viet, Knut Wannheden, Ladislav Thon, Loïc Mathieu, Lucca Biagi de Paula Prado, luneo7, Manyanda Chitimbo, Mark Little, Martin Kouba, Martin Panzer, Masafumi Miura, Matej Vasek, Max Rydahl Andersen, Mayank Kunwar, Michael Edgar, Michał Szynkiewicz, mrizzi, Nicolas Gimenez, nragon, Oscar, Peter Palaga, Phillip Kruger, Pierre Smeyers, Piotr Delert, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Rustam Sultansoy, Samuel Le Berrigaud, Sanne Grinovero, Saumya Singh, Sergey Beryozkin, Simon Bengtsson, Slava, Stuart Douglas, Stéphane Épardaud, Timothy Power, Viacheslav Medvediev, Vincent Sevel, Willem Jan Glerum, Yoann Rodière, Zach Kimberg, and Àngel Ollé Blázquez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I had the question multiple times: how do I use Eclipse Vert.x in Quarkus? Indeed, you can use Vert.x in Quarkus.  You can deploy _verticles_, communicate with the event bus, or use anything from the Vert.x ecosystem.  But, you can also use the Mutiny variant of Vert.x in Quarkus, and get a seamless experience with the other reactive APIs offered by Quarkus.  Several posts have already mentioned this, but it deserves a specific blog post.  So, here we are.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>よく次の質問をされます:「QuarkusでEclipse Vert.xを使うにはどうすればいいですか?」確かに、QuarkusではVert.xを使用することができます。 _Verticles_ をデプロイしたり、イベントバスと通信したり、Vert.xエコシステムのものなら何でも使えます。しかし、QuarkusでVert.xのMutinyバリアントを使用して、Quarkusが提供する他のReactive APIとシームレスな体験を得ることもできます。これについてはすでにいくつかの記事で触れていますが、具体的なブログ記事に値する内容です。というわけで、ここで紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse Vert.x</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit to build reactive applications.  The Vert.x ecosystem is enormous.  From HTTP and data access abilities to messaging clients via microservice and security facilities, the Vert.x ecosystem is remarkably diverse and versatile.  To understand that variety, just check the https://vertx.io/docs/[Vert.x documentation].  That makes Vert.x popular in many areas such as web applications, IoT gateways, banking applications and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://vertx.io[Vert.x] はリアクティブなアプリケーションを構築するためのツールキットです。Vert.x のエコシステムは膨大です。HTTP やデータアクセス機能からマイクロサービスやセキュリティー機能を介したメッセージングクライアントまで、Vert.x のエコシステムは非常に多様で汎用性に富んでいます。その多様性を理解するには、Vert https://vertx.io/docs/[Vert.xのドキュメント]をチェックしてください。そのため、Vert.xはWebアプリケーション、IoTゲートウェイ、銀行アプリケーションなど、多くの分野で人気があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you may know, Quarkus is based on Vert.x.  Under the hood, there is a managed Vert.x instance that powers the rest of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご存知のように、QuarkusはVert.xをベースにしています。裏側では、マネージドのVert.xのインスタンスが存在し、Quarkusに力を与えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus serves a HTTP endpoint, under the hood, there is a Vert.x HTTP server handling the request and response.  That's also true for messaging, gRPC and almost any I/O.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusがHTTPエンドポイントを提供する場合、フードの下には、リクエストとレスポンスを処理するVert.x HTTPサーバーがあります。これは、メッセージング、gRPC、およびほぼすべてのI/Oにも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vert.x "bare" API and friends</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.xの「素の」APIとその仲間たち</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x provides multiple APIs.  Let's focus on the "bare" one for now.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.xは複数のAPIを提供しています。ここでは「素」のものに注目してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the reactive nature of Vert.x, the API contains mostly asynchronous methods.  These methods are following a syntax convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x のリアクティブな性質にしたがって、API のほとんどを非同期メソッドが占めています。これらのメソッドは構文規則に従っています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part is the last parameter.  It's a function, a callback to be more precise, that gets called when the operation completes or fails.  Indeed, the asynchronous nature of Vert.x does not allow using `try/catch` blocks.  So you need to pass a continuation callback, invoked with the outcome.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>興味深いのは最後のパラメーターです。これは関数、より正確にはコールバックで、操作が完了したときや失敗したときに呼び出されます。実際、Vert.xの非同期の性質上、 `try/catch`  ブロックを使用することはできません。そのため、結果に応じて呼び出される継続コールバックを渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AsyncResult` is a structure capturing this outcome.  It contains the result (of type `&lt;T&gt;`) produced by the operation, or the failure if it failed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AsyncResult`  は、この結果をキャプチャする構造体です。これは、操作によって生成された結果 ( `&lt;T&gt;`  型)、または失敗した場合の失敗を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を挙げてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code reads a file, and as it's an asynchronous operation, invokes the callback when the file is read.  The `readFile` method reads the complete content of the file and accumulates it in a _buffer_.  The callback receives the asynchronous result containing either the file's content (`ar.result()`) or a failure.  Vert.x invokes this callback when the operation has either completed or failed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコードはファイルを読み込み、非同期操作であるため、ファイルが読み込まれたときにコールバックを呼び出します。 `readFile`  メソッドは、ファイルの完全な内容を読み込み、 _バッファ_ に蓄積します。コールバックは、ファイルの内容 ( `ar.result()` ) または失敗を含む非同期の結果を受け取ります。Vert.x は、操作が完了または失敗したときにこのコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x also supports streams thanks to the `ReadStream` and `WriteStream` classes.  A `ReadStream` represents a stream of data you can read.  So you can attach a callback invoked on every item traversing the stream.  A `WriteStream` is a data source.  You can push items to a `WriteStream.` These items will be consumed by a `ReadStream`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x は `ReadStream`  と `WriteStream`  クラスのおかげでストリームもサポートしています。 `ReadStream`  は読み込み可能なデータのストリームを表します。そのため、ストリームを通過するすべての項目で呼び出されるコールバックをアタッチすることができます。 `WriteStream`  はデータソースです。アイテムを `WriteStream.`  にプッシュすることができます。 これらのアイテムは `ReadStream`  によって消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x streams do not implement Reactive Streams.  Vert.x provides a different back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x ストリームは、Reactive Streams を実装していません。Vert.x は別のバックプレッシャープロトコルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why are these API shaping rules important? Vert.x does not provide a single API.  The "bare" API presented above is just one of the proposed API.  It also provides API in Kotlin, API for RX Java, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜこれらの API シェーピングルールが重要なのか?Vert.xは単一のAPIを提供していません。上で紹介した「素の」APIは、提案されているAPIの1つに過ぎません。他にもKotlinでのAPIやRX JavaでのAPIなども提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These APIs are **generated**.  Vert.x provides a code generator that _ translates_ the Vert.x "bare" API into the other APIs.  Because all methods are well-formed, the generator understands how they should be adapted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの API は *生成され* ます。Vert.x は、Vert.x の "むき出しの" API を他の API に変換するコード ジェネレーターを提供します。すべてのメソッドは整形されているので、ジェネレータはどのように適応されるべきかを理解しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated code exposes a different API; each method delegating to the "bare" API.  Asynchronous methods and streams can follow different transformations, so the resulting API uses the right idioms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたコードは、異なる API を公開しており、各メソッドは「素」の API にデリゲートします。非同期メソッドとストリームは異なる変換を行うことができるので、生成されたAPIは適切なイディオムを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven reactive programming library.  It's not related to Vert.x.  However, we have written a code generator that generates the Mutiny variant for the Vert.x API:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。Vert.xとは関係ありませんが、Vert.x API用のMutiny版を生成するコードジェネレータを書いています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/mutiny.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;span class="image"&gt;&lt;img src="/assets/images/posts/mutiny-vertx/mutiny.png" alt="mutiny"&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transformations are straightforward:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>変換は簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx` package =&gt; `io.vertx.mutiny` package</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.vertx`  パッケージ ⇒ `io.vertx.mutiny`  パッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous methods =&gt; method returning a `Uni&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メソッド⇒メソッドが返す `Uni&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReadStreams&lt;T&gt;` =&gt; can be consumed as `Multi&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReadStreams&lt;T&gt;`  ⇒消費することができます。 `Multi&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WriteStreams&lt;T&gt;` =&gt; can be consumed as Reactive Streams `Subscriber&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`WriteStreams&lt;T&gt;` ⇒ リアクティブストリームとして消費することができます。 `Subscriber&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also adapts the Vert.x back pressure protocol to Reactive Streams, as Mutiny implements Reactive Streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、MutinyがReactive Streamsを実装しているため、Vert.xのバックプレッシャープロトコルをReactive Streamsに適応させています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the first example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、上から1番目の例では、次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One difference between the two APIs is related to laziness. The Vert.x "bare" API triggers the operation as soon as the method is called.  The Mutiny variant expects a subscription to trigger the operation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つのAPIの違いの1つは、怠惰性に関連しています。Vert.x の "素の" API は、メソッドが呼び出されるとすぐに操作をトリガーします。Mutiny 版では、操作をトリガーするためにサブスクリプションを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The stream example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上からのストリームの例は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit more than this</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう少し補足</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny variant does not only apply the rules exposed in the previous section.  For asynchronous methods, it also provides:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny版は、前のセクションで公開されたルールを適用するだけではありません。非同期メソッドに対しても提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndAwait()` methods - blocks the caller thread until the outcome is received. In the case of a failure, throws a `RuntimeException`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`xAndAwait()`  メソッド - 結果を受け取るまで呼び出し元のスレッドをブロックします。失敗した場合は `RuntimeException` を発生させます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndForget()` methods - triggers the operation, discard the outcome</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`xAndForget()`  methods - 操作をトリガし、結果を破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can we find this API?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このAPIはどこにありますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment of writing, we only provide Vert.x core and Vert.x clients (MongoDB, Redis, Web client, Mqtt, and so on).  We are extending the support to cover the full Vert.x stack.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>執筆時点では、Vert.xコアとVert.xクライアント(MongoDB、Redis、Webクライアント、Mqttなど)のみを提供しています。私たちはVert.x スタック全体をカバーするようにサポートを拡張しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the Mutiny clients, you need to add the right dependency to your project.  Browse https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[the list of dependency] to pick the one you need.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyクライアントを使用するには、適切な依存関係をプロジェクトに追加する必要があります。 https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[依存関係のリスト]を見て、必要なものを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to you use the Mutiny variant of the Vert.x Web client, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Vert.x Web クライアントの Mutiny 版を使用するには、以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have the dependency, just create the web client instance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係ができたら、あとはWebクライアントのインスタンスを作成するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Something missing? Open an issue on https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何か足りないものがあった場合は、 https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils] に課題を提起してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Javadoc is available http://smallrye.io/smallrye-reactive-utils/apidocs/[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javadocは http://smallrye.io/smallrye-reactive-utils/apidocs/[こちら] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The road ahead: Vert.x 4!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今後の道:Vert.x 4!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x 4 is coming soon! We are already working in Quarkus and the different satellite projects to migrate.  With Vert.x 4, a new generator has been implemented (following the same code generation approach), paving the road to a smooth upgrade.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x 4が間もなく登場します!既にQuarkusと異なるサテライトプロジェクトで移行作業を行っています。Vert.x 4では、新しいジェネレータが実装されており(同じコード生成アプローチを踏襲しています)、スムーズなアップグレードへの道が開かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: Next Monday (8th Feb 21), we will do Quarkus Insights based on your questions.
author: maxandersen
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: 来週の月曜日(2月8日)は、ご質問をもとにQuarkus Insightsを行います。
author: maxandersen
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the next Quarkus Insights episode, we are trying something new.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のQuarkus Insightsのエピソードでは、新しいことを試しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will cover the most often asked questions we have seen and any question tagged with `#quarkusinsights` on our various social media presences: https://twitter.com/search?q=%23quarkusinsights[Twitter], https://www.facebook.com/hashtag/quarkusinsights/[Facebook], https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] or on the https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtube event] directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、私たちが見てきた最も頻繁に質問された質問や、私たちの様々なソーシャルメディアで `#quarkusinsights` とタグ付けされた任意の質問をカバーします( link:https://twitter.com/search?q=%23quarkusinsights[Twitter] 、 link:https://www.facebook.com/hashtag/quarkusinsights/[Facebook] 、 link:https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] 、または link:https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtubeイベント] で直接)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a question about Quarkus you would like answered let us know on one of thoses sites.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>答えてほしいQuarkusに関する質問がある場合は、以下のいずれかのサイトでお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See you all Monday!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>月曜日にお会いましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloudevents.io/[Cloud Events] is a specification for describing events.  It aims to ease interoperability.  With the rise of event-driven architecture, it's not surprising to see Cloud Events gaining popularity.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://cloudevents.io/[クラウドイベントは]、イベントを記述するための仕様です。相互運用性を容易にすることを目的としています。イベント駆動型アーキテクチャの台頭により、Cloud Eventsの人気が高まっているのは驚くに値しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post explains how you can generate and consume Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを生成して消費する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Cloud Event?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントとは?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's look at the why.  Events are everywhere.  Many modern systems are using events one way or another.  Events can be used to implement event sourcing, communicate facts, trigger out-of-band processing, or send notifications.  Events become an essential piece of any system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは「なぜ」を見てみましょう。イベントはどこにでもあります。最近のシステムの多くは、何らかの方法でイベントを使用しています。イベントは、イベントソーシングの実装、事実の伝達、帯域外処理のトリガー、通知の送信などに使用できます。イベントはどんなシステムにも欠かせないものとなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yet event publishers tend to describe events differently.  I don't mean the content is different, but the envelope and the event's format are heterogeneous, even if these events transit on the same event mesh.  Some applications choose JSON and encode everything in the event's payload; some other systems prefer binary formats, such as Avro or Protobuf, and use the protocol capability, such as headers or properties, to transport metadata about the wrapped payload.  While event-driven architecture claims to ease the integration with external systems, this disparity is doing the opposite.  It's not rare to need a specific event translator with the only purpose to adapt events from one format to another.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、イベント発行者はイベントを異なる形で表現する傾向があります。内容が違うという意味ではありませんが、エンベロープとイベントのフォーマットは異種混在で、たとえこれらのイベントが同じイベントメッシュ上を通過するとしてもです。アプリケーションの中には JSON を選択してイベントのペイロードにすべてをエンコードするものもあれば、Avro や Protobuf のようなバイナリー形式を好み、ヘッダやプロパティーのようなプロトコル機能を使って、ラップされたペイロードに関するメタデータを転送するものもあります。イベント駆動型アーキテクチャは外部システムとの統合を容易にすると主張していますが、この不均衡はその逆を行っています。イベントをあるフォーマットから別のフォーマットに適応させることだけを目的とした特定のイベントトランスレータを必要とすることは珍しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, what's Cloud Event? Cloud Event proposes a common way to describe events.  The goal is, obviously, interoperability and easing the integration burden.  Cloud Event 1.0 was released almost a year ago.  Over the past year, many Cloud Providers adopted this format, such as Azure and Oracle.  Several middlewares have also added support for Cloud Events, such as Knative, Kogito, Debezium, and Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、クラウドイベントとは何か?クラウドイベントは、イベントを記述するための共通の方法を提案しています。目的は明らかに相互運用性と統合負担の軽減です。クラウドイベント1.0はほぼ1年前にリリースされました。この1年で、AzureやOracleなど、多くのクラウドプロバイダーがこの形式を採用しました。また、Knative、Kogito、Debezium、Quarkusなど、いくつかのミドルウェアがクラウドイベントのサポートを追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me some examples!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を見せてください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, so, how does it look? The easiest way to understand Cloud Event is to look at one of them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さてさて、どんな感じでしょうか?クラウドイベントを理解する一番簡単な方法は、そのうちの一つを見てみることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This event is described in JSON, but that's just one of the possibilities.  Let's look at the fields.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このイベントはJSONで記述されていますが、それは可能性の一つに過ぎません。フィールドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the `specversion` indicates which version of Cloud Event it is using (1.0).  The `id` field provides an id for that specific event.  The `source` attribute is a URI identifying the event source, i.e., the context in which an event happened or the application that emitted that specific event.  Combining the `id` and the `source` provides a unique identifier.  Such uniqueness is essential to implement idempotence and handle potential duplicates.  The `type` is the last mandatory attribute.  It indicates the _type_ of the event.  Here, I use the fully qualified class name, but you can imagine anything.  It should refer to the kind of event you have defined in your system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、 `specversion`  は、使用しているクラウドイベントのバージョン(1.0)を示しています。 `id`  フィールドは、その特定のイベントの ID を提供します。 `source`  属性は、イベントソースを識別する URI であり、イベントが発生したコンテキストや、特定のイベントを発生させたアプリケーションを示します。 `id`  と `source`  を組み合わせることで、一意な識別子が得られます。このような一意性は、冪等性を実装し、潜在的な重複を処理するために不可欠です。 `type`  は最後の必須属性です。これはイベントの _タイプ_ を示します。ここでは完全修飾クラス名を使用していますが、何を想像しても構いません。システムで定義されているイベントの種類を参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other attributes are optional.  `datacontenttype` defines the content-type of the `data` attribute.  `subject` allows passing extra details about the event, such as an additional hint about the context or the type of event.  `time` is a timestamp, generally indicating the creation time.  There is another optional attribute not used in my example.  The `dataschema` attribute lets you pass the schema of the event data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`datacontenttype`  は `data`  属性の content-type を定義します。 `subject`  では、コンテキストやイベントのタイプに関する追加のヒントなど、イベントに関する追加の詳細を渡すことができます。 `time`  はタイムスタンプで、一般的には作成時刻を示します。私の例では使用していない別のオプションの属性があります。 `dataschema`  属性は、イベントデータのスキーマを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `data` attribute contains the wrapped business event.  It is an essential part, and the other attributes are just providing details about that specific business event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`data`  属性には、ラップされたビジネスイベントが含まれています。これは本質的な部分であり、他の属性はその特定のビジネスイベントについての詳細を提供しているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also define _extensions_.  These extensions would be a set of custom attributes used when the proposed set of attributes is not enough for your use case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_拡張_ を定義することもできます。これらの拡張は、提案された属性のセットがユースケースに十分でない場合に使用されるカスタム属性のセットになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's it! So, we can summarize Cloud Events as _just enough metadata to understand an event_ - its source, an id, a type, and the business data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これだ!これだ!と思ったイベントをまとめてみました。ということで、クラウドイベントを、 _イベントを理解するために必要な最低限のメタデータ、つまり、イベントの_ ソース、ID、タイプ、ビジネスデータとしてまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Events on the wire - the bindings</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>転送におけるクラウドイベント - バインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, how would these events be encoded? The previous example using JSON is nice, but some protocols may want to leverage their own capabilities to transmit these metadata.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、これらのイベントはどのようにエンコードされるのでしょうか?JSON を使った先ほどの例もいいですが、プロトコルによっては、独自の機能を活用してこれらのメタデータを送信したい場合もあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's why Cloud Events also proposes bindings.  A binding is a set of recommendations specific to one protocol.  It explains how each protocol should encode Cloud Events.  For example, there is a binding for HTTP, one for Kafka, and another for AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、Cloud Eventsではバインディングも提案しています。バインディングとは、あるプロトコルに固有の推奨事項のセットです。各プロトコルがどのようにCloud Eventsをエンコードすべきかを説明します。例えば、HTTP用のバインディング、Kafka用のバインディング、AMQP用のバインディングがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of these bindings propose two approaches:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのバインディングのほとんどは、2つのアプローチを提案しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>structured</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>structured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>binary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>binary</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach keeps event metadata and data together in the payload of the message or request.  It generally uses JSON to encode that data.  If you pass the Cloud Event example (from above), in an HTTP request, it will use the structured mode.  It will also use the structured mode when you write that JSON snippet in a Kafka record's value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構造化されたアプローチは、イベントのメタデータとデータをメッセージやリクエストのペイロードにまとめて保持します。一般的には JSON を使用してデータをエンコードします。Cloud Event の例 (上記) を HTTP リクエストで渡すと、構造化モードを使用します。また、Kafka レコードの値にその JSON スニペットを書き込む場合も構造化モードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach allows simple forwarding across multiple protocols.  However, it may not be efficient and may constraint the type of business data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構造化されたアプローチでは、複数のプロトコルをまたいで簡単に転送することができます。しかし、効率的でない場合があり、ビジネスデータの種類を制約する場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other approach relies on protocol capabilities and enables efficient transfer and encoding.  If we use the binary mode with Kafka, we will store the `data` attribute value in the Kafka record's value and pass the other attributes using the record's headers.  Consequently, business data can be encoded using binary protocols such as Avro, leading to higher efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つのアプローチはプロトコルの能力に依存しており、効率的な転送とエンコードを可能にします。Kafkaでバイナリーモードを使用する場合、Kafkaレコードの値に `data`  属性の値を格納し、レコードのヘッダを使用して他の属性を渡すことになります。その結果、Avroなどのバイナリープロトコルを使ってビジネスデータをエンコードすることができ、効率化につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the post explains how you can send and receive Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>残りの記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを送受信する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Cloud Events on Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントをKafkaで送信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector used by Quarkus has built-in support for Cloud Events.  It can send and consume Cloud Events using the structured mode (encoding everything in a JSON payload) or the binary mode (using Kafka headers).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusが使用するKafkaコネクタは、Cloud Eventsをビルトインでサポートしています。構造化モード(JSONペイロードですべてをエンコード)またはバイナリーモード(Kafkaヘッダーを使用)を使用して、クラウドイベントを送信したり消費したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write your outgoing messages as Cloud Event, you only need to specify the `cloud-events-type` and `cloud-events-source` attributes on your channel:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信メッセージをクラウドイベントとして記述するには、チャンネルに `cloud-events-type`  と `cloud-events-source`  属性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector writes Cloud Events using the binary mode.  The connector generates a random `id` for each message.  You can also customize the other Cloud Event attributes using `cloud-events-$attribute`, such as `cloud-events-subject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、コネクタはバイナリーモードを使用してクラウドイベントを書き込みます。コネクタはメッセージごとにランダムな `id`  を生成します。 `cloud-events-$attribute`  を使用して、 `cloud-events-subject`  などの他のクラウドイベント属性をカスタマイズすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration shown above is applied to all the outgoing messages.  Sometimes, you want to customize the value for each message individually.  To achieve this, you can also attach `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` to your message to customize the id, source, type and subject for each message:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の設定は、すべての送信メッセージに適用されます。場合によっては、各メッセージの値を個別にカスタマイズしたいこともあるでしょう。これを実現するには、メッセージに `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata`  を添付して、各メッセージの id、ソース、タイプ、件名をカスタマイズすることもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector also supports the _structured_ mode.  You can write structured Cloud Events by setting the `cloud-events-mode` attribute to `structured`.  It only supports JSON at the moment.  The written record gets its `content-type` header set to `application/cloudevents+json; charset=UTF-8`, which allows the receiver to understand that it's a structured Cloud Event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コネクタは _構造化_ モードもサポートしています。 `cloud-events-mode`  属性を `structured`  に設定することで、構造化された Cloud Events を書くことができます。現時点では JSON のみサポートしています。書き込まれたレコードの `content-type`  ヘッダーは `application/cloudevents+json; charset=UTF-8`  に設定され、これにより受信者はそれが構造化されたクラウドイベントであることを理解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Cloud Event from Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントをKafkaから消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, the connector can also consume Cloud Events.  The connector detects Cloud Events automatically by checking the record's headers.  It also determines the mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当然のことながら、コネクタはクラウドイベントを消費することもできます。コネクタは、レコードのヘッダをチェックすることで、自動的にクラウドイベントを検出します。また、モードも決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the connector receives a Cloud Event, it attaches an `IncomingKafkaCloudEventMetadata` to the message metadata.  So, you can retrieve the various attributes as well as the extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コネクタはクラウドイベントを受信すると、メッセージのメタデータに `IncomingKafkaCloudEventMetadata`  をアタッチします。そのため、拡張だけでなく様々な属性を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the rise of event-driven architecture, Cloud Events are becoming highly popular.  Since Quarkus 1.9, the Kafka Connector used in Quarkus has built-in support for Cloud Events.  This post introduced Cloud Events and showed how you could write and read Cloud Events easily.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント駆動型アーキテクチャの台頭に伴い、クラウドイベントの人気が高まっています。Quarkus 1.9以降、Quarkusで使用されているKafka ConnectorはCloud Eventsをビルトインでサポートしています。この投稿では、Cloud Eventsを紹介し、Cloud Eventsを簡単に書いたり読んだりする方法を紹介しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many more options are http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[available], and Kafka is not the only part of Quarkus with Cloud Events support.  For example, Funqy[https://quarkus.io/guides/funqy#context-injection] also supports Cloud Event out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも多くのオプションが http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[用意]されており、KafkaだけがクラウドイベントをサポートしているQuarkusの一部ではありません。例えば、Funqy https://quarkus.io/guides/funqy#context-injection ]もクラウドイベントをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.3.0 release of Quarkus Tools for IntelliJ.  This release brings codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Tools for IntelliJの1.3.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードにcodestartsのサポートが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard adds a new codestarts option, allowing to enable/disable codestarts generation for Quarkus extensions that support this feature.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトウィザードに新しいcodestartsオプションが追加され、この機能をサポートするQuarkusエクステンションのcodestarts生成を有効/無効にすることができるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.2.Final released - Bugfixes'
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.2.Final リリース - バグ修正
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final では問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.2.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.2.Final は、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to Hibernate ORM 5.4.27.SP1 which fixes an important issue, potentially causing data losses.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM 5.4.27.SP1 にアップグレードし、データ損失を引き起こす可能性のある重要な問題が修正されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the upgrade is highly recommended.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>したがって、アップグレードを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full changelog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[the full changelog of 1.11.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[GitHub 上で 1.11.2.Final の完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We took a little break, but now another Newsletter round of stories found!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>少しお休みをとっていましたが、かなりの量の見つかったストーリーのニュースレターを発行します!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the news below - give it a read and if you feel something is missing or have an article coming out for future Quarkus Newsletter install the https://github.com/quarkusio/url2quarkuspub[bookmarklet] on your laptop and phone to easily submit a story. If you prefer the manual way please https://github.com/quarkusio/quarkusio.github.io/issues[open an issue] with a short description and a url.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のニュースを読んで、もし、何かが欠けていると感じたり、将来のQuarkus ニュースレターのために記事をお持ちの場合は、 link:https://github.com/quarkusio/url2quarkuspub[ブックマークレット] をラップトップやスマートフォンにインストールして、簡単に記事を投稿することができます。あなたが手動の方法を好む場合は、短い説明とURLを link:https://github.com/quarkusio/quarkusio.github.io/issues[Issueを登録] してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>楽しんで!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.3.Final released - Bugfixes'
date: 2020-12-08
tags: release
synopsis: 1.10.3.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.10.3.Finalリリース - バグフィックス
date: 2020-12-08
tags: release
synopsis: 1.10.3.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.3.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.3.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it really helped a lot!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題を報告し、再現手順を提供してくれたすべてのコントリビューターに感謝します。非常に助かりました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[the full changelog of 1.10.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[GitHub上の1.10.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.1.Final released - Bugfixes'
date: 2021-01-27
tags: release
synopsis: 1.11.1.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.1.Finalリリース - バグフィックス
date: 2021-01-27
tags: release
synopsis: 1.11.1.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.1.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it allowed us to make steady progress on fixing issues.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題点を報告し、再現手順を提供してくれたすべての貢献者に感謝します。問題の修正の確かな進捗に繋がりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also a big thanks to all the contributors providing pull requests, be they for the code or the documentation!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コードであれドキュメントであれ、プルリクエストを提供してくれたすべての貢献者にも感謝しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.1.Finalは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended GraalVM version is now GraalVM 20.3.1.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの推奨バージョンはGraalVM 20.3.1になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[the full changelog of 1.11.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[GitHubで1.11.1.Finalの完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of this blog post is to clear up some confusion about RESTEasy Reactive and answer some commonly asked questions around it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このブログ記事の目的は、RESTEasy Reactive についての混乱を解消し、よくある質問に答えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>謝辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and Reactive: the elevator pitch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令型とリアクティブ型: エレベーターピッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our quest to understand why RESTEasy Reactive is important and how it differs from RESTEasy Classic, it helps to paraphrase a very important message that was first introduced https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が重要な理由と、RESTEasy Classic と異なる点を理解するために、link:https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[ここ] で最初に紹介した非常に重要なメッセージを再び考察してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Java web applications use imperative programming combined with blocking IO operations. This is incredibly popular because it is easier to reason about the code.  Things get executed sequentially. When the application receives a request, the framework associates this request to a worker thread.  When the request processing needs to interact with a database or another remote service, it relies on blocking IO.  The thread is blocked waiting for the answer, making the communication synchronous. With this model one request is not affected by another as they are run on different threads.  Even when one thread is waiting, other requests running on different threads are not slowed down significantly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的に、Java のWeb アプリケーションでは、ブロッキング IO 操作と組み合わせた命令型プログラミングを使用します。これは、コードを推論するのが簡単なので、非常に人気があります。物事は順次実行されます。アプリケーションがリクエストを受け取ると、フレームワークはこのリクエストをワーカースレッドに関連付けます。リクエスト処理がデータベースや他のリモートサービスと対話する必要があるときは、ブロッキング IO に依存します。スレッドは応答を待ってブロックされ、通信を同期化します。このモデルでは、1 つのリクエストは別のスレッドで実行されるので、別のリクエストの影響を受けません。1 つのスレッドが待機している場合でも、異なるスレッド上で実行されている他のリクエストが大幅に遅くなることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, with this model, you need one thread for every concurrent request, which places a limit on the achievable concurrency.  On the other side, the reactive execution model embraces asynchronous development models and non-blocking IO.  With this model, multiple requests can be handled by the same thread. When the processing of a request can no longer make progress (because it requests a remote service, or interacts with a database for example), it uses non-blocking IO.  Instead of blocking the thread, it schedules the operation and passes a continuation which would be invoked after the completion of the operationfootnote:[This article won’t detail how operating systems and non-blocking IO libraries enable such a model. Under the hood, kernel mechanisms such as select, epoll and ICMP are making the handling of IO very efficient, in terms of speed and resource utilization.].  This releases the thread immediately, which can then be used to serve another request. When the result of the IO operation is available, the processing of the request is resumed and continues its execution.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、このモデルでは、同時実行リクエストごとに1つのスレッドが必要となり、達成可能な同時実行性に制限が生じます。一方、リアクティブ実行モデルでは、非同期開発モデルとノンブロッキング IO を採用しています。このモデルでは、複数のリクエストを同じスレッドで処理することができます。(リモートサービスをリクエストしたり、データベースと対話したりするために) リクエストの処理が進まなくなった場合は、ノンブロッキング IO を使用します。スレッドをブロックする代わりに、操作をスケジュールし、操作の完了後に呼び出される継続を渡します footnote:[この記事ではOSとノンブロッキング IO ライブラリがどのようにそういったモデルを実現しているかの詳細には踏み込みません。内部的に、select、epoll、ICMPといったカーネルメカニズムがIO処理をスピードとリソース利用の観点で非常に効率的にしています]。これによりスレッドはすぐに解放され、別のリクエストに対応するために使用することができます。IO 操作の結果が利用可能になると、リクエストの処理が再開され、その実行が継続されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This model enables the usage of a single IO thread to handle multiple requests. There are three significant benefits.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このモデルでは、単一の IO スレッドを使用して複数のリクエストを処理することができます。3 つの大きなメリットがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the response time is smaller because it does not have to jump to another thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、別のスレッドにジャンプする必要がないので、レスポンス時間が短くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, it reduces memory consumption as it decreases the usage of threads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第 2 に、スレッドの使用量が減るため、メモリーの消費量を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Third, your concurrency is no longer limited by the number of threads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第 3 に、並行処理はスレッド数に制限されなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive model uses the hardware resources more efficiently, but... a significant pitfall lurks. If the processing of a request starts to block, things can go south really quickly as no other request can be handled. To avoid this, you need to learn how to write asynchronous and non-blocking code, how to schedule operations, how to write continuations, how to chain actions.  Basically, we need a way to structure asynchronous processing, and use non-blocking IO. No doubt, that consists of a paradigm shift.  In Quarkus, we want to make the shift as easy as possible, so RESTEasy Reactive allows you to choose whether an endpoint is blocking or non-blocking (an application is free to mix and match blocking and non-blocking methods at will).  So don’t be intimidated by the reactive word, the infrastructure is reactive, but your code can be either reactive or imperative. That’s what we mean by unification of reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブモデルはハードウェアリソースをより効率的に使用しますが、重大な落とし穴が潜んでいます。もしリクエストの処理がブロックされ始めると、他のリクエストが処理できなくなるため、本当にすぐに事態が悪化してしまいます。これを避けるためには、非同期でノンブロッキングなコードの書き方、操作のスケジュールの立て方、連続処理の書き方、アクションの連鎖の仕方などを学ぶ必要があります。基本的には、非同期処理を構造化し、ノンブロッキングIOを使う方法が必要です。これは間違いなく、パラダイムシフトであることは間違いありません。Quarkusでは、このシフトをできるだけ簡単にしたいと考えているので、RESTEasy Reactiveでは、エンドポイントがブロッキングかノンブロッキングかを選択することができます (アプリケーションはブロッキングとノンブロッキングのメソッドを自由に組み合わせて使用することができます)。インフラストラクチャはリアクティブですが、あなたのコードはリアクティブ型にも命令型にもなり得ます。これが、リアクティブ型と命令型の統一の意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive by default handles each HTTP request on an IO thread (otherwise known as an event-loop thread)footnote:[More information about the execution model of RESTEasy Reactive can be found https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[here]].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、デフォルトでは IO スレッド(イベントループスレッドとして知られている)上の各 HTTP リクエストを処理します footnote:[RESTEasy Reactiveの実行モデルについて詳細は https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[ここ] にあります]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following image shows what that looks at a high level:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のイメージでは、ハイレベルの様子を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-non-blocking.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RR-non-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ensures that maximum throughput can be achieved, but it also means that the implementation of an endpoint method should complete in a timely fashion otherwise the thread will be used for too longfootnote:["Too long" depends on your target concurrency. You may consider 1ms as too long for some endpoint heavily used, but 100ms might be acceptable for less used endpoints] and other requests will be queued up and lead to degraded throughput.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、最大のスループットを達成することがきます。ただし、エンドポイントメソッドの実装がタイムリーに完了しなければならないことも意味しています。そうでなければ、スレッドの使用が長くなり過ぎてしまい footnote:["長過ぎる" は目標とする並列度次第です。頻繁に使用されるエンドポイントでは 1ms も長過ぎると考える場合もありますし、あまり使われないエンドポイントでは 100ms でも許容可能かもしれません。]、他のリクエストがキューイングされ、スループットの低下につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to understand that a method body that uses imperative code only becomes a problem when it takes a long time to execute - which is almost always the case for blocking IO operations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令型コードを使用するメソッド本体が問題になるのは、実行に長い時間がかかるときだけ - ブロッキング IO 処理がほぼ全てのケース - であることを理解することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For that reason, when the body of the method performs some kind of blocking IO operation (or even some CPU bound operation that requires time to complete), the request needs to be offloaded to a worker thread.  In RESTEasy Reactive that is done declaratively using the `@Blocking` annotation - no reactive programming or complex Java concurrency related code is needed.  Quarkus also warns you when you attempt to use blocking IO on an IO thread.  If however the method body performs non-blocking IO (or some CPU bound operation that completes very quickly) then RESTEasy Reactive can continue to serve the entire request on the IO thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、メソッドの本体が何らかのブロッキング IO 操作 (あるいは完了までに時間を要する CPU バインド操作) を実行する場合、リクエストはワーカースレッドにオフロードされる必要があります。RESTEasy Reactiveでは、`@Blocking` アノテーションを使用して宣言的に行われます。Quarkus は、IO スレッドでブロッキング IO を使用しようとした場合にも警告します。しかし、メソッド本体がノンブロッキング IO (または非常に速く完了するCPUバインド操作) を実行する場合、RESTEasy Reactive は、IO スレッド上でリクエスト全体を提供し続けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely not!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん違います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although RESTEasy Reactive was built from the ground up to do non-blocking IO and serve requests from the event loop threads (thus avoiding the needless usage of worker pool threads)  it can effortlessly work with blocking IO and any piece of code that provides a blocking API (such as Hibernate) without blocking the event loop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、ノンブロッキング IO とイベントループスレッドからのリクエストを処理するために一から構築されていますが(そのため、ワーカープールスレッドの不要な使用を避けることができます)、ブロッキング IO と、(Hibernate のような) ブロッキング APIを提供するあらゆるコードをイベントループをブロッキングせずに簡単に動作させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only thing you have to do is add `@Blocking` on your endpoint method or class.  That’s it! If you use `@Blocking` you are back to the regular dispatching mechanism: a worker thread is used to execute your method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントのメソッドやクラスに `@Blocking` を追加するだけです。これだけです。`@Blocking` を使用すると、通常のディスパッチの仕組み:ワーカースレッドがメソッドの実行に使用される方式に戻れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At a high level it this looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ハイレベルでは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-blocking.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RR-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can probably guess from the answer to the previous question, the answer is no.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の質問の答えからわかる通り、答えは「ノー」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate, the `@Blocking` annotation should be placed on the endpoint methods that interact with Hibernate.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が Hibernate と一緒に使用されるシナリオでは、 `@Blocking` アノテーションを Hibernate と相互作用するエンドポイントメソッドに配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate Reactive, no `@Blocking` annotation is necessary on the endpoint methods that interact with Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が Hibernate Reactive とともに使用されるシナリオでは、Hibernate Reactive と相互作用するエンドポイントメソッドに `@Blocking` アノテーションは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the performance implication of using @Blocking?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Blocking を使用することによるパフォーマンスへの影響について</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the absolute highest throughput is achieved when an endpoint method is non-blocking (that is the HTTP request is served completely from the event loop thread), great performance can nonetheless be achieved even when `@Blocking` is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントメソッドがノンブロッキング (つまり、HTTP リクエストがイベントループスレッドから完全に提供される) の場合には、絶対的に最高のスループットが達成されますが、 `@Blocking` を使用していても優れたパフォーマンスを達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our benchmarks we see the use of `@Blocking` reduce maximum throughput by around 30%footnote:[This is basically the cost we have to pay for dispatching the request to a worker thread. The percentage of the slowdown decreases the longer the target method takes to execute].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのベンチマークでは、`@Blocking` を使用することで最大スループットが約 30%footnote 低下することがわかります footnote:[これは基本的にワーカースレッドにリクエストを振り分けるためにかかるコストです]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, an endpoint method using `@Blocking` in RESTEasy Reactive still achieves around 50% higher throughput than the same method using RESTEasy Classic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、RESTEasy Reactive で `@Blocking` を使用したエンドポイントメソッドでは、RESTEasy Classic を使用した同じメソッドよりも約 50% 高いスループットを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does RESTEasy Reactive using @Blocking perform better than RESTEasy Classic?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ @Blocking を使用した RESTEasy Reactive は RESTEasy Classic よりもパフォーマンスが良いのですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is able to gain its performance advantage over RESTEasy Classic by:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、RESTEasy Classic と比較して、以下のような特徴を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating very tightly with Eclipse Vert.x for everything IO related. Vert.x has been extremely well optimized for IO operations and so tight integration with it allows RESTEasy Reactive to benefit from all that work.  You might recall that RESTEasy Classic on Quarkus uses Vert.x under the hood as well, but in that case the integration is not as deep and is therefore unable to fully utilize the power of Vert.x.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IO に関連するすべてを Eclipse Vert.x と緊密に統合します。Vert.x は IO 操作のために非常によく最適化されています。そのため、RESTEasy Reactive はそれとの緊密な統合により、その恩恵を受けることができます。RESTEasy Classic on Quarkus も同様に Vert.x を使用しています。ただし、その場合、統合はそれほど深くないため、Vert.x のパワーを十分に活用することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving a lot of work to build time. As RESTEasy Reactive was built from the ground up to serve the needs of Quarkus, it benefits from the tightest possible integration with Quarkus and is probably the extension that does the most build time work.  This in turn results in creating an optimal data pipeline for serving each request, helping the JIT compiler by generating bytecode to inline runtime operations, eliminating reflection at runtime (both for invoking methods and for determining types) and reducing memory allocations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの作業をビルド時に移行しています。RESTEasy Reactive は、Quarkus のニーズに応えるためにゼロから構築されています。そのため、Quarkus との統合が可能な限り緊密に行われており、おそらく最も多くをビルド時に作業を行うエクステンションとなっています。これにより、各リクエストを処理するための最適なデータパイプラインを作成し、実行時の操作をインラインで行うバイトコードを生成することで JIT コンパイラを支援し、実行時の (メソッドの呼び出しと型の決定のための) リフレクションを排除し、メモリーの割り当てを削減します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Avoiding the use of ThreadLocals and instead by utilizing a context object that contains all the necessary information.  ThreadLocals are a convenient way to make data available to different parts of a framework, but their frequent use comes at a cost and are thus fully avoided in RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ThreadLocals の使用を避け、代わりに必要な情報をすべて含むコンテキストオブジェクトを利用します。ThreadLocals はフレームワークのさまざまな部分でデータを利用できるようにする便利な方法です。ただし、その頻繁な使用にはコストがかかるため、RESTEasyReactive では完全に回避されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Utilizing Arc in an optimal manner for all necessary injections. RESTEasy Classic provides an abstraction layer that performs the various injection operations, which for the needs of Quarkus is entirely unnecessary since Arc provides the same functionality with better performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要なすべてのインジェクションに最適な方法でArcを活用します。RESTEasy Classic は、さまざまなインジェクション操作を実行する抽象化レイヤーを提供しますが、Arcは同じ機能をより優れたパフォーマンスで提供するため、Quarkus のニーズには全く不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might recall that Quarkus allows you to use Mutiny return types (Uni and Multi) when using RESTEasy Classic via the `quarkus-resteasy-mutiny` extension and thus might be wondering how that compares to using RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic を使用しているときに Quarkus では、`quarkus-resteasy-mutiny` エクステンションを介して Mutiny 戻り値の型 (UniとMulti) を使用することができることや、これが RESTasy Reactive の使用と、どのように異なるかと思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main thing to understand about RESTEasy Classic is that it *always* handles requests on a worker thread as it does not use the event-loop concept at all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic について最も理解しておくべきこととして、RESTEasy Classic はイベントループの概念を一切使用しないため、*常に*ワーカースレッド上でリクエストを処理することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is best shown by the following image:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを最もよく表しているのは、以下の画像です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CR.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CR.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when using RESTEasy Classic even when you return a reactive type like `Uni` or `Multi` the initial request is still being handled on a worker thread and while the call to the library may result in non-blocking IO, nevertheless there is no way for RESTEasy Classic to reuse the worker thread once it is blocked waiting on IO.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、RESTEasy Classic を使用する場合、`Uni` や `Multi` のようなリアクティブ型を返しても、最初のリクエストはワーカースレッドで処理され、ライブラリーの呼び出しはノンブロッキング IO になることがあります。それでも IO の待機中にブロックされると、RESTEasyClassic がワーカースレッドを再利用する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the gain of using reactive return types in RESTEasy Classic is a syntactic gain, not a runtime gain - the underlying hardware isn’t used more efficiently despite the use of reactive types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、RESTEasy Classic でリアクティブな戻り値型を使用することで得られる利益は、ランタイムの利益ではなく、構文的な利益です。リアクティブ型を使用していても、基礎となるハードウェアが、より効率的に使用されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning Mutiny types using RESTEasy Reactive, everything happens on the IO Thread (except if the endpoint is annotated with `@Blocking`). By the way, no need for an external extension to use Mutiny with RESTEasy Reactive, it’s built-in!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive を使用して Mutiny 型を返す場合、すべての処理は IO スレッド上で行われます (エンドポイントが `@Blocking` でアノテーションされている場合を除く)。RESTEasy Reactive で Mutiny を使用するための外部エクステンションは不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do I have to use the new RESTEasy Reactive APIs to achieve maximum performance?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最大のパフォーマンスを実現するためには、新しい RESTEasy Reactive API を使用する必要がありますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading through the RESTEasy Reactive documentation you soon come across the new APIs for writing request filters (https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[@ServerRequestFilter]), response filters (`@ServerResponseFilter`) and exception mappers (https://quarkus.io/guides/resteasy-reactive#exception-mapping[@ServerExceptionMapper]).  You might wonder if their usage affects performance in any way compared to the standard JAX-RS APIs (`ContainerRequestFilter`, `ContainerResponseFilter` and `ExceptionMapper`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive のドキュメントを読むと、すぐにリクエストフィルター link:https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[(@ServerRequestFilter])、レスポンスフィルター (`@ServerResponseFilter`)、例外マッパー link:https://quarkus.io/guides/resteasy-reactive#exception-mapping[(@ServerExceptionMapper]) を記述するための新しい API に出くわします。これらの使用法が標準の JAX-RS API (`ContainerRequestFilter`, `ContainerResponseFilter`, `ExceptionMapper`) と比べてパフォーマンスに影響を与えるかどうかを疑問に思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new APIs will give a tiny performance advantage over using the old APIs if the use of `@Context` is involved in the latter case, the advantage is negligible and should not worry you unless you are trying to squeeze out every inch of performance you can find.  One thing to keep in mind when writing filters with either API, is that using `org.jboss.resteasy.reactive.server.SimpleResourceInfo` instead of `javax.ws.rs.container.ResourceInfo` is advised as the latter results in reflection being performed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>後者のケースで `@Context` を使用する場合、新しい API は古い API を使用するよりもわずかなパフォーマンスの優位性を与えます。ただし、その優位性は取るに足らない程度で、可能な限りのパフォーマンスを限界まで引き出すのでない限り、心配する必要はありません。どちらの API を使ってフィルターを書く場合でも注意すべきことは、`javax.ws.rs.container.ResourceInfo` の代わりに `org.jboss.resteasy.reactive.server.SimpleResourceInfo` を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A special (albeit rather advanced) case where the new APIs do result in noticeably better performance is the case of `MessageBodyReader` and `MessageBodyWriter` classes.  When reading the HTTP request and writing the HTTP response, the use of https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader] and `ServerMessageBodyWriter` allows RESTEasy Reactive to optimize the data-path for serving the request.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい API によってパフォーマンスが顕著に向上する特別なケースとして、`MessageBodyReader` と `MessageBodyWriter` クラスがあります。HTTP リクエストの読み込みと HTTP レスポンスの書き込みの際に、 link:https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader]と `ServerMessageBodyWriter` を使用することで、RESTEasy Reactive はリクエストを提供するためのデータパスを最適化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about Reactive Routes?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブルートは?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was already providing a way to handle HTTP requests from the IO thread. Reactive Routes provides a declarative model to implement HTTP API. Each route can be called on the IO thread (default) or on a worker thread (using the `@Blocking` annotation).  Reactive Routes provide very good throughput and performance as highlighted in https://quarkus.io/blog/io-thread-benchmark/[this] article. How does reactive routes compare to RESTEasy Reactive?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはすでに IO スレッドから HTTP リクエストを処理する方法を提供していました。Reactive Routes (リアクティブルート) は、HTTP API を実装するための宣言モデルを提供します。各ルートは、IO スレッド (デフォルト) またはワーカースレッド (`@Blocking` アノテーションを使用) で呼び出すことができます。link:https://quarkus.io/blog/io-thread-benchmark/[この]記事で強調されているように、Reactive Routes は非常に優れたスループットとパフォーマンスを提供します。リアクティブルートは RESTEasy Reactive と比較してどうでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main complaints we got about Reactive Routes was about the development model: it’s very different from the one used with RESTEasy. However, Reactive Routes allowed us to verify the performance and efficiency benefits of using an end-to-end reactive model on top of Quarkus.  RESTEasy Reactive can be seen as the “next generation”: you get the runtime benefits while also using a familiar development model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Routes についての主な不満の 1 つは、開発モデルに関するものでした。RESTEasy で使用したものとは大きく異なります。しかし、Reactive Routes を使用することで、Quarkus 上にエンドツーエンドのリアクティブモデルを使用することで得られるパフォーマンスと効率性のメリットを検証することができました。RESTEasy Reactive は「次世代」と考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is the next generation of HTTP framework. It unifies reactive (non-blocking IO, asynchronous APIs) and imperative (thanks to the `@Blocking` annotation). It improves raw performances without constraining the user experience.  Its reactive/imperative duality makes it fit any use cases, from highly concurrent HTTP APIs, to more traditional transactional CRUD applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は次世代の HTTP フレームワークです。リアクティブ型 (ノンブロッキング IO、非同期 API) と命令型 (`@Blocking` アノテーションを使用) を統合しています。ユーザーエクスペリエンスを制限することなく、生のパフォーマンスを向上させます。その命令型/リアクティブ型の二面性により、高度に並列化された HTTP API から、より伝統的なトランザクション型の CRUD アプリケーションまで、あらゆるユースケースに適合するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see RESTEasy Reactive as becoming the default HTTP layer in Quarkus in the near future and are completely committed to making it perform at the best possible level while also introducing new features that spark developer joy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、近い将来 Quarkus のデフォルト HTTP レイヤーになると思われます。また、開発者にうれしい新機能を導入しながら、可能な限り最高のパフォーマンスを実現することに完全にコミットしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In that vein, we hope that this short blog post will provide you with some insight on what makes RESTEasy Reactive special and clear up any misconceptions you may have had about it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この短いブログ記事が、RESTEasy Reactive が特別である理由と、RESTEasy Reactive について抱いていた誤解を解き明かすためのヒントになればと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error 404</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Error 404</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どこでもないスペースを見つけました。&lt;br/&gt;
通常のスペースへのパスは、&lt;br/&gt;
ナビゲーションメニューに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A haiku for you.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ポエム
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドを完成させるには、以下が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 1.8+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `pom.xml` に以下が追加されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>References</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security provides the architecture, multiple authentication and authorization mechanisms, and other tools for the developers to build a production-quality security for their Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityでは、開発者がQuarkusアプリケーションの商用品質のセキュリティーを構築するためのアーキテクチャ、複数の認証および認可メカニズム、その他のツールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document provides a brief overview of Quarkus Security and links to the individual guides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus Securityの簡単な概要と、各ガイドへのリンクについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`HttpAuthenticationMechanism` is the main entry into Quarkus HTTP Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`HttpAuthenticationMechanism`  は、Quarkus HTTP Securityのメインエントリーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security Manager uses `HttpAuthenticationMechanism` to extract the authentication credentials from the HTTP request and delegates to `IdentityProvider` to complete the conversion of these credentials to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Security Managerは、 `HttpAuthenticationMechanism`  を使用してHTTPリクエストから認証資格情報を抽出し、 `IdentityProvider`  に委任して、これらの資格情報の `SecurityIdentity`  への変換を完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the credentials may be coming with the HTTP `Authorization` header, client HTTPS certificates or cookies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、資格情報は、HTTP `Authorization`  ヘッダー、クライアントの HTTPS 証明書、またはクッキーを使用している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` verifies the authentication credentials and maps them to `SecurityIdentity` which contains the username, roles, the original authentication credentials, and other attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`IdentityProvider`  は認証資格情報を検証し、ユーザー名、ロール、元の認証資格情報、およびその他の属性を含む `SecurityIdentity`  にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every authenticated resource, you can inject a `SecurityIdentity` instance to get the authenticated identity information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証済みリソースごとに、 `SecurityIdentity`  インスタンスを注入して、認証済みの ID 情報を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some other contexts you may have other parallel representations of the same information (or parts of it) such as `SecurityContext` for JAX-RS or `JsonWebToken` for JWT.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他の文脈では、JAX-RSであれば `SecurityContext`  、JWTであれば `JsonWebToken`  のように、同じ情報(またはその一部)を他の別の表現で表現している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports several sources to load authentication information from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、認証情報をロードするためのいくつかのソースをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本認証とフォーム認証の仕組み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form HTTP-based authentication mechanisms are the core authentication mechanisms supported in Quarkus.  Please see link:security-built-in-authentication#basic-auth[Basic HTTP Authentication] and link:security-built-in-authentication#form-auth[Form HTTP Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Basic HTTPベースの認証メカニズムとForm HTTPベースの認証メカニズムは、Quarkusでサポートされている主要な認証メカニズムです。詳細については、 link:security-built-in-authentication#basic-auth[基本HTTP認証]と link:security-built-in-authentication#form-auth[フォームHTTP認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutual TLS Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>相互TLS認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides Mutual TLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは相互TLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security-built-in-authentication#mutual-tls[Mutual TLS Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳しくは link:security-built-in-authentication#mutual-tls[相互TLS認証] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenId Connect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenId Connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` extension provides a reactive, interoperable, multi-tenant enabled OpenId Connect adapter which supports `Bearer Token` and `Authorization Code Flow` authentication mechanisms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-oidc`  エクステンションは、 `Bearer Token`  および `Authorization Code Flow`  認証メカニズムをサポートする、リアクティブで相互運用可能なマルチテナント対応の OpenId Connect アダプターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bearer Token` mechanism extracts the token from HTTP `Authorization` header.  `Authorization Code Flow` mechanism uses OpenId Connect Authorization Code flow. It redirects the user to IDP to authenticate and completes the authentication process after the user has been redirected back to Quarkus by exchanging the provided code grant for ID, access and refresh tokens.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer Token`  メカニズムは、HTTP `Authorization`  ヘッダーからトークンを抽出します。 `Authorization Code Flow`  メカニズムは、OpenId Connect Authorization Code Flowを使用します。ユーザーをIDPにリダイレクトして認証を行い、提供されたCode GrantをID、アクセストークン、リフレッシュトークンと交換することで、ユーザーがQuarkusにリダイレクトされた後に認証プロセスを完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ID and access `JWT` tokens are verified with the refreshable `JWK` key set but both JWT and opaque (binary) tokens can be introspected remotely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ID とアクセス `JWT` トークンは、リフレッシュ可能な `JWK` キーセットで検証されますが、JWT と不透明な (バイナリーの) トークンの両方をリモートで検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect[Using OpenID Connect to Protect Service Applications] guide for more information about `Bearer Token` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer Token` 認証メカニズムの詳細については、 link:security-openid-connect[Using OpenID Connect to Protect Service Applications]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application] guide for more information about `Authorization Code Flow` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Authorization Code Flow`  認証メカニズムの詳細については、 link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `quarkus-oidc` `Bearer` and `Authorization Code Flow` Authentication mechanisms use &lt;&lt;smallrye-jwt, SmallRye JWT&gt;&gt; to represent JWT tokens as Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-oidc` の`Bearer` と `Authorization Code Flow`  認証メカニズムはいずれも link:#smallrye-jwt[SmallRye JWT ]を使用して、JWT トークンを Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken` として表現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] for more information about multiple tenants which can support `Bearer` or `Authorization Code Flow` authentication mechanism and configured statically or dynamically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer`  または `Authorization Code Flow`  認証メカニズムをサポートし、静的または動的に設定できる複数のテナントの詳細については、 link:security-openid-connect-multitenancy[OpenID Connect マルチテナントの使用]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would like to have Quarkus OIDC extension enabled at runtime then set `quarkus.oidc.tenant-enabled=false` at build time and re-enable it at runtime using a system property.  See also link:security-openid-connect-multitenancy#disable-tenant[Disabling Tenant Configurations] for more information about managing the individual tenant configurations in the multi-tenant OIDC deployments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時にQuarkus OIDCエクステンションを有効にしたい場合は、ビルド時に `quarkus.oidc.tenant-enabled=false` を設定し、システムプロパティーを使用して実行時に再度有効にします。マルチテナントOIDCデプロイメントでの個々のテナント設定の管理の詳細については、テナント link:security-openid-connect-multitenancy#disable-tenant[設定の無効化]も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Keycloak and Bearer tokens then also see the link:security-keycloak-authorization[Using Keycloak to Centralize Authorization] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloak と Bearer トークンを使用する場合は、 link:security-keycloak-authorization[Using Keycloak to Centralize Authorization]ガイドも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to configure Keycloak programmatically then consider using https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API] with the help of the `quarkus-keycloak-admin-client` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloakをプログラムで設定する必要がある場合は、 `quarkus-keycloak-admin-client` エクステンションの助けを借りて、 link:https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API]の使用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` provides Microprofile JWT 1.1.1 implementation and many more options to verify signed and encrypted `JWT` tokens and represent them as `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-jwt` はMicroprofile JWT 1.1.1.1 の実装と、署名・暗号化された `JWT` トークンを検証し、 `org.eclipse.microprofile.jwt.JsonWebToken` として表現するための多くのオプションを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It can currently verify only `JWT` tokens using the PEM keys or refreshable `JWK` key set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは `quarkus-oidc` ベアラートークン認証メカニズムに代わるものを提供します。現在、PEM 鍵または更新可能な `JWK` 鍵セットを使用して `JWT` トークンのみを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally it provides `JWT Generation API` for creating `signed`, `inner-signed` and/or `encrypted` `JWT` tokens with ease.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、 `JWT Generation API` を提供して、 `signed` , `inner-signed` , および/または `encrypted` `JWT`トークンを簡単に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-jwt[Using SmallRye JWT] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-jwt[Using SmallRye JWT]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OAuth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It is based on `Elytron` and is primarily meant for introspecting the opaque tokens remotely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-elytron-security-oauth2`  は `quarkus-oidc`  Bearer Token 認証メカニズムの代替手段を提供します。これは `Elytron` をベースにしており、主に不透明なトークンをリモートでイントロスペクトするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-oauth2[Using OAuth2] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-oauth2[OAuth2 の使用]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see the link:security-ldap[Authenticate with LDAP] guide for more information about LDAP authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>LDAP認証メカニズムの詳細については、 link:security-ldap[Authenticate with LDAP]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity Providers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイデンティティ・プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`IdentityProvider`  は、 `HttpAuthenticationMechanism`  が提供する認証資格情報を `SecurityIdentity`  に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions such as `OIDC`, `OAuth2`, `SmallRye JWT`, `LDAP` have the inlined `IdentityProvider` implementations which are specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`OIDC` , `OAuth2` , `SmallRye JWT` , `LDAP`  などのエクステンションには、サポートされている認証フローに固有の `IdentityProvider` のインライン実装があります。例えば、 `quarkus-oidc` は独自の `IdentityProvider` を使用してトークンを `SecurityIdentity` に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use `Basic` or `Form` HTTP-based authentication then you have to add an `IdentityProvider` which can convert a user name and password to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Basic` または `Form` HTTP ベースの認証を使用している場合は、ユーザー名とパスワードを `SecurityIdentity` に変換できる `IdentityProvider` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-jpa[JPA IdentityProvider] and link:security-jdbc[JDBC IdentityProvider] for more information.  You can also use link:security-testing#configuring-user-information[User Properties IdentityProvider] for testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、 link:security-jpa[JPA IdentityProvider]および link:security-jdbc[JDBC IdentityProvider]を参照してください。また、テストに link:security-testing#configuring-user-information[User Properties IdentityProvider を]使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証メカニズムの組み合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can combine multiple authentication mechanisms if they get the authentication credentials from the different sources.  For example, combining built-in `Basic` and `quarkus-oidc` `Bearer` authentication mechanisms is allowed, but combining `quarkus-oidc` `Bearer` and `smallrye-jwt` authentication mechanisms is not allowed because both will attempt to verify the token extracted from the HTTP `Authorization Bearer` scheme.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるソースから認証証明書を取得する場合、複数の認証メカニズムを組み合わせることができます。例えば、組み込みの `Basic`  と `Bearer`   `quarkus-oidc`  認証機構を組み合わせることはできますが、 `quarkus-oidc`   `Bearer`  と `smallrye-jwt`  認証機構を組み合わせることはできません。なぜなら、両方とも HTTP `Authorization Bearer`  スキームから抽出されたトークンを検証しようとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proactive Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロアクティブ認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます(ターゲットページが認証を必要としない場合でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-built-in-authentication#proactive-authentication[Proactive Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-built-in-authentication#proactive-authentication[プロアクティブ認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-authorization[Security Authorization] for more information about Role Based Access Control and other authorization options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>役割ベースのアクセス制御およびその他の認可オプションの詳細については、 link:security-authorization[セキュリティー認可]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customization and other useful tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタマイズやその他の便利なヒント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security is highly customizable. One can register custom ``HttpAuthenticationMechanism``s, ``IdentityProvider``s and ``SecurityidentityAugmentor``s.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityは、高度なカスタマイズが可能です。カスタム `HttpAuthenticationMechanism` 、 `IdentityProvider` 、 `SecurityidentityAugmentor` を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-customization[Security Customization] for more information about customizing Quarkus Security and other useful tips about the reactive security, registering the security providers, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityのカスタマイズの詳細や、リアクティブセキュリティー、セキュリティープロバイダーの登録などの便利なヒントについては、セキュリティーの link:security-customization[カスタマイズ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:http-reference#ssl[Supporting secure connections with SSL] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:http-reference#ssl[SSL による安全な接続のサポート]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-Origin Resource Sharing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クロスオリジンリソース共有</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to make your Quarkus application accessible to another application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the link:http-reference#cors-filter[HTTP CORS documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを別のドメインで実行している別のアプリケーションにアクセスできるようにする場合は、CORS(Cross-Origin Resource Sharing)を設定する必要があります。詳細については、 link:http-reference#cors-filter[HTTP CORSのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-testing[Security Testing] for more information about testing Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityのテストの詳細については、 link:security-testing[セキュリティーのテスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret Engines</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットエンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a very comprehensive HashiCorp Vault support, please see the link:vault[Quarkus and HashiCorp Vault] documentation for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは非常に包括的な HashiCorp Vault のサポートを提供しています。詳しくは link:vault[Quarkus and HashiCorp Vault] のドキュメントを参照下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class Fruit {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class Fruit {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Fruit() {
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public Fruit() {
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してAMQPと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.time.Duration;
import java.util.Random;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import java.time.Duration;
import java.util.Random;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private Random random = new Random();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private Random random = new Random();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Outgoing("generated-price")                        // &lt;1&gt;
    public Multi&lt;Integer&gt; generate() {                  // &lt;2&gt;
        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))
                .onOverflow().drop()
                .map(tick -&gt; random.nextInt(100));
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Outgoing("generated-price")                        // &lt;1&gt;
    public Multi&lt;Integer&gt; generate() {                  // &lt;2&gt;
        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))
                .onOverflow().drop()
                .map(tick -&gt; random.nextInt(100));
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private static final double CONVERSION_RATE = 0.88;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private static final double CONVERSION_RATE = 0.88;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Channel;
import org.reactivestreams.Publisher;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Channel;
import org.reactivestreams.Publisher;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;h2&gt;Last price&lt;/h2&gt;
    &lt;div class="row"&gt;
    &lt;p class="col-md-12"&gt;The last price is &lt;strong&gt;&lt;span id="content"&gt;N/A&lt;/span&gt;&amp;nbsp;&amp;euro;&lt;/strong&gt;.&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var source = new EventSource("/prices/stream");
    source.onmessage = function (event) {
        document.getElementById("content").innerHTML = event.data;
    };
&lt;/script&gt;
&lt;/html&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    &lt;h2&gt;Last price&lt;/h2&gt;
    &lt;div class="row"&gt;
    &lt;p class="col-md-12"&gt;The last price is &lt;strong&gt;&lt;span id="content"&gt;N/A&lt;/span&gt;&amp;nbsp;&amp;euro;&lt;/strong&gt;.&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var source = new EventSource("/prices/stream");
    source.onmessage = function (event) {
        document.getElementById("content").innerHTML = event.data;
    };
&lt;/script&gt;
&lt;/html&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルの構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs with very little effort.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST Clientを使用して、ほとんど手間をかけずにREST APIとやりとりする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need to write server link:rest-json[JSON REST APIs].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバー link:rest-json[JSON REST API] を書く必要がある場合は、別のガイドがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `rest-client` と `resteasy-jackson` の拡張子をインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `resteasy` and `resteasy-jackson` extensions for the REST server support;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST サーバーのサポートのために `resteasy` と `resteasy-jackson` のエクステンションを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `rest-client` and `rest-client-jackson` extensions for the REST client support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST クライアントのサポートのために `rest-client` と `rest-client-jackson` のエクステンションを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `rest-client` and the `rest-client-jackson` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、 `rest-client` と `rest-client-jackson` の拡張子をプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up the model</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モデルのセットアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will be demonstrating how to consume part of the REST API supplied by the link:https://restcountries.eu[restcountries.eu] service.  Our first order of business is to setup the model we will be using, in the form of a `Country` POJO.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:https://restcountries.eu[restcountries.eu] サービスが提供するREST APIの一部を利用する方法をデモします。まず最初に、 `Country` POJO の形式で使用するモデルをセットアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `src/main/java/org/acme/rest/client/Country.java` file and set the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/rest/client/Country.java` ファイルを作成し、以下の内容を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The model above is only a subset of the fields provided by the service (thus the `@JsonIgnoreProperties` annotation), but it suffices for the purposes of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のモデルは、サービスによって提供されるフィールドのサブセットに過ぎません(`@JsonIgnoreProperties` アノテーションによる)が、このガイドの目的には十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the interface</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターフェースの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations. In our case the interface should be created at `src/main/java/org/acme/rest/client/CountriesService.java` and have the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile REST Client を使うのは、適切な JAX-RS と MicroProfile アノテーションを使ってインターフェースを作成するのと同じくらい簡単です。私たちの場合、インターフェイスは `src/main/java/org/acme/rest/client/CountriesService.java` で作成され、次のような内容になっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `getByName` method gives our code the ability to query a country by name from the REST Countries API. The client will handle all the networking and marshalling leaving our code clean of such technical details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getByName` メソッドは、私たちのコードに、REST Countries API から名前を指定して国を問い合わせる機能を与えます。クライアントがすべてのネットワーキングとマーシャリングを処理してくれるので、このような技術的な詳細は一切ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of the annotations in the code above is the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコードのアノテーションの目的は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@RegisterRestClient` により、Quarkusは、このインターフェイスがRESTクライアントとしてCDIインジェクションに利用可能であることを知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Path`, `@GET` and `@PathParam` are the standard JAX-RS annotations used to define how to access the service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Path` 、 `@GET` 、 `@PathParam` は、サービスへのアクセス方法を定義するために使用される標準的な JAX-RS アノテーションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Produces` defines the expected content-type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Produces` は、期待されるコンテンツタイプを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-rest-client-jackson` or `quarkus-rest-client-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-rest-client-jackson` や `quarkus-rest-client-jsonb` などの JSON エクステンションがインストールされている場合、メディアタイプが `@Produces` や `@Consumes` アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` メディアタイプをデフォルトで使用します( `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` と `application/octet-stream` がデフォルトとなっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want JSON by default you can set `quarkus.resteasy-json.default-json=false` and the default will change back to being auto-negotiated. If you set this you will need to add `@Produces(MediaType.APPLICATION_JSON)` and `@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to use JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでJSONを使用したくない場合は、 `quarkus.resteasy-json.default-json=false` を設定すると、デフォルトは自動ネゴシエーションに戻ります。これを設定した場合、JSON を使用するためには `@Produces(MediaType.APPLICATION_JSON)` と `@Consumes(MediaType.APPLICATION_JSON)` をエンドポイントに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't rely on the JSON default, it is heavily recommended to annotate your endpoints with the `@Produces` and `@Consumes` annotations to define precisely the expected content-types.  It will allow to narrow down the number of JAX-RS providers (which can be seen as converters) included in the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON のデフォルトに頼らない場合は、エンドポイントに `@Produces` や `@Consumes` のアノテーションを付けて、期待されるコンテンツタイプを正確に定義することを強くお勧めします。これにより、ネイティブ実行ファイルに含まれる JAX-RS プロバイダ (コンバータとみなすことができます) の数を絞り込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンフィグレーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to determine the base URL to which REST calls will be made, the REST Client uses configuration from `application.properties`.  The name of the property needs to follow a certain convention which is best displayed in the following code:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST 呼び出しが行われるベース URL を決定するために、REST クライアントは `application.properties` からの設定を使用します。プロパティーの名前は、以下のコードで表示される特定の規則に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having this configuration means that all requests performed using `org.acme.rest.client.CountriesService` will use `https://restcountries.eu/rest` as the base URL.  Using the configuration above, calling the `getByName` method of `CountriesService` with a value of `France` would result in an HTTP GET request being made to `https://restcountries.eu/rest/v2/name/France`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をすると、 `org.acme.rest.client.CountriesService` を使用して実行されるすべてのリクエストが `https://restcountries.eu/rest` をベースURLとして使用します。上記の設定を使用して、 `CountriesService` の `getByName` メソッドを `France` の値で呼び出すと、HTTP GET リクエストが `https://restcountries.eu/rest/v2/name/France` に対して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having this configuration means that the default scope of `org.acme.rest.client.CountriesService` will be `@Singleton`. Supported scope values are `@Singleton`, `@Dependent`, `@ApplicationScoped` and `@RequestScoped`. The default scope is `@Dependent`.  The default scope can also be defined on the interface.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をすると、 `org.acme.rest.client.CountriesService` のデフォルトのスコープは `@Singleton` になります。サポートされているスコープの値は `@Singleton` , `@Dependent` , `@ApplicationScoped` および `@RequestScoped` です。既定のスコープは `@Dependent` です。デフォルトのスコープはインターフェイス上で定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `org.acme.rest.client.CountriesService` _must_ match the fully qualified name of the `CountriesService` interface we created in the previous section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.rest.client.CountriesService` は、前のセクションで作成した `CountriesService` インターフェイスの完全修飾名と _一致しなければならない_ ことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To facilitate the configuration, you can use the `@RegisterRestClient` `configKey` property that allows to use another configuration root than the fully qualified name of your interface.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構成を容易にするために、 `@RegisterRestClient` `configKey` プロパティーを使用して、インターフェイスの完全修飾名とは別の構成ルートを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling Hostname Verification</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホスト名の検証を無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable the SSL hostname verification for a specific REST client, add the following property to your configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のRESTクライアントのSSLホスト名検証を無効にするには、次のプロパティーを構成に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/rest/client/CountriesResource.java` file and update it with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/rest/client/CountriesResource.java` ファイルを開き、以下の内容で更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in addition to the standard CDI `@Inject` annotation, we also need to use the MicroProfile `@RestClient` annotation to inject `CountriesService`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>標準の CDI `@Inject` アノテーションに加えて、MicroProfile `@RestClient` アノテーションを使用して `CountriesService` を注入する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/rest/client/CountriesResourceTest.java` file and change the content of the `testCountryNameEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/rest/client/CountriesResourceTest.java` ファイルを編集し、 `testCountryNameEndpoint` メソッドの内容を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code above uses link:http://rest-assured.io/[REST Assured]'s link:https://github.com/rest-assured/rest-assured/wiki/GettingStarted#jsonpath[json-path] capabilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコードでは、 link:http://rest-assured.io/[REST Assured] の link:https://github.com/rest-assured/rest-assured/wiki/GettingStarted#jsonpath[json-path] 機能を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Async Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest client supports asynchronous rest calls.  Async support comes in 2 flavors: you can return a `CompletionStage` or a `Uni` (requires the `quarkus-rest-client-mutiny` extension).  Let's see it in action by adding a `getByNameAsync` method in our `CountriesService` REST interface. The code should look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>rest クライアントは非同期の rest 呼び出しをサポートしています。非同期のサポートには、 `CompletionStage` と `Uni` ( `quarkus-rest-client-mutiny` のエクステンションが必要です) の 2 種類があります。 `CountriesService` REST インタフェースに `getByNameAsync` メソッドを追加してみましょう。コードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test asynchronous methods, add the test method below in `CountriesResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メソッドをテストするには、`CountriesResourceTest` に以下のテストメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Uni` version is very similar:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` 版は非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CountriesResource` becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountriesResource` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous snippet uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のスニペットでは、Mutinyのリアクティブタイプを使用していますが、もし慣れていない場合は、まず link:getting-started-reactive#mutiny[Getting Started with Reactiveガイド] を読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning a `Uni`, every _subscription_ invokes the remote service.  It means you can re-send the request by re-subscribing on the `Uni`, or use a `retry` as follow:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` を返すとき、すべての _サブスクリプション_ は 、リモートサービスを呼び出します。つまり、 `Uni` で再購読してリクエストを再送信するか、以下のように `retry` を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use a `CompletionStage`, you would need to call the service's method to retry.  This difference comes from the laziness aspect of Mutiny and its subscription protocol.  More details about this can be found in https://smallrye.io/smallrye-mutiny/#_uni_and_multi[the Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` を使用する場合は、サービスのメソッドを呼び出して再試行する必要があります。この違いは、Mutinyとそのサブスクリプションプロトコルの lazy 性の側面から来ています。これについての詳細は Mutiny の link:https://smallrye.io/smallrye-mutiny/#_uni_and_multi[ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom headers support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムヘッダーのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile REST client allows amending request headers by registering a `ClientHeadersFactory` with the `@RegisterClientHeaders` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile REST クライアントでは、 `ClientHeadersFactory` を `@RegisterClientHeaders` アノテーションで登録することで、リクエストヘッダを修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see it in action by adding a `@RegisterClientHeaders` annotation pointing to a `RequestUUIDHeaderFactory` class in our `CountriesService` REST interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountriesService` REST インタフェースに `@RegisterClientHeaders` アノテーションを追加して、 `RequestUUIDHeaderFactory` クラスを指すようにしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the `RequestUUIDHeaderFactory` would look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `RequestUUIDHeaderFactory` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any CDI bean matching the declared factory class will be picked up and can of course benefit from the usual CDI infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>宣言されたファクトリークラスにマッチする CDI Bean は、ピックアップされ、もちろん通常のCDIインフラストラクチャの恩恵を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをパッケージ化して実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/country/name/greece.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行します。ブラウザで http://localhost:8080/country/name/greece を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see a JSON object containing some basic information about Greece.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ギリシャに関する基本情報を含む JSON オブジェクトが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file.  You can also generate the native executable with `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative` でネイティブ実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the REST Client extension and link:rest-json[the RESTEasy extension] share the same infrastructure.  One important consequence of this consideration is that they share the same list of providers (in the JAX-RS meaning of the word).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、RESTクライアントエクステンションと link:rest-json[RESTEasyエクステンション] は同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RSの意味での)プロバイダーのリストを共有しているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, if you declare a `WriterInterceptor`, it will by default intercept both the servers calls and the client calls, which might not be the desired behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `WriterInterceptor` を宣言した場合、デフォルトではサーバーの呼び出しとクライアントの呼び出しの両方をインターセプトしますが、これは望ましい動作ではないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can change this default behavior and constrain a provider to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、このデフォルトの動作を変更してプロバイダを制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 *クライアント* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 *サーバー* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a Mock HTTP Server for tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストにモックHTTPサーバーを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up a mock HTTP server, against which tests are run, is a common testing pattern.  Examples of such servers are link:http://wiremock.org/[Wiremock] and link:https://docs.hoverfly.io/projects/hoverfly-java/en/latest/index.html[Hoverfly].  In this section we'll demonstrate how Wiremock can be leveraged for testing the `CountriesService` which was developed above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを実行するためのモックHTTPサーバーを設定することは、一般的なテストパターンです。そのようなサーバーの例としては、 link:http://wiremock.org/[Wiremock] や link:https://docs.hoverfly.io/projects/hoverfly-java/en/latest/index.html[Hoverfly] があります。このセクションでは、上で開発した `CountriesService` をテストするために Wiremock をどのように活用できるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, Wiremock needs to be added as a test dependency. For a Maven project that would happen like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず第一に、Wiremockをテスト依存関係として追加する必要があります。Mavenプロジェクトの場合は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a proper Wiremock version. All available versions can be found link:https://search.maven.org/artifact/com.github.tomakehurst/wiremock-jre8[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>適切なWiremockのバージョンを使用してください。利用可能なすべてのバージョンは link:https://search.maven.org/artifact/com.github.tomakehurst/wiremock-jre8[ここで]  見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus tests when some service needs to be started before the Quarkus tests are ran, we utilize the `@io.quarkus.test.common.QuarkusTestResource` annotation to specify a `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` which can start the service and supply configuration values that Quarkus will use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのテストを実行する前にサービスを開始する必要がある場合、Quarkusのテストでは、 `@io.quarkus.test.common.QuarkusTestResource` アノテーションを利用して、サービスを開始できる `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を指定し、Quarkusが使用する設定値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details about `@QuarkusTestResource` refer to link:getting-started-testing#quarkus-test-resource[this part of the documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusTestResource` の詳細については、 link:getting-started-testing#quarkus-test-resource[ドキュメントのこの部分] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an implementation of `QuarkusTestResourceLifecycleManager` called `WiremockCountries` like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように `QuarkusTestResourceLifecycleManager` の実装である `WiremockCountries` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Statically importing the methods in the Wiremock package makes it easier to read the test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Wiremockパッケージのメソッドを静的にインポートすると、テストを読みやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `start` method is invoked by Quarkus before any test is run and returns a `Map` of configuration properties that apply during the test execution.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`start` メソッドは、テストを実行する前にQuarkusによって呼び出され、テスト実行中に適用される設定プロパティーの `Map` を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Wiremock.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Wiremockを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Wiremock to stub the calls to `/v2/name/GR` by returning a specific canned response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Wiremockが特定の定型文を返すことで、 `/v2/name/GR` への呼び出しをスタブするように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All HTTP calls that have not been stubbed are handled by calling the real service. This is done for demonstration purposes, as it is not something that would usually happen in a real test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタブ化されていないすべての HTTP 呼び出しは、実際のサービスを呼び出すことで処理されます。これは、実際のテストでは通常発生しないことなので、デモンストレーションのために行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the `start` method returns configuration that applies for tests, we set the rest-client property that controls the base URL which is used by the implementation of `CountriesService` to the base URL where Wiremock is listening for incoming requests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`start` メソッドはテストに適用される設定を返すので、 `CountriesService` の実装で使用されるベースURLを制御する rest-client プロパティーを、Wiremock がリクエストの着信をリッスンするベースURLに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When all tests have finished, shutdown Wiremock.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのテストが終了したら、Wiremockをシャットダウンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CountriesResourceTest` test class needs to be annotated like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountriesResourceTest` テストクラスには、このようなアノテーションが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusTestResource` applies to all tests, not just `CountriesResourceTest`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusTestResource` は `CountriesResourceTest` だけでなく、すべてのテストに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further reading</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブルートの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for properties file based authentication that is intended for development and testing purposes. It is not recommended that this be used in production as at present only plaintext and MD5 hashed passwords are used, and properties files are generally too limited to use in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、開発とテストを目的としたプロパティーファイルベースの認証をサポートしています。現在のところ、平文とMD5ハッシュ化されたパスワードしか使用されておらず、プロパティーファイルは一般的に本番環境で使用するには制限が多すぎるため、本番環境で使用することはお勧めできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下を `pom.xml` に追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elytron-security-properties-file extension currently supports two different realms for the storage of authentication and authorization information. Both support storage of this information in properties files. The following sections detail the specific configuration properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>elytron-security-properties-file エクステンションは、現在、認証と認可情報の保存のための2つの異なる領域をサポートしています。どちらもこの情報のプロパティーファイルへの保存をサポートしています。以下のセクションでは、特定の設定プロパティーについて詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties Files Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーファイルレルム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties files realm supports mapping of users to password and users to roles with a combination of properties files. They are configured with properties starting with `quarkus.security.users.file`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーファイルのレルムは、プロパティーファイルの組み合わせを使用して、ユーザーをパスワードに、ユーザーをロールにマッピングすることをサポートしています。これらは `quarkus.security.users.file` で始まるプロパティーで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーズプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.security.users.file.users` configuration property specifies a classpath resource which is a properties file with a user to password mapping, one per line. The following &lt;&lt;test-users-example&gt;&gt; illustrates the format:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.security.users.file.users` 設定プロパティーは、クラスパスリソースを指定します。これは、1行に1つずつ、ユーザーとパスワードをマッピングしたプロパティーファイルです。以下の link:#test-users-example[test-users-example] はそのフォーマットを示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password defined as `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` のパスワードは `jb0ss` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has password defined as `p4ssw0rd`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `jdoe` のパスワードは `p4ssw0rd` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルには、ユーザー名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roles.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Roles.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has been assigned the roles `Admin`, `admin`, `Tester` and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester` および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has been assigned the role `NoRolesUser`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `jdoe` に役割が割り当てられています。 `NoRolesUser`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has been assigned the roles `admin` and `user`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` には `admin` と `user` の役割が割り当てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンベデッドレルムの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The embedded realm also supports mapping of users to password and users to roles. It uses the main `application.properties` Quarkus configuration file to embed this information. They are configured with properties starting with `quarkus.security.users.embedded`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>埋め込まれたレルムは、ユーザーのパスワードへのマッピングやユーザーのロールへのマッピングもサポートしています。この情報を埋め込むには、メインの `application.properties` Quarkus設定ファイルを使用します。これらは、 `quarkus.security.users.embedded` で始まるプロパティーで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example application.properties file section illustrating the embedded realm configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、組み込みレルムの設定を示すapplication.propertiesファイルのセクションの例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the first example this file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の例と同様に、このファイルにはユーザー名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上記の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Users</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>組込ユーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to password mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;`. The following &lt;&lt;password-example&gt;&gt; illustrates the syntax with 4 user to password mappings:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーからパスワードへのマッピングは、 `application.properties` ファイル内で `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;` 形式のプロパティーキーで指定します。以下の link:#password-example[password-example] は]、4 つのユーザーからパスワードへのマッピングの構文を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Passwords</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスワードの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` はパスワード `jb0ss` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has password `test`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` はパスワード `test` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Roles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>組込ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to role mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.roles.&lt;user&gt;=role1[,role2[,role3[,...]]]`. The following &lt;&lt;roles-example&gt;&gt; illustrates the syntax with 4 user to role mappings:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーとロールのマッピングは、 `application.properties` ファイルで `quarkus.security.users.embedded.roles.&amp;amp;lt;user&amp;amp;gt;=role1[,role2[,role3[,…​]]]` 形式のプロパティー・キーで指定されます。以下の link:#roles-example[[role-example]]は、4つのユーザーとロールをマッピングした構文を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Roles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロールの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has roles `Admin`, `admin`, `Tester`, and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester`, および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has roles `admin` and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` には `admin` と `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While users are encouraged to use link:cache[Quarkus annotations for caching], Quarkus nevertheless provides a compatibility layer for Spring Cache annotations in the form of the `spring-cache` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーは link:cache[キャッシュ用のQuarkusアノテーション] を使用することが推奨されていますが、Quarkusはそれにもかかわらず、 `spring-cache` エクステンションの形でSpring Cacheアノテーションの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how a Quarkus application can leverage the well known Spring Cache annotations to enable application data caching for their Spring beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがよく知られているSpring Cacheアノテーションを活用して、Spring Beanのアプリケーションデータのキャッシュを可能にする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with a REST endpoint and imports the `spring-cache` and `spring-di` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `spring-cache` と `spring-di` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `spring-cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service which will simulate an extremely slow call to an external meteorological service.  Create `src/main/java/org/acme/spring/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、外部の気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/spring/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is where the slowness comes from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅さの原因はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class which contains the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/spring/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、ユーザーが3日間の天気予報を聞いてきたときに、ユーザーに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/spring/cache/WeatherForecast.java` をこのように作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we just need to update the generated `WeatherForecastResource` class to use the service and response:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、サービスとレスポンスを使用するために生成された `WeatherForecastResource` クラスを更新するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `daysInFuture` query parameter is omitted, the three days weather forecast will start from the current day.  Otherwise, it will start from the current day plus the `daysInFuture` value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`daysInFuture` クエリパラメーターが省略された場合、3 日間の天気予報は現在の日から始まります。それ以外の場合は、現在の日に `daysInFuture` の値を加えたものから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We're all done! Let's check if everything's working.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>終わりました!すべて上手く動いているか確認してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, run the application using `./mvnw compile quarkus:dev` from the project directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、プロジェクトディレクトリーから `./mvnw compile quarkus:dev` を使ってアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, call `http://localhost:8080/weather?city=Raleigh` from a browser.  After six long seconds, the application will answer something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、ブラウザから `http://localhost:8080/weather?city=Raleigh` を呼び出します。6秒ほど長い時間が経過すると、アプリケーションはこのような回答をします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response content may vary depending on the day you run the code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードを実行する日によってレスポンスの内容が異なる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can try calling the same URL again and again, it will always take six seconds to answer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何度も同じURLを呼び出してみても、必ず6秒で返事が返ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling the cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュの有効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションが稼働しているので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを以下のように更新します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We only added this annotation (and the associated import of course).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーション(もちろん関連するインポートも)を追加しただけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try to call `http://localhost:8080/weather?city=Raleigh` again.  You're still waiting a long time before receiving an answer.  This is normal since the server just restarted and the cache was empty.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`http://localhost:8080/weather?city=Raleigh` をもう一度呼び出して確認してみてください。返事が来るまでにまだ長い時間待たされています。これはサーバーが再起動したばかりでキャッシュが空になっているので正常です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing features for developers called `live coding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちょっと待って!? `WeatherForecastService` のアップデート後、サーバーが勝手に再起動した?はい、これは、 `live coding` と呼ばれる開発者のためのQuarkusの驚くべき機能の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the cache was loaded during the previous call, try calling the same URL.  This time, you should get a super fast answer with an `executionTimeInMs` value close to 0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前回の呼び出しでキャッシュが読み込まれたので、同じ URL を呼び出してみてください。今度は、 `executionTimeInMs` の値が 0 に近い超高速な応答が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see what happens if we start from one day in the future using the `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` URL.  You should get an answer two seconds later since two of the requested days were already loaded in the cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URL `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` を使って未来のある日から始めるとどうなるか見てみましょう。要求された日のうち2つはすでにキャッシュに読み込まれていたので、2秒後に回答が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also try calling the same URL with a different city and see the cache in action again.  The first call will take six seconds and the following ones will be answered immediately.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、同じURLを別の都市で呼び出してみて、再度キャッシュの動作を確認することもできます。最初の呼び出しには6秒ほどかかり、次の呼び出しにはすぐに出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations! You just added application data caching to your Quarkus application with a single line of code!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おめでとうございます。たった1行のコードでQuarkusアプリケーションにアプリケーションデータのキャッシングを追加できました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされている機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in this first version of the Spring Cache annotations extension, not all features of these annotations are supported (with proper errors being logged when trying to use an unsupported feature).  However, additional features are planned for future releases.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最初のバージョンの Spring Cache アノテーションエクステンションでは、これらのアノテーションのすべての機能がサポートされているわけではないことに注意してください (サポートされていない機能を使用しようとすると、適切なエラーがログに記録されます)。しかし、今後のリリースでは追加機能が計画されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のSpringガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、より多くのSpring互換機能があります。詳細については、以下のガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがOpenTracingを利用してインタラクティブなウェブアプリケーションのための分散トレースを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate distributed tracing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、分散トレースを実証するための簡単なRESTアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、すぐに完成した例に飛んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `smallrye-opentracing` extension, which includes the OpenTracing support and the default https://www.jaegertracing.io/[Jaeger] tracer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、OpenTracing サポートとデフォルトの link:https://www.jaegertracing.io/[Jaeger] トレーサーを含む `smallrye-opentracing` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-opentracing` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-opentracing` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/opentracing/TracedResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/opentracing/TracedResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CTRL+C`  を叩いてアプリケーションを停止させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events] builds off of the link:funqy-http[Funqy HTTP] extension to allow you to route and process Knative Events within a Funqy function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events]は 、link:funqy-http[Funqy HTTP] エクステンションをベースに構築されており、Funqy関数内でKnative Eventsをルーティングして処理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions with Knative Events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、クイックスタートコードを使って、Knative Events を使って Funqy 関数をデプロイして呼び出す方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about link:funqy[Funqy Basics].  This is a short read!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:funqy[Funqy の基礎] を読む。短時間で読めます!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have gone through the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial], specifically link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knativeチュートリアル] 、特に link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[ブローカーとトリガー] を一読していること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  It is advised to follow https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[this] Knative Tutorial put together by Red Hat.  It walks through how to set up Knative on Minikube or OpenShift in a local environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Minikube 環境で Knative をローカルに設定することは、このガイドの範囲を超えています。link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Red HatがまとめたKnativeチュートリアル] に従うことをお勧めします。このチュートリアルでは、ローカル環境でMinikubeやOpenShift上でKnativeをセットアップする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specifically you should run the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers] tutorial as this guide requires that you can invoke on a Broker to trigger the quickstart code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、クイックスタートコードをトリガーするためにブローカーを呼び出す必要があるため、特に link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[ブローカーとトリガー] のチュートリアルを実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event link:https://cloudevents.io/[specification] is a good read to give you an even greater understanding of Knative Events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative Events をより深く理解するために、Cloud Events の link:https://cloudevents.io/[仕様] を読んでおくと良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quickstart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quickstart Flow</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタートの流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quickstart works by manually sending an HTTP request containing a Cloud Event to the Knative Broker using `curl`.  The Knative Broker receives the request and triggers the startup of the Funqy container built by the quickstart.  The event triggers the invocation of a chain of Funqy functions.  The output of one function triggers the invocation of another Funqy function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタートは、Cloud Eventを含む HTTP リクエストを `curl` を使用して Knative Broker に手動で送信することで動作します。Knative Broker はリクエストを受信し、クイックスタートによって構築された Funqy コンテナの起動をトリガーします。イベントは、一連の Funqy 関数の呼び出しをトリガーします。1 つの関数の出力は、別の Funqy 関数の呼び出しをトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When living within a Knative Events environment, Funqy functions are triggered by a specific Cloud Event type.  You can have multiple Funqy functions within a single application/deployment, but they must be triggered by a specific Cloud Event Type.  The exception to this rule is if there is only one Funqy function in the application.  In that case, the event is pushed to that function irregardless of the Cloud Event type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative Events環境内で稼働する場合、Funqy関数は特定のタイプの Cloud Event によってトリガーされます。1つのアプリケーション/デプロイメント内に複数のFunqy関数を持つことができますが、それらは特定のタイプの Cloud Event によってトリガーされなければなりません。このルールの例外は、アプリケーション内にFunqy関数が1つしかない場合です。この場合、イベントは Cloud Event タイプに関係なく、その関数にプッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Funqy can only consume JSON-based data.  It supports both Binary and Structured mode of execution, but the data component of the Cloud Event message must be JSON.  This JSON must also be marshallable to and from the Java parameters and return types of your functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在、FunqyはJSONベースのデータしか消費できません。それ自体はバイナリモードと構造化モードの両方をサポートしていますが、Cloud EventメッセージのデータコンポーネントはJSONでなければなりません。このJSONは、関数のJavaパラメータやリターンタイプとの間でマーシャル可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Code</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start looking at our quickstart code so that you can understand how Knative Events map to Funqy.  Open up {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative イベントがどのように Funqy にマップされるかを理解するために、クイックスタートのコードを見てみましょう。クイックスタートコードは、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java] を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first function we'll look at is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初に見る関数は `defaultChain` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is, a Funqy function has a default Cloud Event mapping.  By default, the Cloud Event type must match the function name for the function to trigger.  If the function returns output, the response is converted into a Cloud Event and returned to the Broker to be routed to other triggers.  The default Cloud Event type for this response is the function name + `.output`.  The default Cloud Event source is the function name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この状態で、Funqy関数はデフォルトの Cloud Event マッピングを持っています。デフォルトでは、 Cloud Event のタイプは、トリガする関数の関数名と一致していなければなりません。関数が出力を返す場合、レスポンスは Cloud Event に変換され、ブローカに返されて他のトリガーにルーティングされます。このレスポンスのデフォルトの Cloud Event  タイプは、関数名 + `.output` です。デフォルトの Cloud Event のソースは、関数名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, for the `defaultChain` function, the Cloud Event type that triggers the function is `defaultChain`.  It generates a response that triggers a new Cloud Event whose type is `defaultChain.output` and the event source is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>したがって、 `defaultChain` 関数の場合、この関数をトリガーする Cloud Event のタイプは `defaultChain` です。これは、タイプが `defaultChain.output` でイベントソースが `defaultChain` である新しい Cloud Event をトリガーするレスポンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the default mapping is simple, it might not always be feasible.  You can change this default mapping through configuration.  Let's look at the next function:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのマッピングはシンプルですが、必ずしもうまくいくとは限りません。このデフォルトのマッピングは設定で変更することができます。次の関数を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `configChain` function has its Cloud Event mapping changed by configuration within {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`configChain` 関数は、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties] 内の設定により、 Cloud Event のマッピングが変更されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the configuration maps the incoming Cloud Event type `defaultChain.output` to the `configChain` function.  The `configChain` function maps its response to the `annotated` Cloud Event type, and the Cloud Event source `configChain`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、この構成では、受信するCloud Eventのタイプ `defaultChain.output` を `configChain` 関数にマッピングします。 `configChain` 関数は、そのレスポンスを `annotated` Cloud Event タイプに、Cloud Event ソース `configChain` にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.trigger` sets the Cloud Event type that triggers a specific function</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.trigger` は、特定の機能をトリガーする Cloud Event タイプを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.response-type` sets the Cloud Event type of the response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.response-type` は、レスポンスの Cloud Event タイプを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.resource-source` sets the Cloud Event source of the response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.resource-source` は、レスポンスの Cloud Event のソースを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy Knative Events extension also has annotations to do this Cloud Event mapping to your functions.  Take a look at the `annotatedChain` method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy Knative Events 拡張機能には、この Cloud Event の関数へのマッピングを行うためのアノテーションも用意されています。 `annotatedChain` メソッドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the `@CloudEventMapping` annotation on your function you can map the Cloud Event type trigger and the Cloud Event response.  In this example the `annotatedChain` function will be triggered by the `annotated` Cloud Event type and the response will be mapped to a `lastChainLink` type and `annotated` Cloud Event source.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数に `@CloudEventMapping` アノテーションを使用すると、Cloud Event タイプのトリガーとCloud Event レスポンスをマッピングできます。この例では、 `annotatedChain` 関数は `annotated` Cloud Event タイプによってトリガされ、レスポンスは `lastChainLink` タイプと `annotated` Cloud Eventソースにマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if look at all the functions defined within `SimpleFunctionChain` you'll notice that one function triggers the next.  The last function that is triggered is `lastChainLink`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、 `SimpleFunctionChain` 内で定義されているすべての関数を見てみると、ある関数が次の関数を引き金にしていることに気づくでしょう。最後にトリガーされる関数は `lastChainLink` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two things to notice about this function.  One, it has no output.  Your functions are not required to return output.  Second, there is an additional `event` parameter to the function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能には2つの注意点があります。一つは、この関数には出力がありません。あなたの関数は出力を返す必要はありません。第二に、この関数には追加の `event` パラメータがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to know additional information about the incoming Cloud Event, you can inject the `CloudEvent` interface using the Funqy `@Context` annotation.  The `CloudEvent` interface exposes information about the triggering event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したCloud Eventに関する追加情報を知りたい場合は、Funqy `@Context` アノテーションを使用して `CloudEvent` インターフェイスを注入することができます。 `CloudEvent` インターフェイスは、トリガーとなるイベントに関する情報を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom], you'll see that it is a typical Quarkus pom that pulls in one funqy dependency</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom] を見ると、典型的なQuarkusのpomで、以下のような1つのfunqy依存関係を持っていることがわかるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode and Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードとテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy Knative Events support dev mode and unit testing using RestAssured.  You can invoke on Funqy Knative Events functions using the same invocation model as link:funqy-http[Funqy HTTP] using normal HTTP requests, or Cloud Event Binary mode, or Structured Mode.  All invocation modes are supported at the same time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy Knative Eventsは、RestAssuredを使用したdevモードとユニットテストをサポートしています。通常のHTTPリクエストを使用した link:funqy-http[Funqy HTTP] と同じ呼び出しモデルを使用してFunqy Knative Events関数上で呼び出すか、Cloud Event Binaryモード、またはStructured Modeを使用して呼び出すことができます。すべての呼び出しモードが同時にサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if you open up the unit test code in {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java] you'll see that its simply using RestAssured to make HTTP invocations to test the functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java] のユニットテストコードを開くと、関数をテストするためのHTTP呼び出しを行うために、単にRestAssuredを使用していることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First build the Java artifacts:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、Javaアーティファクトをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, a docker image is required by Knative, so you'll need to build that next:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、Knativeではdockerイメージが必要なので、続いてそれをビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to replace `yourAccountName` with your docker or quay account name when you run `docker build`.  The Dockerfile is a standard Quarkus dockerfile.  No special Knative magic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`docker build` を実行する際には、必ず `yourAccountName` を docker または quay のアカウント名に置き換えてください。Dockerfileは標準のQuarkusのdockerfileです。特別なKnativeマジックはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Push your image to docker hub or quay</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イメージをDocker HubやQuayにプッシュする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, make sure to replace `yourAccountName` with your docker or quay account name when you run `docker push`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>繰り返しになりますが、 `docker push` を実行する際には、 `yourAccountName` を docker または quay のアカウント名に置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to define a Kubernetes/OpenShift service to points to your the docker image you created and pushed during build.  Take a look at {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/funqy-service.yaml[funqy-service.yaml]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のステップは、ビルド時に作成してプッシュしたdockerイメージを指すKubernetes/OpenShiftサービスを定義することです。クイックスタート/src/main/k8s/funqy-service.yaml[funqy-service.yaml]を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a standard Kubernetes service definition yaml file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはKubernetesの標準的なサービス定義のyamlファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you change the image url to point to the image you built and pushed earlier!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あなたが以前に構築してプッシュしたイメージを指すように、イメージのURLを変更することを確認してください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For our quickstart, one Kubernetes service will contain all functions.  There's no reason you couldn't break up this quickstart into multiple different projects and deploy a service for each function.  For simplicity, and to show that you don't have to have a deployment per function, the quickstart combines everything into one project, image, and service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のクイックスタートでは、1つのKubernetesサービスにすべての機能が含まれます。このクイックスタートを複数の異なるプロジェクトに分割して、機能ごとにサービスをデプロイできない理由はありません。シンプルにするために、また、機能ごとにデプロイする必要がないことを示すために、このクイックスタートでは、すべての機能を1つのプロジェクト、イメージ、サービスにまとめています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy the service yaml.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスyamlをデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next step is to deploy Knative Event triggers for each of the event types.  As noted in the code section, each Funqy function is mapped to a specific Cloud Event type.  You must create Knative Event triggers that map a Cloud Event and route it to a specific Kubernetes service.  We have 4 different triggers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップは、イベントタイプごとにKnative Eventのトリガーを展開することです。コードのセクションで述べたように、各Funqy関数は特定のCloud Eventタイプにマッピングされています。Cloud Eventをマッピングし、特定のKubernetesサービスにルーティングするKnative Eventトリガーを作成する必要があります。ここでは4つの異なるトリガーを用意しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `spec:filter:attributes:type` maps a Cloud Event type to the Kubernetes service defined in `spec:subscriber:ref`.  When a Cloud Event is pushed to the Broker, it will trigger the spin up of the service mapped to that event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`spec:filter:attributes:type` は、 `spec:subscriber:ref` で定義されている Kubernetes サービスにCloud Eventのタイプをマッピングします。Cloud EventがBrokerにプッシュされると、そのイベントにマッピングされたサービスのスピンアップがトリガーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's a trigger yaml file for each of our 4 Funqy functions.  Deploy them all:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>4つのFunqy関数それぞれのトリガーyamlファイルがあります。それらをすべてデプロイしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the demo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デモの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You'll need two different terminal windows.  One to do a curl request to the Broker, the other to watch the pod log files so you can see the messages flowing through the Funqy function event chain.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つの異なるターミナルウィンドウが必要です。一つは Broker への curl リクエストを行うためのもので、もう一つはポッドのログファイルを見るためのもので、Funqy 関数のイベントチェーンを流れるメッセージを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have the `stern` tool installed.  See the Knative Tutorial setup for information on that.  Run stern to look for logs outputted by our Funqy deployment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`stern` ツールがインストールされていることを確認してください。それについての情報は Knative チュートリアルのセットアップを参照してください。Funqy デプロイメントが出力したログを探すために stern を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a separate terminal.  You'll first need to learn the URL of the broker.  Execute this command to find it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の端末を開きます。まずブローカーのURLを知る必要があります。このコマンドを実行して探します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will provide you a url like this (exactly like this if you followed the knative tutorial): `http://default-broker.knativetutorial.svc.cluster.local` Remember this URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなURLが表示されます(knativeのチュートリアルに従った場合はこのようになります)。 `http://default-broker.knativetutorial.svc.cluster.local` このURLを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next thing we need to do is ssh into our Kubernetes cluster so that we can send a curl request to our broker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に行う必要があるのは、Kubernetes クラスタに ssh して、ブローカーに curl リクエストを送信できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now be in a shell within the Kubernetes cluster.  Within the shell, execute this curl command</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでKubernetesクラスタ内のシェルになります。シェル内で、次のような curl コマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This posts a Knative Event to the broker, which will trigger the `defaultChain` function.  As discussed earlier, the output of `defaultChain` triggers an event that is posted to `configChain` which triggers an event posted to `annotatedChain` then finally to the `lastChainLink` function.  You can see this flow in your `stern` window.  Something like this should be outputted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ブローカーに Knative イベントをポストし、 `defaultChain` 関数をトリガーします。前述したように、 `defaultChain` の出力は、 `configChain` に投稿されたイベントをトリガーにして、 `annotatedChain` に投稿されたイベントをトリガーにして、最後に `lastChainLink` 関数をトリガーにします。この流れは `stern` ウィンドウで見ることができます。以下のようなものが出力されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging を使用して HTTP メッセージを消費および生成する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM, Docker or Podman installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行したい場合は、GraalVM、Docker、Podman がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will implement a service, namely `CostConverter` that consumes HTTP messages with costs in multiple currencies and converts each cost to its value in Euro.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、複数の通貨のコストを持つ HTTP メッセージを消費し、各コストをユーロの値に変換するサービス、すなわち `CostConverter` を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let a user easily try out the service, we will implement an HTTP resource summing up the costs (`CostCollector`), and a simple web page to add new costs and watch the sum.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーが簡単にサービスを試すことができるように、コストを合計したHTTPリソース( `CostCollector` )と、新しいコストを追加して合計を見るためのシンプルなWebページを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and HTTP connector extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、Reactive MessagingとHTTPコネクタエクステンションをインポートしてMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Converter</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/reactivehttp/CostConverter.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/java/org/acme/reactivehttp/CostConverter.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume messages from the `incoming-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`incoming-costs` ストリームからメッセージを消費します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dispatch returned values to the `outgoing-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>返された値を `outgoing-costs` ストリームにディスパッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume an event with payload of type `Cost` and produce a `double`.  In the case of consuming an arbitrary object, the reactive-messaging-http extension will attempt to deserialize the request body assuming it is JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Cost` 型のペイロードを持つイベントを消費して `double` を生成します。任意のオブジェクトを消費する場合、reactive-messaging-http エクステンションは、リクエストボディが JSON であると仮定して、リクエストボディをデシリアライズしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define the `Cost` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Cost` クラスを定義してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the next step, we will create configurations for both streams in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップでは、 `application.properties` ファイルに両方のストリームの設定を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the HTTP connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP コネクタを設定する必要があります。これは `application.properties` ファイルで行います。キーは以下のように構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`channel-name` セグメントは、 `@Incoming` および `@Outgoing` アノテーションで設定された値と一致する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CostCollector</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コストコレクター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate that converting messages and passing them through works, let's add an endpoint that will receive the outgoing costs and sum them up.  This is a usual JAX-RS endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージを変換して受け渡す様子を説明するために、送信コストを受け取って集計するエンドポイントを追加してみましょう。これは通常のJAX-RSエンドポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To conveniently interact with the application, let's create a simple web page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションと便利にやりとりするために、簡単なWebページを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The page will provide a form to add costs, and an info of the current sum of costs.  The page periodically updates the sum by requesting the current sum from `/cost-collector`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このページでは、コストを追加するためのフォームと、現在のコストの合計の情報を提供します。ページは定期的に `/cost-collector` から現在の合計を要求することによって合計を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/index.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/resources/META-INF/resources/index.html` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get it running</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/index.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザで `http://localhost:8080/index.html` を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Native</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the native executable with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下ででネイティブ実行ファイルをビルドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `quarkus-http` connector options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-http` コネクタの全オプション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except of the `quarkus-http` connector, the `quarkus-reactive-messaging-http` extension also brings in `quarkus-websocket` - a connector for exposing and feeding WebSockets.  At the moment only binary data is supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-http` コネクタ以外に、 `quarkus-reactive-messaging-http` エクステンションには `quarkus-websocket` - WebSocket を公開して供給するためのコネクタ - が組み込まれています。現時点ではバイナリーデータのみサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the sink of the HTTP connector checks if the message is consumed by the remote endpoint, the WebSocket sink does not. It may happen that a failure to receive a message is not reported, e.g. if the remote side closes the WebSocket connection in a crucial moment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP コネクタのシンクは、メッセージがリモートエンドポイントによって消費されるかどうかをチェックしますが、WebSocket シンクはチェックしません。例えば、リモート側が肝心な時に WebSocket 接続を閉じた場合など、メッセージの受信に失敗したことが報告されないことがあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-websocket` connector is configured with the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-websocket` コネクタは、以下のプロパティーで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes MicroProfile Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、MicroProfile Reactive Messaging を利用してデータストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka or AMQP quickstart, you have realized that it's the same code.  The only difference is the connector configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>KafkaやAMQPのクイックスタートをした人は、同じコードであることに気づいたはずです。違いはコネクタの設定だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく知りたい場合は、Quarkusで使用されている実装である link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] のドキュメントを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting it up</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは以下をカバーしています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがOAuth2トークンを利用して、JAX-RSエンドポイントへのセキュアなアクセスを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops.  This guide explains how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、以下の方法を説明します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a Quarkus application with a main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインメソッドでQuarkusアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write command mode applications that run a task and then terminate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タスクを実行して終了するコマンドモードのアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application starts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの開始時に通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application stops</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが停止したときに通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `lifecycle-quickstart` {quickstarts-tree-url}/lifecycle-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `lifecycle-quickstart`  {quickstarts-tree-url}/lifecycle-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下が生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenの構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page accessible on `http://localhost:8080`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランディングページは次のURLでアクセス可能です: `http://localhost:8080`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native`  と `jvm`  の両方のモードに対応した `Dockerfile`  ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.lifecycle.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.lifecycle.GreetingResource`  リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will automatically generate a main method, that will bootstrap Quarkus and then just wait for shutdown to be initiated. Let's provide our own main method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは自動的にメインメソッドを生成し、Quarkusを起動し、シャットダウンが開始されるのを待つだけです。独自のメインメソッドを追加してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation tells Quarkus to use this as the main method, unless it is overridden in the config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、設定でオーバーライドされない限り、これをメインのメソッドとして使用するようQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This launches Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これによりQuarkusが起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This main class will bootstrap Quarkus and run it until it stops. This is no different to the automatically generated main class, but has the advantage that you can just launch it directly from the IDE without needing to run a Maven or Gradle command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメインクラスはQuarkusを起動し、停止するまで実行します。これは自動生成されたメインクラスと変わりませんが、MavenやGradleのコマンドを実行する必要がなく、IDEから直接起動するだけで済むという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not recommenced to do any business logic in this main method, as Quarkus has not been set up yet, and Quarkus may run in a different ClassLoader. If you want to perform logic on startup use an `io.quarkus.runtime.QuarkusApplication` as described below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだQuarkusが設定されておらず、Quarkusは別のClassLoaderで動作する可能性があるため、このメインメソッドでビジネスロジックを行うことは推奨されていません。起動時にロジックを実行したい場合は、以下のように `io.quarkus.runtime.QuarkusApplication`  を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we want to actually perform business logic on startup (or write applications that complete a task and then exit)  we need to supply a `io.quarkus.runtime.QuarkusApplication` class to the run method. After Quarkus has been started the `run` method of the application will be invoked. When this method returns the Quarkus application will exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動時に実際にビジネスロジックを実行したい場合(またはタスクを完了してから終了するアプリケーションを書きたい場合)、runメソッドに `io.quarkus.runtime.QuarkusApplication`  クラスを指定する必要があります。Quarkusが起動すると、アプリケーションの `run`  メソッドが呼び出されます。このメソッドが返されると、Quarkusアプリケーションは終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to perform logic on startup you should call `Quarkus.waitForExit()`, this method will wait until a shutdown is requested (either from an external signal like when you press `Ctrl+C` or because a thread has called `Quarkus.asyncExit()`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動時にロジックを実行したい場合は、 `Quarkus.waitForExit()`  を呼び出す必要があります。このメソッドは、シャットダウンが要求されるまで待機します( `Ctrl+C`  を押したときのような外部シグナルや、スレッドが `Quarkus.asyncExit()`  を呼び出したときのような外部シグナルのいずれか)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of what this looks like is below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その一例が以下のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting the command line arguments</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドライン引数の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to inject the arguments that were passed in on the command line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインで渡された引数を注入することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening for startup and shutdown events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタートアップとシャットダウンのイベントをリッスンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class named `AppLifecycleBean` (or pick another name) in the `org.acme.lifecycle` package, and copy the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.lifecycle`  パッケージ内に `AppLifecycleBean`  という名前の新しいクラスを作成し(または別の名前を選び)、以下の内容をコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is starting</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is terminating</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの終了時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The events are also called in _dev mode_ between each redeployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、各再配置の間に _devモード_ でイベントが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The methods can access injected beans. Check the {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] class for details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドは注入されたBeanにアクセスすることができます。詳細は {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] クラスを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the difference from `@Initialized(ApplicationScoped.class)` and `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Initialized(ApplicationScoped.class)`  との違いは? `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JVM mode, there is no real difference, except that `StartupEvent` is always fired *after* `@Initialized(ApplicationScoped.class)` and `ShutdownEvent` is fired *before* `@Destroyed(ApplicationScoped.class)`.  For a native executable build, however, `@Initialized(ApplicationScoped.class)` is fired as *part of the native build process*, whereas `StartupEvent` is fired when the native image is executed.  See link:writing-extensions#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMモードでは、 `StartupEvent`  は常に `@Initialized(ApplicationScoped.class)`  の *後に* 実行され、 `ShutdownEvent`  は `@Destroyed(ApplicationScoped.class)`  の *前に* 実行されることを除けば、実質的な違いはありません。しかし、ネイティブの実行可能なビルドでは、 `@Initialized(ApplicationScoped.class)`  はネイティブの *ビルドプロセスの一部* として実行され、 `StartupEvent`  はネイティブイメージが実行されたときに実行されます。詳細については、 link:writing-extensions#bootstrap-three-phases[Bootstrapの3つのフェーズとQuarkusの哲学]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI applications, an event with qualifier `@Initialized(ApplicationScoped.class)` is fired when the application context is initialized. See https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[the spec, window="_blank"] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI アプリケーションでは、アプリケーションコンテキストが初期化されると、修飾子 `@Initialized(ApplicationScoped.class)`  を持つイベントが発生します。詳細は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[仕様, window=_blank]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@Startup` to initialize a CDI bean at application startup</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  を使用して、アプリケーション起動時に CDI Bean を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean represented by a class, producer method or field annotated with `@Startup` is initialized at application startup:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  でアノテーションされたクラス、プロデューサメソッド、フィールドで表現されたビーンは、アプリケーションの起動時に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  でアノテーションされた各Beanに対して、 `StartupEvent`  の合成オブザーバが生成されます。デフォルトの優先度が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビーンのコンストラクタは、アプリケーションの起動時に呼び出され、結果として得られるコンテキストインスタンスがアプリケーションのコンテキストに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Dependent` beans are destroyed immediately afterwards to follow the behavior of observers declared on `@Dependent` beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Dependent` ビーンは、 `@Dependent`  ビーンに宣言されたオブザーバーの行動に従うために、その後すぐに破壊されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class is annotated with `@Startup` but with no scope annotation then `@ApplicationScoped` is added automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスが `@Startup`  でアノテーションされていて、スコープのアノテーションがない場合は、 `@ApplicationScoped`  が自動的に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`, the logged message is printed.  When the application is stopped, the second log message is printed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev`  でアプリケーションを実行すると、ログメッセージが表示されます。アプリケーションを停止すると、2 番目のログメッセージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has 3 different launch modes, `NORMAL` (i.e. production), `DEVELOPMENT` and `TEST`. If you are running `quarkus:dev` then the mode will be `DEVELOPMENT`, if you are running a JUnit test it will be `TEST`, otherwise it will be `NORMAL`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには3種類の起動モードがあります。 `NORMAL`  (つまりプロダクション)、 `DEVELOPMENT`  、 `TEST`  です。 `quarkus:dev`  を実行している場合は `DEVELOPMENT`  、JUnit テストを実行している場合は `TEST`  、それ以外の場合は `NORMAL`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application can get the launch mode by injecting the `io.quarkus.runtime.LaunchMode` enum into a CDI bean, or by invoking the static method `io.quarkus.runtime.LaunchMode.current()`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは、 `io.quarkus.runtime.LaunchMode`  enum を CDI ビーンに注入するか、静的メソッド `io.quarkus.runtime.LaunchMode.current()`  を呼び出すことで起動モードを取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Graceful Shutdown</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グレースフルシャットダウン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes support for graceful shutdown, this allows Quarkus to wait for running requests to finish, up till a set timeout. By default this is disabled, however you can configure this by setting the `quarkus.shutdown.timeout` config property. When this is set shutdown will not happen until all running requests have completed, or until this timeout has elapsed. This config property is a duration, and can be set using the standard `java.time.Duration` format, if only a number is specified it is interpreted as seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Quarkusは、実行中のリクエストが終了するまで、設定されたタイムアウトまで待機することができます。デフォルトでは無効になっていますが、 `quarkus.shutdown.timeout`  configプロパティーを設定することで設定することができます。これが設定されている場合、すべての実行中のリクエストが完了するまで、またはこのタイムアウトが経過するまでシャットダウンは行われません。この設定プロパティーは持続時間であり、標準の `java.time.Duration`  形式で設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions that accept requests need to add support for this on an individual basis. At the moment only the HTTP extension supports this, so shutdown may still happen when messaging requests are active.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストを受け付けるエクステンションは、個別にサポートを追加する必要があります。現時点では HTTP エクステンションだけがこれをサポートしているので、メッセージングリクエストがアクティブなときにシャットダウンが発生する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/users/me`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/users/me`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/admin`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/admin`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can find a list of Build Items and the extension that provides them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、ビルドアイテムとそれを提供するエクステンションの一覧を見ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK の `CompletableFuture` オブジェクトと Netty HTTP クライアントをベースにした link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[非同期プログラミング]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Identity and Access Management (IAM) enables users to manage access to AWS services and resources securely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon Identity and Access Management(IAM)は、ユーザーがAWSのサービスやリソースへのアクセスを安全に管理できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about IAM at https://aws.amazon.com/iam/[the Amazon IAM website].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://aws.amazon.com/iam/[アマゾンのIAMのサイト]を見てみると、IAMについての詳しい情報が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The IAM extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IAMエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x]をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the _lingua franca_ between microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON は今やマイクロサービス間の _共通言語_ となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、REST サービスが JSON ペイロードを消費および生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need a link:rest-client[REST client] (including support for JSON).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:rest-client[REST クライアント] が必要な場合は、別のガイドがあります (JSON のサポートを含む)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで開発するアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、リストが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server are formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザとサーバー間の情報はすべて JSON 形式になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and https://github.com/FasterXML/jackson[Jackson] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RSと link:https://github.com/FasterXML/jackson[Jackson] エクステンションをインポートするMaven構造を生成し、特に以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To improve user experience, Quarkus registers the three Jackson https://github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need to do it manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーエクスペリエンスを向上させるために、Quarkusは3つのJackson link:https://github.com/FasterXML/jackson-modules-java8[Java 8モジュール] を登録しているので、手動で登録する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports http://json-b.net/[JSON-B] so, if you prefer JSON-B over Jackson, you can create a project relying on the RESTEasy JSON-B extension instead:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは link:http://json-b.net/[JSON-B] もサポートしているので、JacksonよりもJSON-Bが好きな場合は、代わりにRESTEasy JSON-B エクステンションに依存したプロジェクトを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and http://json-b.net/[JSON-B] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RSと link:http://json-b.net/[JSON-B] 拡張をインポートするMaven構造を生成し、特に以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating your first JSON REST service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのJSON RESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、果物のリストを管理するアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create the `Fruit` bean as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下のように `Fruit` Bean を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことはJSONシリアライズレイヤーで必須であるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.rest.json.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `org.acme.rest.json.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/fruits")
public class FruitResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/fruits")
public class FruitResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実装は非常に簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Fruit` objects will be automatically serialized/deserialized by http://json-b.net/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], depending on the extension you chose when initializing the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Fruit` オブジェクトは、プロジェクトの初期化時に選択した拡張子に応じて、 link:http://json-b.net/[JSON-B] または link:https://github.com/FasterXML/jackson[Jackson] によって自動的にシリアライズ/デシリアライズされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-resteasy-jackson` or `quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-resteasy-jackson` や `quarkus-resteasy-jsonb` などの JSON 拡張機能がインストールされている場合、メディアタイプが `@Produces` や `@Consumes` アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` メディアタイプをデフォルトで使用します( `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` と `application/octet-stream` がデフォルトとなっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and consumed by the Quarkus extensions) is configured to ignore unknown properties (by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` feature).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、CDI経由で取得した(そしてQuarkusのエクステンションによって消費される)デフォルトのJackson `ObjectMapper` は、未知のプロパティーを無視するように設定されています( `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 機能を無効にすることで)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the default behavior of Jackson by setting `quarkus.jackson.fail-on-unknown-properties=true` in your `application.properties` or on a per class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で `quarkus.jackson.fail-on-unknown-properties=true` を設定するか、 `@JsonIgnoreProperties(ignoreUnknown = false)` を経由してクラスごとに設定することで、Jackson のデフォルトの動作を復元することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, Quarkus makes it very easy to configure various Jackson settings via CDI beans.  The simplest (and suggested) approach is to define a CDI bean of type `io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson configuration can be applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkusは、CDI Bean を介して、様々なJackson設定を非常に簡単に設定することができます。最も単純な(そして推奨される)アプローチは、 `io.quarkus.jackson.ObjectMapperCustomizer` 型の CDI Bean を定義し、その中で、Jackson の設定を適用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example where a custom module needs to be registered would look like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムモジュールを登録する必要がある場合の例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can even provide their own `ObjectMapper` bean if they so choose.  If this is done, it is very important to manually inject and apply all `io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that produces `ObjectMapper`.  Failure to do so will prevent Jackson specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーは、選択すれば自分の `ObjectMapper` ビーンを提供することもできます。この場合、 `ObjectMapper` を生成する CDI プロデューサの中で、すべての `io.quarkus.jackson.ObjectMapperCustomizer` Bean を手動で注入して適用することが非常に重要です。これを怠ると、様々な拡張機能によって提供される Jackson 固有のカスタマイズが適用されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As stated above, Quarkus provides the option of using JSON-B instead of Jackson via the use of the `quarkus-resteasy-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のように、Quarkusでは、 `quarkus-resteasy-jsonb` エクステンションを使用することで、Jacksonの代わりにJSON-Bを使用するオプションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same approach as described in the previous section, JSON-B can be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前項と同様のアプローチで、 `io.quarkus.jsonb.JsonbConfigCustomizer` beanを使用してJSON-Bを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example a custom serializer named `FooSerializer` for type `com.example.Foo` needs to be registered with JSON-B, the addition of a bean like the following would suffice:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `FooSerializer` という名前のカスタムシリアライザを `com.example.Foo` タイプで JSON-B で登録する必要がある場合、以下のような Bean を追加すれば十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more advanced option would be to directly provide a bean of `javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  If the latter approach is leveraged it is very important to manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI producer that produces `javax.json.bind.Jsonb`.  Failure to do so will prevent JSON-B specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より高度なオプションとしては、 `javax.json.bind.JsonbConfig` ( `Dependent` スコープ付き)の Bean を直接提供するか、極端な場合には `javax.json.bind.Jsonb` ( `Singleton` スコープ付き)のタイプの Bean を提供することが考えられます。後者のアプローチを利用する場合は、 `javax.json.bind.Jsonb` を生成する CDI プロデューサに `io.quarkus.jsonb.JsonbConfigCustomizer` Bean をすべて手動で注入して適用することが非常に重要です。これを怠ると、様々な拡張機能によって提供される JSON-B 固有のカスタマイズが適用されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a frontend</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フロントエンドの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `FruitResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now interact with your REST service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、REST サービスと対話できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with `./mvnw compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` で Quarkus を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser to `http://localhost:8080/fruits.html`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザで `http://localhost:8080/fruits.html` を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルは、通常のコマンド `./mvnw package -Pnative` でビルドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行は簡単で、 `./target/rest-json-quickstart-1.0-SNAPSHOT-runner` を実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then point your browser to `http://localhost:8080/fruits.html` and use your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、ブラウザで `http://localhost:8080/fruits.html` を開いてアプリケーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シリアライゼーションについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON serialization libraries use Java reflection to get the properties of an object and serialize them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSONシリアライズライブラリは、Javaのリフレクションを使用してオブジェクトのプロパティーを取得してシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native executables with GraalVM, all classes that will be used with reflection need to be registered.  The good news is that Quarkus does that work for you most of the time.  So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMでネイティブ実行ファイルを使用する場合、リフレクションで使用されるすべてのクラスを登録する必要があります。良いニュースは、Quarkusがほとんどの場合、その作業を代行してくれるということです。これまでのところ、 `Fruit` でさえ、リフレクトを使用するためのクラスを登録しておらず、すべてが正常に動作しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.  When you have the following REST method, Quarkus determines that `Fruit` will be serialized:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、RESTメソッドからシリアライズされた型を推論することができる場合に、何らかのマジックを実行します。以下のようなRESTメソッドがある場合、Quarkusは、 `Fruit` がシリアライズされると判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does that for you automatically by analyzing the REST methods at build time and that's why we didn't need any reflection registration in the first part of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、ビルド時にRESTメソッドを分析することで、自動的にそのような処理を行ってくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another common pattern in the JAX-RS world is to use the `Response` object.  `Response` comes with some nice perks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSの世界では、 `Response` オブジェクトを使用するのがもう一つの一般的なパターンです。 `Response` にはいくつかの素晴らしい特典があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can return different entity types depending on what happens in your method (a `Legume` or an `Error` for instance);</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドで何が起こるかによって異なるエンティティータイプを返すことができます (例えば `Legume` や `Error` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can set the attributes of the `Response` (the status comes to mind in the case of an error).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `Response` の属性を設定することができます (エラーが発生した時にステータスを知ることができます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your REST method then looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTメソッドは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.  In this case, Quarkus won't be able to automatically register for reflection the required classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Response` に含まれるタイプは情報がないため、Quarkusがビルド時に判断することはできません。この場合、Quarkusは必要なクラスを自動的に反映登録することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This leads us to our next section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが次のセクションにつながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create the `Legume` class which will be serialized as JSON, following the same model as for our `Fruit` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Fruit` クラスと同じモデルに従って、JSON としてシリアライズされる `Legume` クラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's create a `LegumeResource` REST service with only one method which returns the list of legumes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、マメ科植物のリストを返すメソッドを一つだけ持つ `LegumeResource` REST サービスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method returns a `Response` and not a list of `Legume`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは `Response` を返し、 `Legume` のリストではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to display our list of legumes.  In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、マメ科植物のリストを表示するための簡単なウェブページを追加してみましょう。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] ファイルの内容を含む `legumes.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a browser to http://localhost:8080/legumes.html and you will see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザを開いて http://localhost:8080/legumes.html にアクセスすると、マメ科植物のリストが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part starts when running the application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>興味深い部分は、アプリケーションをネイティブ実行ファイルとして実行するときに始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the native executable with `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative` でネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>execute it with `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./target/rest-json-quickstart-1.0-SNAPSHOT-runner` で実行します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No legumes there.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこには豆類はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.  The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のように、Quarkusが `Legume` クラスを判断できなかったことが問題となっており、REST エンドポイントを解析して何らかの反映が必要となります。JSONシリアライズライブラリは、 `Legume` のフィールドのリストを取得しようとすると空のリストを取得するので、フィールドのデータをシリアライズしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.  GraalVM will simply return an empty list of fields.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現時点では、JSON-BやJacksonがクラスのフィールドのリストを取得しようとしたときに、そのクラスがリフレクションに登録されていない場合、例外はスローされません。GraalVMは単に空のフィールドのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully, this will change in the future and make the error more obvious.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>うまくいけば、将来的にはこれが変化して、エラーがより明白になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can register `Legume` for reflection manually by adding the `@RegisterForReflection` annotation on our `Legume` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Legume` クラスに `@RegisterForReflection` アノテーションを追加することで、手動で `Legume` を リフレクション用に登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's do that and follow the same steps as before:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それを実行して、今までと同じ手順を踏んでみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hit `Ctrl+C` to stop the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Ctrl+C` を叩いてアプリケーションを停止させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, you can see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回はマメ科の一覧が表示されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return _reactive types_ to handle asynchronous processing.  Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write reactive and asynchronous code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期処理を処理するために _リアクティブ型_ を返すことができます。Quarkusでは、リアクティブで非同期なコードを書くために link:https://smallrye.io/smallrye-mutiny[Mutiny] の使用を推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To integrate Mutiny and RESTEasy, you need to add the `quarkus-resteasy-mutiny` dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny と RESTEasy を統合するには、 `quarkus-resteasy-mutiny` 依存関係をプロジェクトに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, your endpoint can return `Uni` or `Multi` instances:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、エンドポイントは `Uni` や `Multi` のインスタンスを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `Uni` when you have a single result.  Use `Multi` when you have multiple items that may be emitted asynchronously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>単一の結果がある場合は `Uni` を使用します。 `Multi` は、非同期的に放出される可能性のある複数の項目がある場合に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Uni` and `Response` to return asynchronous HTTP responses: `Uni&lt;Response&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` と `Response` を使用して、非同期 HTTP レスポンスを返すことができます: `Uni&lt;Response&gt;` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about Mutiny can be found in the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyについての詳細は、 link:getting-started-reactive#mutiny[Reactiveの入門ガイド] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both HTTP request and response can be intercepted by providing `ContainerRequestFilter` or `ContainerResponseFilter` implementations respectively. These filters are suitable for processing the metadata associated with a message: HTTP headers, query parameters, media type, and other metadata. They also have the capability to abort the request processing, for instance when the user does not have the permissions to access the endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP リクエストとレスポンスの両方とも、それぞれ `ContainerRequestFilter` または `ContainerResponseFilter` の実装を提供することで、 インターセプトすることができます。これらのフィルタは、メッセージに関連付けられたメタデータを処理するのに適しています。HTTP ヘッダ、クエリパラメーター、メディアタイプ、その他のメタデータです。また、ユーザーがエンドポイントにアクセスする権限を持っていない場合など、リクエスト処理を中止する機能も持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's use `ContainerRequestFilter` to add logging capability to our service. We can do that by implementing `ContainerRequestFilter` and annotating it with the `@Provider` annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ContainerRequestFilter` を使用して、サービスにロギング機能を追加してみましょう。 `ContainerRequestFilter` を実装して、 `@Provider` アノテーションをつけることで実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, whenever a REST method is invoked, the request will be logged into the console:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、RESTメソッドが呼び出されるたびに、リクエストがコンソールにログとして記録されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[クロスオリジンリソース共有] (CORS)は、ウェブページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a CORS filter. Read the link:http-reference#cors-filter[HTTP Reference Documentation] to learn how to use it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはCORSフィルターが付属しています。使用方法については、 link:http-reference#cors-filter[HTTPリファレンスドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with GZip support (even though it is not enabled by default). The following configuration knobs allow to configure GZip support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはGZipサポートが搭載されています(デフォルトでは有効になっていませんが)。以下の設定ノブを使用して、GZipサポートを設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable Gzip support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gzipサポートを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the upper limit on deflated request body. This is useful to mitigate potential attacks by limiting their reach. The default value is `10M`.  This configuration option would recognize strings in this format (shown as a regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix is given, assume bytes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフレーションされたリクエストボディの上限を設定します。これは、リーチを制限することで潜在的な攻撃を緩和するのに便利です。既定値は `10M` です。この設定オプションは、以下の形式の文字列を認識します(正規表現で表示されます): `[0-9]+[KkMmGgTtPpEeZzYy]?` .サフィックスが指定されていない場合は、バイトとみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once GZip support has been enabled you can use it on an endpoint by adding the `@org.jboss.resteasy.annotations.GZIP` annotation to your endpoint method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GZip サポートが有効になったら、エンドポイントメソッドに `@org.jboss.resteasy.annotations.GZIP` アノテーションを追加することで、エンドポイントで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to compress everything then we recommended that you use the `quarkus.http.enable-compression=true` setting instead to globally enable compression support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてを圧縮したい場合は、代わりに `quarkus.http.enable-compression=true` の設定を使用してグローバルに圧縮サポートを有効にすることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multipart Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチパートサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy supports multipart via the https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyは link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider] を介してマルチパートをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides an extension called `quarkus-resteasy-multipart` to make things easier for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、 `quarkus-resteasy-multipart` というエクステンションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension slightly differs from the RESTEasy default behavior as the default charset (if none is specified in your request) is UTF-8 rather than US-ASCII.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この拡張機能は、デフォルトの文字セットが US-ASCII ではなく UTF-8 であるため、RESTEasy のデフォルトの動作とは若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior with the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、以下の構成プロパティーで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Servlet compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーブレットとの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP server, or on top of Undertow if you have any servlet dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、RESTEasyはVert.x HTTPサーバーの上で直接実行するか、サーブレットに依存している場合はUndertowの上で実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a result, certain classes, such as `HttpServletRequest` are not always available for injection. Most use-cases for this particular class are covered by JAX-RS equivalents, except for getting the remote client's IP. RESTEasy comes with a replacement API which you can inject: https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`], which has the methods https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] and https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] to solve this problem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その結果、 `HttpServletRequest` のような特定のクラスが常にインジェクションに利用できるわけではありません。この特定のクラスのほとんどのユースケースは、リモートクライアントの IP を取得することを除いて、JAX-RS と同等のものでカバーされています。RESTEasy には、インジェクション可能な代替 API が付属しています。 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`] これは以下のメソッドを持っています。 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] そして link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] を解決するために、この問題を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the RESTEasy extension and link:rest-client[the REST Client extension] share the same infrastructure.  One important consequence of this consideration is that they share the same list of providers (in the JAX-RS meaning of the word).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、RESTEasyエクステンションと link:rest-client[RESTクライアントエクステンションは] 同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RSの意味での)プロバイダーのリストを共有しているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 *サーバー* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 *クライアント* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No Need for `Application` Class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Application` クラスは不要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration via an application-supplied subclass of `Application` is supported, but not required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Application` のアプリケーションが提供するサブクラスによる設定もサポートされていますが、必須ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only a single JAX-RS application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>単一のJAX-RSアプリケーションのみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In contrast to JAX-RS (and RESTeasy) running in a standard servlet-container, Quarkus only supports the deployment of a single JAX-RS application.  If multiple JAX-RS `Application` classes are defined, the build will fail with the message `Multiple classes have been annotated with @ApplicationPath which is currently not supported`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS(およびRESTeasy)が標準のサーブレットコンテナーで実行されているのとは対照的に、Quarkusは単一のJAX-RSアプリケーションのデプロイのみをサポートしています。複数のJAX-RS `Application` クラスが定義されている場合、ビルドは `Multiple classes have been annotated with @ApplicationPath which is currently not supported` というメッセージとともに失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If multiple JAX-RS applications are defined, the property `quarkus.resteasy.ignoreApplicationClasses=true` can be used to ignore all explicit `Application` classes. This makes all resource-classes available via the application-path as defined by `quarkus.resteasy.path` (default: `/`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の JAX-RS アプリケーションが定義されている場合、プロパティー `quarkus.resteasy.ignoreApplicationClasses=true` を使用して、すべての明示的な `Application` クラスを無視することができます。これにより、すべてのリソースクラスが `quarkus.resteasy.path` で定義されたアプリケーションパスを介して利用できるようになります(デフォルトは `/` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle of Resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus all JAX-RS resources are treated as CDI beans.  It's possible to inject other beans via `@Inject`, bind interceptors using bindings such as `@Transactional`, define `@PostConstruct` callbacks, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、すべてのJAX-RSリソースはCDI Bean として扱われます。 `@Inject` を介して他の Bean を注入したり、 `@Transactional` のようなバインディングを使用してインターセプターをバインドしたり、 `@PostConstruct` コールバックを定義したりすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no scope annotation declared on the resource class then the scope is defaulted.  The default scope can be controlled through the `quarkus.resteasy.singleton-resources` property.  If set to `true` (default) then a *single instance* of a resource class is created to service all requests (as defined by `@javax.inject.Singleton`).  If set to `false` then a *new instance* of the resource class is created per each request.  An explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, etc.) always overrides the default behavior and specifies the lifecycle of resource instances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースクラスでスコープ注釈が宣言されていない場合は、スコープはデフォルトになります。デフォルトのスコープは `quarkus.resteasy.singleton-resources` プロパティーで制御できます。 `true` (デフォルト) に設定すると、( `@javax.inject.Singleton` で定義されているように) すべてのリクエストにサービスを提供するためのリソースクラスの *単一のインスタンス* が作成されます。 `false` に設定すると、各リクエストごとにリソースクラスの *新しい インスタンス* が作成されます。明示的な CDI スコープ注釈 ( `@RequestScoped` , `@ApplicationScoped` , など) は常にデフォルトの動作を上書きし、リソースインスタンスのライフサイクルを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating JSON REST services with Quarkus is easy as it relies on proven and well known technologies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用したJSON RESTサービスの作成は、実績のあるよく知られたテクノロジーに依存しているため、簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, Quarkus further simplifies things under the hood when running your application as a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、Quarkusは、アプリケーションをネイティブ実行ファイルとして実行する際に、水面下の作業をさらに簡略化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is only one thing to remember: if you use `Response` and Quarkus can't determine the beans that are serialized, you need to annotate them with `@RegisterForReflection`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>覚えておくべきことは一つだけあります。 `Response` を使用していて、Quarkus がシリアライズされているビーンを特定できない場合は、 `@RegisterForReflection` を使って注釈を付ける必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to test your Quarkus Application.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションのテスト方法について説明します。このガイドでは、以下の内容について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing in native mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of resources into tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへのリソースの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The completed greeter application from the link:getting-started[Getting Started Guide]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:getting-started[入門ガイド]の完成済のgreeterアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、入門ガイドの一部として作成された最初のテストを拡張します。テストへのインジェクションと、ネイティブの実行ファイルをテストする方法もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started-testing`  {quickstarts-tree-url}/getting-started-testing[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide assumes you already have the completed application from the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 `getting-started`  ディレクトリーの完成したアプリケーションをすでに持っていることを前提としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have started from the Getting Started example you should already have a completed test, including the correct `pom.xml` setup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめにのサンプルから始めた場合は、正しい `pom.xml`  の設定を含めて、すでにテストが完了しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file you should see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml`  ファイルには、2つのテスト依存関係があるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-junit5`  は、テストフレームワークを制御する `@QuarkusTest`  アノテーションを提供するため、テストには必須です。 `rest-assured`  は必須ではありませんが、HTTP エンドポイントをテストするのに便利な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JUnit 5を使用しているので、 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]のバージョンを設定する必要があります。デフォルトのバージョンはJUnit 5をサポートしていない為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `java.util.logging.manager`  システムプロパティーを設定して、テストが正しい logmanager と `maven.home`  を使用して、 `${maven.home}/conf/settings.xml` からのカスタム設定が適用されるようにしています (存在する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project should also contain a simple test:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトには簡単なテストも含まれているはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストはHTTPを使用して、RESTエンドポイントを直接テストします。テストが実行されると、テストが実行される前にアプリケーションが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controlling the test port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートの制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはデフォルトではポート `8080`  をリッスンしますが、テストを実行する場合はデフォルトで `8081`  をリッスンします。これにより、アプリケーションを並行して実行しながらテストを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the test port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `application.properties` の `quarkus.http.test-port` を設定することで、を HTTP 用にテストで使われるポートを設定出来、 `quarkus.http.test-ssl-port` を設定することで HTTPS 用にテストで使用するポートを設定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`0` will result in the use of a random port (assigned by the operating system).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`0` を使用すると、(オペレーティングシステムによって割り当てられた)ランダムなポートが使用されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはまた、テストを実行する前にRestAssuredによって使用されるデフォルトのポートを更新するRestAssuredインテグレーションも提供しているため、追加の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストで REST Assured を使用する場合、接続と応答のタイムアウトは 30 秒に設定されます。この設定は `quarkus.http.test-timeout`  プロパティーでオーバーライドできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URLをテストに直接注入することも可能で、別のクライアントを使用するのが簡単になります。これは `@TestHTTPResource`  アノテーションで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的なリソースをロードするための簡単なテストを書いてみましょう。まず、シンプルなHTMLファイルを `src/main/resources/META-INF/resources/index.html` に作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create a simple test to ensure that this is being served correctly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが正しく提供されているかどうかを確認するための簡単なテストを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションを使用すると、QuarkusインスタンスのURLを直接注入することができます。アノテーションの値は、URLのパス部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ `@TestHTTPResource`  では、URL の `URI` , `URL` , `String`  表現を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a specific endpoint</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のエンドポイントのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured と `@TestHTTPResource`  の両方で、パスをハードコーディングするのではなく、テストするエンドポイントクラスを指定することができます。これは現在、JAX-RS エンドポイント、サーブレット、リアクティブルートの両方をサポートしています。これにより、特定のテストがどのエンドポイントをテストしているかを正確に確認することが非常に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of these examples I am going to assume we have an endpoint that looks like the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの例では、以下のようなエンドポイントを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは現在、JAX-RS のコンテキストパスを設定するための `@ApplicationPath()`  アノテーションをサポートしていません。カスタムのコンテキストパスを設定したい場合は、代わりに `quarkus.resteasy.path`  の設定値を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TestHTTPResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストHTTPリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用してエンドポイントのパスを指定することが出来、指定されたエンドポイントからパスが抽出されます。 `TestHTTPResource`  エンドポイントにも値を指定すると、エンドポイントパスの最後に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because `GreetingResource` is annotated with `@Path("/hello")` the injected URL will end with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingResource`  は `@Path("/hello")`  とアノテーションされているので、注入された URL は `/hello`  で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTassured</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured ベースパス (すなわち、すべてのリクエストのルートとなるデフォルトパス) を制御するには、 `io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用できます。これはクラスやメソッドレベルで適用できます。グリーティングリソースをテストするには、以下のようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells RESTAssured to prefix all requests with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、RESTAssured はすべてのリクエストの前に `/hello` を付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note we don't need to specify a path here, as `/hello` is the default for this test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストでは `/hello`  がデフォルトなので、ここでパスを指定する必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection into tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、HTTP エンドポイントを介してアプリをテストする統合スタイルのテストしか取り上げてきませんでしたが、ユニットテストを行い、Beanを直接テストしたい場合はどうでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、 `@Inject`  アノテーションを介してテストにCDI Beanを注入できるようにすることで、これをサポートしています(実際、Quarkusのテストは完全なCDI Beanなので、すべてのCDI機能を使用することができます)。HTTPを使用せずにグリーティングサービスを直接テストするシンプルなテストを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GreetingService` bean will be injected into the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingService`  Beanがテストに注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applying Interceptors to Tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへのインターセプターの適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述したように、Quarkusのテストは実際には完全なCDI Beanであり、通常のようにCDIインターセプターを適用することができます。例えば、トランザクションのコンテキスト内でテストメソッドを実行したい場合、 `@Transactional`  アノテーションをメソッドに適用するだけで、トランザクションインターセプターがそれを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this you can also create your own test stereotypes. For example we could create a `@TransactionalQuarkusTest` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これに加えて、独自のテスト・ステレオタイプを作成することもできます。例えば、次のように `@TransactionalQuarkusTest`  を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションをテストクラスに適用すると、 `@QuarkusTest`  と `@Transactional`  の両方のアノテーションを適用したかのように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tests and Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストとトランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストでは標準のQuarkus `@Transactional`  アノテーションを使用することができますが、これは、テストでデータベースに加えた変更が永続化されることを意味します。テストの終了時に変更をロールバックしたい場合は、 `io.quarkus.test.TestTransaction`  アノテーションを使用することができます。これは、トランザクション内でテストメソッドを実行しますが、テストメソッドが完了したらロールバックして、データベースの変更を元に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターの代わりに、あるいはインターセプターに加えて、以下のコールバックインターフェースを実装することで、 *すべての* `@QuarkusTest` クラスを充実させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback` has been deprecated in favor of `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback` and will be removed in future releases of Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback`  は `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`  に代わって非推奨となり、Quarkusの将来のリリースでは削除される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a callback implementation has to be registered as a "service provider" as defined by `java.util.ServiceLoader`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなコールバックの実装は、 `java.util.ServiceLoader`  で定義されている「サービスプロバイダ」として登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the following sample callback:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下のようなサンプルコールバックです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to read annotations from the test class or method to control what the callback shall be doing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスやメソッドからアノテーションを読み込んで、コールバックが何をするかを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has
         to run tests in a custom classloader which JUnit is not aware of.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BeforeEachCallback` のような JUnit Jupiter コールバックインターフェイスを使うことも可能ですが、QuarkusはJUnitが把握しないカスタムクラスローダーでテストを実行する必要がある為、クラスローディングの問題にぶつかるかもしれません。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Different Profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるプロファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shutdown at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでのところ、すべての例では、すべてのテストに対して一度だけQuarkusを起動しています。最初のテストが実行される前にQuarkusが起動し、次にすべてのテストが実行され、最後にQuarkusがシャットダウンします。これにより、非常に高速なテストが可能になりますが、異なる設定をテストすることができないため、少し制限があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この問題を回避するために、Quarkusはテストプロファイルの考え方をサポートしています。以前に実行したテストとは異なるプロファイルを持つテストがある場合、Quarkusはテストを実行する前にシャットダウンされ、新しいプロファイルで開始されます。これは、テスト時間にシャットダウン/起動サイクルが追加されるため、明らかに少し遅くなりますが、非常に大きな柔軟性が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to reduce the amount of times Quarkus needs to restart it is recommended that you place all tests that need a specific profile into their own package, and then run tests alphabetically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの再起動の回数を減らすために、特定のプロファイルを必要とするすべてのテストを独自のパッケージに入れ、アルファベット順にテストを実行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロフィールの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストプロファイルを実装するには、 `io.quarkus.test.junit.QuarkusTestProfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to override configuration properties. Here we are changing the JAX-RS root path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法では、設定プロパティーをオーバーライドすることができます。ここでは、JAX-RSのルートパスを変更しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to enable CDI `@Alternative` beans. This makes it easy to mock out certain beans functionality.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドを使うことで、CDI `@Alternative`  Beanを有効にすることができます。これにより、特定のBeanの機能を簡単にモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to change the config profile. As this default is `test` this does nothing, but is included for completeness.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは設定プロファイルを変更するために使用できます。このデフォルトは `test`  なので、これは何もしませんが、完全性を保つために含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to apply **additional** `QuarkusTestResourceLifecycleManager` classes, specific for this profile only. If this method is not overridden, then only the `QuarkusTestResourceLifecycleManager` classes enabled via the `@QuarkusTestResource` class annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドを使用すると、このプロファイル専用の `QuarkusTestResourceLifecycleManager`  クラスを *追加で* 適用することができます。このメソッドがオーバーライドされていない場合は、 `@QuarkusTestResource`  クラスアノテーションを介して有効化された `QuarkusTestResourceLifecycleManager`  クラスのみが、このプロファイルを使用するテストに使用されます (これは、プロファイルを全く使用しないテストと同じ動作です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have defined our profile we need to include it on our test class. We do this with `@TestProfile(MockGreetingProfile.class)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルを定義したので、それをテストクラスに含める必要があります。 `@TestProfile(MockGreetingProfile.class)` で、これを行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the test profile config is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストプロファイルの設定はすべて単一のクラスに保存されているので、前回のテストが同じ設定で実行されたかどうかが簡単にわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モックサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、2つの異なるアプローチを使用したモックオブジェクトの使用をサポートしています。CDIの代替品を使用してすべてのテストクラスのBeanをモックアウトするか、 `QuarkusMock`  を使用してテストごとにBeanをモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI `@Alternative` mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI `@Alternative`  メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使用するには、 `src/test/java`  ディレクトリーのクラスでモックしたいBeanをオーバーライドし、 `@Alternative`  と `@Priority(1)`  アノテーションをBeanに配置するだけです。あるいは、便利な `io.quarkus.test.Mock`  ステレオタイプアノテーションを使用することもできます。この組み込みステレオタイプは、 `@Alternative`  、 `@Priority(1)`  、 `@Dependent`  を宣言します。例えば、以下のようなサービスがあるとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I could mock it with the following class in `src/test/java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/test/java`  で以下のクラスでモックできました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overrides the `@Dependent` scope declared on the `@Mock` stereotype.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Mock`  ステレオタイプで宣言された `@Dependent`  スコープをオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替品が `src/main/java`  ではなく `src/test/java`  ディレクトリーに存在することが重要です。そうでなければ、テスト以外も常に有効になってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that at present this approach does not work with native image testing, as this would required the test alternatives to be baked into the native image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、このアプローチはネイティブイメージテストでは機能しないことに注意してください。テスト代替品がネイティブイメージに焼き込まれる必要がある為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.QuarkusMock`  クラスは、通常のスコープ付きBeanを一時的にモックアウトするために使用することができます。 `@BeforeAll`  メソッドでこのメソッドを使用した場合、モックは現在のクラスのすべてのテストに対して有効になりますが、test メソッドでこれを使用した場合、モックは現在のテストの間のみ有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法は、通常のスコープ付き CDI Bean(例: `@ApplicationScoped` , `@RequestScoped`  など、 `@Singleton`  と `@Dependent`  以外の基本的にすべてのスコープ)に対して使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage could look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用例は次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションされたインスタンスはここでは利用できないので、 `installMockForType` を使用します。このモックは両方のテストメソッドに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは `installMockForInstance`  を使用して注入されたBeanを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mockitoには依存しないことに注意してください。好きなモッキングライブラリを使うことができますし、必要な動作を提供するためにオブジェクトを手動でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further simplification with `@InjectMock`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock` での更なる単純化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusMock`  で提供されている機能をベースに、Quarkusでは、 `QuarkusMock`  でサポートされているBeanをモックするために link:https://site.mockito.org/[Mockito を]簡単に利用できるようにしています。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectMock`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock`  を使用すると、先ほどの例は次のように書くことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock` により、モックがテストクラスのテストメソッドに存在することになり、利用可能になります (他のテストクラスはこの影響を受け *ません* )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mockableBean1` is configured here for every test method of the class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスのすべてのテストメソッドに対して `mockableBean1`  が設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the `mockableBean2` mock has not been configured, it will return the default Mockito response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mockableBean2`  のモックが設定されていないので、デフォルトの Mockito レスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this test the `mockableBean2` is configured, so it returns the configured response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストでは、 `mockableBean2`  が設定されているので、設定されたレスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のテストは `@InjectMock`  の機能を示すのには良いですが、実際のテストを上手く表してはいません。実際のテストでは、ほとんどの場合、モックを設定し、モックされたBeanを使用するBeanをテストします。以下に例を示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greetingService`  をモックとして設定したので、 `GreetingService`  Beanを使用する `GreetingResource`  は、通常の `GreetingService` Beanのレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spies instead of Mocks with `@InjectSpy`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `@InjectSpy` で、モックの代わりにスパイを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`InjectMock`  で提供されている機能をベースに、 `QuarkusMock`  でサポートされているビーンズをスパイするために link:https://site.mockito.org/[Mockito ]を簡単に利用できるようにしました。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectSpy`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを行う際に、特定の論理パスが取られたかどうかを確認するだけで済む場合もありますし、Spied クローン上で残りのメソッドを実行している間に、1つのメソッドのレスポンスをスタブアウトするだけで済む場合もあります。Spy パーシャル モックの詳細については link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito のドキュメント]を参照してください。いずれの場合も、オブジェクトの Spy が望ましいでしょう。 `@InjectSpy`  を使用して、先ほどの例は次のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値をオーバーライドするのではなく、 `GreetingService`  の greet メソッドがこのテストで呼び出されたことを確認したいだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we are telling the Spy to return "hi" instead of "hello". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、"hello"の代わりに"hi"を返すようにSpyに指示しています。 `GreetingResource`  が `GreetingService`  から挨拶を要求するとき、通常の `GreetingService`  Bean のレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are verifying that we get the mocked response from the Spy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、スパイからのモックされた応答を得ることを検証しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock` with `@RestClient`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock`  との併用 `@RestClient`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@RegisterRestClient`  は、実行時に rest-client の実装を登録しています。Beanは通常のスコープである必要があるため、インターフェイスに `@ApplicationScoped` を付与する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the test class here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスの例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that this injection point is meant to use an instance of `RestClient`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この注入ポイントが `RestClient`  のインスタンスを使用することを意味していることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the link:hibernate-orm-panache#mocking[Hibernate ORM with Panache Mocking] and link:mongodb-panache#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-hibernate-orm-panache`  や `quarkus-mongodb-panache` のエクステンションを使っている場合は、 link:hibernate-orm-panache#mocking[Hibernate ORM とPanache Mocking]や link:mongodb-panache#mocking[MongoDB とPanache Mocking]のドキュメントをチェックして、データアクセスをモックする最も簡単な方法を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus Security, check out the link:security-testing[Testing Security] section for information on how to easily test security features of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityを使用している場合、アプリケーションのセキュリティー機能を簡単にテストする方法については、「 link:security-testing[セキュリティーのテスト]」のセクションをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非常に一般的なニーズは、Quarkusアプリケーションがテストを開始する前に、Quarkusアプリケーションに依存するいくつかのサービスを開始することです。このニーズに対応するために、Quarkusでは、 `@io.quarkus.test.common.QuarkusTestResource`  と `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[here]), or starting a mock HTTP server using http://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here]).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、 `QuarkusTestResourceLifecycleManager`  の実装がいくつか提供されていますが(H2データベースを起動する `io.quarkus.test.h2.H2DatabaseTestResource` や、モックKubernetes APIサーバーを起動する `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource`  を参照)、特定のアプリケーションのニーズに対応するためにカスタム実装を作成するのが一般的です。一般的なケースとしては、 link:https://www.testcontainers.org/[Testcontainers]を使ってdockerコンテナーを起動したり(その例は link:https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[こちら]にあります)、 link:http://wiremock.org/[Wiremock]を使ってモックHTTPサーバを起動したり(その例は link:https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[こちら]にあります)などがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to test native executables using `@NativeImageTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@NativeImageTest` を使用してネイティブ実行ファイルをテストすることも可能です。これは、テストに注入すること(そして、ネイティブ実行可能ファイルは別の非JVMプロセスで実行されることーこれは実際には可能ではありません)を除いて、このガイドで述べたすべての機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is covered in the link:building-native-image[Native Executable Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは link:building-native-image[ネイティブ実行可能ファイルガイド] で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `@QuarkusTest` from an IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE から `@QuarkusTest`  を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most IDEs offer the possibility to run a selected class as JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ほとんどの IDE では、選択したクラスを JUnit テストとして直接実行できるようになっています。そのためには、選択した IDE の設定でいくつかのプロパティーを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.logging.manager` (see link:logging[Logging Guide])</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java.util.logging.manager`  (ロ link:logging[ギングガイド]を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`maven.settings`  (カスタム版の `settings.xml`  ファイルをテストに使用する場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy your current "Installed JRE" definition into a new one, where you will add the properties as a new VM arguments:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の"Installed JRE"定義を新しい定義にコピーし、新しいVMの引数としてプロパティーを追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Dmaven.home=&lt;path-to-your-maven-installation&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`-Dmaven.home=&amp;amp;lt;path-to-your-maven-installation&amp;amp;gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any "Run as JUnit" configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このJRE定義をQuarkusプロジェクトのターゲットランタイムとして使用すると、「Run as JUnit」設定に回避策が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode "run with" configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VSCode "run with" 設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `settings.json` placed in the root of your project directory or in the workspace will need the workaround in your test configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトディレクトリーやワークスペースのルートにある `settings.json`  は、テスト設定で回避策が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing needed in IntelliJ because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJでは何も必要ありません。なぜなら、IDEは `systemPropertyVariables` を `pom.xml`のsurefireプラグイン設定から取得するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCを始めるには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers three endpoints:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、3つのエンドポイントを提供する非常にシンプルなマイクロサービスを構築します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple. The main difference here is that we are using a `@RolesAllowed` annotation to make sure that only users granted with the `admin` role can access the endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/admin` エンドポイントのソースコードも非常にシンプルです。ここでの主な違いは、 `admin` ロールで付与されたユーザーだけがエンドポイントにアクセスできるように `@RolesAllowed` アノテーションを使用していることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Health specification through the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Healthエクステンションを使用してMicroProfile Health仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-health-quickstart \
    -Dextensions="health"
cd microprofile-health-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-health-quickstart \
    -Dextensions="health"
cd microprofile-health-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>adding the `smallrye-health` Quarkus extension to your project using the `quarkus-maven-plugin`: +</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`smallrye-health` Quarkusエクステンションをプロジェクトに追加するには、 `quarkus-maven-plugin`. +</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="health"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="health"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or simply adding the following Maven dependency: +</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、単に以下のMaven依存関係を追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Introduction to Contexts and Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - コンテキストと依存性注入(CDI)の紹介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本原理について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_制御の反転_ (Inversion of Control, IoC )というプログラミングの原理を聞いたことがあると思います。依存性注入はIoCの実装技術の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Bean Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなBeanの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all other beans that inject `Translator`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはスコープアノテーションです。これはコンテナーに、Beanのインスタンスをどのコンテキストに関連付けるかを伝えます。この特定のケースでは、 *単一のBeanインスタンス* がアプリケーション用に作成され、 `Translator`の注入を行う他の全てのBeanによって使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはフィールド注入ポイントです。 `Translator`  が `Dictionary`  Beanに依存していることをコンテナーに伝えます。マッチするBeanがない場合、ビルドは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics. We will talk about &lt;&lt;interceptors,interceptors&gt;&gt; later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはインターセプター結合アノテーションです。この場合、アノテーションは MicroProfile Metrics から来ています。関連するインターセプターは呼び出しをインターセプトし、関連するメトリクスを更新します。 &lt;&lt;interceptors,インターセプター&gt;&gt;については後述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your can use programmatic lookup via `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance`  を通じてプログラム的なルックアップを使用して、実行時に曖昧さを解決したり、指定された型を実装しているすべてのBeanを反復処理したりすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このインジェクションポイントは、 `Dictionary`  型を実装した複数のBeanがあっても、曖昧な依存関係にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.inject.Instance` extends `Iterable`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance` は `Iterable` を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initialized and Constructor Injection Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初期化とコンストラクタのインジェクション例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the absence of no-args constructor and "add" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one constructor present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはコンストラクタのインジェクションです。実際には、このコードは通常のCDI実装では動作しません。通常のスコープを持つBeanは常にno-argsコンストラクタを宣言しなければならず、Beanのコンストラクタは `@Inject`  でアノテーションされなければなりません。しかし、Quarkusでは、no-argsコンストラクタが存在しないことを検出し、バイトコードに直接「追加」します。また、コンストラクタが1つしかない場合は、 `@Inject`  を追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer method must be annotated with `@Inject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イニシャライザメソッドには `@Inject`  をアノテーションしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer may accept multiple parameters - each one is an injection point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イニシャライザは複数のパラメーターを受け付けることができ、それぞれがインジェクションポイントとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@javax.inject.Qualifier` meta-annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Qualifier型は、 `@Retention(RUNTIME)`  として定義された Java アノテーションで、 `@javax.inject.Qualifier`  メタアノテーションでアノテーションされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修飾子の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanの修飾子は、Beanクラスやプロデューサのメソッドやフィールドに修飾子タイプをアノテーションすることで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean With Custom Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム修飾子を持つ Bean の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Superior`  は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[修飾子アノテーション, window=_blank]です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このBeanは `@Inject @Superior Translator`  と `@Inject @Superior SuperiorTranslator`  には割り当てられますが、 `@Inject Translator`  には割り当てられません。その理由は、 `@Inject Translator`  はタイプセーフ解決の際に自動的に `@Inject @Default Translator`  に変換されるからです。また、私たちの `SuperiorTranslator`  は `@Default`  を宣言していないので、元の `Translator`  Beanだけが代入可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanのスコープはインスタンスのライフサイクルを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every bean has exactly one scope.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての豆は、正確に1つのスコープを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There can be other custom scopes provided by Quarkus extensions. For example, `quarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションによって提供される他のカスタムスコープもあります。例えば、 `quarkus-narayana-jta` は `javax.transaction.TransactionScoped` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window="_blank"] could be hard to grasp but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実際、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[クライアントプロキシー, window=_blank]は理解するのが難しいかもしれませんが、いくつかの有用な機能を提供します。クライアントプロキシーは基本的に、すべてのメソッド呼び出しをターゲットのBeanインスタンスに委譲するオブジェクトです。これは `io.quarkus.arc.ClientProxy`  を実装し、Bean クラスを拡張したコンテナー構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with non-contextual or stale data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシーはメソッドの呼び出しをデリゲートするだけです。そのため、通常のスコープされたBeanのフィールドを読み書きしてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generated Client Proxy Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたクライアントプロキシーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[contextual instance, window="_blank"] of the `Translator` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Translator_ClientProxy`  インスタンスは、 `Translator`  Beanの link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[コンテキストインスタンス, window=_blank]への直接参照の代わりに、常に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies allow for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシーは、以下のことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy instantiation - the instance is created once a method is invoked upon the proxy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅延インスタンス化 - メソッドがプロキシーに呼び出されるとインスタンスが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ability to inject a bean with "narrower" scope to a bean with "wider" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>「狭い」スコープのBeanを「広い」スコープのBeanに注入する機能、すなわち、 `@RequestScoped`  Beanを `@ApplicationScoped`  Beanに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes it's inevitable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係グラフの円形の依存関係。循環的な依存関係を持つことは、しばしば再設計を検討すべきであることを示していますが、時には避けられないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まれなケースでは、手動でBeanを破棄するのが現実的です。直接参照を注入すると、古くなったBeanのインスタンスになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer fields</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成Beanは通常、エクステンションによって提供されます。そのため、このガイドではそれらを取り上げません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサ・メソッドとフィールドは、Beanのインスタンス化を追加で制御する必要がある場合に便利です。また、サードパーティのライブラリを統合する際に、クラスソースを制御できず、追加のアノテーションなどを追加できない場合にも便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producers Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは,フィールドアノテーションを分析して,Beanのメタデータを構築します。 _型_ は,Beanの型の集合を構築するために使用されます。この場合、 `double`  と `java.lang.Object` .スコープアノテーションは宣言されていないので、デフォルトは `@Dependent` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will read this field when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは、Beanのインスタンスを作成するときにこのフィールドを読みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In this case, it will be `List&lt;String&gt;`, `Collection&lt;String&gt;`, `Iterable&lt;String&gt;` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは,メソッドのアノテーションを解析して,Beanのメタデータを構築します。戻り値の _型_ は、Bean型のセットを構築するために使用されます。この場合、 `List&lt;String&gt;` と `Collection&lt;String&gt;`、 `Iterable&lt;String&gt;`、 `java.lang.Object` となります。スコープアノテーションは宣言されていないので、デフォルトは `@Dependent`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will call this method when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは、Beanのインスタンスを作成する際にこのメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーについては他にもあります。修飾子を宣言したり、プロデューサーメソッドのパラメーターに依存性を注入したりすることができます。プロデューサについては、例えば link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld, window=_blank] のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanクラスは、ライフサイクル `@PostConstruct`  と `@PreDestroy`  コールバックを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバックの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコールバックは、Beanインスタンスがサービスに投入される前に呼び出されます。ここでいくつかの初期化を行うのが安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコールバックは、Beanインスタンスが破棄される前に呼び出されます。ここでいくつかのクリーンアップタスクを実行しても安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a good practice to keep the logic in the callbacks "without side effects", i.e. you should avoid calling other beans inside the callbacks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コールバック内のロジックを「副作用なし」に保つこと、つまり、コールバック内で他のBeanを呼び出すことは避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターは、横断的な問題をビジネス・ロジックから分離するために使用されます。基本的なプログラミングモデルとセマンティクスを定義した Java Interceptors という別の仕様があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Interceptor Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなインターセプターの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、インターセプターをBeanにバインドするために使用されるインターセプターバインディングアノテーションです。Beanクラスに `@Logged`  をアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Priority`  はインターセプターを有効にし、インターセプターの順序に影響を与えます。優先度の値が小さいインターセプターが最初に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Marks an interceptor component.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターコンポーネントをマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interceptor instance may be the target of dependency injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターインスタンスは、依存性注入の対象となる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AroundInvoke` denotes a method that interposes on business methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AroundInvoke`  とは、ビジネスの方法に口出しする方法を指します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターチェーンの次のインターセプターに進むか、インターセプターされたビジネスメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプタのインスタンスは、インターセプトするBeanのインスタンスに依存するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events and Observers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントとオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event payload.  The optional qualifiers act as topic selectors.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanは、完全に分離された方法で相互作用するために、イベントを生成したり消費したりすることもできます。任意の Java オブジェクトをイベントのペイロードとして使用できます。オプションの修飾子は、トピックセレクタとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Event Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなイベントの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.event.Event` is used to fire events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.event.Event`  は、イベントの火付けに使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fire the event synchronously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントを同期的に発生させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is notified when a `TaskCompleted` event is fired.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、 `TaskCompleted`  イベントが発生したときに通知されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント/オブザーバーの詳細については、 link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docsを, window=_blank]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we've covered some of the basic topics of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.  However, a full CDI implementation is not used under the hood.  Quarkus only implements a subset of the CDI features - see also &lt;&lt;cdi-reference.adoc#supported_features,the list of supported features&gt;&gt; and &lt;&lt;cdi-reference.adoc#limitations,the list of limitations&gt;&gt;.  On the other hand, there are quite a few &lt;&lt;cdi-reference#nonstandard_features,non-standard features&gt;&gt; and &lt;&lt;cdi-reference.adoc#build_time_apis,Quarkus-specific APIs&gt;&gt;.  We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本的なトピックをいくつか取り上げました。ただし、CDIの完全な実装が使用されている訳ではありません。QuarkusはCDI link:cdi-reference.html#supported_features[機能]のサブセットのみを実装しています。一方で、 link:cdi-reference.html#nonstandard_features[非標準の機能]や link:cdi-reference.html#build_time_apis[Quarkus固有のAPI]もかなりの数があります。私たちの努力は、将来的にビルドタイム指向の開発者スタックに向けてCDI仕様の革新を推進するものと信じています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus link:cdi-reference[CDI Reference Guide].  We also recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus固有の機能や制限について詳しく知りたい場合は、Quarkus link:cdi-reference[CDIリファレンスガイド]があります。また、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDIの仕様]や link:https://docs.jboss.org/weld/reference/latest/en-US/html/[Weldのドキュメント](WeldはCDIリファレンスインプリメンテーションです)を読んで、より複雑なトピックに精通することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes how to test Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus Securityのテスト方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring User Information</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー情報の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:security-properties[quarkus-elytron-security-properties-file] for testing security. This supports both embedding user info in `application.properties` and standalone properties files.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーをテストするために link:security-properties[quarkus-elytron-security-properties-file] を使用することができます。これは `application.properties` へのユーザー情報の埋め込みとスタンドアロンのプロパティーファイルの両方をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following configuration will allow for configuring the users in both the production where OAuth2 is required and development modes using link:https://quarkus.io/guides/config#configuration-profiles[Configuration Profiles].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下の構成では、OAuth2が必要な本番モードと開発モードの両方で link:https://quarkus.io/guides/config#configuration-profiles[Configuration Profiles]を使用してユーザーを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test Security Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーエクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides explicit support for testing with different users, and with the security subsystem disabled. To use this you must include the `quarkus-test-security` artifact:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、異なるユーザーでのテストや、セキュリティーサブシステムを無効にした状態でのテストを明示的にサポートしています。これを使用するには、 `quarkus-test-security` のアーティファクトを含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This artifact provides the `io.quarkus.test.security.TestSecurity` annotation, that can be applied to test methods and test classes to control the security context that the test is run with. This allows you to do two things, you can disable authorization so tests can access secured endpoints without needing to be authenticated, and you can specify the identity that you want the tests to run under.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアーティファクトは `io.quarkus.test.security.TestSecurity` アノテーションを提供します。これをテストメソッドやテストクラスに適用することで、テストが実行されるセキュリティーコンテキストを制御することができます。認証を必要とせずに安全なエンドポイントにテストがアクセスできるように認証を無効にすることができ、テストを実行する際の ID を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A test that runs with authorization disabled can just set the enabled property to false:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可を無効にして実行されるテストは、enabled プロパティーを false に設定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will disable all access checks, which allows the test to access secured endpoints without needing to authenticate.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、すべてのアクセスチェックが無効になり、認証を必要とせずに保護されたエンドポイントにアクセスできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use this to configure the current user that the test will run as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使用して、テストを実行する現在のユーザーを設定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will run the test with an identity with the given username and roles. Note that these can be combined, so you can disable authorization while also providing an identity to run the test under, which can be useful if the endpoint expects an identity to be present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、指定されたユーザー名とロールを持つ ID でテストを実行します。これらを組み合わせることができるので、認証を無効にしながらテストを実行するための ID を提供することができることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The feature is only available for `@QuarkusTest` and will **not** work on a `@NativeImageTest`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能は `@QuarkusTest` でのみ利用可能で、 `@NativeImageTest` では動作 *しません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing security tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーテストの混合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it becomes necessary to test security features using both `@TestSecurity` and Basic Auth (which is the fallback auth mechanism when none is defined), then Basic Auth needs to be enabled explicitly, for example by setting `quarkus.http.auth.basic=true` or `%test.quarkus.http.auth.basic=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@TestSecurity` と Basic Auth の両方を使ってセキュリティー機能をテストする必要が出てきた場合 (何も定義されていない場合のフォールバック認証メカニズムです)、明示的に有効にする必要があり、例えば `quarkus.http.auth.basic=true` や`%test.quarkus.http.auth.basic=true` と設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Wiremock for Integration Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合テストにWiremockを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use Wiremock to mock the authorization OAuth2 and OIDC services: See link:security-oauth2#integration-testing[OAuth2 Integration testing] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Wiremockを使ってauthorization OAuth2とOIDCサービスをモックすることもできます。詳細は link:security-oauth2#integration-testing[OAuth2 統合テスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code are a _no go_ (even if we all did it at some point ;-)).  In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードの中にハードコードされた値を使うことは _できません_ (たとえ誰もがどこかの時点でそうしていたとしてもです ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.config.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.config.GreetingResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus reads configuration properties from &lt;&lt;config-reference.adoc#configuration_sources,several sources&gt;&gt;.  For the purpose of this guide, we will use an application configuration file located in `src/main/resources/application.properties`.  Edit the file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus は link:config-reference.html#configuration_sources[複数のソース] から設定プロパティーを読み取ります。このガイドでは、 `src/main/resources/application.properties` にあるアプリケーション設定ファイルを使用します。以下の内容でファイルを編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting configuration properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、 link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] アノテーションを使用して、アプリケーションに設定プロパティーを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.  The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.  This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Inject @ConfigProperty` を使用することも、 `@ConfigProperty` だけを使用することもできます。 `@Inject` アノテーションは、 `@ConfigProperty` でアノテーションされたメンバーには必要ありません。この動作は link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the application attempts to inject a configuration property that is not set, an error is thrown.  So you can quickly know when your configuration is complete.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが設定されていない設定プロパティーを注入しようとすると、エラーがスローされます。そのため、設定が完了したときにすぐに知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.config.GreetingResource`, and introduce the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.config.GreetingResource` を編集し、以下の設定プロパティーを導入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティーに値を指定しないと、アプリケーションの起動は `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message` エラーで失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is injected if the configuration does not provide a value for `greeting.suffix`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト値は、設定が `greeting.suffix` の値を提供していない場合に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティーはオプションです - 設定が `greeting.name` の値を提供していない場合は、空の `Optional` が注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, modify the `hello` method to use the injected properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `hello` メソッドを修正して、注入されたプロパティーを使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once set, check the application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定したら、アプリケーションを使って確認します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.  See the &lt;&lt;config-reference.adoc#using_configproperties,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の関連する設定値を注入する代わりに、 `@io.quarkus.arc.config.ConfigProperties` アノテーションを使用して、これらのプロパティーをまとめてグループ化することもできます。詳細については、『 link:config-reference.html#using_configproperties[設定リファレンスガイド] 』を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/config/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/config/GreetingResourceTest.java` ファイルを編集し、 `testHelloEndpoint` メソッドの内容を変更します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行するには、次の手順を実行します: `./mvnw compile quarkus:dev` 。ブラウザで http://localhost:8080/greeting を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.  You can add the `greeting.suffix`, remove the other properties, change the values, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定ファイルの変更はすぐに反映されます。 `greeting.suffix` の追加、他のプロパティーの削除、値の変更などが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically access the configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定にプログラムでアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also access the configuration programmatically.  It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラムで設定にアクセスすることもできます。動的なルックアップを実現したり、CDI Bean でも JAX-RS リソースでもないクラスから設定値を取得したりするのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `org.eclipse.microprofile.config.ConfigProvider.getConfig()` を使用してプログラムで設定にアクセスすることも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the notion of configuration profiles.  These allow you to have multiple configuration values in the same file and select between them via a profile name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、設定プロファイルという概念をサポートしています。これにより、同じファイル内に複数の設定値を持つことができ、プロファイル名を使用してそれらの間で選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax for this is `%{profile}.config.key=value`. For example if I have the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このための構文は `%{profile}.config.key=value` です。例えば、以下のような場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>個の場合、Quarkus の HTTP ポートは9090になります。 `dev` プロファイルがアクティブでない場合は8181になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuration_profiles,Configuration Reference Guide&gt;&gt; for more information about configuration profiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイルの詳細については、 link:config-reference.html#configuration_profiles[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in `application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 自体は、アプリケーションと同じメカニズムで設定されます。Quarkus は、独自の設定のために `quarkus.` ネームスペースを予約します。たとえば、HTTPサーバーのポートを設定するには、 `application.properties` で `quarkus.http.port` を設定します。Quarkusの設定プロパティーはすべて link:all-config[文書化されており、検索可能です] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and therefore `quarkus.` should **never** be used as prefix for application specific properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上述したように、 `quarkus.` で始まるプロパティーは、Quarkus 自体を設定するために実質的に予約されているため、アプリケーション固有のプロパティーのプレフィックスとして `quarkus.` を使用してはいけ *ません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の例では、 `greeting.message` の代わりに `quarkus.message` を使用すると、予期せぬ動作をすることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does much of its configuration and bootstrap at build time and some configuration properties are read and used during the build.  These properties are _fixed at build time_ and it's not possible to change them at runtime.  You always need to repackage your application in order to reflect changes of such properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、その設定とブートストラップの多くをビルド時に行い、いくつかの設定プロパティーはビルド中に読み込まれて使用されます。これらのプロパティーは _ビルド時に固定され_ ており、実行時に変更することはできません。このようなプロパティーの変更を反映させるには、常にアプリケーションをリパッケージする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時に固定されたプロパティーは、 link:all-config[すべての設定オプションのリスト] でロックアイコン([lock])でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, some extensions do define properties _overridable at runtime_.  A canonical example is the database URL, username and password which is only known specifically in your target environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、いくつかのエクステンションは _実行時にオーバーライド可能な_ プロパティーを定義しています。定型的な例としては、データベースの URL、ユーザー名とパスワードがありますが、これはターゲット環境でしか知られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>System properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An environment file named `.env` placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の作業ディレクトリーに配置された `.env` という名前の環境ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A configuration file placed in `$PWD/config/application.properties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`$PWD/config/application.properties` に配置された設定ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuring_quarkus,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:config-reference.html#configuring_quarkus[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新規プロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you just launch `mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create` the Maven plugin asks for user inputs. You can disable (and use default values) this interactive mode by passing `-B` to the Maven command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create`  を起動するだけで、Maven プラグインはユーザー入力を要求します。 `-B`  を Maven コマンドに渡すことで、この対話型モードを無効にすることができます (デフォルト値を使用します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the attributes you can pass to the `create` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の表は、 `create`  コマンドに渡すことができる属性の一覧です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is either generated in the current directory or in a directory named after the passed artifactId.  If the current directory is empty, the project is generated in-place.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは、カレント・ディレクトリーに生成されるか、渡されたartifactIdにちなんだ名前のディレクトリーに生成されます。カレントディレクトリーが空の場合,プロジェクトはその場で生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションへの対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions are passed using a comma-separated list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、カンマ区切りのリストを使用して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, attach your debugger to `localhost:5005`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、デバッガーを `localhost:5005`  にアタッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Maven project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;project-creation, プロジェクトを生成したら&gt;&gt;、お気に入りのIDEでインポートすることができます。唯一の要件は、Mavenプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Eclipse**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Eclipse**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Maven -&gt; Existing Maven Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Maven → Existing Maven Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish` をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**IntelliJ**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**IntelliJ**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside IntelliJ select `File -&gt; New -&gt; Project From Existing Sources...` or, if you are on the welcome dialog, select `Import project`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJの内部から `File → New → Project From Existing Sources…​`  を選択するか、ウェルカム・ダイアログであれば `Import project`  を選択してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select the project root</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのルートを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Maven`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Import project from external model`  を選択して `Maven`を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the last screen click on Finish</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後の画面でFinishをクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `File -&gt; Open Project`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`File → Open Project` を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Maven project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VS Codeでプロジェクトディレクトリーを開きます。Java Extension Pack(Java拡張のセットをグループ化したもの)をインストールしている場合、プロジェクトはMavenプロジェクトとしてロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://picocli.info/[Picocliは] 、リッチなコマンドラインアプリケーションを作成するためのオープンソースツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、Picocli を使用するためのサポートを提供しています。このガイドには、 `picocli` エクステンションの使用例が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus のコマンドモードに詳しくない場合は、まず link:command-mode-reference[コマンドモードのリファレンスガイド] を読むことを検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `picocli` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus プロジェクトを設定すると、プロジェクトのベースディレクトリーで次のコマンドを実行することで、 `picocli` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple command line application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple PicocliApplication with only one `Command` can be created as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Command` を 1 つだけ使ったシンプルな PicocliApplication は、以下のように作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスが 1 つだけある場合、これは Picocli CommandLine のエントリーポイントとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスはすべて CDI Bean として登録されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans with `@CommandLine.Command` should not use proxied scopes (e.g. do not use `@ApplicationScope`)  because Picocli will not be able set field values in such beans. This extension will register classes with `@CommandLine.Command` annotation using `@Depended` scope. If you need to use proxied scope, then annotate setter and not field, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CommandLine.Command` を持つ Bean では、プロキシーされるスコープを使用してはいけません (例: `@ApplicationScope` は使用しないでください)。Picocli はそのような Bean でフィールド値を設定できないためです。このエクステンションは `@CommandLine.Command` アノテーションを持つクラスを `@Depended` スコープを使って登録します。プロキシーされるスコープを使用する必要がある場合は、フィールドではなくセッターを次の例のようにアノテーションしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line application with multiple Commands</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のコマンドを使用したコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.  This can be overwritten with the `quarkus.picocli.top-command` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のクラスが `picocli.CommandLine.Command` アノテーションを持つ場合、そのうちの 1 つに `io.quarkus.picocli.runtime.annotations.TopCommand` アノテーションを付ける必要があります。これは `quarkus.picocli.top-command` プロパティーで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自の Bean インスタンスを生成することで、 `picocli` エクステンションで使用される CommandLine クラスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`PicocliCommandLineFactory` は、 `TopCommand` と `CommandLine.IFactory` を注入した CommandLine のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different entry command for each profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルごとに異なるエントリーコマンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create different entry command for each profile, using `@IfBuildProfile`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@IfBuildProfile` を使用して、プロファイルごとに異なるエントリーコマンドを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return instance of `java.lang.Class` here. In such case `CommandLine` will try to instantiate this class using `CommandLine.IFactory`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは `java.lang.Class` のインスタンスを返すことができます。この場合、 `CommandLine` は `CommandLine.IFactory` を使ってこのクラスのインスタンスを作成しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure CDI Beans with parsed arguments</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>解析された引数での CDI Beans の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Event&lt;CommandLine.ParseResult&gt;` or just `CommandLine.ParseResult` to configure CDI beans based on arguments parsed by Picocli.  This event will be generated in `QuarkusApplication` class created by this extension. If you are providing your own `@QuarkusMain` this event will not be raised.  `CommandLine.ParseResult` is created from default `CommandLine` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli によって解析された引数に基づいて CDI Bean を設定するために、 `Event&lt;CommandLine.ParseResult&gt;` 、または単に `CommandLine.ParseResult` を使用することができます。このイベントは、このエクステンションによって作成された `QuarkusApplication` クラスで生成されます。独自の `@QuarkusMain` を提供している場合、このイベントは発生しません。 `CommandLine.ParseResult` はデフォルトの `CommandLine` Bean から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing own QuarkusMain</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自の QuarkusMain の提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide your own application entry point annotated with `QuarkusMain` (as described in link:command-mode-reference[Command Mode reference guide]).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `QuarkusMain` でアノテーションされた独自のアプリケーションのエントリーポイントを提供することもできます (link:command-mode-reference[コマンドモードのリファレンスガイド] に記載されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus-compatible `CommandLine.IFactory` bean created by `picocli` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli` のエクステンションで作成された Quarkus 互換の `CommandLine.IFactory` Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native mode support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension uses the Quarkus standard build steps mechanism to support GraalVM Native images. In the exceptional case that incompatible changes in a future picocli release cause any issue, the following configuration can be used to fall back to the annotation processor from the picocli project as a temporary workaround:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションでは、Quarkus 標準のビルドステップメカニズムを使用して、GraalVM Nativeイメージをサポートしています。将来のpicocliリリースで互換性のない変更が問題を引き起こす例外的なケースでは、一時的な回避策として、以下の設定を使用してpicocliプロジェクトのアノテーションプロセッサーにフォールバックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle, you need to add the following in `dependencies` section of the `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle の場合は、 `build.gradle` ファイルの `dependencies` セクションに以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limitations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's see our application in action. Run it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、実際にアプリケーションを見てみましょう。以下のように実行してみてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Software Transactional Memory (STM) has been around in research environments since the late 1990's and has relatively recently started to appear in products and various programming languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].  However, suffice it to say that STM offers an approach to developing transactional applications in a highly concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations, or at least made optional. This is not the situation with JTA, where state changes are made durable to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA standard].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソフトウェア・トランザクション・メモリー(STM)は、1990 年代後半から研究環境に存在し、比較的最近になって製品や様々なプログラミング言語に登場し始めました。STM の背後にあるすべての詳細については触れませんが,興味のある方は link:https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[この論文] を参照してください.しかし、STM は、JTA を通じて既に使用されている ACID トランザクションと同じ特性を持つ、高度な同時実行環境でトランザクショ ン・アプリケーションを開発するためのアプローチを提供していることは言うまでもありません。しかし、重要なことは、STM の実装では Durability プロパティーが緩和(削除)されているか、少なくともオプションになっていることです。これは、 link:https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[X/Open XA 標準] をサポートするリレーショナル・データベースに対して状態の変更を耐久性のあるものにするという JTA の状況とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities into Quarkus when developing Kubernetes native applications and microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusが提供するSTMの実装は、 link:https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] の実装に基づいています。このドキュメントは、そのプロジェクトのドキュメントに代わるものではありませんので、詳細についてはそちらを参照してください。しかし、Kubernetesネイティブアプリケーションやマイクロサービスを開発する際に、主要な機能のいくつかをQuarkusにどのように組み合わせることができるかについて、より焦点を当ててみたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why use STM with Quarkus?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜQuarkusでSTMを使うのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you may still be asking yourself "Why STM instead of JTA?" or "What are the benefits to STM that I don't get from JTA?" Let's try to answer those or similar questions, with a particular focus on why we think they're great for Quarkus, microservices and Kubernetes native applications. So in no specific order ...</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今、あなたはまだ「なぜJTAではなくSTMなのか?」や「JTAでは得られないSTMのメリットは何か?」と自問自答しているかもしれません。ここでは、Quarkus、マイクロサービス、Kubernetesネイティブアプリケーションに最適だと思う理由を中心に、これらの質問や似たような質問に答えてみましょう。ということで、順不同で ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the extension include it as a dependency in your application pom:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションを使用するには、アプリケーションの依存関係として以下を pom にインクルードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining transaction boundaries</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの境界の定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once an object is placed within an STM container the application developer can manage the scope of transactions within which it is used. There are some annotations which can be applied to the STM-aware class to have the container automatically create a transaction whenever a specific method is invoked.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一度オブジェクトをSTMコンテナー内に配置すると、アプリケーション開発者はそれが使用されるトランザクションの範囲を管理することができます。特定のメソッドが呼び出されたときにコンテナーが自動的にトランザクションを作成するように、STM-aware クラスに適用できるアノテーションがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declarative approach</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>宣言的アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distributed transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分散型トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing a transaction between multiple services is possible but is currently an advanced use case only and the Narayana documentation should be consulted if this behaviour is required. In particular, STM does not yet support the features described in the link:context-propagation[Context Propagation guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のサービス間でトランザクションを共有することは可能ですが、現在のところ高度なユースケースのみであり、この動作が必要な場合はNarayanaのドキュメントを参照してください。特に、STMは link:context-propagation[コンテキスト伝搬ガイド] で説明されている機能をまだサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application.  In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、開発者がライブリーロードから Kubernetes アプリケーションのデプロイまでを可能にするツールチェーンが付属しています。このガイドでは、以下を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE でアプリケーションを開発する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドツールの選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a native CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、すべての開発段階で役立つツールチェーンが付属しています。ビルドツールとして Maven や Gradle を使うことができます。また、使い勝手の良いネイティブ CLI も提供しています (近日公開予定)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before anything can be done you must first install a JVMCI build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何かをする前に、まずJVMCIビルドをインストールしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be downloaded from OTN http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[here]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは link:http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[ここ]でOTNからダウンロードすることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, if you are installing on an alternative system, you can use the developer tools on chrome or firefox to capture a direct URL with an auth param.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のシステムにインストールする場合は、ChromeやFirefoxの開発者ツールを使用して、auth パラメーターを指定して直接 URL をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After obtaining the download install it and set `JAVA_HOME`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ダウンロードした後、インストールして `JAVA_HOME` をセットします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the latest version available as graal tends to keep updating the minimum requirements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>graalは最小要件を更新し続ける傾向があるので、最新版を入手しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to install Graal’s special build tool, `mx`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今、あなたはGraalの特別なビルドツール `mx` をインストールする必要があります、.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus allows different beans to interact using asynchronous events, thus promoting loose-coupling.  The messages are sent to _virtual addresses_.  It offers 3 types of delivery mechanism:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、異なる Bean が非同期イベントを使用して相互作用することができるため、疎結合化が促進されます。メッセージは _仮想アドレス_ に送信されます。3種類の配信メカニズムを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round robin is applied;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>point-to-point - メッセージを送信し、1 つのコンシューマがそれを受信します。複数のコンシューマがアドレスをリスンしている場合、ラウンドロビンが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>publish/subscribe - メッセージをパブリッシュし、アドレスをリスンしているすべてのコンシューマがメッセージを受信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>request/reply - メッセージを送信し、応答を待ちます。受信者は非同期的にメッセージに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these delivery mechanism are non-blocking, and are providing one of the fundamental brick to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの配信メカニズムはすべてノンブロッキングであり、リアクティブアプリケーションを構築するための基本的なブロックの1つを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The asynchronous message passing feature allows replying to messages which is not supported by Reactive Messaging.  However, it is limited to single-event behavior (no stream) and to local messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メッセージパッシング機能は、Reactive Messagingではサポートされていないメッセージへの返信を可能にします。ただし、シングルイベント動作(ストリームなし)とローカルメッセージに限定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter are follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この仕組みはVert.x EventBusを利用しているので、この機能を利用するには `vertx` エクステンションを有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに作成済みのプロジェクトがある場合は、 `vertx` エクステンションを既存のQuarkusプロジェクトに `add-extension` コマンドで追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントのコンシューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントをコンシュームするには、 `io.quarkus.vertx.ConsumeEvent` アノテーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, the address is the fully qualified name of the bean, for instance, in this snippet it's `org.acme.vertx.GreetingService`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定されていない場合、アドレスは Bean の完全修飾名となり、例えばこのスニペットでは `org.acme.vertx.GreetingService` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter is the message body. If the method returns _something_ it's the message response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドのパラメーターはメッセージ本体です。メソッドが _何か_ を返す場合は、それがメッセージのレスポンスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the code consuming the event must be _non-blocking_, as it's called on the Vert.x event loop.  If your processing is blocking, use the `blocking` attribute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Vert.x イベントループで呼び出されるため、イベントをコンシュームするコードは _ノンブロッキング_ でなければなりません。処理がブロッキングである場合は、 `blocking` 属性を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can annotate your method with `@io.smallrye.common.annotation.Blocking`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、メソッドに `@io.smallrye.common.annotation.Blocking` と注釈を付けることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Blocking` を使用する場合、 `@ConsumeEvent` の `blocking` 属性の値は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.mutiny.Uni` または `java.util.concurrent.CompletionStage` のどちらかを返すことで、非同期処理も可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses Mutiny reactive types, if you're not familiar with them, we recommend reading the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の例では Mutiny リアクティブタイプを使用していますが、もしよく知らないのであれば、 link:getting-started-reactive#mutiny[Reactive の入門ガイド] を読むことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the address</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アドレスの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ConsumeEvent` annotation can be configured to set the address:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConsumeEvent` アノテーションでアドレスを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receive the messages sent to the `greeting` address</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greeting` アドレスに送信されたメッセージを受信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replying</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>応答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _return_ value of a method annotated with `@ConsumeEvent` is used as response to the incoming message.  For instance, in the following snippet, the returned `String` is the response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConsumeEvent` でアノテーションされたメソッドの _戻り値_ が、着信メッセージに対するレスポンスとして使用されます。例えば、次のスニペットでは、 `String` がレスポンスとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also return a `Uni&lt;T&gt;` or a `CompletionStage&lt;T&gt;` to handle asynchronous reply:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `Uni&lt;T&gt;` や `CompletionStage&lt;T&gt;` を返すことで、非同期応答を扱うこともできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject an `executor` if you use the Context Propagation extension:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Context Propagation エクステンションを使えば、 `executor` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing fire and forget interactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>fire and forget インタラクションの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to reply to received messages.  Typically for a _fire and forget_ interaction, the messages are consumed and the sender does not need to know about it.  To implement this, your consumer method just returns `void`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したメッセージに返信する必要はありません。通常、 _fire and forget_ インタラクションでは、メッセージはコンシュームされ、送信者はそれについて知る必要はありません。これを実装するには、 consumer メソッドは `void` を返すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, this mechanism is based on the Vert.x event bus. So, you can also use `Message` directly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上でも述べたように、この仕組みはVert.xイベントバスをベースにしています。なので、直接 `Message` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, we have seen how to receive messages, let's now switch to the _other side_: the sender.  Sending and publishing messages use the Vert.x event bus:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、メッセージを受信する方法を見てきましたが、次は送信者 _側_ に切り替えましょう。メッセージの送信とパブリッシュは Vert.x イベントバスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントバスのインジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send a message to the address `greeting`. Message payload is `name`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アドレス `greeting` にメッセージを送信。メッセージのペイロードは `name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `EventBus` object provides methods to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EventBus` オブジェクトは、以下のメソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`send` a message to a specific address - one single consumer receives the message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`send` 特定のアドレスへのメッセージ - 一人のコンシューマーがメッセージを受信する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`publish` a message to a specific address - all consumers receive the messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`publish` 特定のアドレスにメッセージを送る - すべてのコンシューマーがメッセージを受け取る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Putting things together - bridging HTTP and messages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>物事をまとめる - HTTPとメッセージのブリッジング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.  This message is consumed by another bean and the response is sent using the _reply_ mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>greeting HTTP エンドポイントを再訪し、非同期メッセージパッシングを使用して分離された Bean に呼び出しを委譲してみましょう。リクエスト/レスポンスディスパッチの仕組みを利用しています。JAX-RS エンドポイント内にビジネスロジックを実装する代わりに、メッセージを送信しています。このメッセージは別の Bean によってコンシュームされ、応答は _返信_  機構を使用して送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First create a new project using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、新しいプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can already start the application in _dev mode_ using `./mvnw compile quarkus:dev`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` を実行すると、自動的に _開発者モード_ でアプリケーションを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, creates a new JAX-RS resource with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、以下の内容の JAX-RS リソースを新規に作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>send the `name` to the `greeting` address and request a response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greeting` アドレスに  `name`  を送信し、レスポンスを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we get the response, extract the body and send it to the user</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスを取得したら、ボディを抽出してユーザーに送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.  So, we need a consumer listening on the `greeting` address. Create a `GreetingService` bean with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエンドポイントを呼び出すと、しばらく待ってからタイムアウトになります。実際、誰もリスンしていません。そこで、 `greeting` アドレスをリスンするコンシューマーが必要です。以下の内容の `GreetingService` Bean を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean receives the name, and returns the greeting message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この Bean は name を受け取り、 greeting メッセージを返します.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, open your browser to http://localhost:8080/async/Quarkus, and you should see:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、ブラウザで http://localhost:8080/async/Quarkus を開くと、以下が表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand, let's detail how the HTTP request/response has been handled:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より理解しやすくするために、HTTP リクエスト/レスポンスがどのように処理されたかを詳しく見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request is received by the `hello` method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストは `hello` メソッドが受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a message containing the _name_ is sent to the event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_name_ を含むメッセージがイベントバスに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another bean receives this message and computes the response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の Bean がこのメッセージを受信して、レスポンスを計算します.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This response is sent back using the reply mechanism</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このレスポンスは、応答機構を使用して返信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the reply is received by the sender, the content is written to the HTTP response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信者が応答を受信すると、HTTP レスポンスに内容が書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application can be packaged using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションは、以下の方法でパッケージングできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also compile it as a native executable with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下でネイティブ実行ファイルとしてコンパイルすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using codecs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コーデックを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.xイベントバス] では、コーデックを使用してオブジェクトの _シリアライズ_ と _デシリアライズ_ を行います。Quarkusでは、ローカル配信用のデフォルトのコーデックを提供しています。そのため、以下のようにオブジェクトを交換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use a specific codec, you need to explicitly set it on both ends:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のコーデックを使用したい場合は、両サイドで明示的に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the name of the codec to use to send the message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの送信に使用するコーデックの名前を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the codec to use to receive the message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの受信に使用するコーデックを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of web applications are monotonous CRUD applications with REST APIs that are tedious to write.  To streamline this task, REST Data with Panache extension can generate the basic CRUD endpoints for your entities and repositories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くのWebアプリケーションは、REST APIを使った単調なCRUDアプリケーションで、書くのが面倒です。このタスクを合理化するために、REST Data with Panache エクステンションは、エンティティーやリポジトリの基本的なCRUDエンドポイントを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While this extension is still experimental and provides a limited feature set, we hope to get an early feedback for it.  Currently this extension supports Hibernate ORM and MongoDB with Panache and can generate CRUD resources that work with `application/json` and `application/hal+json` content.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションはまだ実験的なものであり、限られた機能しか提供していませんが、早期にフィードバックが得られることを期待しています。現在のところ、このエクステンションは Hibernate ORM と MongoDB with Panache をサポートしており、 `application/json` と `application/hal+json` のコンテンツで動作する CRUD リソースを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the required dependencies to your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要な依存関係を `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache extension (`quarkus-hibernate-orm-rest-data-panache`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM REST Data with Panache エクステンション ( `quarkus-hibernate-orm-rest-data-panache` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC ドライバーエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the RESTEasy JSON serialization extensions (`quarkus-resteasy-jackson` or `quarkus-resteasy-jsonb`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy JSON シリアライゼーションエクステンションのどれか ( `quarkus-resteasy-jackson` または `quarkus-resteasy-jsonb` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the Panache entities and/or repositories as explained in the link:hibernate-orm-panache[Hibernate ORM with Panache guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:hibernate-orm-panache[Panacheを使ったHibernate ORM with Panacheガイド] で説明されているように、Panacheエンティティーおよび/またはリポジトリを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the interfaces for generation as explained in the resource generation section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソース生成の項で説明したように、生成用のインターフェースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB REST Data with Panache extension (`quarkus-mongodb-rest-data-panache`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDB REST Data with Panache エクステンション ( `quarkus-mongodb-rest-data-panache` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the Panache entities and/or repositories as explained in the link:mongodb-panache[MongoDB with Panache guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:mongodb-panache[MongoDB with Panache ガイド] で説明されているように、Panache エンティティーやリポジトリを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache generates JAX-RS resources based on the interfaces available in your application.  For each entity and repository that you want to generate, provide a resource interface.  _Do not implement these interfaces and don't provide custom methods because they will be ignored._ You can, however, override the methods from the extended interface in order to customize them (see the section at the end).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST Data with Panache は、アプリケーションで利用可能なインターフェイスに基づいて JAX-RS リソースを生成します。生成したい各エンティティーとリポジトリに対して、リソースインターフェイスを提供してください。 _これらのインターフェイスを実装したり、カスタムメソッドを提供したりしないでください。_ ただし、拡張インターフェースからメソッドをオーバーライドしてカスタマイズすることは可能です(最後のセクションを参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheEntityResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheEntityResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has an entity (e.g. `Person`) that extends either `PanacheEntity` or `PanacheEntityBase` class, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションに `PanacheEntity` または `PanacheEntityBase` クラスを拡張したエンティティー ( `Person` など) がある場合、REST Data with Panache に、次のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheRepositoryResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheRepositoryResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has a simple entity (e.g. `Person`) and a repository (e.g. `PersonRepository`) that implements either `PanacheRepository` or `PanacheRepositoryBase` interface, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが単純なエンティティー(例: `Person` )と、 `PanacheRepository` または `PanacheRepositoryBase` インターフェイスを実装したリポジトリ(例: `PersonRepository` )を持っている場合、REST Data with Panache に、以下のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheMongoEntityResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheMongoEntityResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has an entity (e.g. `Person`) that extends either `PanacheMongoEntity` or `PanacheMongoEntityBase` class, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションに `PanacheMongoEntity` または `PanacheMongoEntityBase` クラスを拡張したエンティティー ( `Person` など) がある場合、REST Data with Panache に、次のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheMongoRepositoryResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheMongoRepositoryResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has a simple entity (e.g. `Person`) and a repository (e.g. `PersonRepository`) that implements either `PanacheMongoRepository` or `PanacheMongoRepositoryBase` interface, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが単純なエンティティー(例: `Person` )と、 `PanacheMongoRepository` または `PanacheMongoRepositoryBase` インターフェイスを実装したリポジトリ(例: `PersonRepository` )を持っている場合、REST Data with Panache に、以下のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated resources will be functionally equivalent for both entities and repositories.  The only difference being the particular data access pattern and data storage in use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されるリソースは、エンティティーとリポジトリの両方で機能的に同等となります。唯一の違いは、利用時の特定のデータアクセスパターンとデータストレージです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have defined one of the `PeopleResource` interfaces mentioned above, this extension will generate its implementation using a particular data access strategy.  The implemented class then will be used by a generated JAX-RS resource, which will look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の `PeopleResource` インターフェイスのいずれかを定義している場合、このエクステンションは特定のデータアクセス戦略を使用してその実装を生成します。実装されたクラスは、生成された JAX-RS リソースによって使用され、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resource customisation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache provides a `@ResourceProperties` and `@MethodProperties` annotations that can be used to customize certain features of the resource.  It can be used in your resource interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST Data with Panache は、リソースの特定の機能をカスタマイズするために使用できる `@ResourceProperties` と `@MethodProperties` のアノテーションを提供します。リソースのインターフェイスで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ResourceProperties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ResourceProperties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`exposed` - whether resource could be exposed. A global resource property that can be overridden for each method. Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`exposed` - リソースが公開される可能性があるかどうか。各メソッドに対してオーバーライド可能なグローバルリソースプロパティー。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path` - resource base path. Default path is a hyphenated lowercase resource name without a suffix of `resource` or `controller`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`path` - リソースのベースパス。デフォルトのパスは、 `resource` または `controller` のサフィックスを含まないハイフン付きの小文字のリソース名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`paged` - whether collection responses should be paged or not.  First, last, previous and next page URIs are included in the response headers if they exist.  Request page index and size are taken from the `page` and `size` query parameters that default to `0` and `20` respectively.  Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`paged` - コレクションのレスポンスをページングするかどうか。最初、最後、前、次のページの URI が存在する場合は、レスポンスヘッダに含まれます。リクエストページのインデックスとサイズは、 `page` と `size` のクエリパラメーターから取得され、それぞれのデフォルトは `0` と `20` です。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`hal` - in addition to the standard `application/json` responses, generates additional methods that can return `application/hal+json` responses if requested via an `Accept` header.  Default is `false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`hal` - 標準の `application/json` レスポンスに加えて、 `Accept` ヘッダでリクエストされた場合に `application/hal+json` レスポンスを返す追加のメソッドを生成します。デフォルトは `false` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`halCollectionName` - name that should be used when generating a hal collection response. Default name is a hyphenated lowercase resource name without a suffix of `resource` or `controller`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`halCollectionName` - HAL コレクションレスポンスを生成する際に使用されるべき名前です。デフォルトの名前は `resource` または `controller` のサフィックスなしのハイフン付き小文字のリソース名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@MethodProperties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@MethodProperties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`exposed` - does not expose a particular HTTP verb when set to `false`. Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`exposed` - `false` に設定されている場合、特定の HTTP Verb を公開しません。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path` - operation path (this is appended to the resource base path). Default is an empty string.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`path` - 操作パス (これはリソースベースのパスに追加されます)。デフォルトは空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query parameters</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クエリパラメーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache supports the following query parameters with the generated resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST Data with Panacheは、生成されたリソースで以下のクエリパラメーターをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`page` - a page number which should be returned by a list operation.  It applies to the paged resources only and is a number starting with 0. Default is 0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`page` - リスト操作で返されるべきページ番号。これはページ化されたリソースにのみ適用され、0 から始まる番号です。 デフォルトは 0 です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`size` - a page size which should be returned by a list operation.  It applies to the paged resources only and is a number starting with 1. Default is 20.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`size` - リスト操作で返されるべきページサイズ。これはページ化されたリソースにのみ適用され、1から始まる数値です。 デフォルトは20です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sort` - a comma separated list of fields which should be used for sorting a result of a list operation.  Fields are sorted in the ascending order unless they're prefixed with a `-`.  E.g. `?sort=name,-age` will sort the result by the name ascending by the age descending.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sort` - リスト操作の結果をソートするために使われるべきフィールドのカンマ区切りのリスト。フィールドの前に `-` を付けない限り、フィールドは昇順でソートされます。例えば `?sort=name,-age` は、名前の昇順、年齢の降順で結果をソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Response body examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスボディの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above REST Data with Panache supports the `application/json` and `application/hal+json` response content types.  Here are a couple of examples of how a response body would look like for the `get` and `list` operations assuming there are five `Person` records in a database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述の通り、REST Data with Panache は `application/json` と `application/hal+json` のレスポンス コンテンツ タイプをサポートしています。 `Person` ここでは、データベース内に `get` レコードが 5 つあると仮定して、 と `list` 操作を行った場合のレスポンスボディがどのようになるか、いくつかの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GET /people/1</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GET /people/1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Accept: application/json`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Accept: application/json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Accept: application/hal+json`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Accept: application/hal+json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GET /people?page=0&amp;size=2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GET /people?page=0&amp;size=2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both responses would also contain these headers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>両方のレスポンスには、これらのヘッダも含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `previous` link header (and hal link) would not be included, because the previous page does not exist.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のページが存在しないため、 `previous` リンクヘッダ(および HAL リンク)が含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the Quarkus Dev UI for link:building-my-first-extension[extension authors].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:building-my-first-extension[エクステンションの作者] のためのQuarkus Dev UIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset {project-name} has been designed around a container first philosophy.  What this means in real terms is that {project-name} is optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初から {project-name} はコンテナーファーストの哲学に基づいて設計されています。これが実際に意味することは、{project-name} は以下の方法でメモリー使用量を抑え、起動時間を短縮するように最適化されているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Substrate support has been an important part of the design for {project-name} from the beginning.  When an application is compiled down to a native image it starts much faster and can run with a much smaller heap than a standard JVM. {project-name} are all tested in Substrate, and can run without the `-H:+ReportUnsupportedElementsAtRuntime` flag.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サブストレートのサポートは、最初から {project-name} の設計の重要な部分でした。アプリケーションがネイティブイメージにコンパイルされると、標準的なJVMよりもはるかに高速に起動し、より小さなヒープで実行することができます。project-name} はすべて Substrate でテストされており、 `-H:+ReportUnsupportedElementsAtRuntime` フラグなしで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Metadata Processing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドタイムメタデータ処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time, so your application will only contain the classes that are actually needed at runtime. In a traditional model all the classes required to perform the initial application deployment hang around for the life of the application, even though they are only used once. With {project-name} they are not even loaded into the production JVM. This results in less memory usage, and also faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>可能な限り多くの処理はビルド時に行われるので、アプリケーションは実行時に実際に必要とされるクラスだけを含みます。従来のモデルでは、最初のアプリケーションのデプロイメントを実行するために必要なすべてのクラスは、一度しか使用されないにもかかわらず、アプリケーションの寿命の間、ぶら下がっています。project-name}では、それらのクラスは本番環境のJVMにロードされません。その結果、メモリー使用量が少なくなり、すべてのメタデータ処理がすでに行われているため、起動時間も速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リフレクション使用量の削減</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible {project-name} tries to avoid reflection, reducing startup time and memory usage.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name}は可能な限り反射を避け、起動時間とメモリー使用量を減らすようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre Boot</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージのプリブート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in a native image {project-name} pre-boots as much of the framework as possible during the native image build process. This means that the resulting native image has already run most of the startup code and serialized the result into the executable, resulting in even faster startup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージで {project-name}を実行する場合、ネイティブイメージのビルドプロセスの間に、フレームワークの可能な限りの部分をプリブートします。これは、結果として得られるネイティブイメージがすでにほとんどのスタートアップコードを実行し、その結果を実行ファイルにシリアライズしていることを意味し、より高速なスタートアップを実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI.  You can use JAX-RS annotations to define the REST endpoints.  You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries.  You can use Eclipse MicroProfile to configure and monitor your application.  You can use Vert.x, Apache Camel and we support much more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々の依存性注入ソリューションはCDIに基づいています。 JAX-RS アノテーションを使用して REST エンドポイントを定義できます。 JPA アノテーションを使用して、永続エンティティーをマップし、 JTA アノテーションを使用してトランザクション境界を宣言することができます。 Eclipse MicroProfileを使用して、アプリケーションを構成およびモニターできます。 Vert.x、Apache Camelを使用することが出来、そして更に多くをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we're not limited to standards we can go beyond and extend your possibilities.  Of course, {project-name} is not a passive consumer.  Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々は標準に限定されない為、あなたの可能性を広げることが可能です。 もちろん、{project-name} は受動的な消費者ではありません。 私たちのゴールは、使用する技術を改善、革新し、私たちが頼りにしているオープンソースプロジェクトと標準に貢献することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Gradle plugin is published to the https://plugins.gradle.org/plugin/io.quarkus[Gradle Plugin Portal].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradle プラグインは、Gradle link:https://plugins.gradle.org/plugin/io.quarkus[プラグインポータル] に公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use it, add the following to your `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用するには、 `build.gradle` ファイルに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You also need to add the following at the top of your `settings.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、`settings.gradle` ファイルの先頭に以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `plugins{}` method in `settings.gradle` is not supported in Gradle 5.x. In this case make sure to explicitly declare the plugin version in the `build.gradle` file like the example below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`settings.gradle` の `plugins{}` メソッドは Gradle 5.x ではサポートされていません。この場合、以下の例のように `build.gradle` ファイルでプラグインのバージョンを明示的に宣言するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://kotlinlang.org/[Kotlin] は、JVMをターゲットにした(他の環境を含めても)非常に人気のあるプログラミング言語です。Kotlinはここ数年で人気が急上昇し、Javaを除いて最も人気のあるJVM言語となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qute is a templating engine designed specifically to meet the Quarkus needs.  The usage of reflection is minimized to reduce the size of native images.  The API combines both the imperative and the non-blocking reactive style of coding.  In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible.  Furthermore, we try to detect most of the template problems at build time.  In this guide, you will learn how to easily render templates in your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteは、Quarkus のニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブイメージのサイズを小さくするために、リフレクションの使用は最小限に抑えられています。API は、命令型とノンブロッキングリアクティブ型の両方のスタイルのコーディングを組み合わせています。開発モードでは、 `src/main/resources/templates` にあるすべてのファイルが変更のために監視され、変更はすぐに表示されます。さらに、ビルド時にテンプレートの問題のほとんどを検出するようにしています。このガイドでは、アプリケーションでテンプレートを簡単にレンダリングする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Qute in your JAX-RS application, you need to add the `quarkus-resteasy-qute` extension first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS アプリケーションで Qute を使用する場合は、まず `quarkus-resteasy-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに以下を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll start with a very simple template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずはとてもシンプルなテンプレートから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{name}` is a value expression that is evaluated when the template is rendered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{name}` は、テンプレートがレンダリングされたときに評価される値の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, all files located in the `src/main/resources/templates` directory and its subdirectories are registered as templates. Templates are validated during startup and watched for changes in the development mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `src/main/resources/templates` ディレクトリーとそのサブディレクトリーにあるすべてのファイルがテンプレートとして登録されます。開発モードではテンプレートは起動時に検証され、変更が監視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's inject the "compiled" template in the resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、リソースクラスに「コンパイル済み」テンプレートを注入してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no `@ResourcePath` qualifier provided, the field name is used to locate the template. In this particular case, we're injecting a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ResourcePath` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この特定のケースでは、パスが `templates/hello.txt` であるテンプレートを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Template.data()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Template.data()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we don't trigger the rendering - this is done automatically by a special `ContainerResponseFilter` implementation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レンダリングをトリガーしないことに注意してください - これは特別な `ContainerResponseFilter` の実装によって自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application is running, you can request the endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが動作している場合は、エンドポイントを要求することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's an alternate way to declare your templates in your Java code, which relies on the following convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java コードでテンプレートを宣言する別の方法もあり、以下の規約に依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Organise your template files in the `/src/main/resources/templates` directory, by grouping them into one directory per resource class. So, if your `ItemResource` class references two templates `hello` and `goodbye`, place them at `/src/main/resources/templates/ItemResource/hello.txt` and `/src/main/resources/templates/ItemResource/goodbye.txt`. Grouping templates per resource class makes it easier to navigate to them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートファイルを `/src/main/resources/templates` ディレクトリーに整理し、リソースクラスごとに 1 つのディレクトリーにグループ化します。つまり、 `ItemResource` クラスが `hello` と `goodbye` の 2 つのテンプレートを参照している場合は、 `/src/main/resources/templates/ItemResource/hello.txt` と `/src/main/resources/templates/ItemResource/goodbye.txt` に配置します。リソースクラスごとにテンプレートをグループ化することで、テンプレートへのナビゲートが容易になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In each of your resource class, declare a `@CheckedTemplate static class Template {}` class within your resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各リソースクラスで、リソースクラス内で `@CheckedTemplate static class Template {}` クラスを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare one `public static native TemplateInstance method();` per template file for your resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リ ソ ース のテ ン プ レー ト フ ァ イ ルごとに `public static native TemplateInstance method();` を 1 つずつ宣言 し ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use those static methods to build your template instances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートインスタンスを構築するには、これらの静的メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's the previous example, rewritten using this style:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどの例を、このスタイルで書き換えてみました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's declare and use those templates in the resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、これらのテンプレートをリソースクラスで宣言して使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/HelloResource/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パス `templates/HelloResource/hello.txt` でテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Templates.hello()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Templates.hello()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have declared a `@CheckedTemplate` class, we will check that all its methods point to existing templates, so if you try to use a template from your Java code and you forgot to add it, we will let you know at build time :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CheckedTemplate` クラスを宣言したら、すべてのメソッドが既存のテンプレートを指しているかどうかをチェックしますので、もし Java コードからテンプレートを使おうとして追加するのを忘れてしまった場合は、ビルド時にお知らせします :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind this style of declaration allows you to reference templates declared in other resources too:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このスタイルの宣言では、他のリソースで宣言されたテンプレートも参照できることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Top-level type-safe templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トップレベルのタイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, if you want to declare templates at the top-level, directly in `/src/main/resources/templates/hello.txt`, for example, you can declare them in a toplevel (non-nested) `Templates` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当然のことながら、トップレベルでテンプレートを宣言したい場合、例えば `/src/main/resources/templates/hello.txt` で直接宣言したい場合は、トップレベル(非入れ子)の `Templates` クラスで宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パス `templates/hello.txt` のテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Parameter Declarations </seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートパラメーター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you declare a *parameter declaration* in a template then Qute attempts to validate all expressions that reference this parameter and if an incorrect expression is found the build fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートで *パラメーター宣言* を宣言した場合、Quteはこのパラメーターを参照するすべての式の検証を試み、間違った式が見つかった場合はビルドが失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose we have a simple class like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなシンプルなクラスがあったとしましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Item.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Item.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we'd like to render a simple HTML page that contains the item name and price.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、商品名と価格が記載されたシンプルな HTML ページをレンダリングしたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start again with the template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>改めてテンプレートから始めてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource/item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ItemResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is validated. Try to change the expression to `{item.nonSense}` and the build should fail.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この式は検証済みです。式を `{item.nonSense}` に変更するとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is also validated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これも検証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class with type-safe templates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、タイプセーフなテンプレートを使ってリソースクラスを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ItemResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a method that gives us a `TemplateInstance` for `templates/ItemResource/item.html` and declare its `Item item` parameter so we can validate the template.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`templates/ItemResource/item.html` に対して `TemplateInstance` を与えるメソッドを宣言し、その `Item item` パラメーターを宣言することで、テンプレートを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make the `Item` object accessible in the template.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート内で `Item` オブジェクトにアクセスできるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template parameter declaration inside the template itself</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート内部のテンプレートパラメーター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can declare your template parameters in the template file itself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、テンプレートファイル自体でテンプレートパラメーターを宣言することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional parameter declaration. Qute attempts to validate all expressions that reference the parameter `item`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションのパラメーター宣言。Qute は、パラメーター `item` を参照するすべての式の検証を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、リソースクラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the template with path `templates/item.html`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスが `templates/item.html` のテンプレートを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Extension Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート拡張メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Template extension methods* are used to extend the set of accessible properties of data objects.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*テンプレート拡張メソッド* は 、データオブジェクトのアクセス可能なプロパティーのセットを拡張するために使用されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you're not in control of the classes that you want to use in your template, and you cannot add methods to them. Template extension methods allows you to declare new method for those classes that will be available from your templates just as if they belonged to the target class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、テンプレートで使用したいクラスをコントロールできず、それらのクラスにメソッドを追加できないことがあります。テンプレート拡張メソッドを使うと、テンプレートから利用できるようになるクラスのメソッドを、あたかもターゲットクラスに属しているかのように宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's keep extending on our simple HTML page that contains the item name, price and add a discounted price.  The discounted price is sometimes called a "computed property".  We will implement a template extension method to render this property easily.  Let's update our template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイテム名、価格、値引き価格を含むシンプルな HTML ページを拡張していきましょう。値引き価格は「計算プロパティー」と呼ばれることがあります。このプロパティーを簡単にレンダリングするためのテンプレート拡張メソッドを実装します。テンプレートを更新してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`if` is a basic control flow section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`if` は、基本的な制御フローのセクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is also validated against the `Item` class and obviously there is no such property declared. However, there is a template extension method declared on the `TemplateExtensions` class - see below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この式は `Item` クラスに対しても検証されており、明らかにそのようなプロパティーは宣言されていません。しかし、 `TemplateExtensions` クラスにはテンプレート拡張メソッドが宣言されています - 以下を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a class where we put all our extension methods:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、すべての拡張メソッドを置くクラスを作りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TemplateExtensions.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>TemplateExtensions.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A static template extension method can be used to add "computed properties" to a data class. The class of the first parameter is used to match the base object and the method name is used to match the property name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的テンプレート拡張メソッドを使用して、データクラスに「計算プロパティー」を追加することができます。最初のパラメーターのクラスはベースオブジェクトと一致するように使用され、メソッド名はプロパティー名と一致するように使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can place template extension methods in every class if you annotate them with `@TemplateExtension` but we advise to keep them either grouped by target type, or in a single `TemplateExtensions` class by convention.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート拡張メソッドは、 `@TemplateExtension` でアノテーションを付ければ、すべてのクラスに配置することができますが、規約上、ターゲットタイプでグループ化するか、 `TemplateExtensions` クラスにまとめておくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rendering Periodic Reports</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>定期レポートのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating engine could be also very useful when rendering periodic reports.  You'll need to add the `quarkus-scheduler` and `quarkus-qute` extensions first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレーティングエンジンは、定期的なレポートをレンダリングする際にも非常に便利かもしれません。最初に `quarkus-scheduler` と `quarkus-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose the have a `SampleService` bean whose `get()` method returns a list of samples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SampleService` ビーンがあり、その `get()` メソッドがサンプルのリストを返すとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sample.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The template is simple:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートはシンプルです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The loop section makes it possible to iterate over iterables, maps and streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ループセクションでは、イテレーション、マップ、ストリームの反復処理が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This value expression is using the https://en.wikipedia.org/wiki/Elvis_operator[elvis operator] - if the name is null the default value is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この値式は link:https://en.wikipedia.org/wiki/Elvis_operator[elvis 演算子] を使用します - nameが NULL の場合はデフォルト値が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ReportGenerator.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ReportGenerator.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use the `@ResourcePath` qualifier to specify the template path: `templates/reports/v1/report_01.html`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、 `@ResourcePath` の修飾子を使用してテンプレートのパスを指定します: `templates/reports/v1/report_01.html` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to execute this method on the half hour. For more information see the link:scheduler[Scheduler] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用して、Quarkusにこのメソッドを30分に実行するよう指示します。詳細については、 link:scheduler[スケジューラーガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `TemplateInstance.render()` method triggers rendering. Note that this method blocks the current thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`TemplateInstance.render()` メソッドはレンダリングをトリガします。このメソッドは現在のスレッドをブロックすることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive and Asynchronous APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブと非同期API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates can be rendered as a `CompletionStage&lt;String&gt;` (completed with the rendered output asynchronously) or as `Publisher&lt;String&gt;` containing the rendered chunks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートは、 `CompletionStage&lt;String&gt;` (非同期にレンダリングされた出力で完了)としてレンダリングすることも、レンダリングされたチャンクを含む `Publisher&lt;String&gt;` としてレンダリングすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of a `Publisher`, the template is rendered chunk by chunk following the requests from the subscriber.  The rendering is not started until a subscriber requests it.  The returned `Publisher` is an instance of `io.smallrye.mutiny.Multi`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Publisher` の場合、テンプレートはサブスクライバーからのリクエストに応じてチャンクごとにレンダリングされます。レンダリングは、サブスクライバーがリクエストするまで開始されません。返された `Publisher` は `io.smallrye.mutiny.Multi` のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create an instance of `io.smallrye.mutiny.Uni` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように、 `io.smallrye.mutiny.Uni` のインスタンスを作成することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the rendering only starts once the subscriber requests it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、サブスクライバーが要求した場合にのみレンダリングが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about Qute, please refer to the link:qute-reference[Qute reference guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Qute について詳しく知りたい方は、 link:qute-reference[Qute リファレンスガイド] を参考にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の場合のHibernate Validator/Bean Validation の使用方法について説明します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the input/output of your REST services;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST サービスの入出力の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the parameters and return values of the methods of your business services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスサービスのメソッドのパラメーターと戻り値の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple. The user fills a form on a web page.  The web page sends the form content to the `BookResource` as JSON (using Ajax). The `BookResource` validates the user input and returns the _result_ as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで構築されたアプリケーションは非常にシンプルです。ユーザーはウェブページ上でフォームを入力します。Web ページはフォームの内容を JSON として `BookResource` に送信します (Ajax を使用)。 `BookResource` はユーザーの入力を検証し、 _結果_ をJSON として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson and Hibernate Validator/Bean Validation extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、およびHibernate Validator/Bean ValidationエクステンションをインポートするMavenディレクトリー構造を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `hibernate-validator` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `hibernate-validator` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the Validator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデータへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.validation.BookResource` class, and inject the `Validator` object as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.validation.BookResource` クラスを編集し、以下のように `Validator` オブジェクトを注入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Validator` allows checking constraints on a specific object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Validator` では、特定のオブジェクトに対する制約をチェックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this application, we are going to test an elementary object, but we support complicated constraints and can validate graphs of objects.  Create the `org.acme.validation.Book` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のアプリケーションでは、基本のオブジェクトをテストすることになりますが、複雑な制約にも対応しており、オブジェクトのグラフを検証することができます。以下の内容で `org.acme.validation.Book` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints are added on fields, and when an object is validated, the values are checked.  The getter and setter methods are also used for JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールドに制約を加え、オブジェクトが検証されると値がチェックされます。ゲッターメソッドとセッターメソッドはJSONマッピングにも使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to the `BookResource` class.  Add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BookResource` クラスに戻り、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes it does not compile, `Result` is missing, but we will add it very soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、これはコンパイル出来ません。 `Result` がありませんが、私たちはすぐに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter (`book`) is created from the JSON payload automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドパラメーター( `book` )は、JSONペイロードから自動的に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method uses the `Validator` to check the payload.  It returns a set of violations.  If this set is empty, it means the object is valid.  In case of failures, the messages are concatenated and sent back to the browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは `Validator` を使用してペイロードをチェックします。これは違反のセットを返します。このセットが空の場合は、オブジェクトが有効であることを意味します。失敗した場合は、メッセージを連結してブラウザに送り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create the `Result` class as an inner class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、 `Result` クラスをインナークラスとして作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class is very simple and only contains 2 fields and the associated getters and setters.  Because we indicate that we produce JSON, the mapping to JSON is made automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは非常にシンプルで、2つのフィールドとそれに関連するゲッターとセッターだけが含まれています。JSONを生成することを示しているので、JSONへのマッピングは自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `Validator` manually might be useful for some advanced usage, if you simply want to validate the parameters or the return value or your REST end point, you can annotate it directly, either with constraints (`@NotNull`, `@Digits`...)  or with `@Valid` (which will cascade the validation to the bean).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Validator` を手動で使用することは、高度な使用法には便利かもしれませんが、単にパラメーターや戻り値、RESTのエンドポイントを検証したい場合は、制約( `@NotNull`, `@Digits`...)や `@Valid` (ビーンに検証をカスケードします)を使用して直接アノテーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an end point validating the `Book` provided in the request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストで提供された `Book` を検証するエンドポイントを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, we don't have to manually validate the provided `Book` anymore as it is automatically validated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、提供された `Book` は自動的に検証されるので、もう手動で検証する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a validation error is triggered, a violation report is generated and serialized as JSON as our end point produces a JSON output.  It can be extracted and manipulated to display a proper error message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証エラーが発生した場合、違反レポートが生成され、そしてエンドポイントがJSON出力を生成することによってJSONとしてシリアライズされます。これを抽出して操作することで、適切なエラーメッセージを表示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service method validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスメソッドの検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might not always be handy to have the validation rules declared at the end point level as it could duplicate some business validation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーションルールをエンドポイントレベルで宣言するのは、必ずしも便利とは限りません。ビジネスバリデーションと重複する可能性があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best option is then to annotate a method of your business service with your constraints (or in our particular case with `@Valid`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最良の選択肢は、ビジネスサービスのメソッドに制約をアノテーションすることです(私たちの場合は `@Valid` ):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling the service in your rest end point triggers the `Book` validation automatically:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントでサービスを呼び出すと、自動的に `Book` の検証が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that, if you want to push the validation errors to the frontend, you have to catch the exception and push the information yourselves as they will not be automatically pushed to the JSON output.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証エラーをフロントエンドにプッシュしたい場合は、例外をキャッチして自分で情報をプッシュしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that you usually don't want to expose to the public the internals of your services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あなたは通常、あなたのサービスの内部を公開したくないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and especially not the validated value contained in the violation object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に違反オブジェクトに含まれる検証された値は公開したくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A frontend</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フロントエンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add the simple web page to interact with our `BookResource`.  Quarkus automatically serves static resources contained in the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, replace the `index.html` file with the content from this {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、 `BookResource`.Quarkusと対話するためのシンプルなウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーに含まれる静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーで、 `index.html` ファイルをこの {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] ファイルの内容で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open your browser to http://localhost:8080/:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、ブラウザで http://localhost:8080/ を開いてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the book details (valid or invalid)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>書籍の詳細を入力してください(有効または無効)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the _Try me..._ buttons to check if your data is valid using one of the methods we presented above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_Try me..._ ボタンをクリックして、上記で紹介した方法のいずれかを使用してデータが有効かどうかを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate Validator extension is tightly integrated with CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ValidatorエクステンションはCDIと緊密に統合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you might need to configure the behavior of the `ValidatorFactory`, for instance to use a specific `ParameterNameProvider`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、 `ValidatorFactory` の動作を設定する必要があるかもしれません。例えば、特定の `ParameterNameProvider` を使用するためなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the `ValidatorFactory` is instantiated by Quarkus itself, you can very easily tweak it by declaring replacement beans that will be injected in the configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ValidatorFactory` は、Quarkus 自体によってインスタンス化されていますが、設定に注入される代わりのビーンを宣言することで、非常に簡単に微調整することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you create a bean of the following types in your application, it will automatically be injected into the `ValidatorFactory` configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションで以下のタイプのBeanを作成すると、自動的に `ValidatorFactory` の設定に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to wire anything.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何も設定しなくても大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, for each listed type, you can declare only one bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論、リストされた各型に対して、宣言することができるのは1つのBeanだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These beans should be declared as `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのBeanは、 `@ApplicationScoped` として宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can declare your constraint validators as CDI beans:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約バリデータをCDI Beanとして宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When initializing a constraint validator of a given type, Quarkus will check if a bean of this type is available and, if so, it will use it instead of instantiating one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定された型の制約バリデータを初期化する際、Quarkusはこの型のBeanが利用可能かどうかをチェックし、利用可能な場合はインスタンスを作成する代わりにそれを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, as demonstrated in our example, you can fully use injection in your constraint validator beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、例で示したように、制約バリデータビーンでインジェクションを完全に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except in very specific situations, it is recommended to make the said beans `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非常に特定の状況を除いて、このBeanは `@ApplicationScoped` として作ることをお勧めします.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation and localization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーションとローカリゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, constraint violation messages will be returned in the build system locale.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、制約違反のメッセージはビルドシステムのロケールで返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior by adding the following configuration in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、以下の設定を `application.properties` に追加することで変更することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy, in the context of a JAX-RS endpoint, Hibernate Validator will automatically resolve the optimal locale to use from the `Accept-Language` HTTP header, provided the supported locales have been properly specified in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyを使用している場合、JAX-RSエンドポイントのコンテキストでは、 サポートされるロケールが `application.properties` で適切に指定されている場合、Hibernate Validatorが使用する最適なロケールを `Accept-Language` HTTPヘッダから自動的に解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging 利用して Apache Kafka とやりとりする仕組みを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Kafka cluster, or Docker Compose to start a development cluster</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中の Kafka クラスター、または開発クラスターを開始するための Docker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行する場合は、GraalVM がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、1 つのコンポーネントでランダムな価格 (price) を生成します。これらの価格は、Kafka トピック (`prices`) に書かれています。2 番目のコンポーネントは `prices` Kafka トピックから読み込み、この価格に変換を適用します。その結果は、JAX-RS リソースによって消費されるインメモリーストリームに送られます。データは、サーバーから送信されたイベントを使用してブラウザーに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-guide-architecture.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>kafka-guide-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このソリューションは `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=kafka-quickstart \
    -DclassName="org.acme.kafka.PriceResource" \
    -Dpath="/prices" \
    -Dextensions="resteasy,smallrye-reactive-messaging-kafka"
cd kafka-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=kafka-quickstart \
    -DclassName="org.acme.kafka.PriceResource" \
    -Dpath="/prices" \
    -Dextensions="resteasy,smallrye-reactive-messaging-kafka"
cd kafka-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドにより、Maven プロジェクトが作成され、Reactive Messaging と Kafka コネクターエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行して、プロジェクトに `smallrye-reactive-messaging-kafka` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-reactive-messaging-kafka"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-reactive-messaging-kafka"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need a Kafka cluster.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、Kafka クラスターが必要です。https://kafka.apache.org/quickstart[Apache Kafka の Web サイト] の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  zookeeper:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  zookeeper:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  kafka:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  kafka:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once created, run `docker-compose up`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成したら、`docker-compose up` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a development cluster, do not use in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは開発クラスターであり、本番では使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price generator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格ジェネレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/java/org/acme/kafka/PriceGenerator.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.kafka;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.kafka;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A bean producing random prices every 5 seconds.
 * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.
 */
@ApplicationScoped
public class PriceGenerator {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
 * A bean producing random prices every 5 seconds.
 * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.
 */
@ApplicationScoped
public class PriceGenerator {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、5 秒ごとにランダムな _価格_ を生成する Mutiny _ストリーム_ (`Multi`) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、_Reactive Stream_ を返します。生成されたアイテムは `generated-price` という名前のストリームに送られます。このストリームは、次に作成する `application.properties` ファイルを使用して Kafka にマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price converter</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格 (price) コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格コンバーターは、Kafka から価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/kafka/PriceConverter.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A bean consuming data from the "prices" Kafka topic and applying some conversion.
 * The result is pushed to the "my-data-stream" stream which is an in-memory stream.
 */
@ApplicationScoped
public class PriceConverter {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
 * A bean consuming data from the "prices" Kafka topic and applying some conversion.
 * The result is pushed to the "my-data-stream" stream which is an in-memory stream.
 */
@ApplicationScoped
public class PriceConverter {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("prices")                                     // &lt;1&gt;
    @Outgoing("my-data-stream")                             // &lt;2&gt;
    @Broadcast                                              // &lt;3&gt;
    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // &lt;4&gt;
    public double process(int priceInUsd) {
        return priceInUsd * CONVERSION_RATE;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Incoming("prices")                                     // &lt;1&gt;
    @Outgoing("my-data-stream")                             // &lt;2&gt;
    @Broadcast                                              // &lt;3&gt;
    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // &lt;4&gt;
    public double process(int priceInUsd) {
        return priceInUsd * CONVERSION_RATE;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the method consumes the items from the `prices` topic</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドが `prices` トピックのアイテムを消費することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the objects returned by the method are sent to the `my-data-stream` stream</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドによって返されたオブジェクトが `my-data-stream` ストリームに送られることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the item are dispatched to all _subscribers_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイテムがすべての _サブスクライバー_ に発送されていることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to acknowledge the incoming message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>着信メッセージの受け取りを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`process` メソッドは、`prices` トピック (アプリケーションコンフィグレーションの中で設定) からの Kafka _record_ ごとに呼び出されます。すべての結果は `my-data-stream` インメモリーストリームに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ストリームを JAX-RSリソース にバインドしてみましょう。以下の内容の `src/main/java/org/acme/kafka/PriceResource.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.jboss.resteasy.annotations.SseElementType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.jboss.resteasy.annotations.SseElementType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A simple resource retrieving the in-memory "my-data-stream" and sending the items as server-sent events.
 */
@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
 * A simple resource retrieving the in-memory "my-data-stream" and sending the items as server-sent events.
 */
@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @Channel("my-data-stream") Publisher&lt;Double&gt; prices; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    @Channel("my-data-stream") Publisher&lt;Double&gt; prices; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS) // &lt;2&gt;
    @SseElementType("text/plain") // &lt;3&gt;
    public Publisher&lt;Double&gt; stream() { // &lt;4&gt;
        return prices;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS) // &lt;2&gt;
    @SseElementType("text/plain") // &lt;3&gt;
    public Publisher&lt;Double&gt; stream() { // &lt;4&gt;
        return prices;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injects the `my-data-stream` channel using the `@Channel` qualifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the content is sent using `Server Sent Events`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Server Sent Events` を使用してコンテンツが送信されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the data contained within the server sent events is of type `text/plain`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバーから送信されたイベントに含まれるデータのタイプが `text/plain` であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the stream (_Reactive Stream_)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ストリーム (_Reactive Stream_) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka コネクターを設定する必要があります。これは `application.properties` ファイルで行います。このキーは以下のような構造になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`generated-price` -&gt; sink in which we write the prices</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`generated-price` -&gt; sink (価格の書き込み先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`prices` -&gt; source in which we read the prices</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`prices` -&gt; source (価格の読み取り先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the SmallRye Kafka connector
kafka.bootstrap.servers=localhost:9092
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the SmallRye Kafka connector
kafka.bootstrap.servers=localhost:9092
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.generated-price.connector=smallrye-kafka
mp.messaging.outgoing.generated-price.topic=prices
mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.generated-price.connector=smallrye-kafka
mp.messaging.outgoing.generated-price.topic=prices
mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.prices.connector=smallrye-kafka
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.prices.connector=smallrye-kafka
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定の詳細は、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。これらのプロパティは、`kafka` という接頭辞で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about `my-data-stream`? This is an in-memory stream, not connected to a message broker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`my-data-stream` はどうでしょうか? これはインメモリストリームであり、メッセージブローカーには接続されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Final touch, the HTML page reading the converted prices using SSE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、SSE を使って変換された価格を読み込む HTML ページです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here. On each received price, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に目を見張るようなものは何もありません。受信した価格ごとに、ページが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have Kafka running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指示に従えば、Kafka が起動しているはずです。あとは、以下でアプリケーションを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/prices.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザーで `http://localhost:8080/prices.html` を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you started the Kafka broker with docker compose, stop it using `CTRL+C` followed by `docker-compose down`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーを docker compose で起動した場合は、`CTRL+C` に続いて `docker-compose down` で停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令的な使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you need to have an imperative way of sending messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、命令的な方法でメッセージを送ることが必要になる場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Output` because your method has parameters.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、POST リクエストを受信したときに、REST エンドポイントの内部からストリームにメッセージを送信する必要があるとします。この場合、メソッドにはパラメーターがあるため、`@Output` を使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you can use an `Emitter`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合には `Emitter` が利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Emitter` の設定は、`@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非推奨</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.reactive.messaging.annotations.Emitter`、`io.smallrye.reactive.messaging.annotations.Channel`、`io.smallrye.reactive.messaging.annotations.OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると、`CompletionStage` の完了を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka` can add a readiness health check to validate the connection to the broker. This is disabled by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、`quarkus-kafka` は、ブローカーへの接続を検証するためにレディネスヘルスチェックを追加することができます。これはデフォルトでは無効になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabled, when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを有効にすると、アプリケーションの `/q/health/ready` エンドポイントにアクセスしたときに、接続検証ステータスに関する情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作を有効にするには、`application.properties` の `quarkus.kafka.health.enabled` プロパティを `true` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in capabilities to deal with JSON Kafka messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、JSON Kafka メッセージを扱う機能が組み込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine we have a `Fruit` pojo as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `Fruit` の pojo があると想像してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public String name;
    public int price;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public String name;
    public int price;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Kafka からメッセージを受信して、何らかの価格変換を行い、Kafka にメッセージを送り返すために使いたいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
* A bean consuming data from the "fruit-in" Kafka topic and applying some price conversion.
* The result is pushed to the "fruit-out" stream.
*/
@ApplicationScoped
public class FruitProcessor {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
* A bean consuming data from the "fruit-in" Kafka topic and applying some price conversion.
* The result is pushed to the "fruit-out" stream.
*/
@ApplicationScoped
public class FruitProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, we will need to setup JSON serialization with Jackson or JSON-B.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのためには、Jackson や JSON-B で JSON シリアライゼーションを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With JSON serialization correctly configured, you can also use `Publisher&lt;Fruit&gt;` and `Emitter&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON シリアライゼーションが正しく設定されていれば、 `Publisher&lt;Fruit&gt;` や `Emitter&lt;Fruit&gt;` も利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、`quarkus-jackson` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jackson` のエクステンションを使用している場合は、これは必要ありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson, but the corresponding deserializer is generic, so it needs to be subclassed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jackson によって全ての POJO をシリアルに変換することができる既存の `ObjectMapperSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、`ObjectMapperDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package com.acme.fruit.jackson;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package com.acme.fruit.jackson;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your streams to use the Jackson serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Jackson シリアライザーとデシリアライザーを使用するようにストリームを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、Kafka メッセージには、Fruit pojo の Jackson によるシリアライズ表現が含まれるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、`quarkus-jsonb` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jsonb` のエクステンションを使用している場合は不要です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B, but the corresponding deserializer is generic, so it needs to be subclassed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON-B によってすべての pojos をシリアライズするために使用できる既存の `JsonbSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、一般的な `JsonbDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package com.acme.fruit.jsonb;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package com.acme.fruit.jsonb;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.kafka.client.serialization.JsonbDeserializer;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.kafka.client.serialization.JsonbDeserializer;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pojo に個別にデシリアライザーを作成したくない場合は、`javax.json.JsonObject` にデシリアライズする汎用の `io.vertx.kafka.client.serialization.JsonObjectDeserializer` を使用することができます。対応するシリアライザーも使用できます。`io.vertx.kafka.client.serialization.JsonObjectSerializer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your streams to use the JSON-B serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、JSON-B シリアライザーとデシリアライザーを使用するようにストリームを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、Kafka のメッセージには、JSON-B でシリアライズされた Fruit pojo の表現が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy で JSON Server-Sent Events を送信したい場合は、`@SseElementType` アノテーションを使用してイベントのコンテンツタイプを定義する必要があります。これは、このメソッドが `@Produces(MediaType.SERVER_SENT_EVENTS)` のアノテーションが付くためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example shows how to use SSE from a Kafka topic source.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の例は、Kafka トピックソースから SSE を使用する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @Channel("fruit-out") Publisher&lt;Fruit&gt; fruits;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    @Channel("fruit-out") Publisher&lt;Fruit&gt; fruits;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.APPLICATION_JSON)
    public Publisher&lt;Fruit&gt; stream() {
        return fruits;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.APPLICATION_JSON)
    public Publisher&lt;Fruit&gt; stream() {
        return fruits;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking processing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブロッキング処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Messaging とデータベースインタラクションなどのブロッキング処理を組み合わせる必要がある状況は少なくありません。そのためには、処理が _ブロックしていて_ 呼び出し元のスレッドで実行できないこと示している `@Blocking` アノテーションを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下のコードは、Hibernate with Panacheを 使用してデータベースに受信ペイロードを格納する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.panache;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.panache;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class PriceStorage {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
public class PriceStorage {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("prices")
    @Blocking
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Incoming("prices")
    @Blocking
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な例は `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Blocking` アノテーションは 2 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>効果はどちらも同じです。したがって、両方を使うことができます。最初のものは、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2 番目のものは、Quarkus の他のリアクティブ機能でも使用され、デフォルトのワーカープールを使用し、順序を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing without a broker</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーなしでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーを起動しなくてもアプリケーションをテストできるのは便利です。これを行うには、Kafka コネクターで管理しているチャンネルを _インメモリー_ に _切り替え_ できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a Quarkus Test Resource as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、以下のように Quarkus Test Resource を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");  // &lt;1&gt;
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("queue");   // &lt;2&gt;
        env.putAll(props1);
        env.putAll(props2);
        return env;  // &lt;3&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");  // &lt;1&gt;
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("queue");   // &lt;2&gt;
        env.putAll(props1);
        env.putAll(props2);
        return env;  // &lt;3&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void stop() {
        InMemoryConnector.clear();  // &lt;4&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public void stop() {
        InMemoryConnector.clear();  // &lt;4&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the incoming channel "orders" (expecting messages from Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(Kafka からのメッセージが想定される) 受信チャンネル "order" をインメモリーに切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the outgoing channel "queue" (writing messages to Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信チャネル "キュー" (Kafka へのメッセージの書き込み) をインメモリーに切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む `Map` をビルドして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Quarkus Test using the test resource created above:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記で作成したテストリソースを使用して Quarkus テストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject @Any
    InMemoryConnector connector; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject @Any
    InMemoryConnector connector; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; orders = connector.source("orders"); // &lt;2&gt;
        InMemorySink&lt;Beverage&gt; queue = connector.sink("queue");    // &lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; orders = connector.source("orders"); // &lt;2&gt;
        InMemorySink&lt;Beverage&gt; queue = connector.sink("queue");    // &lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        orders.send(order);  // &lt;4&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        orders.send(order);  // &lt;4&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(queue::received, t -&gt; t.size() == 1); // &lt;5&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(queue::received, t -&gt; t.size() == 1); // &lt;5&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Beverage queuedBeverage = queue.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Beverage queuedBeverage = queue.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the in-memory connector in your test class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスにインメモリーコネクタ－を挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信チャンネルを取得します (`orders`) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信チャネルを取得します (`queue`) - テストリソース内でチャネルがインメモリーに切り替えられている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `send` method to send a message to the `orders` channel. So, the application will process this message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`send` メソッドを使用して、`orders` チャンネルにメッセージを送信します。つまり、アプリケーションはこのメッセージを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `received` method to check the messages produced by the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが生成するメッセージを確認するには、`received` メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting Kafka in a test resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストリソースでの Kafka の起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、テストリソースで Kafka ブローカを起動することもできます。次のスニペットは、https://www.testcontainers.org/modules/kafka/[Testcontainers] 使用して Kafka ブローカを起動するテストリソースを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class KafkaResource implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class KafkaResource implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private final KafkaContainer kafka = new KafkaContainer();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private final KafkaContainer kafka = new KafkaContainer();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  // &lt;1&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  // &lt;1&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void stop() {
        kafka.close();
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public void stop() {
        kafka.close();
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the Kafka bootstrap location, so the application connects to this broker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションがこのブローカーに接続するように、Kafka ブートストラップの場所を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーが認証メカニズムとして OAuth を使用している場合は、この認証プロセスを有効にするために Kafka コンシューマーを設定する必要があります。まず、以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この依存関係は、OAuth ワークフローを処理するために必要なコールバックハンドラーを提供します。そして、`application.properties` で追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`oauth.client.id`、`oauth.client.secret`、`oauth.token.endpoint.uri` の値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth authentication works for both JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OAuth 認証は JVM とネイティブモードの両方で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.  It utilizes MicroProfile Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus を使用して Kafka とやりとりする方法を示しました。MicroProfile Reactive Messaging を利用して、データストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is developed by a third party and is part of the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションはサードパーティによって開発されたもので、Quarkus Platformの一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependencies to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の依存関係をプロジェクトに追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンティティーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration properties listed here allow you to override such defaults, and customize and tune various aspects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここに記載されている設定プロパティーでは、このようなデフォルトを上書きしたり、様々な面をカスタマイズしたり調整したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to log to Sentry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusがSentryにログ送信するように設定する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry is a really easy way to be notified of errors happening in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentryは、Quarkusアプリケーションで発生したエラーを通知する本当に簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a self-hosted and cloud-based error monitoring that helps software teams discover, triage, and prioritize errors in real-time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セルフホスト型か、クラウドベースのエラーモニターリングで、ソフトウェアチームがリアルタイムでエラーを発見し、トリアージし、優先順位をつけるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They offer a free starter price for cloud-based or you can self host it for free.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドベースの場合は無料のスターター価格を提供してくれますし、セルフホストでも無料で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry's Java SDK is open source, but recently sentry.io https://blog.sentry.io/2019/11/06/relicensing-sentry[changed the license] for their backend to the non-open source https://github.com/getsentry/sentry/blob/master/LICENSE[BSL license]. This might or might not be an issue for your project and product.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry の Java SDK はオープンソースですが、最近 sentry.io はバックエンドの link:https://blog.sentry.io/2019/11/06/relicensing-sentry[ライセンス] を非オープンソースの link:https://github.com/getsentry/sentry/blob/master/LICENSE[BSL ライセンス]に link:https://blog.sentry.io/2019/11/06/relicensing-sentry[変更しました]。これはあなたのプロジェクトや製品にとって問題になるかもしれませんし、ならないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start with, you need to get a Sentry DSN either by https://sentry.io/signup/[creating a Sentry account] or https://docs.sentry.io/server/[installing your own self-hosted Sentry].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手始めに、Sentry link:https://sentry.io/signup/[アカウントを作成する]か、自前のSentry link:https://docs.sentry.io/server/[をインストール] してSentry DSNを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“In Application” Stack Frames</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"in Application" スタックフレーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry differentiates stack frames that are directly related to your application (“in application”) from stack frames that come from other packages such as the standard library, frameworks, or other dependencies. The difference is visible in the Sentry web interface where only the “in application” frames are displayed by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry は、アプリケーションに直接関連するスタックフレーム("in application")と、標準ライブラリやフレームワーク、その他の依存関係のあるパッケージから来るスタックフレームを区別します。この違いは、SentryのWebインタフェースでは、デフォルトでは "in application" フレームのみが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure which package prefixes your application uses with the `in-app-packages` option, which takes a comma separated list of packages:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`in-app-packages` オプションで、アプリケーションが使用するパッケージの接頭辞を設定できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don’t want to use this feature but want to disable the warning, simply set it to `*`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用したくないが警告を無効にしたい場合は、 `*` をセットしてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors and warnings occurring in any of the packages will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いずれかのパッケージで発生したすべてのエラーや警告は、DSNと共にSentryに送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors occurring in the package `org.example` will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージ `org.example` で発生したすべてのエラーは、DSN と共にSentry に送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is configured through the standard `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、標準の `application.properties` ファイルを介して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI is provided as a native binary for Linux and macOS or as a jar-file for all operating systems.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI は、Linux と macOS 用のネイティブバイナリーとして、またはすべてのオペレーティングシステム用の jar ファイルとして提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the binaries here:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バイナリーはこちらからダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://coming-soon[macOS Binary] (coming soon)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://coming-soon[macOSバイナリー](近日公開予定)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you create a specific Quarkus folder, eg '~/quarkus' and move the binary there.  Then in your shell profile (for Bash shell edit '~/.bash_profile'), export the 'QUARKUS_HOME' folder and add that to your 'PATH':</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定の Quarkus フォルダー、例えば '~/quarkus' を作成し、そこにバイナリーを移動することをお勧めします。次に、シェルプロファイル (Bash シェルの場合は'~/.bash_profile' を編集) で、'QUARKUS_HOME' フォルダーをエクスポートして 'PATH' に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>export QUARKUS_HOME=/path/to/quarkus-cli
export PATH="$PATH:$QUARKUS_HOME"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>export QUARKUS_HOME=/path/to/quarkus-cli
export PATH="$PATH:$QUARKUS_HOME"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reload your terminal or do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>端末をリロードするか、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>source ~/.bash_profile
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>source ~/.bash_profile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can run the Quarkus CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで Quarkus CLI を実行できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus --help
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will display the help information with all the available commands.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、利用可能なすべてのコマンドのヘルプ情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus -i
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus -i
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start the Quarkus CLI in interactive mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、対話型モードで Quarkus CLI が起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jar CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jar CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the jar-file here:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jar ァイルはこちらからダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://coming-soon[jar-file] (coming soon)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://coming-soon[jar-file](近日公開)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the native CLI we recommend that you copy the binary to a specific folder, eg '~/quarkus'.  The jar file requires Java 8 or newer to run. To start the CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ CLI と同様に、バイナリーを特定のフォルダー (例: '~/quarkus') にコピーすることをお勧めします。jar ファイルを実行するには Java 8 以降が必要です。CLI を起動するには以下を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ java -jar quarkus-cli.jar
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ java -jar quarkus-cli.jar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The jar file CLI accepts all the same options and commands as the native binary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jar ファイルの CLI は、ネイティブのバイナリーと同じオプションとコマンドをすべて受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: In the examples below switch out 'quarkus' with 'java -jar quarkus-cli.jar'.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意: 以下の例では、'quarkus' を 'java -jar quarkus-cli.jar' で置き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a new project we use the create-project command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいプロジェクトを作成するには、create-project コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project hello-world
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a folder called 'hello-world' in your current working directory using default groupId, artifactId and version values (groupId='org.acme', artifactId='quarkus' and version='1.0.0-SNAPSHOT').</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、デフォルトの groupId、artifactId、および version の値 (groupId='org.acme', artifactId='quarkus', version='1.0.0-SNAPSHOT') を使用して、現在の作業ディレクトリーに 'hello-world' という名前のフォルダーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify the groupId, artifactId and version values, use the '--groupid', '--artifactid' and '--version' options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>groupId、artifactId、および version の値を指定するには、'--groupid'、'--artifactid'、および '--version' オプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the help option to display all the possible options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なすべてのオプションを表示するには、ヘルプオプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI では、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus list-extensions
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus list-extensions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To more easily get an overview and only display the extension names:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より簡単に概要を取得し、エクステンション名のみを表示する場合は、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus list-extensions -n
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus list-extensions -n
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding extension(s)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can add Quarkus extensions to your project with the 'add-extension' command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI では、'add-extension' コマンドを使用して、Quarkus のエクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus add-extension --extension=hibernate-validator /path/to/my/project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus add-extension --extension=hibernate-validator /path/to/my/project
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The argument path either needs to be the base folder for the project or a direct path to the build file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>引数のパスは、プロジェクトのベースフォルダーかビルドファイルへの直接パスである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start dev mode from the Quarkus CLI do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI から dev モードを起動するには、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus dev /path/to/my/project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus dev /path/to/my/project
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with 'add-extension' the argument path needs to be the base folder for the project or a direct path to the build file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>add-extension' と同様、引数のパスは、プロジェクトのベースフォルダーまたはビルドファイルへの直接パスである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document explains the Quarkus class loading architecture. It is intended for extension authors and advanced users who want to understand exactly how Quarkus works.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus のクラスロードアーキテクチャについて説明します。このドキュメントは、Quarkus がどのように動作するかを正確に理解したいエクステンションの作者や上級ユーザーを対象としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus class loading architecture is slightly different depending on the mode that the application is run in. When running a production application everything is loaded in the system ClassLoader, so it is a completely flat class path. This also applies to native image mode which does not really support multiple ClassLoaders, and is based on a normal production Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus のクラスロードアーキテクチャは、アプリケーションを実行するモードによって若干異なります。本番環境のアプリケーションを実行しているときは、すべてがシステム ClassLoader でロードされるため、完全にフラットなクラスパスとなります。これは、複数の ClassLoader をサポートしていないネイティブイメージモードにも当てはまり、通常のプロダクション Quarkus アプリケーションをベースにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For all other use cases (e.g. tests, dev mode, and building the application) Quarkus uses the class loading architecture outlined here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のすべてのユースケース(テスト、開発モード、アプリケーションのビルドなど)では、Quarkus はここで説明したクラスロードアーキテクチャを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus application. The end result of this process is a `CuratedApplication`, which contains all the class loading information for the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての Quarkus アプリケーションは、 `independent-projects/bootstrap` モジュールの QuarkusBootstrap クラスによって作成されます。このクラスは、Quarkus アプリケーションに必要なすべての関連する依存関係(デプロイメントとランタイムの両方)を解決するために使用されます。このプロセスの最終結果は、 `CuratedApplication` であり、これにはアプリケーションのすべてのクラスロード情報が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `CuratedApplication` を使用して `AugmentAction` インスタンスを作成し、本番アプリケーションを作成したり、ランタイムのものを起動/再起動したりすることができます。このアプリケーションインスタンスは、分離された ClassLoader 内に存在しています。収集処理によって解決されるため、クラスパスに Quarkus デプロイメントクラスを配置する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このブートストラッププロセスは、Quarkus がどのように起動されても、異なるパラメーターが渡されているだけで、同じであるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Current Run Modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の実行モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment we have the following use cases for bootstrapping Quarkus:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、Quarkus のブートストラップには以下のようなユースケースがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファクタの目的の一つは、これらの異なる実行モードのすべてが基本的に同じ方法で Quarkus を起動できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A ClassLoader is said to be 'transformer safe' if it is safe to load classes in the class loader before the transformers are ready. Once a class has been loaded it cannot be changed, so if a class is loaded before the transformers have been prepared this will prevent the transformation from working. Loading classes in a transformer safe ClassLoader will not prevent the transformation, as the loaded class is not used at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ClassLoader は、Transformer が準備される前にクラスをロードしても安全であれば、「Transformerセーフ」と言われます。一度ロードされたクラスは変更することができないので、もし Transformer の準備が整う前にロードされた場合、変換が機能しなくなります。Transformer セーフな ClassLoader でクラスをロードした場合は、ロードされたクラスは実行時には使用されないので、変換を妨げることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ClassLoader Implementations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスローダーの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベース ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは通常、通常の JVM System ClassLoader です。Maven のような環境では異なる場合があります。この ClassLoader はブートストラップクラスをロードするために使用され、他の ClassLoader インスタンスは JDK クラスのロードをこれに委譲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augment ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張 ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader, and it is transformer safe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、すべての `-deployment` アーティファクトとその依存関係、および他のユーザー依存関係をロードします。アプリケーションのルートやホットデプロイされたコードはロードしません。この ClassLoader は永続的に動作し、アプリケーションが再起動してもそれは残ります (ホットデプロイされている可能性のあるアプリケーションクラスをロードできないのはそのためです)。親はベースの ClassLoader であり、Transformerセーフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、これはベース ClassLoader に委譲するように設定することができますが、計画ではこのオプションは廃止され、常に分離された ClassLoader として使用することになっています。これを分離型 ClassLoader にすることは、すべてのビルダクラスが分離されていることを意味するので複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイメント ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can load all application classes, its parent is the Augment ClassLoader so it can also load all deployment classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはすべてのアプリケーションクラスをロードすることができ、その親は 拡張 ClassLoader なので、すべてのデプロイメントクラスをロードすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader is the context ClassLoader that is used when running the build steps. It is also transformer safe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この ClassLoader は永続的ではなく、アプリケーションの起動時に再作成され、分離されています。この ClassLoader は、ビルドステップを実行する際に使用されるコンテキスト ClassLoader です。また、Transformerセーフでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base Runtime ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベースランタイム ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads all the runtime extension dependencies, as well as other user dependencies (note that this may include duplicate copies of classes also loaded by the Augment ClassLoader). It does not load the application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、他のユーザー依存関係と同様に、すべてのランタイムエクステンション依存関係をロードします(これには 拡張 ClassLoader によってロードされたクラスの重複コピーも含まれる可能性があることに注意してください)。アプリケーションのルートやホットデプロイされたコードはロードされません。この ClassLoader は永続的なもので、アプリケーションが再起動しても残ります (ホットデプロイされている可能性のあるアプリケーションクラスをロードできないのはそのためです)。親はベース ClassLoader です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this transformation is no longer possible). This means that only transformers registered in the first application start will take effect, however as these transformers are expected to be idempotent this should not cause problems. An example of the sort of transformation that might be required here is a Panache entity packaged in an external jar. This class needs to be transformed to have its static methods implemented, however this transformation only happens once, so restarts use the copy of the class that was created on the first start.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはホットリロードできないコードをロードしますが、変換をサポートしています (ただし、クラスがロードされるとこの変換はできなくなります)。これは、最初のアプリケーション起動時に登録された Transformer のみが有効になることを意味しますが、これらの Transformer は冪等であることが期待されているため、これは問題を引き起こすことはないはずです。ここで必要となる可能性のある変換の例として、外部 jar にパッケージ化された Panache エンティティーがあります。このクラスは静的メソッドを実装するために変換する必要がありますが、この変換は一度しか行われないため、再起動時には最初の起動時に作成されたクラスのコピーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications to behave more like a production application (production applications are isolated in that they run in a whole new JVM).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この ClassLoader は、拡張 ClassLoader とデプロイメント ClassLoader から分離されています。つまり、デプロイメント側の静的フィールドに値を設定して、実行時に読み込まれることを期待することはできません。これにより、開発アプリケーションやテストアプリケーションが本番アプリケーションのように振る舞うことができます(本番アプリケーションは全く新しい JVM で実行されるという点で分離されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、実行時のバージョンは別の依存関係のセットに対してリンクされる可能性があることを意味します。例えば、デプロイ時に使用する Hibernate バージョンには ByteBuddy が含まれていても、実行時に使用するバージョンには含まれていない場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime Class Loader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムクラス ローダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is used to load the application classes and other hot deployable resources. Its parent is the base runtime ClassLoader, and it is recreated when the application is restarted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この ClassLoader は、アプリケーションクラスやその他のホットデプロイ可能なリソースをロードするために使用されます。親はベースランタイム ClassLoader で、アプリケーションの再起動時に再作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Isolated ClassLoaders</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離型クラスローダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime ClassLoader is always isolated. This means that it will have its own copies of almost every class from the resolved dependency list. The exception to this are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムの ClassLoader は常に分離されています。これは、解決された依存関係リストのほとんどすべてのクラスの独自のコピーを持つことを意味します。これには例外があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes from artifacts that extensions have marked as parent first (more on this later).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションが親優先とマークしたアーティファクトからのクラス (これについては後述します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parent First Dependencies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>親優先の依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system ClassLoader (or whatever ClassLoader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about this, however there are a few cases where this is necessary:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された方法でロードされるべきではないクラスがいくつかありますが、それは常にシステムの ClassLoader(または Quarkus のブートストラップを担当している ClassLoader )によってロードされなければなりません。ほとんどのエクステンションはこのことを気にする必要はありませんが、必要な場合もあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some logging related classes, as logging must be loaded by the system ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングはシステム ClassLoader によってロードされなければならないので、いくつかのロギング関連のクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you mark a dependency as parent first then all of its dependencies must also be parent first, or a `LinkageError` can occur.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが必要な場合は、 `quarkus-bootstrap-maven-plugin` で設定することができます。 依存関係を親優先とマークした場合は、その依存関係もすべて親優先にしなければならないことに注意してください。そうでないと、 `LinkageError` が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Banned Dependencies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>禁止された依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some dependencies that we can be sure we do not want. This generally happens when a dependency has had a name change (e.g. smallrye-config changing groups from `org.smallrye` to `org.smallrye.config`, the `javax` -&gt; `jakarta` rename).  This can cause problems, as if these artifacts end up in the dependency tree out of date classes can be loaded that are not compatible with Quarkus. To deal with this extensions can specify artifacts that should never be loaded. This is done by modifying the `quarkus-bootstrap-maven-plugin` config in the pom (which generates the `quarkus-extension.properties` file). Simply add an `excludedArtifacts` section as shown below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の中には、必要ないと確信できるものもあります。これは一般的に、依存関係の名前が変更された場合に起こります(例:smallrye-configがグループを `org.smallrye` から `org.smallrye.config` に変更した、 `javax` → `jakarta` のリネームなど)。これは問題を引き起こす可能性があります。これらのアーティファクトが依存関係ツリーで終わると、Quarkusと互換性のない古いクラスがロードされる可能性があるからです。この問題に対処するために、エクステンションでは、決してロードしてはいけないアーティファクトを指定することができます。これは、 `quarkus-extension.properties` ファイルを生成する pom の `quarkus-bootstrap-maven-plugin` 設定を変更することで行います。以下のように `excludedArtifacts` セクションを追加するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This should only be done if the extension depends on a newer version of these artifacts. If the extension does not bring in a replacement artifact as a dependency then classes the application needs might end up missing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、エクステンションがこれらのアーティファクトの新しいバージョンに依存している場合にのみ行うべきです。もしエクステンションが代替アーティファクトを依存関係として持ち込まなかった場合、 アプリケーションが必要とするクラスが見つからなくなってしまうかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading Class Bytecode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスバイトコードの読み取り</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to use the correct `ClassLoader`. The recommended approach is to get it by calling the `Thread.currentThread().getContextClassLoader()` method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>正しい `ClassLoader` を使用することが重要です。推奨される方法は、 `Thread.currentThread().getContextClassLoader()` メソッドを呼び出して取得することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle support is considered preview.  You can use Gradle to create Quarkus projects as outlined in our guides. If you go beyond there will be cases where the Gradle tasks https://github.com/quarkusio/quarkus/issues/5101[does not behave as expected].  This is just a caution, and we recommend if you like Gradle you try it out and give us feedback.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の Gradle サポートはプレビューとされています。このガイドで Gradle を使用して Quarkus プロジェクトを作成する方法の概要を説明しています。これを超えると、Gradleのタスクが link:https://github.com/quarkusio/quarkus/issues/5101[期待通りに動作しない場合があります] 。これはあくまでも注意事項であり、Gradle が好きな方は試してみてフィードバックをいただくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to scaffold a Gradle project, is currently to use the Quarkus Maven plugin like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleプロジェクトをスキャフォールドにする最も簡単な方法は、現在のところ、このようにQuarkus Mavenプラグインを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus project scaffolding automatically installs the Gradle wrapper (`./gradlew`) in your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトのスキャフォールドは、プロジェクトにGradleラッパー( `./gradlew` )を自動的にインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use a standalone Gradle installation, please use Gradle {gradle-version}.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタンドアロンのGradleを使用したい場合は、Gradle {gradle-version} を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The group id of the created project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたプロジェクトのグループID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The artifact id of the created project. Not passing it triggers the interactive mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたプロジェクトのアーティファクトID。これを渡さないと、インタラクティブモードがトリガされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of the created project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたプロジェクトのバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Not created if omitted_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_省略された場合は作成されない_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fully qualified name of the generated resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースの完全修飾名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The resource path, only relevant if `className` is set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースパス、 `className` が設定されている場合のみ関連します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of extensions to add to the project (comma-separated)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトに追加するエクステンションのリスト (カンマ区切り)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you decide to generate a REST resource (using the `className` attribute), the endpoint is exposed at: `http://localhost:8080/$path`.  If you use the default `path`, the URL is: http://localhost:8080/hello.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST リソースを生成することにした場合 ( `className` 属性を使用)、エンドポイントは次の場所で公開されます: `http://localhost:8080/$path` 。デフォルトの `path` を使用する場合、URL は http://localhost:8080/hello です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A pair of Dockerfiles for native and jvm mode are also generated in `src/main/docker`.  Instructions to build the image and run the container are written in those Dockerfiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードと jvm モード用の Dockerfile も `src/main/docker`  に生成されています。イメージのビルドとコンテナーの実行の指示は、これらの Dockerfile に書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom test configuration profile in JVM mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMモードでのカスタムテスト構成プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus tests in JVM mode are run using the `test` configuration profile. If you are not familiar with Quarkus configuration profiles, everything you need to know is explained in the link:config#configuration-profiles[Configuration Profiles Documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、JVMモードでのQuarkusテストは、 `test`  設定プロファイルを使用して実行されます。Quarkusの設定プロファイルについてよく知らない場合は、必要な情報はすべて link:config#configuration-profiles[設定プロファイルのドキュメント]で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Gradle build configuration shown below.  This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、以下に示す Gradle ビルド設定でテスト用のカスタム設定プロファイルを使用することは可能です。これは例えば、デフォルトのテストデータベースではない特定のデータベースを使ってテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `foo` configuration profile will be used to run the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`foo`  設定プロファイルがテストの実行に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to use a custom test configuration profile in native mode for now. Native tests are always run using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、ネイティブモードでカスタムテスト設定プロファイルを使用することはできません。ネイティブテストは常に `prod`  プロファイルを使用して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside a Quarkus project, you can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトの内部から、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable an extension using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下を使ってエクステンションを有効化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension name is the GAV name of the extension: e.g. `io.quarkus:quarkus-agroal`.  But you can pass a partial name and Quarkus will do its best to find the right extension.  For example, `agroal`, `Agroal` or `agro` will expand to `io.quarkus:quarkus-agroal`.  If no extension is found or if more than one extensions match, you will see a red check mark ❌ in the command result.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus:quarkus-agroal` エクステンション名は、エクステンションのGAV名です。しかし、部分的な名前を渡すことができ、Quarkusは適切なエクステンションを見つけるために最善を尽くします。例えば、 `agroal`  、 `Agroal`  、 `agro`  は `io.quarkus:quarkus-agroal`  に展開されます。エクステンションが見つからなかったり、複数のエクステンションが一致した場合は、コマンドの結果に赤いチェックマーク❌が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グロブパターンに一致するエクステンションをすべてインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a built-in development mode.  Run your application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには開発モードが組み込まれています。以下でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then update the application sources, resources and configurations.  The changes are automatically reflected in your running application.  This is great to do development spanning UI and database as you see changes reflected immediately.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、アプリケーションのソース、リソース、および設定を更新することができます。変更は実行中のアプリケーションに自動的に反映されます。変更がすぐに反映されるので、UIやデータベースにまたがった開発をするのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkusDev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkusDev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティーファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the working directory the development environment runs on:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発環境が動作する作業ディレクトリーを変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `quarkusDev` task uses `compileJava` compiler options. These can be overridden by setting the `compilerArgs` property in the task.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkusDev`  タスクは `compileJava`  コンパイラ・オプションを使用します。これらは、タスクの `compilerArgs`  プロパティーを設定することで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkusDev` sets the debug host to `localhost` (for security reasons). If you need to change this, for example to enable debugging on all hosts, you can use the `-DdebugHost` option like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkusDev` はデバッグホストを `localhost` に設定します (セキュリティー上の理由から)。これを変更する必要がある場合、例えばすべてのホストでデバッグを有効にしたい場合は、 `-DdebugHost` オプションを次のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The plugin also exposes a `quarkusDev` configuration. Using this configuration to declare a dependency will restrict the usage of that dependency to development mode.  The `quarkusDev` configuration can be used as following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプラグインは `quarkusDev` の設定も公開しています。この設定を使って依存関係を宣言すると、その依存関係の使用が開発モードに制限されます。 `quarkusDev` の設定は以下のように使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to use development mode remotely, so that you can run Quarkus in a container environment (such as OpenShift)  and have changes made to your local files become immediately visible.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードをリモートで使用することができるので、コンテナー環境(OpenShiftなど)でQuarkusを実行して、ローカルファイルに加えられた変更をすぐに確認できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to develop in the same environment you will actually run your app in, and with access to the same services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、実際にアプリを実行するのと同じ環境で、同じサービスにアクセスしながら開発することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production applications in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must have the `quarkus-undertow-websockets` extension installed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行するためには、 `quarkus-undertow-websockets` エクステンションがインストールされている必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also have the following config properties set:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下の設定プロパティーを設定しておく必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.live-reload.password`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.live-reload.password`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.live-reload.url`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.live-reload.url`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be set via `application.properties`, or any other way (e.g. system properties, environment vars etc). The password must be set on both the local and remote processes, while the url only needs to be set on the local host.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは `application.properties`  やその他の方法で設定できます (例: システムのプロパティー、環境変数など)。パスワードはローカルプロセスとリモートプロセスの両方で設定しなければなりませんが、 url はローカルホストでのみ設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Quarkus in dev mode on the remote host. Now you need to connect your local agent to the remote host:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモートホストでQuarkusをdevモードで起動します。ここで、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでブラウザを更新するたびに、ローカルで行った変更がリモートアプリにすぐに表示されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In development mode, Quarkus starts by default with debug mode enabled, listening to port `5005` without suspending the JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードでは、Quarkusはデフォルトでデバッグモードを有効にして起動し、JVMをサスペンドせずにポート `5005`  をリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be changed by giving the `debug` system property one of the following values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、 `debug` システム・プロパティーに以下の値のいずれかを与えることで変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false` - the JVM will start with debug mode disabled</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`false`  - JVMはデバッグモードを無効にして起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true` - The JVM is started in debug mode and will be listening on port `5005`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`true`  - JVM はデバッグモードで起動され、 `5005`ポートをリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client` - the JVM will start in client mode and attempt to connect to `localhost:5005`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`client`  - JVM はクライアントモードで起動し、 `localhost:5005`に接続を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{port}` - The JVM is started in debug mode and will be listening on `{port}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{port}` - JVM はデバッグモードで起動されています。 `{port}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An additional system property `suspend` can be used to suspend the JVM, when launched in debug mode. `suspend` supports the following values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のシステム・プロパティー `suspend` は、デバッグ・モードで起動されたときに JVM をサスペンドするために使用できます。 `suspend` は以下の値をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`y` or `true` - The debug mode JVM launch is suspended</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`y` または `true` - デバッグモードの JVM 起動が中断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`n` or `false` - The debug mode JVM is started without suspending</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`n` または `false` - デバッグモードの JVM をサスペンドせずに起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./gradlew quarkusDev -Dsuspend -Ddebug` which is a shorthand for `./gradlew quarkusDev -Dsuspend=true -Ddebug=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew quarkusDev -Dsuspend -Ddebug`  を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます。 `./gradlew quarkusDev -Dsuspend=true -Ddebug=true` の短縮版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#project-creation[プロジェクトを生成] したら、お気に入りのIDEでインポートすることができます。唯一の条件は、Gradleプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Gradle -&gt; Existing Gradle Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Gradle → Existing Gradle Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish`  をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./gradlew quarkusDev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末で `./gradlew quarkusDev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Gradle`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Import project from external model`  を選択して `Gradle`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末または埋め込み端末で、 `./gradlew quarkusDev`  を実行してください。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on `Open Project`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Open Project` をクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./gradlew quarkusDev`  を実行します。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VS Codeでプロジェクトディレクトリーを開きます。Java Extension Pack(Javaエクステンションのセットをグループ化したもの)をインストールしている場合、プロジェクトはGradleプロジェクトとして読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executables make Quarkus applications ideal for containers and serverless workloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルにより、Quarkusアプリケーションはコンテナーやサーバーレスのワークロードに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(必ずGraalVMのJava 11バージョンを使用してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./gradlew build -Dquarkus.package.type=native`.  A native executable will be present in `build/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew build -Dquarkus.package.type=native` を実行し、ネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `build/` に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `buildNative` task has been deprecated in favor of `build -Dquarkus.package.type=native`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`buildNative` タスクは非推奨となり、 `build -Dquarkus.package.type=native` に代わりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native related properties can either be added in `application.properties` file, as command line arguments or in the `quarkusBuild` task.  Configuring the `quarkusBuild` task can be done as following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ関連のプロパティーは、 `application.properties`  ファイルにコマンドライン引数として追加するか、 `quarkusBuild`  タスクに追加することができます。 `quarkusBuild`  タスクの設定は以下のように行います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using the Gradle Kotlin DSL:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、Gradle Kotlin DSLを使用している場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.containerBuild` property to `true`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.containerBuild`  プロパティーを `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.buildImage` property to `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.buildImage`  プロパティーを `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the Gradle Groovy DSL, property keys must follow lower camel case notation.  e.g. `container-build` is not valid, and should be replaced by `containerBuild`.  This limitation does not apply to the Gradle Kotlin DSL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle Groovy DSL を使用する場合、プロパティーキーは小文字のキャメルケース表記に従わなければなりません。例: `container-build` は無効なので、 `containerBuild` で置き換えてください。この制限は Gradle Kotlin DSL には適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build a container friendly executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーフレンドリーな実行ファイルをビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable will be specific to your operating system.  To create an executable that will run in a container, use the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルは、お使いのオペレーティングシステムに固有のものになります。コンテナー内で実行される実行ファイルを作成するには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a Docker container.  Note that in this case the build itself runs in a Docker container too, so you don't need to have GraalVM installed locally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成される実行ファイルは64bitのLinux実行ファイルになるので、OSによっては実行できなくなる可能性があります。しかし、Dockerコンテナーにコピーするので問題ありません。この場合、ビルド自体もDockerコンテナー内で動作するので、ローカルにGraalVMをインストールする必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the native executable will be generated using the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` Docker image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`  Dockerイメージを使用してネイティブ実行ファイルが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build a native executable with a different Docker image (for instance to use a different GraalVM version), use the `-Dquarkus.native.builder-image=&lt;image name&gt;` build argument.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるDockerイメージでネイティブ実行ファイルをビルドしたい場合(例えば、異なるGraalVMのバージョンを使用するなど)、 `-Dquarkus.native.builder-image=&lt;image name&gt;` のbuild引数を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of the available Docker images can be found on https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io].  Be aware that a given Quarkus version might not be compatible with all the images available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なDockerイメージのリストは、 link:https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io]にあります。特定のQuarkusのバージョンは、利用可能なすべてのイメージと互換性がない場合があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running native tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブテストの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the native tests using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のようにネイティブテストを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This task depends on `quarkusBuild`, so it will generate the native image before running the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このタスクは `quarkusBuild`  に依存しているので、テストを実行する前にネイティブイメージを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle plugin supports the generation of Uber-Jars by specifying a `quarkus.package.type` argument as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradleプラグインは、以下のように `--uber-jar`  引数を指定して UberJar の生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `--ignored-entry` argument:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>UberJar を作成する際に、 `--ignored-entry`  引数を使用して生成された jar から除外したいエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entries are relative to the root of the generated Uber-Jar. You can specify multiple entries by adding extra `--ignored-entry` arguments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エントリーは、生成された Uber-Jar のルートからの相対的なものです。追加の `--ignored-entry`  引数を追加することで、複数のエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using fast-jar</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>fast-jar の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When configuring `quarkus.package.type=fast-jar` (which will become the default soon) in `application.properties` (or any of the other supporting configuration sources), then the result of executing `./gradlew build` is a new directory under `build` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` (または他のサポートしている設定ソース) で `quarkus.package.type=fast-jar` (もうすぐデフォルトになります) を設定する場合、 `./gradlew build` を実行した結果、 `build` 以下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行するには、次のようにします: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to successfully run the produced jar, you need to have the entire contents of the `quarkus-app` directory. If any of the files are missing, the application will not start or might not function correctly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された jar を正常に実行するためには、 `quarkus-app` ディレクトリのすべての内容が必要です。いずれかのファイルが欠落していると、アプリケーションが起動しなかったり、正しく機能しない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `fast-jar` packaging results in creating an artifact that starts a little faster and consumes slightly less memory than a legacy Quarkus jar because it has indexed information about which dependency jar contains classes and resources. It can thus avoid the lookup into potentially every jar on the classpath that the legacy jar necessitates, when loading a class or resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`fast-jar` パッケージングでは、どの依存関係のjarにクラスやリソースが含まれているかという情報がインデックス化されているため、レガシーのQuarkus jarよりも起動が少し速く、メモリ消費量もわずかに少ないアーティファクトを作成できます。このため、クラスやリソースをロードする際に、レガシー jar が必要とするクラスパス上のすべての jar を検索する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module projects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトでの作業</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus will not discover CDI beans inside another module.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは別のモジュール内のCDI Bean を検出しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include a `META-INF/beans.xml` file, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトのモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されていない限り、`META-INF/beans.xml`  ファイルをインクルードすることです。モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されている場合は、自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, there is some unofficial link:https://plugins.gradle.org/search?term=jandex[Gradle Jandex plugins] that can be used instead of the `META-INF/beans.xml` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、 `META-INF/beans.xml` ファイルの代わりに使える非公式の link:https://plugins.gradle.org/search?term=jandex[Gradle Jandex プラグイン] もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on this topic can be found on the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このトピックの詳細については、CDIガイドの link:cdi-reference#bean_discovery[Bean Discovery]セクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with `./gradlew build`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew build` によるビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from 1.1.0.Final, `./gradlew build` will no longer build the native image. Add `-Dquarkus.package.type=native` build argument explicitly as explained above if needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.1.1.0.Final から、 `./gradlew build`  はネイティブイメージをビルドしなくなりました。必要であれば、上記で説明したように `-Dquarkus.package.type=native`  のビルド引数を明示的に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events).  It is also usable as a standalone service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqyは、Quarkusのサーバーレス戦略の一環で、AWS Lambda、Azure Functions、Knative、Knative Events（クラウドイベント）など、様々なFaaS環境にデプロイ可能な関数を書くためのポータブルなJava APIを提供することを目的としています。スタンドアロンサービスとしても利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Funqy is an abstraction that spans multiple different cloud/function providers and protocols it has to be a very simple API and thus, might not have all the features you are used to in other remoting abstractions.  A nice side effect though is that Funqy is as optimized and as small as possible.  This means that because Funqy sacrifices a little bit on flexibility, you'll get a framework that has little to no overhead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy は複数の異なるクラウド/ファンクションプロバイダやプロトコルにまたがる抽象化なので、非常にシンプルな API でなければならず、あなたが使い慣れている他のリモーティング抽象化で提供される機能をすべて備えているわけではないかもしれません。しかし、良い副作用として、Funqyは可能な限り最適化されていて小さいということがあります。つまり、Funqy は柔軟性を少し犠牲にしているので、オーバーヘッドがほとんどないフレームワークを手に入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter and may or may not return a response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy API はシンプルです。メソッドに `@Funq` をアノテーションします。このメソッドはオプションの入力パラメータを1つだけ持つことができ、レスポンスを返すこともあれば返さないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java classes can also be used as input and output and must follow the Java bean convention and have a default constructor.  The Java type that is declared as the parameter or return type is the type that will be expected by the Funqy runtime.  Funqy does type introspection at build time to speed up boot time, so any derived types will not be noticed by the Funqy marshalling layer at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javaクラスは入力と出力としても使用でき、Java Bean の規約に従う必要があり、デフォルトのコンストラクタを持たなければなりません。パラメータや戻り値の型として宣言されたJavaの型は、Funqyのランタイムが期待する型です。Funqyは起動時間を短縮するためにビルド時に型のイントロスペクションを行いますので、派生型は実行時にFunqyのマーシャリング層に意識されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's an example of using a POJO as input and output types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>POJO を入出力タイプとして使用した例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Async Reactive Types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期リアクティブ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy supports the https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` reactive type as a return type.  The only requirement is that the `Uni` must fill out the generic type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqyは戻り値の型として link:https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` リアクティブ型をサポートしています。唯一の要件は、 `Uni` がジェネリック型を保持しなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function name defaults to the method name and is case sensitive.  If you want your function referenced by a different name, parameterize the `@Funq` annotation as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数名の既定値はメソッド名で、大文字と小文字を区別します。関数を別の名前で参照したい場合は、 `@Funq` アノテーションを次のようにパラメータ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy DI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy DI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Funqy Java class is a Quarkus Arc component and supports dependency injection through CDI or Spring DI.  Spring DI requires including the `quarkus-spring-di` dependency in your build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各Funqy JavaクラスはQuarkus Arcコンポーネントであり、CDIまたはSpring DIによる依存性注入をサポートしています。Spring DIでは、ビルドに `quarkus-spring-di` 依存関係を含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default object lifecycle for a Funqy class is `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy クラスのデフォルトのオブジェクトライフサイクルは `@Dependent` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy API will usually not allow you to inject or use abstractions that are specific to a protocol (i.e. HTTP) or function API (i.e. AWS Lambda).  There are exceptions to the rule though and you may be able to inject contextual information that is specific to the environment you are deploying in.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy APIは通常、プロトコル(例:HTTP)や関数API(例:AWS Lambda)に固有の抽象化を注入したり使用したりすることはできません。しかし、ルールには例外があり、デプロイしている環境に固有のコンテキスト情報を注入できるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムに固有のコンテキスト情報を注入することはお勧めしません。 Function を移植性の高いものにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contextual information is injected via the `@Context` annotation which can be used on a function parameter or a class field.  A good example is the `CloudEvent` interface that comes with our Funqy Knative Cloud Events integration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト情報は `@Context` アノテーションを介して注入され、関数パラメータやクラスフィールドで使用することができます。良い例としては、Funqy Knative Cloud Events 統合に付属する `CloudEvent` インターフェイスがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Should I Use Funqy?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy を使うべきか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST over HTTP has become a very common way to write services over the past decade.  While Funqy
has an HTTP binding it is not a replacement for REST.  Because Funqy has to work across a variety
of protocols and function cloud platforms, it is very minimalistic and constrained.  For example, if you
use Funqy you lose the ability to link (think URIs) to the data your functions spit out.  You also
lose the ability to leverage cool HTTP features like `cache-control` and conditional GETs.  Many
developers will be ok with that as many won't be using these REST/HTTP features or styles. You'll
have to make the decision on what camp you are in.  Quarkus does support REST integration (through JAX-RS,
 Spring MVC, Vert.x Web, and Servlet) with
various cloud/function providers, but there are some disadvantages of using that approach as well.  For example,
if you want to do link:amazon-lambda-http[HTTP with AWS Lambda], this requires you to use the AWS API Gateway which may
slow down deployment and cold start time or even cost you more.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP 上の REST は過去 10 年間でサービスを書くための非常に一般的な方法になりました。FunqyはHTTPバインディングを持っていますが、RESTの代替ではありません。Funqyは様々なプロトコルと機能を持つクラウドプラットフォームで動作しなければならないため、非常にミニマムで制約があります。例えば、Funqyを使うと、関数が吐き出すデータにリンクする機能（URIを考えてください）を失うことになります。また、 `cache-control` や条件付き GET のようなクールな HTTP 機能を利用する機能も失います。多くの開発者はこれらの REST/HTTP 機能やスタイルを使用しないので、多くの開発者はこれで大丈夫でしょう。自分がどちらの立場にいるのかを判断する必要があります。Quarkusは、さまざまなクラウドプロバイダーや機能プロバイダーとのREST統合（JAX-RS、Spring MVC、Vert.x Web、Servletを介して）をサポートしていますが、このアプローチを使用することにもいくつかのデメリットがあります。例えば、 link:amazon-lambda-http[AWS LambdaでHTTPを] 行いたい場合、AWS API Gatewayを使用する必要があり、デプロイやコールドスタート時間が遅くなったり、コストが高くなったりする可能性があります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of Funqy is to allow you to write cross-provider functions so that you can move off of your current function provider if, for instance, they start charging you a lot more for their service.  Another reason you might not want to use Funqy is if you need access specific APIs of the target function environment.  For example, developers often want access to the AWS Context on Lambda.  In this case, we tell them they may be better off using the link:amazon-lambda[Quarkus Amazon Lambda] integration instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqyの目的は、クロスプロバイダの関数を書けるようにすることで、例えば、現在の Function プロバイダがサービスの料金を高くし始めた場合に、現在の Function プロバイダから離れることができるようにすることです。Funqyを使わないもう一つの理由は、ターゲットの Function 環境の特定のAPIにアクセスする必要がある場合です。例えば、開発者はLambda上のAWSコンテキストにアクセスしたいことがよくあります。この場合、代わりに link:amazon-lambda[Quarkus Amazon Lambda] インテグレーションを使った方が良いかもしれないと伝えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can use https://tika.apache.org/[Apache Tika] to parse the documents.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが link:https://tika.apache.org/[Apache Tika] を使用してドキュメントを解析する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tika.apache.org/[Apache Tika] is a content analysis toolkit which is used to parse the documents in PDF, Open Document, Excel and many other well known binary and text formats using a simple uniform API. Both the document text and properties (metadata) are available once the document has been parsed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://tika.apache.org/[Apache Tika] はコンテンツ分析ツールキットで、シンプルな統合 API を使した PDF、Open Document、Excel やその他多くのよく知られたバイナリーやテキスト形式の文書解析に使われます。文書のテキストとプロパティー (メタデータ) の両方が、文書が解析されると利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided solution contains a few additional elements such as tests and testing infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されるソリューションには、テストやテストのインフラストラクチャなど、いくつかの追加要素が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `tika` and `resteasy` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、`tika` と `resteasy` のエクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured you can add the `tika` and `resteasy` extensions to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで、次のコマンドを実行することで、 `tika` と `resteasy` のエクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the generated JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたJAX-RS リソースを調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/tika/TikaParserResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/tika/TikaParserResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.tika;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.tika;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next update `TikaParserResource` to accept and parse PDF and OpenDocument format documents:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に `TikaParserResource` を更新して、PDF および OpenDocument 形式の文書を受け入れて解析するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        return text;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        return text;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see the JAX-RS resource method was renamed to `extractText`, `@GET` annotation was replaced with `POST` and `@Path(/text)` annotation was added, and `@Consumes` annotation shows that PDF and OpenDocument media type formats can now be accepted. An injected `TikaParser` is used to parse the documents and report the extracted text. It also measures how long does it take to parse a given document.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、JAX-RS のリソースメソッドの名前が `extractText` に変更され、`@GET` アノテーションが `POST` に置き換わり、`@Path(/text)` アノテーションが追加されました。また、`@Consumes` アノテーションでは、PDF と OpenDocument のメディアタイプのフォーマットが受け入れられるようになったことが示されています。注入された `TikaParser` は、文書を解析し、抽出されたテキストを報告するために使用されます。また、指定の文書の解析に要する時間を測定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. Use:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、アプリケーションを実行する準備が整いました。以下を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and you should see output similar to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のような出力が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus:dev Output</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus:dev 出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ ./mvnw clean compile quarkus:dev
[INFO] Scanning for projects...
[INFO]
INFO] --------------------&lt; org.acme.example:apache-tika &gt;--------------------
[INFO] Building apache-tika 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
Listening for transport dt_socket at address: 5005
2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running without servlet container.
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-undertow to run Resteasy within a servlet container
2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 549ms
2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 1.361s. Listening on: http://0.0.0.0:8080
2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, tika]
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ ./mvnw clean compile quarkus:dev
[INFO] Scanning for projects...
[INFO]
INFO] --------------------&lt; org.acme.example:apache-tika &gt;--------------------
[INFO] Building apache-tika 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
Listening for transport dt_socket at address: 5005
2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running without servlet container.
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-undertow to run Resteasy within a servlet container
2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 549ms
2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 1.361s. Listening on: http://0.0.0.0:8080
2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, tika]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the REST endpoint is running, we can get it to parse PDF and OpenDocument documents using a command line tool like curl:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使用して PDF や OpenDocument ドキュメントを解析することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.  Running it is as simple as executing `./target/tika-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常のコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドできます。`./target/tika-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC and Mutual TLS authentication as well as the proactive authentication.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、HTTPベースのFORM認証、BASIC認証、相互TLS認証、およびプロアクティブ認証のためのQuarkusの組み込み認証メカニズムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベーシック認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable basic authentication set `quarkus.http.auth.basic=true`. You must also have at least one extension installed that provides a username/password based `IdentityProvider`, such as link:security-jdbc[Elytron JDBC].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベーシック認証を有効にするには、 `quarkus.http.auth.basic=true` を設定します。また、ユーザー名/パスワードベースの `IdentityProvider` を提供するエクステンションを少なくとも 1 つインストールしておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security#identity-providers[Security Identity Providers] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security#identity-providers[セキュリティー ID プロバイダ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see link:security-testing#configuring-user-information[Configuring User Information in application.properties] section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:security-testing#configuring-user-information[application.propertiesでユーザー情報の設定]セクションも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Form Based Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォームベース認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、従来のサーブレットのフォームベースの認証と同様の方法で動作するフォームベースの認証を提供します。従来のフォーム認証とは異なり、Quarkusはクラスター化されたHTTPセッションをサポートしていないため、認証されたユーザーはHTTPセッションに保存されません。代わりに、認証情報は暗号化されたCookieに保存され、クラスターのすべてのメンバーが読み取ることができます(すべてのメンバーが同じ暗号化キーを共有している場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>暗号化キーは `quarkus.http.auth.session.encryption-key` プロパティーを使って設定でき、少なくとも 16 文字の長さでなければなりません。このキーは SHA-256 を使ってハッシュ化され、その結果のダイジェストがクッキー値の AES-256 暗号化のキーとして使用されます。このクッキーは暗号化された値の一部として有効期限を含んでいますので、クラスター内のすべての ノードはクロックを同期させなければなりません。1 分間隔で、セッションが使用中であれば、更新された有効期限時間を持つ新しいクッキーが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to configure form based auth:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のプロパティーを使用して、フォームベース認証を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはmTLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this authentication method, you should first enable SSL for your application. For more details, check the link:http-reference#ssl[Supporting secure connections with SSL] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この認証方法を利用するには、まずアプリケーションでSSLを有効にする必要があります。詳細については、 link:http-reference#ssl[SSLによるセキュアな接続のサポート]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが安全な接続を受け入れたら、次のステップは、アプリケーションが信頼すべきすべての証明書を保持する `quarkus.http.ssl.certificate.trust-store-file` を設定し、クライアント(例: ブラウザや他のサービス)が保護されたリソースにアクセスしようとしたときに、アプリケーションがどのように証明書を要求するかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a key store where the server's private key is located.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバーの秘密鍵が置かれている鍵ストアを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a trust store from where the trusted certificates are going to be loaded from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>信頼された証明書がロードされるトラストストアを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバーが *常に*クライアントからの証明書を要求することを定義します。 `REQUEST` を使用することで、この動作を緩和することができます。mTLS 以外の認証方法もサポートしている場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines a policy where only authenticated users should have access to resources from your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証されたユーザーのみがアプリケーションからリソースにアクセスできるようにするポリシーを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したリクエストがトラストストアの有効な証明書と一致したら、アプリケーションは以下のように `SecurityIdentity` を注入するだけでサブジェクトを取得できるようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the subject</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>subjectの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should also be able to get the certificate as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下のように証明書を取得できるようにしておきましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the certificate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>証明書の取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, etc.  Please see the link:security-customization#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアント証明書からの情報は、Quarkus `SecurityIdentity` を強化するために使用することができます 。たとえば、クライアント証明書のサブジェクト名などを確認した後に、新しいロールを追加することができます。Quarkus `SecurityIdentity` のカスタマイズの詳細については、 link:security-customization#security-identity-customization[SecurityIdentity]のカスタマイズのセクションを参照してください 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます(ターゲットページが認証を必要としない場合でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、公開ページであっても、無効なクレデンシャルを持つリクエストは常に拒否されることを意味します。この動作を変更して、 `quarkus.http.auth.proactive=false` を設定することで必要な場合のみ認証を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional blocking code uses link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`]
 variables to store contextual objects in order to avoid
passing them as parameters everywhere. Many Quarkus extensions require those contextual objects to operate
properly: link:rest-json[RESTEasy], link:cdi-reference[ArC] and link:transaction[Transaction]
for example.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>従来のブロッキングコードでは  link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`] 変数を使用してコンテキストオブジェクトを格納します。多くのQuarkusエクステンションは、適切に動作するためにこれらのコンテキストオブジェクトを必要とします。例えば、 link:rest-json[RESTEasy]、 link:cdi-reference[ArC]、 link:transaction[Transaction]などです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you write reactive/async code, you have to cut your work into a pipeline of code blocks that get executed "later", and in practice after the method you defined them in have returned. As such, `try/finally` blocks as well as `ThreadLocal` variables stop working, because your reactive code gets executed in another thread, after the caller ran its `finally` block.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ/非同期コードを書く場合、「後で」実行されるコードブロックのパイプラインに作業を切り 込まなければならず、実際には、定義したメソッドがreturnされた後に実行されます。そのため、 `try/finally` ブロックや `ThreadLocal` 変数は動作しなくなります。なぜならば、呼び出し元が `finally` ブロックを実行した後に、 リアクティブコードは別のスレッドで実行されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] was made to make those Quarkus extensions work properly in reactive/async settings. It works by capturing those contextual values that used to be in thread-locals, and restoring them when your code is called.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] は、リアクティブ/非同期設定でQuarkusエクステンションが正しく動作するようにするために作られました。これは、スレッドローカルにあったコンテキスト値を取得し、コードが呼び出されたときにそれらを復元することで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:http://smallrye.io/smallrye-mutiny[Mutiny] (the `quarkus-mutiny` extension), you just need to add the the `quarkus-smallrye-context-propagation` extension to enable context propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://smallrye.io/smallrye-mutiny[Mutiny] ( `quarkus-mutiny` のエクステンション) を使用している場合は、コンテキストの伝播を有効にするために `quarkus-smallrye-context-propagation` のエクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, add the following dependencies to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、以下の依存関係を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, you will get context propagation for ArC, RESTEasy and transactions, if you are using them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、ArC、RESTEasy、トランザクションを使用している場合は、コンテキストの伝播を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションでは、Mutinyのリアクティブタイプ を使用しています。慣れていない場合は、 link:getting-started-reactive#mutiny[Getting Started with Reactive guide] を先にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a REST endpoint that reads the next 3 items from a link:kafka[Kafka topic], stores them in a database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client, you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:kafka[Kafkaトピック] から次の3つのアイテムを読み込んで、 link:hibernate-orm-panache[Hibernate ORM with Panache] を使ってデータベースに保存してからクライアントに返すRESTエンドポイントを書いてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that thanks to Mutiny support for context propagation, this works out of the box.  The 3 items are persisted using the same transaction and this transaction is committed when the stream completes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキストの伝播のための Mutiny サポートのおかげで、これは、そのまま直ぐに動作することに注目してください。3つのアイテムは同じトランザクションを使用して保持され、このトランザクションはストリームが完了するとコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage example for `CompletionStage`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` の使用例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`] you need manual context propagation. You can do that by injecting a `ThreadContext` or `ManagedExecutor` that will propagate every context. For example, here we use the link:vertx[Vert.x Web Client] to get the list of Star Wars people, then store them in the database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client as JSON using link:rest-json[Jackson or JSON-B]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`]を使用する場合、手動でコンテキストを伝播させる必要があります。 `ThreadContext` や `ManagedExecutor` を注入することで、すべてのコンテキストを伝播させることができます。例えば、ここでは link:vertx[Vert.x Web Client] を使用してスターウォーズの登場人物のリストを取得し、 link:hibernate-orm-panache[Hibernate ORM with Panache を]使用して(全て同じトランザクション内で) データベースに保存します。その後、 link:rest-json[Jackson または JSON-B] を使用して JSON としてクライアントに返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `ThreadContext` or `ManagedExecutor` you can wrap most useful functional types and `CompletionStage` in order to get context propagated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ThreadContext` または `ManagedExecutor` を使用することで、ほとんどの有用な関数型と `CompletionStage` をラップしてコンテキストを伝播させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected `ManagedExecutor` uses the Quarkus thread pool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注入された `ManagedExecutor` は、Quarkus のスレッドプールを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In terms of CDI, `@RequestScoped`, `@ApplicationScoped` and `@Singleton` beans get propagated and are available in other threads.  `@Dependent` beans as well as any custom scoped beans cannot be automatically propagated via CDI Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI の観点からは、 `@RequestScoped`, `@ApplicationScoped`, `@Singleton` Beanは伝播され、他のスレッドで利用可能です。 `@Dependent` ビーンやカスタムスコープされたビーンは、CDI コンテキスト伝播を介して自動的に伝播されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` and `@Singleton` beans are always active scopes and as such are easy to deal with - context propagation tasks can work with those beans so long as the CDI container is running.  However, `@RequestScoped` beans are a different story. They are only active for a short period of time which can be bound either to HTTP request or some other request/task when manually activated/deactivated.  In this case user must be aware that once the original thread gets to an end of a request, it will terminate the context, calling `@PreDestroy` on those beans and then clearing them from the context.  Subsequent attempts to access those beans from other threads can result in unexpected behaviour.  It is therefore recommended to make sure all tasks using request scoped beans via context propagation are performed in such a manner that they don't outlive the original request duration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ApplicationScoped` と `@Singleton` のBeanは常にアクティブなスコープであり、そのため対処が簡単です - コンテキスト伝播タスクは、CDI コンテナーが動作している限り、これらのBeanで動作します。しかし、 `@RequestScoped` Beanは話が違います。手動で有効化/無効化すると、HTTP リクエストや他のリクエスト/タスクにバインドされます。この場合、元のスレッドがリクエストの終了に到達すると、コンテキストを終了し、それらのBeanで `@PreDestroy` を呼び出し、コンテキストからクリアされることに注意しなければなりません。その後、他のスレッドからこれらのBeanにアクセスしようとすると、予期せぬ動作をすることがあります。したがって、コンテキストの伝播を介してリクエストスコープされたBeanを使用するすべてのタスクは、元のリクエストの持続時間を超えないような方法で実行されることを確認することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the above described behavior, it is recommended to avoid using `@PreDestroy` on `@RequestScoped` beans when working with Context Propagation in CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記で説明した動作のため、CDI で Context Propagation を使用する際には `@PreDestroy` を `@RequestScoped` Beanで使用しないことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an elastically scalable in-memory data store that you can embed directly in your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanは、アプリケーションに直接埋め込むことができる拡張性の高いインメモリーデータストアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://infinispan.org/documentation/[Infinispan documentation] to find out more about the Infinispan project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanプロジェクトの詳細については、Infinispanの link:https://infinispan.org/documentation/[ドキュメント] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command adds the following dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、以下の依存関係を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feature Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>機能サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension offers core caching functionality that includes clustered caches, off-heap memory, data persistence, and transactions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションは、クラスター化キャッシュ、オフヒープメモリー、データ永続化、トランザクションを含むコアキャッシング機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension does not currently support indexing capabilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションは、現在のところインデックス機能をサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Infinispan caches for transactional operations with a specific `TransactionManagerLookup`, as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan キャッシュを特定の `TransactionManagerLookup` でトランザクション処理用に設定するには、以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, see the Quarkus link:transaction[Transaction Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、Quarkus link:transaction[トランザクションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Limitations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブの制限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running Infinispan in native mode, some limitations apply:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードでInfinispanを実行する場合、いくつかの制限が適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX management is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JMX管理には対応していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM does not allow native VM interfaces.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMは、ネイティブVMインターフェースを許可していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`UDP`/`Multicast` is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`UDP` / `Multicast` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must use `TCP` transport and a non-UDP based membership protocol with JGroups.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JGroupsでは、 `TCP` トランスポートと非UDPベースのメンバーシッププロトコルを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection (CDI)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクション(CDI)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension provides injection capabilities so you do not have to configure and start caches manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションはインジェクション機能を提供するので、手動でキャッシュを設定して起動する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional injection functionality will be available in future versions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のインジェクション機能は、将来のバージョンで利用可能になる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the main entry point to configure and obtain caches.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュを設定したり取得したりするためのメインのエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX elements are disabled during native runtime so you can use the same configuration file in JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JMX要素はネイティブ実行時には無効化されるので、JVMとネイティブモードで同じ設定ファイルを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native compilation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable fails on macOS with `error: unknown type name 'uint8_t'`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS でのネイティブ実行ファイルが `error: unknown type name 'uint8_t'` で失敗する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your macOS has the wrong `*.h` files compared to the OS and no gcc compilation will work.  This can happen when you migrate from versions of the OS.  See https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お使いの macOS には、その OS とは異なる `*.h` ファイルがあるため、gcc コンパイルが動作しません。この問題は、その OS の別のバージョンから移行したときに起こる可能性があります。 https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is to</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>解決策は、以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reinstall XCode for good measure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>念のため Xcode を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>generally reinstall your brew dependencies with native compilation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常は、ネイティブコンパイルで brew の依存関係を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable should work now.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、実行ファイルが動作するようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started-architecture.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>getting-started-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動したら、提供されたエンドポイントにリクエストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`curl -w "\n"` で自動的に改行を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例では、 `curl -w "\n"` を使用して、結果と次のコマンドプロンプトが同じ行に表示されるのを防止しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ArCは `quarkus-resteasy` の依存関係として提供されているので、すでに追加済です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a key/value pair as an environment variable in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースに環境変数としてキーとバリューのペアを追加する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command above will add `MY_ENV_VAR=foobar` as an environment variable.  Please note that the key `my-env-var` will be converted to uppercase and dashes will be replaced by underscores resulting in `MY_ENV_VAR`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコマンドは `MY_ENV_VAR=foobar` を環境変数として追加します。キー `my-env-var` は大文字に変換され、ダッシュはアンダースコアに置き換えられて `MY_ENV_VAR` となることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from Secret</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mounting volumes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ボリュームのマウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret volumes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットのボリューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides extensions for building (and pushing) container images. Currently it supports:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、コンテナーイメージを構築 (およびプッシュ) するためのエクステンションを提供しています。現在は以下をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jib</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-jib` is powered by https://github.com/GoogleContainerTools/jib[Jib] for performing container image builds.  The major benefit of using Jib with Quarkus is that all the dependencies (everything found under `target/lib`) are cached in a different layer than the actual application making rebuilds really fast and small (when it comes to pushing).  Another important benefit of using this extension is that it provides the ability to create a container image without having to have any dedicated client side tooling (like Docker) or running daemon processes (like the Docker daemon)  when all that is needed is the ability to push to a container image registry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-jib` は、コンテナーイメージのビルドを実行するために link:https://github.com/GoogleContainerTools/jib[Jib] を使用しています。Jib を Quarkus で使用する主な利点は、すべての依存関係 (`target/lib` の下にあるすべてのもの) が実際のアプリケーションとは別のレイヤーにキャッシュされるため、リビルドが非常に高速かつ小規模に (プッシュする場合) 行えることです。このエクステンションを使用するもう 1 つの重要な利点は、コンテナーイメージレジストリーにプッシュする機能さえあれば、専用のクライアントサイドツール (Docker など) やデーモンプロセス (Docker デーモンなど) を実行しなくてもコンテナーイーメージを作成できることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In situations where all that is needed to build a container image and no push to a registry is necessary (essentially by having set `quarkus.container-image.build=true` and left `quarkus.container-image.push` unset - it defaults to `false`), then this extension creates a container image and registers it with the Docker daemon. This means that although Docker isn't used to build the image, it is nevertheless necessary. Also note that using this mode, the built container image *will* show up when executing `docker images`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要なことがコンテナーイメージを構築するだけで、レジストリーへのプッシュが不要な場合 (基本的には `quarkus.container-image.build=true` を設定して `quarkus.container-image.push` のままにしておくことで、デフォルトは `false` になります)、このエクステンションはコンテナーイメージを作成し、Docker デーモンに登録します。これは、Docker がイメージのビルドには使われなくても必要であることを意味します。また、このモードを使用すると、`docker images` を実行するとコンテナーイメージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including extra files</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加ファイルの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases when additional files (other than ones produced by the Quarkus build) need to be added to a container image.  To support these cases, Quarkus copies any file under `src/main/jib` into the built container image (which is essentially the same idea that the Jib Maven and Gradle plugins support).  For example, the presence of `src/main/jib/foo/bar` would result in `/foo/bar` being added into the container filesystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージに追加のファイル(Quarkus のビルドで作成されたもの以外)を追加する必要がある場合があります。このような場合に対応するため、Quarkus は、`src/main/jib` 以下のファイルをすべてビルドされたコンテナーイメージにコピーします (これは、Jib Maven や Gradle プラグインがサポートしているのと基本的に同じ考え方です)。例えば、`src/main/jib/foo/bar` が存在すると、`/foo/bar` がコンテナファイルシステムに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-docker` is using the Docker binary and the generated Dockerfiles under `src/main/docker` in order to perform Docker builds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-docker` は、Docker ビルドを実行するために `src/main/docker` 下で Docker バイナリーと生成された Dockerfiles を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-s2i` is using S2I binary builds in order to perform container builds inside the OpenShift cluster.  The idea behind the binary build is that you just upload the artifact and its dependencies to the cluster and during the build they will be merged to a builder image (defaults to `fabric8/s2i-java`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-s2i` は、OpenShift クラスター内でコンテナービルドを実行するために S2I バイナリービルドを使用しています。バイナリービルドの考え方は、アーティファクトとその依存関係をクラスタにアップロードするだけで、ビルド中にそれらがビルダーイメージにマージされます (デフォルトは `fabric8/s2i-java`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The benefit of this approach, is that it can be combined with OpenShift's `DeploymentConfig` that makes it easy to roll out changes to the cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチの利点は、クラスターへの変更を簡単にロールアウトできる OpenShift の `DeploymentConfig` と組み合わせることができることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I builds require creating a `BuildConfig` and two `ImageStream` resources, one for the builder image and one for the output image.  The creation of such objects is being taken care of by the Quarkus Kubernetes extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S2I のビルドでは、`BuildConfig` と 2 つの `ImageStream` リソースを作成する必要があります。このようなオブジェクトの作成は、Quarkus Kubernetes エクステンションによって行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build a container image for your project, `quarkus.container-image.build=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト用のコンテナーイメージを作成するには、Quarkus がサポートしている方法のいずれかで、 `quarkus.container-image.build=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pushing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To push a container image for your project, `quarkus.container-image.push=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトにコンテナーイメージをプッシュするには、Quarkus がサポートしている方法のいずれかで、`quarkus.container-image.push=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no registry is set (using `quarkus.container-image.registry`) then `docker.io` will be used as the default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーが設定されていない場合 (`quarkus.container-image.registry` を使用) は、 `docker.io` がデフォルトとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selecting among multiple extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のエクステンションから選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not make sense to use multiple extension as part of the same build. When multiple container image extensions are present, an error will be raised to inform the user. The user can either remove the uneeded extensions or select one using `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のエクステンションを同じビルドの一部として使用するのは意味がありません。複数のコンテナー-イメージエクステンションが存在する場合は、エラーが発生してユーザーに通知されます。ユーザーは不要なエクステンション削除するか、`application.properties` を使って選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if both `container-image-docker` and `container-image-s2i` are present and the user needs to use `container-image-docker`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、`container-image-docker` と `container-image-s2i` の両方が存在し、ユーザーが `container-image-docker` を使用する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to customize the container image build process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のプロパティーを使用して、コンテナーイメージのビルドプロセスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various CI environments provide a ready to use container-image registry which can be combined with the container-image Quarkus extensions in order to effortlessly create and push a Quarkus application to said registry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さまざまな CI 環境では、Quarkus アプリケーションを作成してレジストリーをプッシュするために、コンテナーイメージ Quarkus エクステンションと組み合わせることで、すぐに使えるコンテナーイメージレジストリ-を利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, https://gitlab.com/[GitLab] provides such a registry and in the provided CI environment, makes available the `CI_REGISTRY_IMAGE` environment variable (see GitLab's https://docs.gitlab.com/ee/ci/variables/[documentation]) for more information), which can be used in Quarkus like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 link:https://gitlab.com/[GitLab] はこのようなレジストリーを提供しており、提供されている CI 環境では、環境変数 `CI_REGISTRY_IMAGE` (詳しくは GitLab の link:https://docs.gitlab.com/ee/ci/variables/[ドキュメント] を参照) を利用できるようになっています。なお、Quarkus ではこのように利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:config.adoc#combine-property-env-var[this] for more information on how to combine properties with environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数とプロパティーを組み合わせる方法については link:config.adoc#combine-property-env-var[こちら] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-jib` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-jib` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-docker` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-docker` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I  Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S2I オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-s2i` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-s2i` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - JGit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - JGit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `jgit` extension which enables the use of https://www.eclipse.org/jgit/[Eclipse JGit] in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、ネイティブモードでの link:https://www.eclipse.org/jgit/[Eclipse JGit]の使用を可能にする `jgit` エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `jgit` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで次のコマンドを実行して、 `jgit` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://wiki.eclipse.org/JGit/User_Guide#API[JGit] dependency is resolved transitively when the extension is added to your project.  Here is an example using it in a JAX-RS endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://wiki.eclipse.org/JGit/User_Guide#API[JGit]依存関係は、エクステンションがプロジェクトに追加されたときに推移的に解決されます。ここでは、JAX-RS エンドポイントでの使用例を示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in native mode, make sure that the link:native-and-ssl#the-truststore-path[SSL access is configured correctly].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行する場合は、 link:native-and-ssl#the-truststore-path[SSLアクセスが正しく設定されていること]を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanは、アプリケーションプロセス以外のサーバーでの実行を可能にするメモリー内データグリッドです。このエクステンションは、Quarkusで実行しているときに、クライアントがサーバーに接続できるようにする機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをネイティブ実行ファイルにコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのコンテナーへのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、 link:getting-started[入門ガイド] で開発されたアプリケーションを入力としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブな実行可能ファイルをビルドするには、GraalVM のディストリビューションを使用する必要があります。ディストリビューションは3つあります。Oracle GraalVM Community Edition (CE)、Oracle GraalVM Enterprise Edition (EE)、そして Mandrel です。Oracle ディストリビューションと Mandrel ディストリビューションの違いは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは、Oracle GraalVM CEのダウンストリームディストリビューションです。Mandrelの主な目的は、Quarkusをサポートするために特別に設計されたネイティブ実行可能ファイルを構築する方法を提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrel のリリースは、アップストリームのOracle GraalVM CEコードベースから派生したコードベースから構築されており、わずかな変更しか行われていませんが、Quarkusネイティブアプリには必要ない重要な除外事項がいくつかあります。これらのリリースは、Oracle GraalVM CEと同じ機能をサポートしており、機能に大きな変更はありません。特筆すべきは、多言語プログラミングのサポートが含まれていないことです。これらの除外の理由は、大多数のQuarkusユーザーにより良いレベルのサポートを提供するためです。また、これらの除外は、Oracle GraalVM CE/EEと比較して、Mandrelの配布サイズが大幅に縮小されていることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは、標準のOpenJDKプロジェクトを使用して、Oracle GraalVM CEとは少し違った形で構築されています。これは、Oracleが独自のGraalVMダウンロードを構築するために使用するOpenJDKのバージョンに追加したいくつかの小さなエクステンションから利益を得られないことを意味します。アップストリームのOpenJDKはそれらを管理しておらず、保証することができないため、このような機能強化は省略されています。これは、規格適合性とセキュリティーに関しては特に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは現在のところ、Linuxのコンテナー化された環境をターゲットとしたネイティブ実行ファイルの構築にのみ推奨されています。つまり、Mandrelユーザーはコンテナーを使用してネイティブ実行ファイルを構築する必要があります。もしmacOSやWindowsをターゲットにしたプラットフォーム用のネイティブ実行ファイルをビルドする場合、Mandrelは現在これらのプラットフォームをターゲットにしていないため、代わりにOracle GraalVMを使用することを検討すべきです。ベアメタルのLinux上で直接ネイティブ実行ファイルをビルドすることも可能ですが、詳細は https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[rel README]と https://github.com/graalvm/mandrel/releases[Mandrelのリリース]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前提条件は、Oracle GraalVM CE/EEを使用しているか、Mandrelを使用しているかによって若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 バージョンのGraalVMをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Oracle GraalVM はJava 8とJava 11の両方に対して存在しますが (Mandrel はJava 11のみをサポート)、Quarkus Java 11でのみ動作します。Oracleのディストリビューションを使用する場合は、Java 11をインストールするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動作するコンテナーランタイム(Docker, podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:getting-started[入門ガイド]で開発したアプリケーションのコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この &lt;&lt;#container-runtime, セクション&gt;&gt;をスキップして、 Mandrel のガイドを続行し、そのセクションの Mandrel 固有の指示に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A xref:configuring-c-development[working C development environment]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>xref:configuring-c-development[動作するC言語の開発環境]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM のバージョン {graalvm-version} (必ずJava 11 のサポートをインストールしてください)がインストールされ、 #configuring-graalvm[適切に設定されていること]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動作するC言語の開発環境があるとはどういう意味でしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Linuxでは、GCC、glibc、zlibヘッダが必要です。一般的なディストリビューションでは次の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS では、XCode が必要な依存関係を提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windowsの場合は、 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools] をインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMをインストールできない場合は、マルチステージのDockerビルドを使用して、GraalVMを含むDockerコンテナー内でMavenを実行することができます。このガイドの最後にこれを行う方法の説明があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Version {graalvm-version} が必要です。コミュニティエディションで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだの場合は、GraalVM(のJava 11バージョン)をインストールしてください。いくつかポイントがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォーム固有の方法を用いてください: https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>適切なコミュニティエディションのアーカイブを &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; からダウンロードし、他のJDK同様に解凍して下さい。Java 11バージョンをダウンロードしてインストールするようにして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム環境を構成します。 `GRAALVM_HOME` 環境変数をGraalVMインストールディレクトリーに設定します。例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOSでは、変数を `Home`  サブディレクトリーに指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windowsでは、コントロールパネルから環境変数を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>scoop でインストールすれば自動的に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gu install`  を使用して `native-image`  ツールをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの以前のリリースでは、デフォルトで `native-image`  ツールが含まれていました。現在はそのようになっておらず、GraalVM自体をインストールした後の第二ステップとしてインストールする必要があります。注意: #graal-and-catalina[macOS CatalinaでGraalVMを使用する]際に、未解決の問題が発生しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(オプション) 環境変数 `JAVA_HOME`  を GraalVM のインストールディレクトリーに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(オプション) GraalVM `bin`  ディレクトリーをパスに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS CatalinaでGraalVMを使用している場合の問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この https://github.com/oracle/graal/issues/1724[GraalVMの問題]で報告されているように、GraalVMバイナリーは(まだ)macOS Catalinaに対して認証されていません。これは、`gu` 使用時に次のエラーが表示される可能性があることを意味します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>回避策として、次のコマンドを使用して、GraalVMインストールディレクトリー上の `com.apple.quarantine` 拡張属性を再帰的に削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のセクションの手順に従って、アプリケーションを段階的にパッケージ化することをお勧めします。しかしながら、完成したサンプルに直接進むこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started` ディレクトリーに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのネイティブ実行ファイルには、アプリケーション・コード、必要なライブラリ、Java API、および VM の縮小版が含まれます。VM ベースが小さくなることで、アプリケーションの起動時間が改善され、ディスクフットプリントが最小限に抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:native-executable-process.png[ネイティブ実行ファイルの生成]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前回のチュートリアルでアプリケーションを生成した場合は、 `pom.xml` に以下の _プロファイル_ があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`&lt;quarkus.native.additional-build-args&gt;` プロパティーを使用して、 `native-image` コマンドにカスタムオプションを指定できます。複数のオプションはカンマで区切ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つの可能性は、 `application.properties` に `quarkus.native.additional-build-args` 設定プロパティーを含めることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージビルド処理の設定方法については、以下の &lt;&lt;設定リファレンス&gt;&gt; の項で詳しく説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルを使用しているのは、すぐにわかると思いますが、ネイティブの実行ファイルをパッケージ化するのに _数_ 分かかるからです。コマンドラインのプロパティーとして -Dquarkus.package.type=native を渡すだけでもいいのですが、プロファイルを使う方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative`  を使用してネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Visual Studio の Microsoft Native Tools はパッケージングを行う前に、初期化する必要があります。これは、Visual Studio ビルドツールと一緒にインストールされた `x64 Native Tools Command Prompt`  を起動することで行うことができます。 `x64 Native Tools Command Prompt` で、プロジェクト・フォルダーに移動して `mvnw package -Pnative` を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つのソリューションは、これを行うためのスクリプトを書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常のファイルに加えて、このビルドでは `target/getting-started-1.0-SNAPSHOT-runner` を生成します。これを実行するには、次のようにします: `./target/getting-started-1.0-SNAPSHOT-runner` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブな実行ファイルを生成することはいくつかの問題を引き起こす可能性があるので、ネイティブファイルで実行されているアプリケーションに対していくつかのテストを実行するのも良いアイデアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml`  ファイルには、 `native`  プロファイルが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、failsaf-maven-plugin が integration-test を実行するように指示し、生成されたネイティブ実行ファイルの場所を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`  を開きます。次の内容が含まれています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの前にネイティブ ファイルからアプリケーションを起動する別のテスト ランナーを使用します。実行ファイルは、 _Failsafe Maven プラグイン_ で構成された `native.image.path`  システム プロパティーを使用して取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のテストを extend していますが、自分でテストを実装することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`NativeGreetingResourceIT`  がネイティブ実行ファイルに対して実行されているのを見るには、 `./mvnw verify -Pnative` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはネイティブテストを開始し、自動的に失敗するまでに60秒待機します。この時間は、 `quarkus.test.native-image-wait-time`  システムプロパティーを使用して変更できます。たとえば、待機時間を300秒に増やすには、 `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、ネイティブテストは `prod`  プロファイルを使用して実行されます。これは `quarkus.test.native-image-profile`  プロパティーを使用して上書きすることができます。たとえば、 `application.properties`  ファイルに `quarkus.test.native-image-profile=test`  を追加します。あるいは、次のようにしてテストを実行することもできます: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` .ただし、ネイティブの実行ファイルがビルドされたときに `prod`  プロファイルが有効になっていることを忘れないでください。したがって、この方法で有効にしたプロファイルは、生成された実行ファイルと互換性がなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルとして実行している場合のテストの除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法でテストを実行する場合、実際にネイティブで実行されるのはアプリケーションのエンドポイントのみで、HTTP 呼び出しでしかテストできません。テストコードは実際にはネイティブには実行されないので、HTTP エンドポイントを呼び出さないコードをテストしている場合は、ネイティブテストの一部として実行するのは良い考えではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のようにJVMとネイティブ実行でテストクラスを共有している場合、特定のテストをJVM上でのみ実行するために、 `@DisabledOnNativeImage`  アノテーションを付けておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにビルドされているネイティブ実行ファイルに対してテストを再実行することも可能です。これを行うには `./mvnw test-compile failsafe:integration-test`  を実行してください。これにより、既存のネイティブイメージが検出され、フェイルセーフを使用してそれに対してテストが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何らかの理由でプロセスがネイティブイメージを見つけられない場合や、ターゲットディレクトリーにないネイティブイメージをテストしたい場合は、 `-Dnative.image.path=`  システムプロパティーで実行ファイルを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先に進む前に、コンテナーランタイム(Docker、podman)の動作環境が整っていることを確認しておきましょう。WindowsでDockerを使用している場合は、Docker Desktopのファイル共有設定でプロジェクトのドライブを共有し、Docker Desktopを再起動する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの場合、Quarkusアプリケーション用のネイティブLinux実行ファイルを作成する必要があります(例えば、コンテナー化された環境で実行するためなど)、このタスクを達成するために適切なGraalVMバージョンをインストールする手間を省きたいと考えています(例えば、CI環境では、できるだけ少ないソフトウェアをインストールするのが一般的です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このため、Quarkusでは、Dockerやpodmanなどのコンテナーランタイムを利用して、ネイティブのLinux実行ファイルを作成する非常に便利な方法を提供しています。このタスクを達成する最も簡単な方法は、次を実行することです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはコンテナーランタイムを自動的に検出します。コンテナーランタイムを明示的に選択したい場合は、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは通常のQuarkusの設定プロパティーなので、常にコンテナーでビルドしたい場合は、毎回指定しなくて済むように、 `application.properties`  に追加することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドはフローティングタグを指していることに注意してください。ビルダーイメージを最新かつ安全に保つために、フローティングタグを使用することを強く推奨します。どうしても必要な場合は、特定のタグをハードコーディングしても構いませんが(利用可能なタグについては https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[こちら]を参照してください)、その方法ではセキュリティーアップデートが受けられず、サポートされていないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージのエクステンションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションからコンテナーイメージを作成する最も簡単な方法は、コンテナーイメージ エクステンションの1つを利用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエクステンションのいずれかが存在する場合、ネイティブ実行ファイル用のコンテナーイメージを作成することは、基本的には単一のコマンドを実行することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.container-build=true`  では GraalVM がインストールされていなくても Linux の実行ファイルを作成することができます(ローカルに GraalVM がインストールされていない場合や、ローカルのオペレーティングシステムが Linux ではない場合にのみ必要です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.container-image.build=true`  最終的なアプリケーションアーティファクト(この場合はネイティブの実行ファイル)を使用してコンテナーイメージを作成するようにQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:container-image[コンテナーイメージガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグインで生成されたJARを使用して、コンテナー内でアプリケーションを実行することができます。ただし、このセクションでは、生成されたネイティブ実行ファイルを使用してコンテナーイメージを作成することに焦点を当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:containerization-process.png[Containerization Process]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:containerization-process.png[alt="Containerization Process"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルのGraalVMインストール環境を使用する場合、ネイティブの実行ファイルは、ローカルのオペレーティングシステム(Linux、macOS、Windowsなど)をターゲットにしています。しかし、コンテナーはオペレーティングシステムによって生成されたものと同じ _実行_ 形式を使用しない場合があるため、コンテナーランタイムを活用して実行形式を生成するようにMavenビルドに指示します(この &lt;&lt;#container-runtime, セクション&gt;&gt; で説明されているように)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成される実行ファイルは64ビットのLinux実行ファイルになりますので、お使いのOSによっては実行できなくなる可能性があります。しかし、コンテナーにコピーするので問題ありません。プロジェクト生成では、 `src/main/docker`  ディレクトリーに `Dockerfile.native`  を用意し、以下のような内容にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ubi?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Ubi?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されている `Dockerfiles`  は親イメージとして https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI](Universal Base Image) を使用しています。このベースイメージはコンテナー内で完全に動作するように調整されています。 `Dockerfiles`  では、生成されるイメージのサイズを小さくするためにベースイメージの https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_最小_バージョン]を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>UBIについての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、生成されたネイティブ実行ファイルを削除していなければ、dockerイメージを使ってビルドします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして最後に、以下を実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in tiny Docker images, check the {quarkus-images-url}/master/distroless[distroless] version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>小さなDockerイメージに興味がある方は、{quarkus-images-url}/master/distroless[distroless] 版をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチステージDockerビルドの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションでは、Mavenを使用してネイティブ実行ファイルをビルドする方法を示しましたが、適切なGraalVMバージョンがビルドマシン(ローカルマシンまたはCI/CDインフラストラクチャ)にインストールされていることが暗黙のうちに要求されていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In cases where the GraalVM requirement cannot be met, you can use Docker to perform the Maven or Gradle build by using a multi-stage Docker build. A multi-stage Docker build is like two Dockerfile files combined in one, the first is used to build the artifact used by the second.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの要件を満たすことができない場合は、Dockerを使ってマルチステージDockerビルドを利用してMavenやGradleのビルドを行うことができます。マルチステージDockerビルドとは、2つのDockerfileファイルを1つにまとめたようなもので、1つ目は2つ目で使用するアーティファクトをビルドするために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will use the first stage to generate the native executable and the second stage to create our runtime image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、第一段階でネイティブ実行ファイルを生成し、第二段階でランタイムイメージを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MavenでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルは、Getting started quickstartには含まれていないので、 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GradleでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトでGradleを使用している場合は、このサンプルDockerfileを使用することができます。 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dockerビルドを起動する前に、デフォルトの `.dockerignore`  ファイルを更新する必要があります。 `target`  ディレクトリー以外は全てフィルタリングされ、コンテナー内でビルドする予定なので、 `src`  ディレクトリーをコピーできるようにする必要があります。そのため、 `.dockerignore`  を編集して、その内容を削除するかコメントしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルにSSLサポートが必要な場合は、Dockerイメージに必要なライブラリを簡単に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳しくは native-and-ssl#working-with-containers[ネイティブ実行可能ファイルでのSSL利用ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Oracle GraalVM 20.2またはMandrel 20.1から、Linux環境用にネイティブ実行ファイルのデバッグシンボルを生成できるようになりました(Windowsのサポートはまだ開発中です)。これらのシンボルは、 `gdb`  のようなツールを使用してネイティブ実行ファイルをデバッグするために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグシンボルを生成するには、ネイティブ実行ファイルの生成時に `-Dquarkus.native.debug.enabled=true`  フラグを追加してください。ネイティブ実行ファイルのデバッグシンボルは、ネイティブ実行ファイルの隣にある `.debug`  ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.debug`  ファイルの生成は `objcopy`  に依存します。一般的な Linux ディストリビューションや macOS では、 `binutils`  パッケージをインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`objcopy`  が利用できない場合、デバッグシンボルが実行ファイルに埋め込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグシンボルとは別に、 `-Dquarkus.native.debug.enabled=true`  フラグを設定すると、ネイティブ実行ファイル生成時に解決された JDK ランタイムクラス、GraalVM クラス、アプリケーションクラスのソースファイルのキャッシュが生成されます。このソースキャッシュは、シンボルと一致するソースコード間のリンクを確立するために、ネイティブデバッグツールにとって有用です。ネイティブ実行ファイルをデバッグする際に、必要なソースだけをデバッガー/IDEが利用できるようにする便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのソースコードを含むサードパーティのjar依存関係のソースは、デフォルトではソースキャッシュに追加されません。これらを含めるには、まず `mvn dependency:sources`  を起動してください。このステップは、これらの依存関係のソースを引き出し、ソースキャッシュに含めるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースキャッシュは `target/sources`  フォルダーにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gdb`  を `target`  とは異なるディレクトリーから実行している場合、ソースは以下を</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `gdb`  プロンプトで実行することで読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、 `gdb`  を以下のように起動してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの生成方法に影響を与える設定オプションがたくさんあります。これらは他の設定プロパティーと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アプリケーション用のネイティブ(バイナリー)実行ファイルの作成について説明しました。これにより、迅速な起動時間と少ないメモリー消費を示すアプリケーションを提供します。しかし、それだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:deploying-to-kubernetes[KubernetesとOpenShiftへのデプロイ]で探検を続けることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://flywaydb.org/[Flyway] is a popular database migration tool that is commonly used in JVM environments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://flywaydb.org/[Flyway] は、JVM環境でよく使われているデータベースマイグレーションツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Flyway as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、このガイドで説明するように、Flywayを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start using Flyway with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトで Flyway を使い始めるには、以下のことを行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your migrations to the `{migrations-path}` folder as you usually do with Flyway</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway で通常行うように、マイグレーションを `{migrations-path}` フォルダーに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Flyway` object and run your migration as you normally do</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`migrate-at-start` オプションを有効にしてスキーマを自動的に移行するか、 `Flyway` オブジェクトを注入して通常のように移行を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `pom.xml`, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml` で、以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Flyway extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway エクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お使いの JDBC ドライバーのエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Flyway to manage the schema.  Also, you can customize the Flyway behaviour by using the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway のサポートは、Quarkus のデータソース設定に依存しています。この設定は、デフォルトのデータソースだけでなく、 すべての link:#multiple-datasources[名前の付いたデータソース] に対してカスタマイズすることができます。まず、Flyway によるスキーマ管理を可能にするために、データソース設定を `{config-file}` ファイルに追加する必要があります。また、以下のプロパティーを使用して、Flyway の動作をカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example for the `{config-file}` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{config-file}` ファイルの例は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration to the default folder following the Flyway naming conventions: `{migrations-path}/V1.0.0__Quarkus.sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{migrations-path}/V1.0.0__Quarkus.sql` のように Flyway の命名規則に従って、デフォルトフォルダーに SQL マイグレーションを追加します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Flyway's migrate method according to your config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを起動でき、Quarkus は設定に従って Flyway のマイグレーションメソッドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Flyway object if you want to use it directly</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway オブジェクトを直接使用する場合はインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway can be configured for multiple datasources.  The Flyway properties are prefixed exactly the same way as the named datasources, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway は、複数のデータソースに対して設定可能です。Flyway のプロパティーには、例えば、名前の付いたデータソースと全く同じように接頭辞が付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.flyway.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーに余分なビットがあることに注意してください。構文は次の通りです。`quarkus.flyway.[optional name.][datasource property]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Flyway is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定なしの場合、Flyway はデフォルト設定を使用して各データソースに対して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Flyway` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Flyway` オブジェクトを直接使いたい場合は、以下のように注入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enabled the `quarkus.flyway.migrate-at-start` property, by the time you use the Flyway instance, Quarkus will already have run the migrate operation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.flyway.migrate-at-start` プロパティーを有効にした場合、Flyway インスタンスを使用する時点で、Quarkus はすでにマイグレーション操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources using the Quarkus `FlywayDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus `FlywayDataSource` 修飾子を使用して、指定されたデータソースに Flyway を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前の付いたデータソースへの Flyway の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Maven, you can scaffold a new project with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenを使えば、新しいプロジェクトをスキャフォールド(足場の作成)できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The group id of the target platform. Given that all the existing platforms are coming from `io.quarkus` this one won't practically be used explicitly. But it's still an option.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対象となるプラットフォームのグループID。既存のすべてのプラットフォームが `io.quarkus` から来ていることを考えると、実際にはこれは明示的には使われないでしょう。しかし、これはまだオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The artifact id of the target platform BOM. It should be `quarkus-bom` in order to use the locally built Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ターゲットプラットフォームBOMのアーティファクトID。ローカルでビルドされたQuarkusを使用するためには、 `quarkus-bom` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's not specified, the latest one will be resolved.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定されていない場合は、最新のものに解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of the platform you want the project to use. It can also accept a version range, in which case the latest from the specified range will be used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトで使用したいプラットフォームのバージョンを指定します。バージョンの範囲を指定することもでき、その場合は指定した範囲の最新のものが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the command will target the latest version of `quarkus-universe-bom` (unless specific coordinates have been specified). If you run offline however, it will look for the latest locally available and if `quarkus-universe-bom` (satisfying the default version range which is currently up to 2.0) is not available locally, it will fallback to the bundled platform based on `quarkus-bom` (the version will match the version of the plugin).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、このコマンドは `quarkus-universe-bom`  の最新バージョンをターゲットにします (特定の coordinates が指定されていない限り)。しかし、オフラインで実行した場合、ローカルで利用可能な最新のものを探し、 `quarkus-universe-bom`  (現在 2.0 までのデフォルトのバージョン範囲を満たしている) がローカルで利用できない場合は、 `quarkus-bom`  をベースにしたバンドルされたプラットフォームにフォールバックします (バージョンはプラグインのバージョンと一致します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is generated in a directory named after the passed artifactId.  If the directory already exists, the generation fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは、渡された artifactId にちなんだ名前のディレクトリーに生成されます。ディレクトリーが既に存在する場合は、生成に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern :</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グロブパターンに一致するすべてのエクステンションをインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus:dev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティーファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkus:dev` sets the debug host to `localhost` (for security reasons). If you need to change this, for example to enable debugging on all hosts, you can use the `-DdebugHost` option like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkus:dev` はデバッグホストを `localhost` に設定します (セキュリティー上の理由から)。これを変更する必要がある場合、例えばすべてのホストでデバッグを有効にしたい場合は、 `-DdebugHost` オプションを次のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production application in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must build a mutable application, using the `mutable-jar` format. Set the following properties in `application.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを行うには、 `mutable-jar`  形式を使用して、ミュータブルアプリケーションを構築する必要があります。 `application.xml`  で以下のプロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Quarkus to use the mutable-jar format. Mutable applications also include the deployment time parts of Quarkus, so they take up a bit more disk space. If run normally they start just as fast and use the same memory as an immutable application, however they can also be started in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、QuarkusにMutable-jar形式を使用するように指示します。ミュータブルアプリケーションには、Quarkusのデプロイメント時間の部分も含まれているため、より多くのディスクスペースを占有します。普通に実行した場合は、イミュータブルアプリケーションと同じ速度で起動し、同じメモリーを使用しますが、devモードで起動することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The password that is used to secure communication between the remote side and the local side.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート側とローカル側の通信を安全に保つためのパスワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL that your app is going to be running in dev mode at. This is only needed on the local side, so you may want to leave it out of the properties file and specify it as a system property on the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリがdevモードで実行されるURL。これはローカル側でのみ必要なので、プロパティー ファイルから除外して、コマンド ラインでシステム プロパティーとして指定するとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you start Quarkus on the remote host set the environment variable `QUARKUS_LAUNCH_DEVMODE=true`. If you are on bare metal you can just set this via the `export QUARKUS_LAUNCH_DEVMODE=true` command, if you are running using docker start the image with `-e QUARKUS_LAUNCH_DEVMODE=true`. When the application starts you should now see the following line in the logs: `Profile dev activated. Live Coding activated`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモートホストでQuarkusを起動する前に、環境変数 `QUARKUS_LAUNCH_DEVMODE=true`  を設定します。ベアメタルを使用している場合は、 `export QUARKUS_LAUNCH_DEVMODE=true`  コマンドで設定します。dockerを使用している場合は、 `-e QUARKUS_LAUNCH_DEVMODE=true`  でイメージを起動します。アプリケーションが起動すると、ログに次のような行が表示されるはずです: `Profile dev activated. Live Coding activated` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The remote side does not need to include Maven or any other development tools. The normal `fast-jar` Dockerfile that is generated with a new Quarkus application is all you need. If you are using bare metal launch the Quarkus runner jar, do not attempt to run normal devmode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート側にはMavenなどの開発ツールを入れる必要はありません。新しいQuarkusアプリケーションで生成される通常の `fast-jar`  Dockerfileがあれば大丈夫です。ベアメタルでQuarkus runner jarを起動している場合は、通常のdevmodeを実行しようとしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to connect your local agent to the remote host, using the `remote-dev` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `remote-dev`  コマンドを使用して、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app. This is done via a HTTP based long polling transport, that will synchronize your local workspace and the remote application via HTTP calls.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、ブラウザを更新するたびに、ローカルで行った変更がリモート アプリに即座に表示されるようになりました。これは、HTTPベースのロングポーリングトランスポートを介して行われ、HTTPコールを介してローカルのワークスペースとリモートアプリケーションを同期させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want to use the HTTP feature then you can simply run the `remote-dev` command without specifying the URL.  In this mode the command will continuously rebuild the local application, so you can use an external tool such as odo or rsync to sync to the remote application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP 機能を使用したくない場合は、URL を指定せずに `remote-dev`  コマンドを実行するだけです。このモードでは、コマンドはローカルアプリケーションを継続的に再構築するので、 odo や rsync のような外部ツールを使ってリモートアプリケーションに同期することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended you use SSL when using remote dev mode, however even if you are using an unencrypted connection your password is never sent directly over the wire. For the initial connection request the password is hashed with the initial state data, and subsequent requests hash it with a random session id generated by the server and any body contents for POST requests, and the path for DELETE requests, as well as an incrementing counter to prevent replay attacks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート開発モードを使用する際には SSL を使用することを推奨しますが、たとえ暗号化されていない接続を使用していても、パスワードが直接ネットワーク上で送信されることはありません。最初の接続リクエストでは、パスワードは初期状態のデータでハッシュ化され、それ以降のリクエストでは、サーバーによって生成されたランダムなセッションIDと、POSTリクエストのためのボディコンテンツ、DELETEリクエストのためのパス、そしてリプレイ攻撃を防ぐためのインクリメントカウンタでハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Maven plugin picks up compiler flags to pass to `javac` from `maven-compiler-plugin`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Maven プラグインは `maven-compiler-plugin`  から `javac`  に渡すコンパイラフラグをピックアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used in development mode, add a `configuration` section to the `plugin` block and set the `compilerArgs` property just as you would when configuring `maven-compiler-plugin`.  You can also set `source`, `target`, and `jvmArgs`.  For example, to pass `--enable-preview` to both the JVM and `javac`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードで使用するコンパイラ・フラグをカスタマイズする必要がある場合は、 `plugin`  ブロックに `configuration`  セクションを追加し、 `maven-compiler-plugin`  を設定するときと同じように `compilerArgs`  プロパティーを設定します。また、 `source`  、 `target`  、および `jvmArgs`  を設定することもできます。例えば、 `--enable-preview`  を JVM と `javac`  の両方に渡すには、 を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./mvnw compile quarkus:dev -Dsuspend` which is a shorthand for `./mvnw compile quarkus:dev -Dsuspend=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev -Dsuspend` を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます( `./mvnw compile quarkus:dev -Dsuspend=true` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./mvnw compile quarkus:dev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末で `./mvnw compile quarkus:dev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルまたは組み込みのターミナルで、 `./mvnw compile quarkus:dev`  を実行してください。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./mvnw compile quarkus:dev`  を実行します。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually, dependencies of an application (which is a Maven project) could be displayed using `mvn dependency:tree` command. In case of a Quarkus application, however, this command will list only the runtime dependencies of the application.  Given that the Quarkus build process adds deployment dependencies of the extensions used in the application to the original application classpath, it could be useful to know which dependencies and which versions end up on the build classpath.  Luckily, the `quarkus-bootstrap` Maven plugin includes the `build-tree` goal which displays the build dependency tree for the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常、アプリケーション(Mavenプロジェクト)の依存関係は、 `mvn dependency:tree`  コマンドを使用して表示することができます。しかし、Quarkusアプリケーションの場合、このコマンドはアプリケーションの実行時の依存関係のみを表示します。Quarkusのビルドプロセスは、アプリケーションで使用されているエクステンションのデプロイメント依存関係を元のアプリケーションのクラスパスに追加するので、どの依存関係とどのバージョンがビルドクラスパスで終わるかを知ることは便利です。幸いにも、 `quarkus-bootstrap`  Mavenプラグインには、アプリケーションのビルド依存関係ツリーを表示する `build-tree`  ゴールが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to use it, the following plugin configuration has to be added to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使えるようにするためには、以下のプラグイン設定を `pom.xml` に追加する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you should be able to execute `./mvnw quarkus-bootstrap:build-tree` on your project and see something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、プロジェクト上で `./mvnw quarkus-bootstrap:build-tree`  を実行して、以下のようなものが表示されるようになるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).  Verify that your `pom.xml` has the proper `native` profile (see &lt;&lt;build-tool-maven&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(GraalVMのJava 11バージョンを使用していることを確認してください)。あなたの `pom.xml`  が適切な `native`  プロファイルを持っていることを確認してください( link:#build-tool-maven[[build-tool-maven]を]参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.  A native executable will be present in `target/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative` を使用してネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `target/` に出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run Integration Tests on the native executable, make sure to have the proper Maven plugin configured (see &lt;&lt;build-tool-maven&gt;&gt;) and launch the `verify` goal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルで統合テストを実行するには、適切なMavenプラグインが設定されていることを確認し( link:#build-tool-maven[[build-tools-maven]を]参照)、 `verify`  ゴールを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can follow the link:building-native-image[Build a native executable guide] as well as link:deploying-to-kubernetes[Deploying Application to Kubernetes and OpenShift] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:building-native-image[ネイティブ実行ファイルのビルドガイド]と同様に、 link:deploying-to-kubernetes[アプリケーションをKubernetesとOpenShiftにデプロイ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have not used &lt;&lt;project-creation,project scaffolding&gt;&gt;, add the following elements in your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;project-creation,プロジェクトのスキャフォールド&gt;&gt;を使用していない場合は、以下の要素を `pom.xml` に追加してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally use a BOM file to omit the version of the different Quarkus dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションで、BOMファイルを使用して、異なるQuarkus依存関係のバージョンを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus Maven plugin that will hook into the build process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドプロセスにフックするQuarkus Mavenプラグインを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add system properties to `maven-surefire-plugin`. + `maven.home` is only required if you have custom configuration in `${maven.home}/conf/settings.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムのプロパティーを `maven-surefire-plugin`  に追加します。+ `maven.home`  は、 `${maven.home}/conf/settings.xml`  にカスタム設定がある場合にのみ必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a specific `native` profile for native executable building.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルのビルドには、特定の `native`  プロファイルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the `native` package type. The build will therefore produce a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native`  パッケージタイプを有効にします。そのため、ビルドはネイティブ実行可能ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to test your native executable with Integration Tests, add the following plugin configuration. Test names `*IT` and annotated `@NativeImageTest` will be run against the native executable. See the link:building-native-image[Native executable guide] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Integration Testsでネイティブ実行可能ファイルをテストしたい場合は、以下のプラグイン設定を追加してください。テスト名 `*IT`  と注釈付き `@NativeImageTest`  は、ネイティブ実行ファイルに対して実行されます。詳細は link:building-native-image[ネイティブ実行ファイルガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Maven plugin supports the generation of Uber-Jars by specifying a `quarkus.package.type=uber-jar` configuration option in your `application.properties` (or `&lt;quarkus.package.type&gt;uber-jar&lt;/quarkus.package.type&gt;` in your `pom.xml`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグインは、 `application.properties` .Quarkus Mavenプラグインで `quarkus.package.type=uber-jar`  設定オプションを指定することで、UberJar の生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The original jar will still be present in the `target` directory but it will be renamed to contain the `.original` suffix.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>元の jar は `target`  ディレクトリーに残っていますが、 `.original`  の接尾辞を含むように名前が変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `quarkus.package.ignored-entries` configuration option, this takes a comma separated list of entries to ignore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-jar をビルドする際に、 `quarkus.package.ignored-entries`  設定オプションを使用して生成された jar から除外したいエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar creation by default excludes link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[signature files] that might be present in the dependencies of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Uber-Jar の作成は、アプリケーションの依存関係に存在する可能性のある link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[署名ファイル]を除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar's final name is configurable via a Maven's build settings `finalName` option.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-Jarの最終的な名前は、Mavenのビルド設定 `finalName`  オプションで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When configuring `quarkus.package.type=fast-jar` (which will become the default soon), then the result of executing `./mvnw package` is a new directory under `target` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.package.type=fast-jar` を設定している場合 (これはもうすぐデフォルトになります)、 `./mvnw package` を実行した結果、 `target` の下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include the `jandex-maven-plugin`, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクト内のモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されていない限り、`jandex-maven-plugin`  をインクルードすることです。モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されている場合は自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Project Output</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト出力の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a several configuration options that will define what the output of your project build will be.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルドの出力を定義するための設定オプションがいくつかあります。これらは他の設定プロパティーと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Maven Surefire and Maven Failsafe configurations shown below. This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ただし、以下に示すMaven SurefireおよびMaven Failsafe構成で、テストにカスタム構成プロファイルを使用することは可能です。これは、例えば、デフォルトのテストデータベースではない特定のデータベースを使用してテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://camel.apache.org/[Apache Camel]は、10年以上の歴史とユーザーや開発者の活発なコミュニティを持つ、異種システムを統合するためのスイスアーミーナイフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus上のApache Camelのサポートは、 link:https://github.com/apache/camel-quarkus[Apache Camel Quarkusプロジェクト]によって提供されています。詳細は link:https://camel.apache.org/camel-quarkus/latest/[彼らのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at either file you will see that it contains both a Kubernetes `Deployment` and a `Service`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらのファイルを見ても、Kubernetes `Deployment` と `Service` 両方が含まれていることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source of the `kubernetes.json` file looks something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`kubernetes.json` ファイルの完全なソースはこんな感じです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example with a configuration like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、次のような設定の場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The image that will be used in the generated manifests will be `quarkus/demo-app:1.0`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストで使用されるイメージは `quarkus/demo-app:1.0` となります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels and Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベルとアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifests use the Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[recommended labels].  These labels can be customized using `quarkus.kubernetes.name`, `quarkus.kubernetes.version` and `quarkus.kubernetes.part-of`.  For example by adding the following configuration to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストには、Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[推奨のラベル]が使用されます。これらのラベルは、 `quarkus.kubernetes.name`, `quarkus.kubernetes.version` および `quarkus.kubernetes.part-of` を使用してカスタマイズすることができます。例えば、 `application.properties` に以下の設定を追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The labels in generated resources will look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースのラベルは次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Labels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Custom Labels</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add additional custom labels, for example `foo=bar` just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のカスタムラベルを追加するには、例えば `foo=bar` を設定する場合、以下の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Out of the box, the generated resources will be annotated with version control related information that can be used either by tooling, or by the user for troubleshooting purposes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースにはバージョン管理に関連する情報がアノテーションされ、ツールによって、またはユーザーがトラブルシューティングの目的で使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes provides multiple ways of defining environment variables:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesでは、環境変数を定義する方法が複数用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kubernetes extension allows the user to configure both volumes and mounts for the application.  Any volume can be mounted with a simple configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesエクステンションを使用すると、アプリケーションのボリュームとマウントの両方を設定することができます。簡単な設定で任意のボリュームをマウントすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the number of replicas:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レプリカの数を変更します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change the number of replicas from 1 to 3:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レプリカの数を1から3に変更する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add readiness and liveness probes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>readinessとlivenessのプローブを追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values of the generated probes will be determined by the configured health properties: `quarkus.smallrye-health.root-path`, `quarkus.smallrye-health.liveness-path` and `quarkus.smallrye-health.readiness-path`.  More information about the health extension can be found in the relevant link:microprofile-health[guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたプローブの値は、設定されたヘルスプロパティー( `quarkus.smallrye-health.root-path` 、 `quarkus.smallrye-health.liveness-path` 、 `quarkus.smallrye-health.readiness-path` )によって決定されます。ヘルスエクステンションの詳細については、関連する link:microprofile-health[ガイドを]参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To set the initial delay of the probe to 20 seconds and the period to 45:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プローブの初期遅延を 20 秒、周期を 45 に設定する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications that are deployed to Kubernetes and need to access the API server will usually make use of the `kubernetes-client` extension:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes にデプロイされ、API サーバーにアクセスする必要があるアプリケーションは、通常 `kubernetes-client` のエクステンションを利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access the API server from within a Kubernetes cluster, some RBAC related resources are required (e.g. a ServiceAccount, a RoleBinding etc.).  So, when the `kubernetes-client` extension is present, the `kubernetes` extension is going to create those resources automatically, so that application will be granted the `view` role.  If more roles are required, they will have to be added manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesクラスター内からAPIサーバーにアクセスするには、いくつかのRBAC関連のリソース(ServiceAccount、RoleBindingなど)が必要です。そのため、 `kubernetes-client` エクステンションが存在する場合、 `kubernetes` エクステンションが自動的にこれらのリソースを作成するため、アプリケーションに `view` ロールが付与されます。より多くのロールが必要な場合は、手動で追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tuning the generated resources using application.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>application.propertiesを使用して生成されたリソースをチューニングする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kubernetes extension allows tuning the generated manifest, using the `application.properties` file.  Here are some examples:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesのエクステンションでは、 `application.properties` ファイルを使用して、生成されたマニフェストをチューニングすることができます。以下にいくつかの例を紹介します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below describe all the available configuration options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の表は、利用可能なすべての設定オプションについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Probe</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Probe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example `initial-delay` and `period` are fields of the type `Probe`.  Below you will find tables describing all available types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、 `initial-delay` と `period` は `Probe` タイプのフィールドです。以下に、利用可能なすべてのタイプを説明した表を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本的な種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Env</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Port</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Container</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mounts and Volumes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マウントとボリューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mount</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMapVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SecretVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SecretVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AzureDiskVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AzureDiskVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AwsElasticBlockStoreVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AwsElasticBlockStoreVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GitRepoVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GitRepoVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AzureFileVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AzureFileVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.kubernetes.deployment-target=openshift
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.kubernetes.deployment-target=openshift
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to generate resources for both platforms (vanilla Kubernetes and OpenShift), then you need to include both (comma separated).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>両方のプラットフォーム(バニラKubernetesとOpenShift)のリソースを生成する必要がある場合は、両方を含める必要があります(カンマ区切り)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenShift resources can be customized in a similar approach with Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesと同様のアプローチでOpenShiftのリソースをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Knative</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated service can be customized using the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたサービスは、以下のプロパティーを使用してカスタマイズすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecated configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非推奨の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following categories of configuration properties have been deprecated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のカテゴリの構成プロパティーは非推奨となりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties without the quarkus prefix</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus接頭辞のないプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In earlier versions of the extension, the `quarkus.` was missing from those properties. These properties are now deprecated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以前のバージョンのエクステンションでは、これらのプロパティーに `quarkus.` がありませんでした。これらのプロパティーは現在非推奨となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties for configuring `docker` and `s2i` are also deprecated in favor of the new container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`docker` と `s2i` を設定するためのプロパティーも非推奨となり、新しいコンテナーイメージエクステンションが採用されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config group arrays</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定グループ配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, `kubernetes.env-vars[0]` etc) have been converted to maps, to align with the rest of the Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンフィググループ配列を参照するプロパティー(例: `kubernetes.labels[0]` 、 `kubernetes.env-vars[0]` など)は、Quarkusのエコシステムの他の部分と一致するようにマップに変換されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `labels` config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードは `labels` の設定を変更した様子を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `env-vars` config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードは `env-vars` の設定を変更した様子を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger building and deploying a container image you need to enable the `quarkus.kubernetes.deploy` flag (the flag is disabled by default - furthermore it has no effect during test runs or dev mode).  This can be easily done with the command line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージをビルドしてデプロイするには、 `quarkus.kubernetes.deploy` フラグを有効にする必要があります (このフラグはデフォルトでは無効になっています - さらに、テスト実行中や開発モードでは何の効果もありません)。これはコマンドラインで簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each time deployment is requested, a container image build will be implicitly triggered (no additional properties are required when the Kubernetes deployment has been enabled).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイが要求されるたびに、暗黙のうちにコンテナーイメージのビルドがトリガーされます(Kubernetes のデプロイが有効になっている場合は、追加のプロパティーは必要ありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment no additional options are provided for further customization.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、さらなるカスタマイズのための追加オプションは提供されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference covers how to write applications that run and then exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスでは、実行して終了するアプリケーションの書き方について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Command Mode Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different approaches that can be used to implement applications that exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>終了するアプリケーションを実装するためには、2つの異なるアプローチがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and have Quarkus run this method automatically</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` を実装し、Quarkusがこのメソッドを自動的に実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and a Java main method, and use the Java main method to launch Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` とJava mainメソッドを実装し、Java mainメソッドを使用してQuarkusを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this document the `QuarkusApplication` instance is referred to as the application main, and a class with a Java main method is the Java main.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、 `QuarkusApplication` インスタンスをアプリケーション mainと呼び、Java mainメソッドを持つクラスを Java mainと呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;.&gt; The `@QuarkusMain` annotation tells Quarkus that this is the main entry point.  &lt;.&gt; The `run` method is invoked once Quarkus starts, and the application stops when it finishes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;.&gt; `@QuarkusMain` アノテーションは、これがメインのエントリーポイントであることをQuarkusに伝えます。  &lt;.&gt; `run` メソッドは、Quarkusが起動すると呼び出され、終了するとアプリケーションが停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contexts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get access to your application beans and services, be aware that a `@QuarkusMain` instance is an application scoped bean by default. It has access to singletons, application and dependent scoped beans. If you want to interact with beans that requires a request scope put a `@ActivateRequestContext` on your `run()` method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションBeanやサービスにアクセスするために、 `@QuarkusMain` インスタンスはデフォルトでapplicationスコープのBeanであることに注意してください。singleton、application、dependentスコープのBeanへのアクセスを持っています。requestスコープを必要とするBeanと対話したい場合は、 `run()` メソッドに `@ActivateRequestContext` を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This let `run()` have access to methods like `listAll()` and `query*` methods on a Panache Entity. Without it you will eventually get a `ContextNotActiveException` when accessing such classes/beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `run()` は Panache Entity 上の `listAll()` や `query*` のようなメソッドにアクセスできるようになります。これがないと、そのようなクラスやビーンにアクセスするときに、最終的には `ContextNotActiveException` に直面することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is effectively the same as running the `HelloWorldMain` application main directly, but has the advantage it can be run from the IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `HelloWorldMain` アプリケーション mainを直接実行するのと実質的には同じですが、IDE から実行できるという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class that implements `QuarkusApplication` and has a Java main then the Java main will be run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` を実装したクラスで Java main がある場合は Java main が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that a Java main perform very little logic, and just launch the application main. In development mode the Java main will run in a different ClassLoader to the main application, so may not behave as you would expect.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java mainはほとんどロジックを実行せず、アプリケーション mainを起動するだけにすることをお勧めします。開発モードでは、Java mainはアプリケーション mainとは異なるClassLoaderで実行されるので、期待通りの動作をしないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Main Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のmainメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to have multiple main methods in an application, and select between them at build time.  The `@QuarkusMain` annotation takes an optional 'name' parameter, and this can be used to select the main to run using the `quarkus.package.main-class` build time configuration option. If you don't want to use annotations this can also be used to specify the fully qualified name of a main class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション内に複数のmainメソッドを持ち、ビルド時にそれらの間で選択することが可能です。 `@QuarkusMain` アノテーションはオプションの 'name' パラメーターを取り、 `quarkus.package.main-class` ビルド時設定オプションを使用して実行するmainを選択するために使用できます。アノテーションを使用したくない場合は、メインクラスの完全修飾名を指定するために使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the `@QuarkusMain` with no name (i.e. the empty string) will be used, and if it is not present and `quarkus.package.main-class` is not specified then Quarkus will automatically generate a main class that just runs the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、名前のない `@QuarkusMain` (つまり空文字列)が使用され、それが存在せず `quarkus.package.main-class` が指定されていない場合は、Quarkus はアプリケーションを実行するだけのメインクラスを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `name` of `@QuarkusMain` must be unique (including the default of the empty string). If you have multiple `@QuarkusMain` annotations in your application the build will fail if the names are not unique.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusMain` の `name` は一意である必要があります(デフォルトの空文字列を含む)。アプリケーション内に複数の `@QuarkusMain` アノテーションがある場合、名前が一意でないとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command mode lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running a command mode application the basic lifecycle is as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのアプリケーションを実行する場合、基本的なライフサイクルは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the `QuarkusApplication` main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` mainメソッドの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shut down Quarkus and exit the JVM after the main method returns</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mainメソッドがreturnされた後にQuarkusをシャットダウンし、JVMを終了する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shutdown is always initiated by the application main thread returning. If you want to run some logic on startup, and then run like a normal application (i.e. not exit) then you should call `Quarkus.waitForExit` from the main thread (A non-command mode application is essentially just running an application that just calls `waitForExit`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シャットダウンは常にアプリケーションのメインスレッドがreturnされることで開始されます。起動時に何らかのロジックを実行して、通常のアプリケーションのように実行したい場合 (つまり終了しない) は、メインスレッドから `Quarkus.waitForExit` を呼び出す必要があります (非コマンドモードのアプリケーションは、基本的に `waitForExit` を呼び出すだけのアプリケーションを実行しているだけです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to shut down a running application and you are not in the main thread then you should call `Quarkus.asyncExit` in order to unblock the main thread and initiate the shutdown process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中のアプリケーションをシャットダウンしたい場合、メインスレッドにいない場合は、 `Quarkus.asyncExit` を呼び出してメインスレッドのブロックを解除し、シャットダウン処理を開始する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also for command mode applications the dev mode is supported. When running `mvn compile quarkus:dev`, the command mode application is executed and on press of the Enter key, is restarted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コマンドモードアプリケーションでは、開発モードにも対応しています。 `mvn compile quarkus:dev` を実行しているときは、コマンドモードアプリケーションを実行し、Enter キーを押すと再起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As command mode applications will often require arguments to be passed on the commandline, this is also possible in dev mode via:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのアプリケーションでは、コマンドラインで引数を渡す必要があることが多く、これは開発モードでも可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>資格情報プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクのスケジュール方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a clustered scheduler use the link:quartz[Quartz extension].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスター化されたスケジューラーが必要な場合は、 link:quartz[Quartz拡張機能] を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application accessible using HTTP to get the current value of a counter.  This counter is periodically (every 10 seconds) incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、カウンタの現在値を取得するために HTTP を使用してアクセスできる簡単なアプリケーションを作成します。このカウンタは定期的に (10 秒ごとに) インクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.scheduler.CountResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.scheduler.CountResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Maven project also imports the Quarkus scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven プロジェクトは、Quarkus scheduler エクステンションもインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `scheduler` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `scheduler` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a scheduled job</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたジョブの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.scheduler` package, create the `CounterBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.scheduler` パッケージで、以下の内容の `CounterBean` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the bean in the _application_ scope</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_application_ スコープでの Bean の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method allows retrieving the current value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`get()` メソッドでは、現在の値を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds provided a worker thread is available (Quarkus is using 10 worker threads for the scheduler). If it is not available the method invocation should be re-scheduled by default i.e it should be invoked as soon as possible. The invocation of the scheduled method does not depend on the status or result of the previous invocation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用して、ワーカースレッドが利用可能であれば 10 秒ごとにこのメソッドを実行するように Quarkus に指示します (Quarkus はスケジューラーに10個のワーカースレッドを使用しています)。ワーカースレッドが利用できない場合は、メソッドの呼び出しをデフォルトで再スケジューリングする必要があります。スケジュールされたメソッドの呼び出しは、前回の呼び出しのステータスや結果には依存しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is pretty straightforward. Every 10 seconds, the counter is incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードはとても簡単です。10 秒ごとにカウンターがインクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression. The annotated method is executed at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cron のような式でジョブを定義します。アノテーションされたメソッドは毎日午前 10 時 15 分に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression `cron.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で設定可能な`cron.expr` で cron のような式でジョブを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the application configuration file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション設定ファイルの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the `cron.expr` configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` ファイルを編集し、 `cron.expr` の設定を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the resource and the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースとテストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `CountResource` class, and update the content to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountResource` クラスを編集して、内容を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CounterBean`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CounterBean` の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send back the current counter value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のカウンターの値の返却</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `CountResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストも更新する必要があります。`CountResourceTest` クラスを一致するように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the response contains `count`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスに `count` が含まれていることを確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  In another terminal, run `curl localhost:8080/count` to check the counter value.  After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行してください。別のターミナルで `curl localhost:8080/count` を実行して、カウンターの値を確認します。数秒後に `curl localhost:8080/count` を再実行して、カウンターがインクリメントされていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observe the console to verify that the message `Cron expression configured in application.properties` has been displayed indicating that the cron job using an expression configured in `application.properties` has been triggered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールを見て、 `application.properties` で構成された式を使用する cron ジョブがトリガーされたことを示すメッセージ `Cron expression configured in application.properties` が表示されたことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラー設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/public`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/public` endpoint can be accessed anonymously.  The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `admin` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.  The `/api/users/me` endpoint is also protected with RBAC (Role-Based Access Control) where only users granted with the `user` role can access. As a response, it returns a JSON document with details about the user.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public` エンドポイントは匿名でアクセスできます。 `/api/admin` エンドポイントは RBAC (Role-Based Access Control) で保護されており、 `admin` の役割を与えられたユーザーのみがアクセスできます。このエンドポイントでは、 `@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。 `/api/users/me` エンドポイントも RBAC (Role-Based Access Control) で保護されており、 `user` ロールで付与されたユーザーのみがアクセスできます。レスポンスとして、ユーザーに関する詳細を含むJSONドキュメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to add the database connector library of choice. Here we are using PostgreSQL as identity store.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>選択したデータベースコネクタライブラリを追加することを忘れないでください。ここでは、PostgreSQLをIDストアとして使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `elytron-security-jdbc` extension which is an https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-jdbc`] adapter for Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドはMavenプロジェクトを生成し、 `elytron-security-jdbc` エクステンションをインポートします。 link:https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-jdbc`] Quarkusアプリケーション用のアダプターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `elytron-security-jdbc` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `elytron-security-jdbc` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/public` endpoint. As you can see from the source code below, it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public` エンドポイントの実装から始めましょう。以下のソースコードから分かるように、通常のJAX-RSリソースです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's consider the `/api/users/me` endpoint. As you can see from the source code below, we are trusting only users with the `user` role.  We are using `SecurityContext` to get access to the current authenticated Principal and we return the user's name. This information is loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `/api/users/me` エンドポイントを考えてみましょう。下のソースコードを見ればわかるように、 `user` の役割を持つユーザのみを信頼しています。現在認証されているプリンシパルへのアクセスを得るために `SecurityContext` を使用しており、ユーザーの名前を返します。この情報はデータベースから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-jdbc` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`elytron-security-jdbc` エクステンションは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store and we initialize the database with users and roles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのコンテキストでは、PostgreSQLをアイデンティティストアとして使用しており、ユーザーとロールでデータベースを初期化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environment ;-).  The `elytron-security-jdbc` offers a built-in bcrypt password mapper.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おそらく無用と思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください ;-)。 `elytron-security-jdbc` は組み込みの bcrypt パスワードマッパーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now configure the Elytron JDBC Realm.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、Elytron JDBC Realmを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-jdbc` extension requires at least one principal query to authenticate the user and its identity.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`elytron-security-jdbc` エクステンションは、ユーザーとそのアイデンティティを認証するために、少なくとも一つのプリンシパルのクエリを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We define a parameterized SQL statement (with exactly 1 parameter) which should return the user's password plus any additional information you want to load.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーのパスワードと、ロードしたい追加情報を返却するパラメーター化されたSQL文(単一のパラメーター付)を定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We configure the password mapper with the position of the password field in the `SELECT` fields and other information like salt, hash encoding, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SELECT` フィールドのパスワードフィールドの位置や、ソルト、ハッシュエンコードなどの情報を使って、パスワードマッパーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `attribute-mappings` to bind the `SELECT` projection fields (ie. `u.role` here) to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`attribute-mappings` を使用して、 `SELECT` の投影フィールド(例:ここでは `u.role` )をターゲットの Principal 表現属性にバインドしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `principal-query` configuration all the `index` properties start at 1 (rather than 0).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`principal-query` の設定では、 `index` のプロパティーはすべて 1 から始まります (0 ではなく)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is now protected and the identities are provided by our database.  The very first thing to check is to ensure the anonymous access works.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが保護され、アイデンティティがデータベースから提供されるようになりました。非常に最初に確認しなければならないことは、匿名アクセスが機能することを確認することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's try a to hit a protected resource anonymously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、匿名で保護されたリソースを攻撃してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far so good, now let's try with an allowed user.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここまでは順調ですが、今度は許可されたユーザーで試してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By providing the `admin:admin` credentials, the extension authenticated the user and loaded their roles.  The `admin` user is authorized to access to the protected resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`admin:admin` 資格情報を提供することで、エクステンションはユーザーを認証し、そのロールをロードしました。 `admin` ユーザーは、保護されたリソースへのアクセスを許可されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user `admin` should be forbidden to access a resource protected with `@RolesAllowed("user")` because it doesn't have this role.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `admin` は、この役割を持っていないので、 `@RolesAllowed("user")` で保護されたリソースへのアクセスを禁止する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, using the user `user` works and the security context contains the principal details (username for instance).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ユーザー `user` を使用すると動作し、セキュリティーコンテキストには主要な詳細(例えばユーザー名)が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>高度な設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide only covered an easy use case, the extension offers multiple datasources, multiple principal queries configuration as well as a bcrypt password mapper.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、簡単な使用例のみを取り上げていますが、このエクステンションは複数のデータソース、複数のプリンシパルクエリの設定、および bcrypt パスワードマッパーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence offers a fluent query builder API on top of JPA with a deep Hibernate ORM integration that enables the use of advanced SQL features like Common Table Expressions while staying in the realm of the JPA model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistenceは、Hibernate ORMとの深い統合により、JPAの上に流れるようなクエリビルダAPIを提供し、JPAモデルの範囲内でありながら、共通テーブル式のような高度なSQL機能の使用を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of that, the Blaze-Persistence Entity-View module allows for DTO definitions that can be applied to business logic queries which are then transformed to optimized queries that only fetch the data that is needed to construct the DTO instances.  The same DTO definitions can further be used for applying database updates, leading to a great reduction in boilerplate code and removing the need for object mapping tools.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、Blaze-Persistence Entity-Viewモジュールは、ビジネスロジッククエリに適用出来るDTO定義を可能にし、そのクエリはDTOインスタンスを構築するために必要なデータのみを取得する最適化されたクエリに変換されます。同じDTO定義をデータベースの更新にも使用することができます。これにより、ボイラプレートコードが大幅に削減され、オブジェクトマッピングツールの必要性がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension comes with default producers for `CriteriaBuilderFactory` and `EntityViewManager` that work out of the box given a working Hibernate ORM configuration. For customization, overriding of the default producers is possible via the standard mechanism as documented in the link:{quarkus-home-url}/guides/cdi-reference#default_beans[Quarkus CDI reference].  This is needed if you need to set custom link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#anchor-configuration-properties[Blaze-Persistence properties].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションには、 `CriteriaBuilderFactory` と `EntityViewManager` のデフォルトのプロデューサーが付属しており、動作する Hibernate ORM 設定があればすぐに動作します。カスタマイズのために、 link:{quarkus-home-url}/guides/cdi-reference#default_beans[Quarkus CDIリファレンス]に記載されている標準的なメカニズムを使用して、デフォルトのプロデューサーをオーバーライドすることができます。これは、カスタムの link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#anchor-configuration-properties[Blaze-Persistenceプロパティー]を設定する場合に必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Inject` `CriteriaBuilderFactory` or `EntityViewManager` and use it</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` または `EntityViewManager` を `@Inject` し、使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Blaze-Persistence extension: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistence エクステンション: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jackson` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson] の為に `blaze-persistence-integration-jackson`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jaxrs` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]の為に `blaze-persistence-integration-jaxrs`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use in native images requires a dependency on the entity view annotation processor that may be extracted into a separate `native` profile:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージでの使用には、別の `native` プロファイルに抽出される可能性のあるエンティティービューアーノテーションプロセッサーへの依存関係が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `CriteriaBuilderFactory` and an `EntityViewManager` will be created based on the configured `EntityManagerFactory` as provided by the link:{quarkus-home-url}/guides/hibernate-orm[Hibernate-ORM extension].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` と `EntityViewManager` は、 link:{quarkus-home-url}/guides/hibernate-orm[Hibernate-ORM エクステンション]で提供される設定された `EntityManagerFactory` に基づいて作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then access these beans via injection:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、注入によってこれらのBeanにアクセスすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CriteriaBuilderFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityViewManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityViewManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark your CDI bean method as `@Transactional` so that a transaction is started or joined.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションが開始またはトランザクションに参加されるように、CDI Beanメソッドを `@Transactional` としてマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity-View</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンティティービューの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example updatable Entity-View</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>更新可能なEntity-Viewの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various optional properties useful to refine your `EntityViewManager` and `CriteriaBuilderFactory` or guide guesses of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityViewManager` と `CriteriaBuilderFactory` を洗練させたり、またはQuarkusの推測をガイドするのに便利な様々なオプションのプロパティーがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no required properties, as long as the Hibernate ORM extension is configured properly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMエクステンションが適切に設定されている限り、必須のプロパティーはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When no property is set, the Blaze-Persistence defaults apply.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーが設定されていない場合は、Blaze-Persistenceのデフォルトが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Derby</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Derby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence currently does not come with support for Apache Derby.  This limitation could be lifted in the future, if there's a compelling need for it and if someone contributes it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistenceは現在、Apache Derbyをサポートしていません。切実なニーズが存在し、誰かがコントリビュートしてくれれば、この制限は、将来的には解除されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with link:hibernate-orm[Hibernate ORM] or link:hibernate-orm-panache[Hibernate ORM with Panache].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用し、 link:hibernate-orm[Hibernate ORM]または link:hibernate-orm-panache[Hibernate ORM with Panache]を使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `security-jpa` extension which allows you to map your security source to JPA entities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、セキュリティー ソースを JPA エンティティーにマップできる `security-jpa` エクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `security-jpa` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `security-jpa` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining our user entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーエンティティーの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now describe how our security information is stored in our model by adding a few annotations to our `User` entity:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、 `User` エンティティーにいくつかのアノテーションを追加することで、セキュリティー情報がモデルにどのように保存されているかを説明することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension is only initialized if there is a single entity annotated with `@UserDefinition`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`security-jpa` 拡張子は、 `@UserDefinition` でアノテーションされた単一のエンティティーがある場合にのみ初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation must be present on a single entity. It can be a regular Hibernate ORM entity or a Hibernate ORM with Panache entity as in this example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、単一のエンティティーに存在しなければなりません。この例のように、通常のHibernate ORMエンティティーまたはHibernate ORM with Panacheエンティティーにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the user name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ユーザー名に使用されるフィールドを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the password. This defaults to using bcrypt hashed passwords, but you can also configure it for clear text passwords.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パスワードに使用するフィールドを示します。これはデフォルトでは bcrypt ハッシュ化されたパスワードを使用するように設定されていますが、クリアテキストパスワード用に設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the comma-separated list of roles added to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、対象のプリンシパル表現属性に追加されたロールのコンマ区切りリストを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to add users while hashing the password with the proper bcrypt hash.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法では、パスワードを適切なbcryptハッシュでハッシュしながらユーザーを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`security-jpa` 拡張モジュールは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store. The database schema is created by Hibernate ORM automatically on startup (change this in production) and we initialize the database with users and roles in the `Startup` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのコンテキストでは、IDストアとしてPostgreSQLを使用しています。データベーススキーマはHibernate ORMによって起動時に自動的に作成され(本番ではこれを変更します)、 `Startup` クラスのユーザーとロールでデータベースを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environments ;-).  As a result, the `security-jpa` defaults to using bcrypt-hashed passwords.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おそらく役に立たないと思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください。)その結果、 `security-jpa` はデフォルトで bcrypt でハッシュ化されたパスワードを使用するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following tests we use the basic authentication mechanism, you can enable it by setting `quarkus.http.auth.basic=true` in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のテストでは、基本的な認証メカニズムを使用していますが、 `application.properties` ファイルに `quarkus.http.auth.basic=true` を設定することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported model types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているモデルの種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@UserDefinition` class must be a JPA entity (with Panache or not).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@UserDefinition` クラスは JPA エンティティーである必要があります(Panache を使用しているかどうかは問いません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Username` and `@Password` field types must be of type `String`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Username` と `@Password` フィールドの型は `String` でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Roles` field must either be of type `String` or `Collection&lt;String&gt;` or alternately a `Collection&lt;X&gt;` where `X` is an entity class with one `String` field annotated with the `@RolesValue` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Roles` フィールドは `String` か `Collection&amp;amp;lt;String&amp;amp;gt;` のいずれかのタイプであるか、または `Collection&amp;amp;lt;X&amp;amp;gt;` である必要があります。 `X` はエンティティークラスで、 `@RolesValue` アノテーションが付与された `String` フィールドが 1 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `String` role element type will be parsed as a comma-separated list of roles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各 `String` role 要素の型は、カンマで区切られたロールのリストとして解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Storing roles in another entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のエンティティーにロールを格納する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also store roles in another entity:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、別のエンティティーにロールを格納することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Password storage and hashing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスワードの保存とハッシュ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, we consider passwords to be stored hashed with https://en.wikipedia.org/wiki/Bcrypt[bcrypt] under the https://en.wikipedia.org/wiki/Crypt_(C)[Modular Crypt Format] (MCF).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、パスワードは MCF ( link:https://en.wikipedia.org/wiki/Crypt_©[Modular Crypt Format]) の下で link:https://en.wikipedia.org/wiki/Bcrypt[bcrypt]でハッシュ化されて保存されると考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to create such a hashed password we provide the convenient `String BcryptUtil.bcryptHash(String password)` function, which defaults to creating a random salt and hashing in 10 iterations (though you can specify the iterations and salt too).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなハッシュ化されたパスワードを作成する必要がある場合は、便利な `String BcryptUtil.bcryptHash(String password)` 関数を用意しています。デフォルトでは、ランダムなソルトを作成して 10 回の繰り返しでハッシュ化します (繰り返しとソルトも指定できます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with MCF you don't need dedicated columns to store the hashing algorithm, the iterations count or the salt because they're all stored in the hashed value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MCF を使うと、ハッシュアルゴリズムや反復回数、 ソルトを格納するための専用のカラムは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARN: you can also store passwords in clear text with `@Password(PasswordType.CLEAR)` but we strongly recommend against it in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>警告: `@Password(PasswordType.CLEAR)` を使ってパスワードをクリアテキストで保存することもできますが、本番では絶対にしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>用語集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントやウェブサイトで好まれる用語を集めたものです。一貫性を保つために、これらの用語の範囲内にとどめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>* ライブコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ロギングとその設定方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>集中ログ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKogitoを使用してビジネスオートメーションを追加し、ビジネスプロセスとルールでパワーアップする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用してリアクティブアプリケーションを作成する方法と、Quarkusが提供するさまざまなリアクティブ機能について説明します。このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick glance at the Quarkus engine and how it enables reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエンジンの概要と、それがどのようにリアクティブを可能にしているかを簡単に説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな JAX-RS エンドポイントの作成（非同期、ストリーム...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータベースアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のリアクティブAPIの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solutions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;bootstrapping-the-project,プロジェクトのブートストラップ&gt;&gt;とそれ以降の解説に従って、ステップバイステップでアプリを作成していくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかしながら、完成した例をすぐ確認することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-archive-url}[アーカイブ] をダウンロードするか、gitレポジトリをクローンします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started-reactive` と `getting-started-reactive-crud` のディレクトリにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはリアクティブです。ボンネットの下を見ると、Quarkusアプリケーションの動力源となっているリアクティブエンジンを見つけることができます。このエンジンはEclipse Vert.x（ https://vertx.io ）です。すべてのネットワークI/Oは、ノンブロッキングでリアクティブなVert.xエンジンを通過します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:quarkus-reactive-stack.png[alt="Quarkusはリアクティブなエンジンをベースとしている", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つの例を挙げて、その仕組みを説明してみましょう。入ってくるHTTPリクエストを想像してみてください。Quarkusに組み込まれたHTTPサーバー（Vert.x）がリクエストを受信し、アプリケーションにルーティングします。リクエストが _命令的な_ メソッド（従来のJAX-RS、 `@Blocking` ...で注釈されたコード）をターゲットにしている場合、ルーティング層は _ワーカースレッド_ でリソースメソッドを呼び出し、データが利用可能になるとレスポンスを書き込みます。今のところ、目新しいものも目立ったものもありません。次の図は、この動作を示しています。この場合、アプリケーションコードはワーカースレッドで呼び出され、ビジネスロジックはそのスレッドをブロックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:http-blocking-sequence.png[alt="命令的な route を使ったときの挙動", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、HTTPリクエストがリアクティブなメソッド（RESTEasy Reactiveを使用したJAX-RS、リアクティブなルート、 `@Incoming` メソッドは `@Blocking` ...でアノテーションされていない）をターゲットにしている場合、ルーティング層はI/Oスレッド上でルートを呼び出し、より高い同時実行性とパフォーマンスなどの多くの利点を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:http-reactive-sequence.png[alt="リアクティブな route を使ったときの挙動", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはI/Oスレッドを使用してコードを呼び出すため、コンテキストスイッチを節約し、大規模なスレッドプール管理を回避し、リソースの利用率を向上させます。ただし、コードはそのスレッドをブロックしてはいけ *ませ* ん。なぜでしょうか？なぜなら、I/O スレッドは複数の同時リクエストを処理するために使用されます。リクエストの処理がいくつかのI/Oを実行する必要があるために進行できなくなるとすぐに、これらのI/Oをスケジュールし、継続(continuation)を渡します。別のリクエストを処理できるスレッドを解放します。スケジュールされたI/Oが完了すると、I/Oスレッドに戻って継続(continuation)が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>結果として、多くのQuarkusコンポーネントは、データベースアクセス（PostgreSQL、MySQL、Mongoなど）、アプリケーションサービス（メール、テンプレートエンジンなど）、メッセージング（Kafka、AMQPなど）など、リアクティブを念頭に置いて設計されています。しかし、このモデルの恩恵を十分に受けるためには、アプリケーションコードはノンブロッキングで書かれなければなりません。そこで、リアクティブ API を持つことが究極の武器となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/smallrye/smallrye-mutiny[Mutiny] は、非同期アクションを表現したり構成したりすることができるリアクティブプログラミングライブラリです。2つのタイプがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.mutiny.Multi` - マルチアイテム（バックプレッシャー付き）ストリーム用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらのタイプも lazy で、サブスクリプションパターンに従います。計算は、実際に必要とされる場合にのみ開始されます (すなわち、サブスクライバがエンリストした場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` も `Multi` もイベント駆動型の API を公開しています: 与えられたイベント (成功、失敗など) に対して何をしたいかを表現します。これらのAPIはグループ(操作の種類)に分けられており、より表現力を高め、1つのクラスに100個ものメソッドをアタッチすることを避けています。主な操作の種類は、失敗に反応するもの、完了するもの、アイテムを操作するもの、抽出するもの、収集するものなどです。ナビゲーション可能なAPIでスムーズなコーディングを実現し、結果的にリアクティブ周りの知識をあまり必要としないようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://www.reactive-streams.org/ `Multi` は Reactive Streams `Publisher` を実装しているので、Reactive Streams のバックプレッシャーメカニズムを実装しています。 `Uni` へのサブスクリプションは結果に興味があることを示すのに十分なので、 `Uni` は `Publisher` を実装していません。これは、Reactive Streams のサブスクリプション/リクエスト式がより複雑であるため、よりシンプルでスムーズな API のアイデアを念頭に置いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのリアクティブな面と命令的な面の統合を受け入れた `Uni` と `Multi` は、両方とも命令的構造への橋渡しをしてくれます。たとえば、 `Multi` を `Iterable` に変換したり、 `Uni` .NET で生成されたアイテムを _待っ_ たりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この時点で、あなたがRxJavaやReactorのユーザーであれば、お馴染みの `Flowable` , `Single` , `Flux` , , `Mono` ... Mutinyでは、 `Unis` と `Multis` をRX JavaやReactorの型に変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、Vert.xはどうでしょうか？Vert.xのAPIはMutiny型を使っても利用できます。以下のスニペットは、Vert.x Web Clientの使い方を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後になりますが、MutinyにはMicroProfile Context Propagationとの統合が組み込まれているので、リアクティブパイプラインでトランザクションやトレーサビリティデータなどを伝搬することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But enough talking, let's get our hands dirty!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>話はもういい、手を汚すんだ！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでリアクティブアプリケーションを実装するには、いくつかの方法があります。このガイドでは、Quarkusのリアクティブエンジンの恩恵を受けるRESTEasyの実装であるRESTEasy Reactiveを使用します。デフォルトでは、I/Oスレッド上のHTTPエンドポイントを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_従来の_ RESTEasy を使用することは可能ですが、 `quarkus-resteasy-mutiny` 拡張モジュールを追加する必要があり、メソッドは _ワーカースレッド_ 上で呼び出されます。つまり、リアクティブプログラミングを使用するとはいえ、ワーカースレッドを必要とし、その目的は達成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use forward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cmd を使用する場合は、(前方スラッシュを使用しないでください `\` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Powershell を使用する場合は、 `-D` のパラメータを二重引用符で囲みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started-reactive`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./getting-started-reactive` 内に以下が生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/hello` で公開されている `org.acme.quickstart.ReactiveGreetingResource` リソース </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/docker` にある `native` と `jvm` の両方のモード用の `Dockerfile` ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive JAX-RS resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな JAX-RS リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト作成時に、 `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` ファイルは以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello RESTEasy Reactive" to requests on "/hello".  As it uses RESTEAsy Reactive, this method is called on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは非常にシンプルなRESTエンドポイントで、"/hello"上のリクエストに対して"Hello RESTEasy Reactive"を返します。RESTEAsy Reactiveを使用しているので、このメソッドはI/Oスレッド上で呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_ワーカースレッド_ でこのメソッドを呼び出すようにQuarkusに指示するには、 `io.smallrye.common.annotation.Blocking` アノテーションを付けます。メソッドやクラスで `@Blocking` を使用したり、 `Application` クラスをアノテーションすることで、アプリケーション全体で を使用できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create a `ReactiveGreetingService` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、以下の内容の `ReactiveGreetingService` クラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, edit the `ReactiveGreetingResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `ReactiveGreetingResource` クラスを以下の内容に合わせて編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReactiveGreetingService` クラスには、 `Uni` を生成する簡単なメソッドが含まれています。この例では、結果として得られるアイテムがすぐに出力されますが、非同期 API で `Uni` を生成することは想像できます。これについては、このガイドで後ほど説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, start the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、以下でアプリケーションを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行したら、 http://localhost:8080/hello/greeting/neo を開いて、期待通りのグリーティングメッセージが表示されているか確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ストリームの取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、非同期の結果を返すだけでした。このセクションでは、複数のアイテムを伝えるストリームを使ってアプリケーションを拡張します。これらのストリームは Kafka や他のデータソースからのものでも構いませんが、物事をシンプルに保つために、定期的にグリーティングメッセージを生成するだけにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingService`, add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReactiveGreetingService` で、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`import io.smallrye.mutiny.Multi;` と `import java.time.Duration;` のステートメントを追加する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a greeting message every second and stops after `count` messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1秒ごとに greeting メッセージを生成し、 `count` メッセージの後に停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingResource` add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReactiveGreetingResource` で、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエンドポイントは、アイテムをJSON配列としてクライアントにストリームします。メッセージの名前と数は、パスパラメータを使用してパラメータ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So calling the endpoint produces something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、エンドポイントを呼び出すと、次のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can also generate Server-Sent Event responses by returning a `Multi`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `Multi` を返すことで Server-Sent Event レスポンスを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどのスニペットとの違いは、生成される型と、各イベントの型を示す `@RestSseElementType` アノテーションだけです。 `@Produces` アノテーションは `SERVER_SENT_EVENTS` を定義しているので、JAX-RS は各（入れ子になった）イベントのコンテンツタイプを知るために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`import org.jboss.resteasy.reactive.RestSseElementType;` の文を追加する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the result using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下で結果を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ API の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはMutinyモデルを使用した多くのリアクティブAPIを提供しています。このセクションでは、リアクティブPostgreSQLドライバを使用して、ノンブロッキングでリアクティブな方法でデータベースと対話する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下で新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application is interacting with a PostgreSQL database, so you need one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションはPostgreSQLデータベースと対話しているので、DBが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>続いて、データソースを設定してみましょう。 `src/main/resources/application.properties` を開き、以下の内容を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の3行はデータソースを定義しています。最後の行は、アプリケーションが初期化されたときにいくつかの項目を挿入するかどうかを示すためにアプリケーションで使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、 _エンティティを_ 作成しましょう。以下の内容で `org.acme.reactive.crud.Fruit` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この _エンティティに_ は、データベースから行を検索、更新、削除するためのいくつかのフィールドとメソッドが含まれています。これらのメソッドは、結果が取得されると非同期的に生成されるので、 `Unis` または `Multis` のいずれかを返します。反応型PostgreSQLクライアントは既に `Uni` と `Multi` のインスタンスを提供していることに注意してください。つまり、データベースからの結果を _ビジネスに適した_ オブジェクトに変換するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にデータベースを初期化する目的で、以下の内容の `DBInit` という名前のクラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、この `Fruit` クラスを `FruitResource` . `FruitResource` クラスを以下の内容に合わせて編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリソースは、 `Fruit` クラスが生成した結果に基づいて `Uni` と `Multi` のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどの例では、Quarkusが提供する _サービス_ を使用しています。また、Vert.xクライアントを直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、 `quarkus-vertx` の エクステンションが存在することを確認してください。存在しない場合は、以下のコマンドを実行して エクステンションを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or add `quarkus-vertx` into your dependencies manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、手動で `quarkus-vertx` を依存関係に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x APIのMutinyバージョンがあります。このAPIは独立してインポートできるいくつかのアーティファクトに分かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 http://smallrye.io/smallrye-reactive-utils/apidocs/ で利用可能な API を確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example.  Add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を挙げてみましょう。以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x Web ClientのMutiny APIを提供します。すると、以下のようにWebクライアントを利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 important points:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>重要なポイントは2つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションされた Vert.x インスタンスは、Vert.x の Mutiny バリアントである `io.vertx.mutiny.core.Vertx` タイプを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Web クライアントは `io.vertx.mutiny.ext.web.client.WebClient` から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny version of the Vert.x APIs also offers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x APIのMutinyバージョンも提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sendAndAwait` . `andAwait` のような `andAwait` メソッドは、結果が得られるまで呼び出し元のスレッドがブロックされていることを示しています。そのような方法でイベントループ/IOスレッドをブロックしないように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`andForget` `writeAndForget` のような `Uni` を返すメソッドが利用可能です。`andForget` は操作の成否を示す結果の `Uni` を必要としないことを示しています。しかし、サブスクライブしないと操作が発動しないことを覚えておいてください。`andForget` はこれを管理してくれるうえに、サブスクリプションも管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`toBlockingIterable` / `toBlockingStream` メソッドは、Vert.x `ReadStream` をブロッキング可能な iterable またはブロッキング可能な `java.util.Stream` に変換することができます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny は RxJava 2 と Project Reactor の型を `Uni` と `Multi` に変換するユーティリティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RxJava 2 converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RxJava 2のコンバータは以下の依存関係にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、RxJava 2 の型を返す API ( `Completable` , `Single` , `Maybe` , `Observable` , `Flowable` ) を持っている場合は、以下のように `Unis` と `Multis` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into RxJava types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Unis` と `Multis` を RxJava 型に変換することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Reactor converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Project Reactorコンバータは、以下の依存関係で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、Reactorの型を返すAPI( `Mono` , `Flux` )を持っている場合は、以下のように `Unis` と `Multis` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into Reactor types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `Unis` と `Multis` を Reactor タイプに変換することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier&lt;CompletionStage&gt;`. For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` , `CompletableFuture` , `Publisher` を使った API に対面している場合、双方向に変換することができます。まず、 `Uni` も `Multi` も `CompletionStage` から作成することも、 `Supplier&lt;CompletionStage&gt;` から作成することもできます。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` 上で、あなたはまた、 `subscribeAsCompletionStage()` を使用して `CompletionStage` を生成することができます。 `Uni` によって放出されたアイテムまたは障害を取得するだろう `CompletionStage` を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`createFrom().publisher(Publisher)` を使って `Unis` と `Multis` を `Publisher` のインスタンスから作成することもできます。 `Uni` を `toMulti` を使って `Publisher` に変換することもできます。実際、 `Multi` は `Publisher` を実装しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusでのリアクティブについて紹介します。Quarkusの機能の中には、すでにリアクティブになっているものがたくさんあります。以下のリストでは、いくつかの例を紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mailer[Sending email]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:mailer[メール送信]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:mongodb#reactive[MongoDB] と link:mongodb-panache#reactive[MongoDBをPanacheで] link:mongodb#reactive[使う]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-routes[Using reactive routes]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:reactive-routes[リアクティブルートの使用]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Metrics specification through the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Metricsエクステンションを使用してMicroProfile Metrics仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, you will learn how to enable application data caching in any CDI managed bean of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションのCDI管理されたBeanでアプリケーションデータのキャッシングを有効にする方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scenario</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シナリオ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for the next three days.  The problem is that you have to rely on an external meteorological service which only accepts requests for one day at a time and takes forever to answer.  Since the weather forecast is updated once every twelve hours, caching the service responses would definitely improve your API performances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションで、ユーザーが今後3日間の天気予報を取得できるREST APIを公開したいとします。問題は、一度に1日分のリクエストしか受け付けず、応答に時間がかかる外部の気象サービスに依存しなければならないことです。天気予報は12時間に一度更新されるので、サービスのレスポンスをキャッシュすればAPIのパフォーマンスは間違いなく向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll do that using a single Quarkus annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これをQuarkusの単一のアノテーションを使用して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create a new Quarkus project using Maven with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下のコマンドでMavenを使って新しいQuarkusプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `cache` and `resteasy-jackson` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `cache` と `resteasy-jackson` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service that will simulate an extremely slow call to the external meteorological service.  Create `src/main/java/org/acme/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、外部気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class that will contain the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、ユーザーが次の3日間の天気予報を求めたときに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/cache/WeatherForecast.java` をこのように作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy Funqy as a standalone service and invoke on Funqy functions using HTTP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Funqyをスタンドアロンサービスとしてデプロイし、HTTPを使ってFunqy関数を呼び出す方法をクイックスタートコードで説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Routes support instead, although Funqy will have less overhead than these alternatives (except Vert.x which is still super fast).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのHTTPバインディングはHTTP上のRESTの代わりではありません。Funqyは多くの異なるプロトコルや Function プロバイダに対してポータブルである必要があるので、HTTPバインディングは非常にミニマムで、リンクのようなREST機能やキャッシュコントロールや条件付きGETのようなHTTPを利用する機能を失うことになります。代わりにQuarkusのJAX-RS、Spring MVC、またはVert.x Web Reactive Routesのサポートを使用することを検討すると良いでしょう。しかしながら、Funqy はこれらの選択肢と比べてオーバーヘッドが小さいでしょう(例外として Vert.x はそれでもすごく早いですが)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the Java code, you'll see that there is no HTTP specific API.  Its just simple Java methods annotated with `@Funq`.  Simple, easy, straightforward.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javaコードを見ると、HTTP固有のAPIがないことがわかります。単純な Java メソッドに `@Funq` と注釈が付けられているだけです。シンプルで、簡単で、わかりやすいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write Funqy HTTP functions, simply include the `quarkus-funqy-http` dependency into your Quarkus `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy HTTP Function を書くには、 `quarkus-funqy-http` 依存関係をQuarkus `pom.xml` ファイルにインクルードするだけでよいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts your functions in Quarkus dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Quarkus devモードで Function が起動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL path to execute a function is the function name.  For example if your function name is `foo` then the URL path to execute the function would be `/foo`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Function を実行するための URL パスは、Function 名です。例えば、Function 名が `foo` の場合、Function を実行する URL パスは `/foo` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP POST or GET methods can be used to invoke on a function.  The return value of the function is marshalled to JSON using the Jackson JSON library.  Jackson annotations can be used.  If your function has an input parameter, a POST invocation must use JSON as the input type.  Jackson is also used here for unmarshalling.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP POST または GET メソッドを使用して Function を呼び出すことができます。Function の戻り値は、Jackson JSON ライブラリを使用して JSON にマーシャルされます。Jackson アノテーションを使用することができます。Function に入力パラメーターがある場合、POST 呼び出しは入力タイプとして JSON を使用しなければなりません。ここでもJackson はアンマーシャリングに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can invoke the `hello` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] by pointing your browser to http://localhost:8080/hello</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザを http://localhost:8080/hello に向けると、 {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `hello` Function を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoking the other functions in the quickstart requires an HTTP POST.  To execute the `greet` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/GreetingFunction.java[GreetingFunction.java] invoke this curl script.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタートの他の Function を呼び出すには、HTTP POST が必要です。 {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/GreetingFunction.java[GreetingFunction.java] で定義されている `greet` 関数を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primitive types can also be passed as input using the standard JSON mapping for them.  To execute the `toLowerCase` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プリミティブ型は、標準の JSON マッピングを使用して入力として渡すこともできます。`toLowerCase` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `toLowerCase` 関数を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To execute the `double` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `double` Function を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For GET requests, the Funqy HTTP Binding also has a query parameter mapping for function input parameters.  Only bean style classes and `java.util.Map` can be used for your input parameter.  For bean style classes, query parameter names are mapped to properties on the bean class.  Here's an example of a simple `Map`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GETリクエストのために、Funqy HTTPバインディングは、Function の入力パラメーターのためのクエリパラメーターマッピングも提供しています。Bean スタイル・クラスと `java.util.Map` だけが入力パラメーターに使用できます。Bean スタイル・クラスでは、クエリ・パラメーター名は Bean クラスのプロパティーにマッピングされます。以下は、単純な `Map` の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Key values must be a primitive type (except char) or `String`.  Values can be primitives (except char), `String`, `OffsetDateTime` or a complex bean style class.  For the above example, here's the corresponding curl request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キー値は、プリミティブ型(char を除く)か `String` でなければなりません。値は、プリミティブ型 (char を除く)、 `String` 、 `OffsetDateTime` 、または複雑な Bean スタイルのクラスを使用できます。上記の例に対して、対応する curl リクエストを以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `map` input parameter of the `hello` function would have the key value pairs: `a`-&gt;1, `b`-&gt;2.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`hello` Function の `map` 入力パラメーターは、 `a` →1, `b` →2 というキーバリューペアを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean style classes can also be use as the input parameter type.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean スタイルクラスを入力パラメーター型として使用することもできます。以下に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property values can be any primitive type except `char`. It can also be `String`, and `OffsetDateTime`.  `OffsetDateTime` query param values must be in ISO-8601 format.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーの値は、 `char` 以外の任意のプリミティブ型にすることができます。また、 `String` や `OffsetDateTime` も可能です。 `OffsetDateTime` クエリのパラメーター値は ISO-8601 形式でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can invoke on this using an HTTP GET and query parameters:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP GET とクエリパラメーターを使用して呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above request, the query parameter names are mapped to corresponding properties in the input class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のリクエストでは、クエリパラメーター名が入力クラスの対応するプロパティーにマッピングされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input class can also have nested bean classes.  Expanding on the previous example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>入力クラスは、入れ子になった Bean クラスを持つこともできます。前の例を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, query parameters for nested values use the `.` notation.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、入れ子になった値のクエリパラメーターは `.` 表記法を使用します。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.List` and `Set` are also supported as property values.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java.util.List` と `Set` もプロパティー値としてサポートされています。例えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To invoke a GET request, just list the `pets` query parameter multiple times.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GETリクエストを実行するためには、 `pets` クエリパラメーターを複数回リストアップするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more complex types, `List` and `Set` members must have an identifier in the query parameter.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より複雑な型の場合、 `List` および `Set` のメンバーは、クエリパラメーターに識別子を持つ必要があります。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `kids` query parameter must identify the kid they are referencing so that the runtime can figure out which property values go to which members in the list.  Here's the curl request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それぞれの `kids` クエリーパラメーターは、参照している kid を識別する必要があります。これにより、ランタイムはどのプロパティー値がリストのどのメンバーに属するかを把握することができます。これが curl リクエストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above URL uses the value `1` and `2` to identity the target member of the list, but any unique string can be used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のURLでは、リストの対象メンバーを識別するために `1` と `2` という値を使用していますが、任意の一意の文字列を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A property can also be a `java.util.Map`.  The key of the map can be any primitive type and `String`.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーは `java.util.Map` でもよいです。 マップのキーは、任意のプリミティブ型と `String` が利用できます。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding call would look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対応する呼び出しは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your `Map` value is a complex type, then just continue the notation by adding the property to set at the end.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Map` の値が複雑な型であれば、最後に set するプロパティーを追加して表記を続けるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hello World Quarkus アプリの作成方法を説明します。 このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>機能テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の JDK をインストール済みで、Maven が意図した Java を使用するかわからない場合は、予期しない結果になることがあります。Maven が使用する JDK は、`mvn --version` コマンドで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、`hello` エンドポイントを提供する簡単なアプリケーションを作成します。依存性の注入を示すために、このエンドポイントでは `greeting` Bean を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、エンドポイントのテストについても解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started` {quickstarts-tree-url}/getting-started[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cmd を使っている場合 (バックスラッシュは使わないでください)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Powershell を使用する場合は、`-D` パラメーターを二重引用符で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `./getting-started` に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.getting.started.GreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.getting.start.GreetingResource` リソースは、`/hello` で公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたら、`pom.xml` を確認してください。 Quarkus の BOM のインポートが存在することが分かります。これにより、異なる Quarkus の依存関係のバージョンを省略できます。さらに、アプリケーションのパッケージングと開発モードを処理する `quarkus-maven-plugin` が存在することが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の部分に注目すると、REST アプリケーションの開発を可能にするエクステンションを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト作成時には、 `src/main/java/org/acme/getting/started/GreetingResource.java` ファイルが以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "hello" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは非常にシンプルな REST エンドポイントで、"/hello" 上のリクエストに "hello" を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バニラ JAX-RS との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、`Application` クラスを作成する必要がありません。作成は可能ですが、必須ではありません。加えて、リソースは 1 つのみが作成され、リクエスト毎に 1 つではありません。これは、異なる `*Scoped` アノテーション (`ApplicationScoped`、`RequestScoped` など) を使用することで設定可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application.  Use: `./mvnw compile quarkus:dev`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを実行する準備が整いました。 `./mvnw compile quarkus:dev` を実行してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CTRL+C` を押してアプリケーションを停止したり、アプリケーションを起動したままにでき、快適な操作を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the link:cdi[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の依存性注入は、Quarkus のアーキテクチャに合わせて調整された CDI ベースの依存性注入ソリューションである ArC をベースにしています。 CDI が初めての方は、 link:cdi[CDI入門] ガイドをお読みになることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the link:cdi-reference[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は CDI 機能のサブセットのみを実装しており、非標準の機能や特定の API が付属しています。詳細は、 link:cdi-reference[Contexts and Dependency Injection ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/getting/started/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを変更してコンパニオン Bean を追加してみましょう。 以下の内容で `src/main/java/org/acme/getting/started/GreetingService.java` ファイルを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingResource` クラスを編集して `GreetingService` を注入し、それを使って新しいエンドポイントを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application, restart the application with `./mvnw compile quarkus:dev`.  Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを停止した場合は、`./mvnw compile quarkus:dev` でアプリケーションを再起動します。 そして、エンドポイントが `hello quarkus` を期待通りに返すことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus:dev` は、開発モードで Quarkus を実行します。これにより、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に反映されます。 これは、設定プロパティーファイルなどのリソースファイルに対しても機能します。 ブラウザをリフレッシュすると、ワークスペースのスキャンがトリガーされ、変更が検出された場合、Java ファイルが再コンパイルされ、アプリケーションが再デプロイされます。リクエストは、再デプロイされたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページで通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはポート `5005` のデバッガーもリッスンします。デバッガーがアタッチされるのを待ってから実行する場合は、コマンドラインで `-Dsuspend` を渡してください。デバッガーを全く必要としない場合は `-Ddebug=false` を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、ここまでは問題ありませんが、念のためにテストをした方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated `pom.xml` file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` ファイルでは、2 つのテスト依存関係を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[Junit 5] tests.  Because of this, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は https://junit.org/junit5/[Junit 5] テストをサポートしています。 デフォルトのバージョンでは Junit 5 をサポートしていないため、 https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] のバージョンを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `java.util.logging` システムプロパティーを設定して、テストが正しいログマネージャーを使用することを確認し、 `maven.home` からカスタム設定が適用されることを確認します (該当する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/getting/started/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたプロジェクトには簡単なテストが含まれています。 `src/test/java/org/acme/getting/started/GreetingResourceTest.java` を以下の内容に合わせて編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusTest` ランナーを使うことで、テストの前にアプリケーションを起動するように JUnit に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP レスポンスのステータスコードと内容を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのテストでは http://rest-assured.io/[RestAssured] を使用していますが、お好きなライブラリーをご自由にお使いください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは Maven を使って実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、IDE から直接テストを実行することもできます (最初にアプリケーションを停止したことを確認してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、実行中のアプリケーションと競合しないように、テストはポート `8081` で実行されます。 RestAssured は、この 8081 ポートを使用するように自動的にを設定されます。別のクライアントを使用したい場合は、`@TestHTTPResource` アノテーションを使用して、テストされたアプリケーションの URL をテストクラスのフィールドに直接注入する必要があります。このフィールドは `String`、 `URL`、`URI` のいずれかの型になります。このアノテーションにはテストパスの値を指定することもできます。例えば、`/myservlet` にマップされたサーブレットをテストしたい場合、次のようにテストに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートは、`quarkus.http.test-port` 設定プロパティーで制御できます。Quarkus はまた、インジェクションを使用できない場合のためにベースとなるテストURLに設定される `test.url` というシステムプロパティーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトや外部モジュールとの連携</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus はビルド時に https://github.com/wildfly/jandex[Jandex] を多用して、さまざまなクラスやアノテーションを発見しています。これをすぐに認識できるアプリケーションの1つは、CDI Beanのディスカバリーです。 その結果、このビルド時のディスカバリーが適切に設定されていないと、Quarkusのエクステンションのほとんどが正しく動作しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このインデックスは、Maven と Gradle プラグインのおかげで、Quarkus が設定されているプロジェクト上にデフォルトで作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the link:maven-tooling#multi-module-maven[Maven] or link:gradle-tooling#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、マルチモジュールプロジェクトで作業する場合は、 link:maven-toolsing#multi-module-maven[Maven] または link:gradle-toolsing#multi-module-maven[Gradle] ガイドの 「マルチモジュールプロジェクトでの作業」のセクションを必ず読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>外部モジュール (例えば、すべてのドメインオブジェクトのための外部ライブラリ) を使用する予定がある場合は、Jandex プラグインを追加するか (変更できる場合)、 `application.properties` 内の `quarkus.index-dependency` プロパティーを使って (モジュールを変更できない場合に便利です)、これらのモジュールをインデックス作成プロセスに知らせておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、CDI ガイドの link:cdi-reference#bean_discovery[Bean Discovery] セクションを必ずお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージングとアプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using `./mvnw package`.  It produces several outputs in `/target`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは `./mvnw package` を使ってパッケージングされています。 これは `/target` に 2 つの jar ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar`: プロジェクトのクラスとリソースだけを含み、Maven ビルドによって生成される通常のアーティファクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getting-started-1.0.0-SNAPSHOT-runner.jar`: 実行可能な _jar_ です。依存関係が `target/lib` ディレクトリーにコピーされているので、これは _über-jar_ ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar` を使ってアプリケーションを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application soemwhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをどこかに(通常はコンテナに)デプロイしたい場合は、 `quarkus-app` ディレクトリ全体をデプロイする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行する前に、ホットリロードモードを停止する (CTRL+C) ことを忘れないでください 。停止しないと、ポートが衝突します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section assumes that the configuration property `quarkus.package.type` has either not been configured explicitly, or that it has been set to `legacy-jar` (in `application.properties` or any of the other supported configuration sources).  When the property has been set to `fast-jar` (which will become in Quarkus 1.12), then the result of executing `./mvnw package` is a new directory under `target` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションでは、設定プロパティ `quarkus.package.type` が明示的に設定されていないか、または `application.properties` またはその他のサポートされている設定ソースで `legacy-jar` に設定されていることを前提としています。プロパティが `fast-jar` に設定されている場合（Quarkus 1.12 で設定されます）、 `./mvnw package` を実行した結果、 `target` の下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バナーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus アプリケーションが起動すると (通常モードまたは開発モードで) 、ASCII アートバナーが表示されます。バナーを無効にするには、 `application.properties` で `quarkus.banner.enabled=false` を設定するか、 `Dquarkus.banner.enabled=false` の Java システムプロパティーを設定するか、 `QUARKUS_BANNER_ENABLED` 環境変数を `false` に設定します。 さらに、 `src/main/resources` にバナーファイルを配置し、 `application.properties` に `quarkus.banner.path=nam-of-file` を設定することで、ユーザーはカスタムのバナーを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the link:building-native-image[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the link:getting-started-reactive[Getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus を使用したアプリケーションの作成について説明しました。 しかし、まだまだ多くのことがあります。 link:built-native-image[ネイティブ実行可能ファイルのビルド] では、ネイティブ実行ファイルの作成とコンテナーへのパッケージングを説明します。 リアクティブに興味がある場合は、link:get-started-reactive[リアクティブ入門ガイド] をお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the link:tooling[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、link:tooling[ツールガイド] のドキュメントでは、以下の方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>enable the _development mode_ (hot reload)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_development mode_ (ホットリロード) を有効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `kubernetes-config` extension which allows developers to use Kubernetes https://cloud.google.com/kubernetes-engine/docs/concepts/configmap[ConfigMaps] and https://cloud.google.com/kubernetes-engine/docs/concepts/secret[Secrets] as a configuration source, without having to mount them into the https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pod] running the Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、 `kubernetes-config` エクステンションが含まれており、開発者はQuarkusアプリケーションを実行している link:https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pod] にマウントしなくても、Kubernetes link:https://cloud.google.com/kubernetes-engine/docs/concepts/configmap[ConfigMaps] と link:https://cloud.google.com/kubernetes-engine/docs/concepts/secret[Secrets] を設定ソースとして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `kubernetes-config` extension by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで以下のコマンドを実行して、 `kubernetes-config` エクステンションを追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension works by reading ConfigMaps and Secrets directly from the Kubernetes API server using the link:kubernetes-client[Kubernetes Client].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、Kubernet link:kubernetes-client[Kubernates クライアント] を使用してKubernetes APIサーバーから直接ConfigMapsとSecretsを読み込むことで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension understands the following types of ConfigMaps and Secrets as input sources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、以下のタイプの ConfigMaps と Secrets を入力ソースとして理解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMaps and Secrets that contain literal data (see https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values[this] for an example on how to create one)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リテラルデータを含む ConfigMaps と Secrets (作成方法の例は link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values[こちら] を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMaps and Secrets created from files named `application.properties`, `application.yaml` or `application.yml` (see https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files[this] for an example on how to create one).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsとSecretsは、 `application.properties` 、 `application.yaml` 、または `application.yml` という名前のファイルから作成されます(作成方法の例は link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files[こちら] を参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to explicitly enable the retrieval of ConfigMaps and Secrets by setting `quarkus.kubernetes-config.enabled=true`.  The default is `false` in order to make it easy to test the application locally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMaps と Secrets の取得を明示的に有効にするには、 `quarkus.kubernetes-config.enabled=true` を設定する必要があります。デフォルトは `false` で、ローカルでのアプリケーションのテストを容易にするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Afterwards, set the `quarkus.kubernetes-config.config-maps` property to configure which ConfigMaps should be used.  Set the `quarkus.kubernetes-config.secrets` property to configure which Secrets should be used.  To access ConfigMaps and Secrets from a specific namespace, you can set the `quarkus.kubernetes-config.namespace` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、 `quarkus.kubernetes-config.config-maps` プロパティーを設定して、どの ConfigMaps を使用するかを設定します。 `quarkus.kubernetes-config.secrets` プロパティーを設定して、どの Secrets を使用するかを設定します。特定の名前空間の
 ConfigMaps と Secrets にアクセスするには、 `quarkus.kubernetes-config.namespace` プロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Priority of obtained properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>取得したプロパティーの優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties obtained from the ConfigMaps and Secrets have a higher priority than (i.e. they override) any properties of the same name that are found in `application.properties` (or the YAML equivalents), but they have lower priority than properties set via Environment Variables or Java System Properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsとSecretsから取得したプロパティーは、 `application.properties` (またはYAMLの等価物)にある同名のプロパティーよりも高い優先度を持っています(すなわち、それらは上書きされます)が、環境変数やJavaシステムプロパティーを介して設定されたプロパティーよりも優先度は低くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when multiple ConfigMaps (or Secrets) are used, ConfigMaps (or Secrets) defined later in the list have a higher priority that ConfigMaps defined earlier in the list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、複数のConfigMap(またはSecret)を使用している場合、後から定義されたConfigMap(またはSecret)は、先に定義されたConfigMap(またはSecret)よりも優先度が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, when both ConfigMaps and Secrets are used, the latter always a higher priority than the former.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ConfigMapsとSecretsの両方を使用する場合、常に後者の方が前者よりも優先度が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since reading ConfigMaps involves interacting with the Kubernetes API Server, when https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] is enabled on the cluster, the https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount] that is used to run the application needs to have the proper permissions for such access.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsの読み込みにはKubernetes API Serverとのやりとりが含まれるため、クラスター上で link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] が有効になっている場合、アプリケーションを実行するために使用される link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount] に適切なアクセス権限が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thankfully, when using the `kubernetes-config` extension along with the link:deploying-to-kubernetes[Kubernetes] extension, all the necessary Kubernetes resources to make that happen are automatically generated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ありがたいことに、 link:deploying-to-kubernetes[Kubernetes] エクステンションと一緒に `kubernetes-config` エクステンションを使うと、それを実現するために必要なKubernetesリソースがすべて自動的に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secrets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Secrets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the link:deploying-to-kubernetes[Kubernetes] extension doesn't generate the necessary resources to allow accessing secrets.  Set `quarkus.kubernetes-config.secrets.enabled=true` to generate the necessary role and corresponding role binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 link:deploying-to-kubernetes[Kubernetes] エクステンションは秘密にアクセスできるようにするために必要なリソースを生成しません。 `quarkus.kubernetes-config.secrets.enabled=true` を設定して、必要なロールと対応するロールバインディングを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのQuarkusアプリケーションを作成する方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのアプリケーションを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用したリアクティブアプリケーションの開発については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMやMandrelを使ってネイティブの実行可能ファイルをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの開発を非常に高速で楽しいものにするQuarkus開発者ツールチェーンをご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツールの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>core</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>core</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードの中でハードコードされた値を使用することはできません (たとえ誰もがどこかの時点でそうしていたとしても ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを設定する為の詳細について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションごとのすべての設定プロパティのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての設定プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、アプリケーションの停止時や起動時に通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの初期化と終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのDIソリューションは、 [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec )仕様に基づいています。このガイドでは、CDIの基本を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDIのQuarkus実装についてさらに詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>arc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の内容をカバーしています：
* JVM モードでのテスト 
* ネイティブモードでのテスト 
* テストへのリソースの注入
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスガイドでは、Quarkusを使用してコマンドラインアプリケーションを開発する方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native images to support SSL, as native images don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ネイティブイメージがそのままではSSLをサポートしていないため、ネイティブイメージをSSLに対応させる方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Images</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージでのSSLの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with our implementation of MicroProfile Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Context Propagation の実装を使ってコンテキスト情報を渡す方法の詳細については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキストの伝搬</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、アプリケーションをネイティブ実行可能ファイルにコンパイルする際に遭遇する問題を解決するためのヒントをまとめたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ウェブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON は現在、マイクロサービス間の共通言語となっています。このガイドでは、REST サービスが JSON ペイロードを消費して生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable reactive REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSとRESTEasyReactiveを使用して拡張性の高いリアクティブRESTサービスを開発する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Highly Scalable Reactive REST Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>高度にスケーラブルなリアクティブRESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM REST Data with Panacheは、JAX-RSとHibernate ORMをベースにしたCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなREST CRUDサービスの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、RESTサービスでHibernate Validator/Bean Validationを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST Clientを使ってREST API(JSONなど)とほとんど手間をかけずにやりとりする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTクライアントを使う（JSONを含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST クライアントを使用してマルチパート REST リクエストを送信する方法、典型的にはドキュメントをアップロードする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチパートでのRESTクライアントの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize MicroProfile JWT RBAC to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アプリケーションがMicroProfile JWT RBACを利用してJAX-RSエンドポイントへのセキュアなアクセスを提供する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがWeb Socketを利用してインタラクティブなウェブアプリケーションを作成する方法を説明します。定型的なWeb Socketアプリケーションなので、簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenAPI エクステンションを使用して OpenAPI ディスクリプタを生成し、Swagger UI フロントエンドを取得して REST エンドポイントをテストする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのVert.xベースのHTTPレイヤーの設定についての詳細と、サーブレットを使用している場合のUndertowについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Fault Toleranceエクステンションを使用してMicroProfile Fault Tolerance仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォールトトレランスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、リアクティブルートの使用方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage Eclipse MicroProfile GraphQL to consume and implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Eclipse MicroProfile GraphQL を活用して GraphQL サービスを利用したり、実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用すると、データソースを簡単に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの完全な息吹を提供します。Quarkusでは見事に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。
複雑なマッピングを可能にしますが、単純で一般的なマッピングをつまらなくするものではありません。
Panacheは、エンティティを些細なことではなく、書いていて楽しいものにすることに焦点を当てています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>KotlinプロジェクトでHibernate ORMをPanacheで使う場合に固有の事情について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Searchは、Elasticsearchクラスタ内のエンティティをインデックス化し、Hibernate ORMベースのすべてのアプリケーションで簡単に全文検索を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはTransaction Managerが付属しており、これを使用してアプリケーションにトランザクションを調整して公開します。
永続性を扱う各エクステンションは、これと統合されます。
そして、CDIを介して明示的にトランザクションと対話することになります。
このガイドでは、これらすべてについて説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Blaze-Persistenceを使用してデータとDTOレイヤーを簡素化する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、シンプルなアノテーションを使用してCDI Beanの高価なメソッド呼び出しをキャッシュする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションデータのキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Flyway エクステンションを使用してスキーマのマイグレーションを管理する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、スキーマのマイグレーションを管理するための Liquibase エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients for MySQL and PostgreSQL in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusのMySQLおよびPostgreSQL用のReactive SQLクライアントの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ SQL クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、低レベルまたは高レベルのRESTクライアントを使用してElasticsearchクラスタを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでMongoDBを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アクティブなレコードやリポジトリを使ったMongoDBの使い方について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでRedisデータストアを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでNeo4jグラフデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/neo4j</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/neo4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでApache Cassandra NoSQLデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon DynamoDBデータベースを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon S3クラウドストレージの使い方を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-s3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-s3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ソフトウェア・トランザクション・メモリ(STM)の使用法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソフトウェア・トランザクション・メモリの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>messaging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメッセージングでのAMQPの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、イベントバスを使用して異なるBeanがどのように相互作用するかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントバスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが、Apache Qpid JMSを使用してAMQP 1.0でJMSメッセージングを使用する方法、またはApache ActiveMQ Artemis JMSを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、Quarkusのすべてのセキュリティに関するエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティの概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが.propertiesファイルを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>.propertiesファイルでセキュリティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してHibernate ORMを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jpa</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがLDAPディレクトリを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Keycloak to protect your JAX-RS applications using bearer token authorization, where these tokens are issued by a Keycloak server.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloakを使用して、ベアラートークン認証を使用してJAX-RSアプリケーションを保護する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sso</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>sso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect Extension to protect your web application based on the Authorization Code Flow using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusを使用してAuthorization Code Flowに基づいてWebアプリケーションを保護するためにOpenID Connect Extensionを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、単一のアプリケーションから複数のテナントにサービスを提供できるように、OpenID Connectアプリケーションがマルチテナントをサポートする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloak認可サービスを使用して保護されたリソースへのアクセスを認可する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenID ConnectとOAuth2クライアント、フィルタを使用してアクセストークンを取得、更新、伝播する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、HashiCorp Vaultを使用してQuarkusにクレデンシャルを安全に保存する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、HashiCorp Vaultを「サービスとしての暗号化」に利用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヴォールトトランジットシークレットエンジンの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-transit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-transit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの資格情報をVaultに保存して、機密を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusがサポートする、Vaultへの認証を行うためのさまざまな方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-auth</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-auth</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vault の資格情報プロバイダを使用する方法、または独自のカスタムのものを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>business-automation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>business-automation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスオートメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OptaPlannerの制約解決人工知能（AI）を使用してQuarkusアプリケーションを作成するプロセスを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Apache Camel でのシステム統合について説明します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command-line</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>command-line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli エクステンションでコマンドラインアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangを使った簡単なQuarkusベースのスクリプティング方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのビルドの一部として、Jib、S2I、またはDockerを使用してコンテナイメージをビルドしてプッシュする方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドコンテナイメージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Kubernetes上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenShift上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsをQuarkusアプリケーションの設定ソースとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Fabric8 Kubernetes クライアントを使用して Kubernetes クラスタと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションをMicrosoft Azure Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAzure Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusベースのAmazon Lambdasをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAmazon Lambdaとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションをGoogle Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusベースのGoogle Cloud Functionsを導入する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをGoogle Cloud Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Funqyフレームワークの基本、シンプルなポータブルクロスプロバイダーCloud Function APIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのHTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのAmazon Lambdaバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのAmazon Lambda HTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのKnative Eventsバインディングについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのAzure Functions HTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのGoogle Cloud Platform Functionsバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのGoogle Cloud Platform FunctionsのHTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon Key Management Serviceの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-kms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-kms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon Identity and Access Managementの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-iam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-iam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Mail Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-ses</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-ses</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Notification Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sns</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-sns</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Queue Serviceを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>observability</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヘルスチェックの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-health</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicrometerエクステンションを使用してメトリクスを収集する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Sentry を使ってアプリケーションを監視し、例外が発生したときに通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging-sentry</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/logging-sentry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Graylog Extended Log Format (GELF) を使用して Logstash または Fluentd でログを集中管理する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>serialization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シリアル化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションにgRPCサービスを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCサービスを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の内容について説明します。
* Maven の設定 
* 新しいプロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下の内容をカバーしています。
* Gradle の設定 
* 新規プロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションのテストカバレッジを測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの適用範囲の測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>compatibility</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションにはCDIアノテーションを使用することが推奨されていますが、Quarkusはspring-diエクステンションの形でSpring依存性インジェクション用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントの定義にはJAX-RSアノテーションを使用することが推奨されていますが、QuarkusはSpring-webエクステンションという形でSpring Webとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データレイヤーにはHibernate ORM with Panacheを使用することが推奨されていますが、Quarkusはspring-data-jpaエクステンションの形でSpring Data JPAの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Spring Data RESTは、当社のSpring Data互換性レイヤをベースにCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのセキュリティレイヤーを使用してアプリケーションを保護することが推奨されていますが、Quarkusはspring-securityのエクステンションの形でSpring Securityとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションレベルのキャッシングにはCacheエクステンションを使用することが推奨されていますが、QuarkusはSpring Cacheエクステンションの形でSpring Cacheの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SchedulerやQuartzのエクステンションを使ってタスクをスケジュールすることが推奨されていますが、QuarkusはSpring-scheduledエクステンションの形でSpring Scheduledとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Config アノテーションの代わりに Spring Boot の `@ConfigurationProperties`  を使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、Spring-cloud-config-clientエクステンションの形でSpring Cloud Config用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>miscellaneous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>miscellaneous</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクをスケジュールする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>定期的なタスクのスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラーエクステンションの詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたタスクにクラスタリングのサポートが必要ですか？このガイドでは、そのための Quartz エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメールクライアントを使用してQuarkusアプリケーションからメールを送信する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メールの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteのテンプレートエンジンを使ったアプリケーションでのテンプレートの使用方法については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteのテンプレートエンジンについて知りたい方は、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Tika ツールキットを使ってドキュメントからコンテンツを抽出する方法についての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tika</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでVert.xを使用してリアクティブアプリケーションを構築する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、JGitを使ってGitリポジトリにアクセスする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jgit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/jgit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが実行時にConsulから設定プロパティを読み取る方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/consul-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/consul-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションのフットプリントを最適に測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パフォーマンスの測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>alternative-languages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>alternative-languages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Kotlinの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>writing-extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡単なエクステンションを構築する方法をステップバイステップで学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのエクステンションのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>building-my-first-extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>building-my-first-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをQuarkusのCDIコンテナに統合する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cdi-integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cdi-integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを Dev UI に機能貢献させる方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dev-ui</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>dev-ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションで消費/生産できるすべての BuildItems を調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのビルドアイテム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all-builditems</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>all-builditems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションは、可能な限り多くの作業をビルド処理にプッシュすることで、アプリケーションを最適化します。このガイドでは、Quarkusエクステンションの根拠を説明し、独自のエクステンションを作成する方法を説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自のエクステンションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusクラスのローディングインフラストラクチャについてはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスローディングリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの世界でプラットフォームと呼ばれているものについては、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォームのコンセプトを理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライセンスは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0] でライセンスされているオープンソースプロジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どこから入手できますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはMaven Centralで公開されています。必要な link:/extensions[which extensions] を確認し、`pom.xml` にインポートするだけでQuarkusを入手できます。link:/get-started[Getting Started guides] からQuarkusの体験を始めることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、Quarkusは安定していると考えています。Quarkusのアプリが使用する機能の95%は、Hibernate ORM、Eclipse Vert.x、Netty、RESTEasyなどのエコシステムによって提供されていることを忘れないでください。これらのライブラリは極めて盤石です:)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://code.quarkus.io/[code.quarkus.io]にアクセスして、特定の拡張子が_安定_(デフォルト)か_プレビュー_かを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの主な目標の1つは、拡張性の容易さと活気のあるエコシステムの構築です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションはプロジェクトの依存関係だと考えてください。エクステンションは、フレームワークまたはテクノロジーをQuarkusアプリケーションに構成、起動、および統合します。また、アプリケーションをネイティブにコンパイルするために、GraalVMに適切な情報を提供するという面倒な作業もすべて行います。これにより、サードパーティのプロジェクトは、GraalVMをターゲットにしやすくするために我々が行った作業を簡単に利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションステータスとは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、Quarkusエコシステムに入る際に、さまざまな成熟度を持ちます。ステータスは、信頼度の期待値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*安定*:下位互換性とエコシステムでの存在感が非常に重要視されています。アプリケーションはこれらのエクステンションに安全に依存できます。プレビューまたは実験的(大部分)としてマークされていないエクステンションは安定しています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*プレビュー*:下位互換性とエコシステム内での存在感は保証されません。特定の改善には、構成またはAPIの変更が必要になる場合があり、_安定_になる計画が進行中です。このようなエクステンションは、成熟プロセスの途中です。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*実験的*:アイデアを成熟させるために、早期のフィードバックが必要です。ソリューションが成熟するまで、プラットフォーム内での安定性や長期的な存在は保証されません。このようなエクステンションは、成熟プロセスの初期段階にあります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションステータスは、https://code.quarkus.io[code.quarkus.io] またはエクステンション link:/guides/[guides] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを作成できますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論です! Quarkusの「初期」チームの外部でかなりの数のエクステンションが作成されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはオープンエコシステムであり、人々がアプリを作成するために必要なすべてのエクステンションが存在することを期待しています。エクステンションを個別のリポジトリと個別のGAVで公開し、Quarkusコアとは独立してMavenリポジトリで公開できるようにするために取り組んでいます。これにより、公開プロセスが大幅に簡素化されます。近いうちのニュースを期待してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/master/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の制限の1つは、エクステンションはOpenJDKとGraalVMの両方のネイティブ実行可能ファイルで機能する必要があるということです。これは、Quarkusユーザーに提供する保証です(アプリのクロスコンパイル)。エクステンションを改善して完全に「Quarked」し、Quarkusの恩恵を受けるための成熟度モデルがあり、すべて段階的に実行されます。 https://quarkus.io/community/#discussions[メーリングリスト] にアクセスして、アイデアについて話し合い、サポートを受けてください。また、https://quarkus.io/guides/writing-extensions[エクステンションガイドの作成] を読み始めることも、 https://github.com/quarkusio/quarkus/tree/master/extensions[既存のエクステンション] からインスピレーションを得ることもできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://www.graalvm.org[GraalVM] は、さまざまな異なる言語で記述されたアプリケーションを実行するためのユニバーサル仮想マシンであり、JVMバイトコードをネイティブ実行可能ファイルにコンパイルする機能を提供します(このネイティブ実行可能ファイルは、SubstrateVMと呼ばれる特別な仮想マシンを実行します)。これらのネイティブ実行可能ファイルは、従来のJVMよりもはるかに高速に起動し、使用するメモリーを大幅に削減できますが、すべてのJVM機能がサポートされているわけではなく、一部は通常よりも制限されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、デフォルトでは、クラス/メンバーがリフレクション用に明示的に登録されていない限り、GraalVMでのリフレクションは機能しません。これは通常、すべてのクラス、メソッド、フィールド、コンストラクターをJSONファイルにリストし、これをパラメーターとしてネイティブイメージビルドに渡すことで実現されます。これは、最も些細なプロジェクトを除いて、明らかに非常に面倒になります。 Quarkusは、これらの注釈を簡単に回避し、何を登録するかをプログラムで決定できるフレームワークを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 命令型プログラミングとリアクティブプログラミングをどのように統合しますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/continuum[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/continuum[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/container-first[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/container-first[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 標準についてどう考えていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/standards[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/standards[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 開発者の満足度を向上させるために何に取り組んでいますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/developer-joy[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/developer-joy[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through Your First Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Bootstrapping an application
- Creating a JAX-RS endpoint
- Injecting beans
- Functional tests
- Packaging of the application
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下をカバーします:
- アプリケーションの起動
- JAX-RSエンドポイントの作成
- Beanの挿入
- ファンクションテスト
- アプリケーションのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.
This guide covers:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでリアクティブアプリケーションを作成する方法を学習し、Quarkusによって提供される様々なリアクティブ機能を学びます。
このガイドは以下をカバーします：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのクイック起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt; では、数クリックでQuarkusアプリケーションを起動し、エクステンションエコシステムを発見出来ます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus applications can be made with.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを作成する際に利用できる幅広いテクノロジーをご覧ください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Compiling the application to a native executable
- The packaging of an application in a Docker container
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下をカバーします：
- アプリケーションのネイティブ実行可能ファイルへのコンパイル
- アプリケーションのDockerコンテナへのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide requires:
- Completion of the [Creating Your First Application]({{site.baseurl}}/guides/getting-started) guide
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下を必要とします:
- [最初のアプリケーションの作成]({{site.baseurl}}/guides/getting-started) ガイドの完了
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application.
In this guide, we will explore:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には開発者がライブリロードからKubernetesへのアプリケーションのデプロイまで、ツールチェインが付属しています。
このガイドでは、以下について説明します：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
  </body>
</tmx>
