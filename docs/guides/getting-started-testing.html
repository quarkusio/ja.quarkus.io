<!DOCTYPE html>
<html lang="ja">







<head>
  <title>アプリケーションのテスト - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="
  connect-src 'self' https://dpm.demdex.net https://adobedc.demdex.net https://analytics.ossupstream.org/ https://search.quarkus.io https://smetrics.redhat.com; 
  script-src 'self' 'unsafe-inline' 'unsafe-eval'
      
      https://assets.adobedtm.com
      js.bizographics.com
      https://www.redhat.com
      https://static.redhat.com
      https://app.requestly.io/
      jsonip.com
      https://ajax.googleapis.com
      https://use.fontawesome.com
      http://www.youtube.com
      http://www.googleadservices.com
      https://googleads.g.doubleclick.net
      https://giscus.app
      https://analytics.ossupstream.org/
      https://app.mailjet.com;

  style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; 
  img-src 'self' * data:; 
  media-src 'self'; 
  frame-src https://redhat.demdex.net https://www.youtube.com https://player.restream.io https://app.mailjet.com http://xy0p2.mjt.lu https://mj.quarkus.io https://giscus.app; 
  base-uri 'none'; 
  object-src 'none'; 
  form-action 'none'; 
  font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/guides/getting-started-testing" />
  <meta property="og:title" content="アプリケーションのテスト" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/getting-started-testing">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />  
  <script src="/assets/javascript/tracking.js"></script>
  
  <script src="/assets/javascript/colormode.js" type="text/javascript"></script>

</head>

<body class="guides">

  


<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io/guides/getting-started-testing">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
        <div class="logo-wrapper">
           <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
        </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="#">Why<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/performance" class="">パフォーマンス</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
          <li><a href="/versatility" class="">多用途性</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/spring" class="">USING SPRING?</a></li>
          <li class="tertiarydropdown">
            <span href="#">AI<i class="fas fa-chevron-down"></i></span>
            <ul class="tertiarymenu">
              <li><a href="/ai" class="">AI OVERVIEW</a></li>
              <li><a href="/java-for-ai" class="">JAVA FOR AI</a></li>
              <li><a href="/quarkus-for-ai" class="">WHY QUARKUS FOR AI</a></li>
              <li><a href="/ai-blueprints" class="">AI BLUEPRINTS</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Learn<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ドキュメント</a></li>
          <li><a href="/userstories/" class="">ユーザーストーリー</a></li>  
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="#">Extensions<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          
          <!-- Note that quarkus.io is hardcoded here, because it is the only url which supports extensions -->
<li><a href="https://quarkus.io/extensions/" class="">エクステンションを探す</a></li>
          <li><a href="/faq/#what-is-a-quarkus-extension" class="">エクステンションの使用</a></li>
          <li><a href="/guides/writing-extensions" class="">エクステンションの作成</a></li>
          <li><a href="https://hub.quarkiverse.io" class="">エクステンションの共有</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Community<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/working-groups" class="">ワーキンググループ</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="">ロードマップ</a></li>
          <li><a href="/benefactors" class="">BENEFACTORS</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/guides/getting-started-testing" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://pt.quarkus.io/guides/getting-started-testing">ポルトガル（BR）</a></li>
          <li><a href="https://es.quarkus.io/guides/getting-started-testing">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/guides/getting-started-testing">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/guides/getting-started-testing">日本語</a></li>
          </ul>
      </li>
      <li>
        <span href="#" class="modeswitcher" id='theme-toggle'><i class="fas
fa-sun"></i><i class="fas fa-moon"></i><i class="fas fa-cog"></i></span>
      </li>
    </ul>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    







<section class="full-width-version-bg flexfilterbar guides">
  <div class="guideflexcontainer">
    <div class="docslink">
      <a class="returnlink" href="/guides/"> Back to Guides</a>
    </div>
    <div class="flexlabel">
      <label>バージョン:</label>
    </div>
    <div class="guidepulldown version">
    <select id="guide-version-dropdown">
      
        
        
        <option value="main" >Main - SNAPSHOT</option>
        
        
        
        <option value="latest" selected>3.28.4 - Latest</option>
        
        
        
        <option value="3.27" >3.27</option>
        
        
        
        <option value="3.20" >3.20</option>
        
        
        
        <option value="3.15" >3.15</option>
        
        
        
        <option value="3.8" >3.8</option>
        </select>
    </div>
  </div>
</section>

<div class="guide">
  <div class="grid-wrapper">
    <div class="grid__item width-8-12 width-12-12-m">
      
      <a class="editlink" href="https://github.com/quarkusio/quarkus/edit/main/docs/src/main/asciidoc/getting-started-testing.adoc">このページを編集</a>
      
      <h1 class="text-caps">アプリケーションのテスト </h1>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkusアプリケーションのテスト方法について説明します。
このガイドでは、以下の内容について説明します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JVM モードでのテスト</p>
</li>
<li>
<p>ネイティブモードでのテスト</p>
</li>
<li>
<p>テストへのリソースの注入</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>1. 要件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このガイドを完成させるには、以下が必要です:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>約15分</p>
</li>
<li>
<p>IDE</p>
</li>
<li>
<p>JDK 17+がインストールされ、 <code>JAVA_HOME</code> が適切に設定されていること</p>
</li>
<li>
<p>Apache Maven 3.9.11</p>
</li>
<li>
<p>使用したい場合は、 <a href="cli-tooling.html">Quarkus CLI</a></p>
</li>
<li>
<p>ネイティブ実行可能ファイルをビルドしたい場合、MandrelまたはGraalVM（あるいはネイティブなコンテナビルドを使用する場合はDocker）をインストールし、 <a href="building-native-image.html#configuring-graalvm">適切に設定</a>していること</p>
</li>
<li>
<p><a href="getting-started.html">入門ガイド</a>に掲載されている、完了済のGreeterアプリケーション</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>2. アーキテクチャー</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このガイドでは、入門ガイドの一部として作成された最初のテストを拡張します。
テストへのインジェクションと、ネイティブ実行可能ファイルをテストする方法もカバーしています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Quarkus は継続的テストをサポートしていますが、これについては <a href="continuous-testing">継続的テストガイド</a> で説明しています。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solution"><a class="anchor" href="#solution"></a>3. ソリューション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>次の章で紹介する手順に沿って、ステップを踏んでアプリケーションを作成することを推奨します。
ただし、完成した例にそのまま進むこともできます。</p>
</div>
<div class="paragraph">
<p>Git リポジトリをクローンする: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code> または <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">アーカイブ</a> をダウンロードする。</p>
</div>
<div class="paragraph">
<p>ソリューションは <code>getting-started-testing</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/getting-started-testing">ディレクトリー</a> にあります。</p>
</div>
<div class="paragraph">
<p>このガイドでは、 <code>getting-started</code> ディレクトリーの完成したアプリケーションをすでに持っていることを前提としています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="recap-of-http-based-testing-in-jvm-mode"><a class="anchor" href="#recap-of-http-based-testing-in-jvm-mode"></a>4. JVM モードでの HTTP ベースのテストの要約</h2>
<div class="sectionbody">
<div class="paragraph">
<p>「はじめに」のサンプルから始めた場合は、正しいツールマップの設定を含めて、
すでにテストが完了しているはずです。</p>
</div>
<div class="paragraph">
<p>ビルドファイルには、2 つのテスト依存関係が表示されます。</p>
</div>
<div class="sidebarblock primary asciidoc-tabs-sync-maven">
<div class="content">
<div class="title">Maven</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock secondary asciidoc-tabs-sync-gradle">
<div class="content">
<div class="title">Gradle</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    testImplementation("io.quarkus:quarkus-junit5")
    testImplementation("io.rest-assured:rest-assured")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>quarkus-junit5</code> は、テストフレームワークを制御する <code>@QuarkusTest</code> アノテーションを提供するため、テストには必須です。
<code>rest-assured</code> は必須ではありませんが、HTTP エンドポイントをテストするための便利な方法です。また、正しい URL を自動的
に設定するインテグレーション機能も提供しているため、設定は必要ありません。</p>
</div>
<div class="paragraph">
<p>JUnit 5を使用しているので、<a href="https://maven.apache.org/surefire/maven-surefire-plugin/">Surefire Maven Plugin</a> 
のバージョンを設定する必要があります。デフォルトのバージョンはJUnit 5をサポートしていない為です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;
    &lt;configuration&gt;
       &lt;systemPropertyVariables&gt;
          &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;
          &lt;maven.home&gt;${maven.home}&lt;/maven.home&gt;
       &lt;/systemPropertyVariables&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、テストが正しいログマネージャーを使用するように <code>java.util.logging.manager</code> システムプロパティーを設定し、
<code>${maven.home}/conf/settings.xml</code> からのカスタム設定 (存在する場合) が適用されるように <code>maven.home</code> も設定します。</p>
</div>
<div class="paragraph">
<p>プロジェクトには簡単なテストも含まれているはずです:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import java.util.UUID;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }

    @Test
    public void testGreetingEndpoint() {
        String uuid = UUID.randomUUID().toString();
        given()
          .pathParam("name", uuid)
          .when().get("/hello/greeting/{name}")
          .then()
            .statusCode(200)
            .body(is("hello " + uuid));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このテストはHTTPを使用して、RESTエンドポイントを直接テストします。テストが実行されると、
テストが実行される前にアプリケーションが開始されます。</p>
</div>
<div class="sect2">
<h3 id="controlling-the-test-port"><a class="anchor" href="#controlling-the-test-port"></a>4.1. テストポートの制御</h3>
<div class="paragraph">
<p>Quarkusはデフォルトではポート <code>8080</code> をリッスンしますが、テストを実行する場合はデフォルトで <code>8081</code> をリッスンします。
これにより、アプリケーションを並行して実行しながらテストを実行することができます。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">テストポートの変更</div>
<div class="paragraph">
<p><code>application.properties</code> の <code>quarkus.http.test-port</code> を設定することで、を HTTP 用にテストで使われるポートを設定出来、 <code>quarkus.http.test-ssl-port</code> を設定することで HTTPS 用にテストで使用するポートを設定することが出来ます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.http.test-port=8083
quarkus.http.test-ssl-port=8446</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>0</code> を使用すると、(オペレーティングシステムによって割り当てられた)ランダムなポートが使用されることになります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Quarkusはまた、テストを実行する前にRestAssuredによって使用されるデフォルトのポートを更新するRestAssuredインテグレーションも提供しているため、
追加の設定は必要ありません。</p>
</div>
</div>
<div class="sect2">
<h3 id="controlling-http-interaction-timeout"><a class="anchor" href="#controlling-http-interaction-timeout"></a>4.2. HTTP インタラクションタイムアウトの制御</h3>
<div class="paragraph">
<p>テストで REST Assured を使用する場合、接続と応答のタイムアウトは 30 秒に設定されます。
この設定は <code>quarkus.http.test-timeout</code> プロパティーでオーバーライドできます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.http.test-timeout=10s</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injecting-a-uri"><a class="anchor" href="#injecting-a-uri"></a>4.3. URI の挿入</h3>
<div class="paragraph">
<p>URLをテストに直接注入することも可能で、別のクライアントを使用するのが簡単になります。
これは <code>@TestHTTPResource</code> アノテーションで行います。</p>
</div>
<div class="paragraph">
<p>静的なリソースをロードするための簡単なテストを書いてみましょう。まず、シンプルなHTMLファイルを
 <code>src/main/resources/META-INF/resources/index.html</code> に作成します:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Testing Guide&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Information about testing
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>これが正しく提供されているかどうかを確認するための簡単なテストを作成します:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.charset.StandardCharsets;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import io.quarkus.test.common.http.TestHTTPResource;
import io.quarkus.test.junit.QuarkusTest;

@QuarkusTest
public class StaticContentTest {

    @TestHTTPResource("index.html") <i class="conum" data-value="1"></i><b>(1)</b>
    URL url;

    @Test
    public void testIndexHtml() throws IOException {
        try (InputStream in = url.openStream()) {
            String contents = new String(in.readAllBytes(), StandardCharsets.UTF_8);
            Assertions.assertTrue(contents.contains("&lt;title&gt;Testing Guide&lt;/title&gt;"));
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>このアノテーションを使用すると、QuarkusインスタンスのURLを直接注入することができます。アノテーションの値は、URLのパス部分になります。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>今のところ <code>@TestHTTPResource</code> では、URL の <code>URI</code> , <code>URL</code> , <code>String</code> 表現を注入することができます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-a-specific-endpoint"><a class="anchor" href="#testing-a-specific-endpoint"></a>5. 特定のエンドポイントのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RESTassuredと <code>@TestHTTPResource</code> の両方が、パスをハードコーディングするのではなく、テストするエンドポイントクラスを指定することをサポートしています。現在、Jakarta RESTエンドポイント、Servlet、Reactive Routesの両方をサポートしています。これにより、あるテストがどのエンドポイント
をテストしているのかを正確に把握することが非常に容易になります。</p>
</div>
<div class="paragraph">
<p>これらの例では、以下のようなエンドポイントを想定しています:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
現在、Jakarta RESTのコンテキストパスを設定するための <code>@ApplicationPath()</code> アノテーションをサポートしていません。カスタムコンテキストパスが必要な場合は、
代わりに <code>quarkus.resteasy.path</code> の設定値を使用してください。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="testhttpresource"><a class="anchor" href="#testhttpresource"></a>5.1. テストHTTPリソース</h3>
<div class="paragraph">
<p><code>io.quarkus.test.common.http.TestHTTPEndpoint</code> アノテーションを使用してエンドポイントのパスを指定することが出来、
指定されたエンドポイントからパスが抽出されます。 <code>TestHTTPResource</code> エンドポイントにも値を指定すると、
エンドポイントパスの最後に追加されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.charset.StandardCharsets;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import io.quarkus.test.common.http.TestHTTPEndpoint;
import io.quarkus.test.common.http.TestHTTPResource;
import io.quarkus.test.junit.QuarkusTest;

@QuarkusTest
public class StaticContentTest {

    @TestHTTPEndpoint(GreetingResource.class)  <i class="conum" data-value="1"></i><b>(1)</b>
    @TestHTTPResource
    URL url;

    @Test
    public void testIndexHtml() throws IOException {
        try (InputStream in = url.openStream()) {
            String contents = new String(in.readAllBytes(), StandardCharsets.UTF_8);
            Assertions.assertEquals("hello", contents);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>GreetingResource</code> は <code>@Path("/hello")</code> とアノテーションされているので、注入された URL は
 <code>/hello</code> で終わります。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="restassured"><a class="anchor" href="#restassured"></a>5.2. RESTassured</h3>
<div class="paragraph">
<p>RESTassured ベースパス (すなわち、すべてのリクエストのルートとなるデフォルトパス) を制御するには、
<code>io.quarkus.test.common.http.TestHTTPEndpoint</code> アノテーションを使用できます。これはクラスやメソッドレベルで適用できます。
グリーティングリソースをテストするには、以下のようにします:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.common.http.TestHTTPEndpoint;
import org.junit.jupiter.api.Test;

import java.util.UUID;

import static io.restassured.RestAssured.when;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
@TestHTTPEndpoint(GreetingResource.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        when().get()    <i class="conum" data-value="2"></i><b>(2)</b>
          .then()
             .statusCode(200)
             .body(is("hello"));
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>これにより、RESTAssured はすべてのリクエストの前に <code>/hello</code> を付けます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>このテストでは <code>/hello</code> がデフォルトなので、ここでパスを指定する必要はないことに注意してください。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="injection-into-tests"><a class="anchor" href="#injection-into-tests"></a>6. テストへの注入</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これまでは、HTTP エンドポイントを介してアプリをテストする統合スタイルのテストしか取り上げてきませんでしたが、
ユニットテストを行い、Beanを直接テストしたい場合はどうでしょうか?</p>
</div>
<div class="paragraph">
<p>Quarkusでは、 <code>@Inject</code> アノテーションを介してテストにCDI Beanを注入できるようにすることで、これをサポートしています(実際、Quarkusのテストは完全なCDI Beanなので、すべてのCDI機能を使用することができます)。HTTPを使用せずにグリーティングサービスを直接テストするシンプルなテストを作成してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import jakarta.inject.Inject;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import io.quarkus.test.junit.QuarkusTest;

@QuarkusTest
public class GreetingServiceTest {

    @Inject <i class="conum" data-value="1"></i><b>(1)</b>
    GreetingService service;

    @Test
    public void testGreetingService() {
        Assertions.assertEquals("hello Quarkus", service.greeting("Quarkus"));
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>GreetingService</code> Beanがテストに注入されます。</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@SessionScoped</code> Bean を注入/テストする場合、セッションコンテキストがアクティブではない可能性が高く、注入された Bean のメソッドが呼び出されたときに <code>ContextNotActiveException</code> を受け取ることになります。ただし、 <code>@io.quarkus.test.ActivateSessionContext</code> インターセプターバインディングを使用して、特定のビジネスメソッドのセッションコンテキストをアクティブ化することは可能です。その他の制限については、javadoc を参照してください。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="applying-interceptors-to-tests"><a class="anchor" href="#applying-interceptors-to-tests"></a>7. テストへのインターセプターの適用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前述したように、Quarkusのテストは実際には完全なCDI Beanであり、通常のようにCDIインターセプターを適用することができます。例えば、トランザクションのコンテキスト内でテストメソッドを実行したい場合、 <code>@Transactional</code> アノテーションをメソッドに適用するだけで、トランザクションインターセプターがそれを処理します。</p>
</div>
<div class="paragraph">
<p>これに加えて、独自のテストステレオタイプを作成することもできます。例えば、以下のように <code>@TransactionalQuarkusTest</code> を作成することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
@Stereotype
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface TransactionalQuarkusTest {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このアノテーションをテストクラスに適用すると、 <code>@QuarkusTest</code> と <code>@Transactional</code> の両方のアノテーションを適用したかのように動作します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TransactionalQuarkusTest
public class TestStereotypeTestCase {

    @Inject
    UserTransaction userTransaction;

    @Test
    public void testUserTransaction() throws Exception {
        Assertions.assertEquals(Status.STATUS_ACTIVE, userTransaction.getStatus());
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tests-and-transactions"><a class="anchor" href="#tests-and-transactions"></a>8. テストとトランザクション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>テストでは標準のQuarkus <code>@Transactional</code> アノテーションを使用することができますが、これは、テストでデータベースに加えた変更が永続化されることを意味します。テストの終了時に変更をロールバックしたい場合は、 <code>io.quarkus.test.TestTransaction</code> アノテーションを使用することができます。これは、トランザクション内でテストメソッドを実行しますが、テストメソッドが完了したらロールバックして、データベースの変更を元に戻します。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="enrichment-via-quarkustestcallback"><a class="anchor" href="#enrichment-via-quarkustestcallback"></a>9. QuarkusTest* コールバックによる強化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>インターセプターの代わりに、あるいはインターセプターに加えて、以下のコールバックインターフェースを実装することで、 <strong>すべての</strong> <code>@QuarkusTest</code> クラスを充実させることができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback</code></p>
</li>
<li>
<p><code>io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback</code></p>
</li>
<li>
<p><code>io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback</code></p>
</li>
<li>
<p><code>io.quarkus.test.junit.callback.QuarkusTestBeforeTestExecutionCallback</code></p>
</li>
<li>
<p><code>io.quarkus.test.junit.callback.QuarkusTestAfterTestExecutionCallback</code></p>
</li>
<li>
<p><code>io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>オプションとして、プロパティ <code>quarkus.test.enable-callbacks-for-integration-tests</code> を <code>true</code> とすることで、これらのコールバックを <code>@QuarkusIntegrationTest</code> テストでも有効にすることができます。</p>
</div>
<div class="paragraph">
<p>このようなコールバックの実装は、 <code>java.util.ServiceLoader</code> で定義されている「サービスプロバイダ」として登録する必要があります。</p>
</div>
<div class="paragraph">
<p>例えば、以下のようなサンプルコールバックです:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback;
import io.quarkus.test.junit.callback.QuarkusTestMethodContext;

public class MyQuarkusTestBeforeEachCallback implements QuarkusTestBeforeEachCallback {

    @Override
    public void beforeEach(QuarkusTestMethodContext context) {
        System.out.println("Executing " + context.getTestMethod());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次のように、 <code>src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback</code> を介して登録する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
テストクラスやメソッドからアノテーションを読み込んで、コールバックが何をするかを制御することができます。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing_different_profiles"><a class="anchor" href="#testing_different_profiles"></a>10. 異なるプロファイルのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これまでの例では、すべてのテストで Quarkus を 1 回だけ起動しました。最初のテストが実行される前に Quarkus が起動し、その後すべてのテストが実行され、最後に Quarkus がシャットダウンされます。これにより、非常に高速なテストが可能になりますが、様々な設定をテストすることができないため、少し制限されます。</p>
</div>
<div class="paragraph">
<p>この問題を回避するために、Quarkusはテストプロファイルの考え方をサポートしています。以前に実行したテストとは異なるプロファイルを持つテストがある場合、Quarkusはテストを実行する前にシャットダウンされ、新しいプロファイルで開始されます。これは、テスト時間にシャットダウン/起動サイクルが追加されるため、明らかに少し遅くなりますが、非常に大きな柔軟性が得られます。</p>
</div>
<div class="paragraph">
<p>Quarkus の再起動回数を減らすために、 <code>io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer</code>
は、<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes">JUnit 5 ユーザーガイド</a> に記載
されているように、グローバル <code>ClassOrderer</code> として登録されます。
この <code>ClassOrderer</code> の動作は、 <code>quarkus.test.class-orderer</code> プロパティーを使用して <code>application.properties</code> 経由で設定できます。
このプロパティーは、使用する <code>ClassOrderer</code> の FQCN を受け入れます。クラスが見つからない場合は、
JUnit のデフォルトの動作にフォールバックし、 <code>ClassOrderer</code> をまったく設定しません。また、JUnit 5 が提供する別の <code>ClassOrderer</code> や、独自のカスタム ClassOrderer を設定することで、完全に無効にすることもできます。</p>
</div>
<div class="sect2">
<h3 id="writing-a-profile"><a class="anchor" href="#writing-a-profile"></a>10.1. プロフィールの書き方</h3>
<div class="paragraph">
<p>テスト プロファイルを実装するには、 <code>io.quarkus.test.junit.QuarkusTestProfile</code> を実装する必要があります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.getting.started.testing;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jakarta.enterprise.inject.Produces;

import io.quarkus.test.junit.QuarkusTestProfile;
import io.quarkus.test.junit.QuarkusTestProfile.TestResourceEntry;

public class MockGreetingProfile implements QuarkusTestProfile { <i class="conum" data-value="1"></i><b>(1)</b>

    /**
     * Returns additional config to be applied to the test. This
     * will override any existing config (including in application.properties),
     * however existing config will be merged with this (i.e. application.properties
     * config will still take effect, unless a specific config key has been overridden).
     *
     * Here we are changing the Jakarta REST root path.
     */
    @Override
    public Map&lt;String, String&gt; getConfigOverrides() {
        return Collections.singletonMap("quarkus.resteasy.path","/api");
    }

    /**
     * Returns enabled alternatives.
     *
     * This has the same effect as setting the 'quarkus.arc.selected-alternatives' config key,
     * however it may be more convenient.
     */
    @Override
    public Set&lt;Class&lt;?&gt;&gt; getEnabledAlternatives() {
        return Collections.singleton(MockGreetingService.class);
    }

    /**
     * Allows the default config profile to be overridden. This basically just sets the quarkus.test.profile system
     * property before the test is run.
     *
     * Here we are setting the profile to test-mocked
     */
    @Override
    public String getConfigProfile() {
        return "test-mocked";
    }

    /**
     * Additional {@link QuarkusTestResourceLifecycleManager} classes (along with their init params) to be used from this
     * specific test profile.
     *
     * If this method is not overridden, then only the {@link QuarkusTestResourceLifecycleManager} classes enabled via the {@link io.quarkus.test.common.QuarkusTestResource} class
     * annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).
     */
    @Override
    public List&lt;TestResourceEntry&gt; testResources() {
        return Collections.singletonList(new TestResourceEntry(CustomWireMockServerManager.class));
    }


    /**
     * If this returns true then only the test resources returned from {@link #testResources()} will be started,
     * global annotated test resources will be ignored.
     */
    @Override
    public boolean disableGlobalTestResources() {
        return false;
    }

    /**
     * The tags this profile is associated with.
     * When the {@code quarkus.test.profile.tags} System property is set (its value is a comma separated list of strings)
     * then Quarkus will only execute tests that are annotated with a {@code @TestProfile} that has at least one of the
     * supplied (via the aforementioned system property) tags.
     */
    @Override
    public Set&lt;String&gt; tags() {
        return Collections.emptySet();
    }

    /**
     * The command line parameters that are passed to the main method on startup.
     */
    @Override
    public String[] commandLineParameters() {
        return new String[0];
    }

    /**
     * If the main method should be run.
     */
    @Override
    public boolean runMainMethod() {
        return false;
    }

    /**
     * If this method returns true then all {@code StartupEvent} and {@code ShutdownEvent} observers declared on application
     * beans should be disabled.
     */
    @Override
    public boolean disableApplicationLifecycleObservers() {
        return false;
    }

    @Produces <i class="conum" data-value="2"></i><b>(2)</b>
    public ExternalService mockExternalService() {
       return new ExternalService("mock");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>これらのメソッドにはすべてデフォルトの実装があるため、オーバーライドが必要なメソッドのみオーバーライドします。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>テストプロファイルの実装で CDI Bean が宣言されている場合 (プロデューサーメソッド/フィールドまたはネストされた静的クラス経由)、この Bean はテストプロファイルが使用されている場合にのみ考慮され、他のテストプロファイルでは無視されます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>これでプロファイルを定義したので、それをテストクラスに含める必要があります。そのためには、テストクラスに <code>@TestProfile(MockGreetingProfile.class)</code> アノテーションを付けます。</p>
</div>
<div class="paragraph">
<p>テストプロファイルの設定はすべて単一のクラスに保存されているので、前回のテストが同じ設定で実行されたかどうかが簡単にわかります。</p>
</div>
</div>
<div class="sect2">
<h3 id="running-specific-tests"><a class="anchor" href="#running-specific-tests"></a>10.2. 特定のテストの実行</h3>
<div class="paragraph">
<p>Quarkus は、テストの実行を特定の <code>@TestProfile</code> アノテーションを持つテストに制限できます。これは、 <code>QuarkusTestProfile</code> の <code>tags</code> メソッドを <code>quarkus.test.profile.tags</code> システムプロパティーと組み合わせて利用することで機能します。</p>
</div>
<div class="paragraph">
<p>基本的に、 <code>quarkus.test.profile.tags</code> の値と一致するタグが少なくとも 1 つある <code>QuarkusTestProfile</code> はアクティブであると見なされ、アクティブなプロファイルの <code>@TestProfile</code> でアノテーションが付けられたすべてのテストが実行されますが、それ以外はスキップされます。以下は、その典型的な例です。</p>
</div>
<div class="paragraph">
<p>まず、次のようないくつかの <code>QuarkusTestProfile</code> 実装を定義しましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Profiles {

    public static class NoTags implements QuarkusTestProfile {

    }

    public static class SingleTag implements QuarkusTestProfile {
        @Override
        public Set&lt;String&gt; tags() {
            return Set.of("test1");
        }
    }

    public static class MultipleTags implements QuarkusTestProfile {
        @Override
        public Set&lt;String&gt; tags() {
            return Set.of("test1", "test2");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで、次のテストがあると仮定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class NoQuarkusProfileTest {

    @Test
    public void test() {
        // test something
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
@TestProfile(Profiles.NoTags.class)
public class NoTagsTest {

    @Test
    public void test() {
        // test something
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
@TestProfile(Profiles.SingleTag.class)
public class SingleTagTest {

    @Test
    public void test() {
        // test something
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
@TestProfile(Profiles.MultipleTags.class)
public class MultipleTagsTest {

    @Test
    public void test() {
        // test something
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次のシナリオを考えてみましょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.test.profile.tags</code> が設定されていない: すべてのテストが実行されます。</p>
</li>
<li>
<p><code>quarkus.test.profile.tags=foo</code>: この場合、 <code>QuarkusTestProfile</code> 実装で定義されたタグはいずれも <code>quarkus.test.profile.tags</code> の値と一致しないため、テストは実行されません。 <code>@TestProfile</code> でアノテーションが付けられていないため、 <code>NoQuarkusProfileTest</code> も実行されないことに注意してください。</p>
</li>
<li>
<p><code>quarkus.test.profile.tags=test1</code>: この場合、それぞれの <code>QuarkusTestProfile</code> 実装のタグが <code>quarkus.test.profile.tags</code> の値と一致するため、 <code>SingleTagTest</code> と <code>MultipleTagsTest</code> が実行されます。</p>
</li>
<li>
<p><code>quarkus.test.profile.tags=test1,test3</code>: この場合、前の場合と同じテストが実行されます。</p>
</li>
<li>
<p><code>quarkus.test.profile.tags=test2,test3</code>: この場合、 <code>MultipleTagsTest</code> は、 <code>tags</code> メソッドが <code>quarkus.test.profile.tags</code> の値と一致する唯一の <code>QuarkusTestProfile</code> 実装であるため、 <code>MultipleTagsTest</code> のみ実行されます。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="nested-tests"><a class="anchor" href="#nested-tests"></a>11. ネストしたテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JUnit 5 <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">@Nested tests</a> are useful for structuring more complex test scenarios.
However, note that it is not possible to assign different test profiles or resources to nested tests within the same parent class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mock-support"><a class="anchor" href="#mock-support"></a>12. モックサポート</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkusでは、2つの異なるアプローチを使用したモックオブジェクトの使用をサポートしています。CDIの代替品を使用してすべてのテストクラスのBeanをモックアウトするか、 <code>QuarkusMock</code> を使用してテストごとにBeanをモックアウトすることができます。</p>
</div>
<div class="sect2">
<h3 id="cdi-alternative-mechanism"><a class="anchor" href="#cdi-alternative-mechanism"></a>12.1. CDI <code>@Alternative</code> メカニズム</h3>
<div class="paragraph">
<p>これを使用するには、 <code>src/test/java</code> ディレクトリーのクラスでモックしたいBeanをオーバーライドし、 <code>@Alternative</code> と <code>@Priority(1)</code> アノテーションをBeanに配置するだけです。あるいは、便利な <code>io.quarkus.test.Mock</code> ステレオタイプアノテーションを使用することもできます。この組み込みステレオタイプは、 <code>@Alternative</code>、 <code>@Priority(1)</code>、 <code>@Dependent</code> を宣言します。例えば、以下のようなサービスがあるとします:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class ExternalService {

    public String service() {
        return "external";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>src/test/java</code> で以下のクラスでモックできました:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Mock
@ApplicationScoped <i class="conum" data-value="1"></i><b>(1)</b>
public class MockExternalService extends ExternalService {

    @Override
    public String service() {
        return "mock";
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@Mock</code> ステレオタイプで宣言された <code>@Dependent</code> スコープをオーバーライドします。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>代替品が <code>src/main/java</code> ではなく <code>src/test/java</code> ディレクトリーに存在することが重要です。そうでなければ、テスト以外も常に有効になってしまいます。</p>
</div>
<div class="paragraph">
<p>現時点では、このアプローチはネイティブイメージテストでは機能しないことに注意してください。これには、代替テストをネイティブイメージに焼き付ける必要があるためです。</p>
</div>
</div>
<div class="sect2">
<h3 id="quarkus_mock"><a class="anchor" href="#quarkus_mock"></a>12.2. QuarkusMock を使用したモッキング</h3>
<div class="paragraph">
<p><code>io.quarkus.test.junit.QuarkusMock</code> クラスは、通常のスコープ付きBeanを一時的にモックアウトするために使用することができます。 <code>@BeforeAll</code> メソッドでこのメソッドを使用した場合、モックは現在のクラスのすべてのテストに対して有効になりますが、test メソッドでこれを使用した場合、モックは現在のテストの間のみ有効になります。</p>
</div>
<div class="paragraph">
<p>この方法は、通常のスコープ付き CDI Bean (例: <code>@ApplicationScoped</code>、 <code>@RequestScoped</code> など、 <code>@Singleton</code> と <code>@Dependent</code> 以外の基本的にすべてのスコープ) に対して使用することができます。</p>
</div>
<div class="paragraph">
<p>使用例は次のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class MockTestCase {

    @Inject
    MockableBean1 mockableBean1;

    @Inject
    MockableBean2 mockableBean2;

    @BeforeAll
    public static void setup() {
        MockableBean1 mock = Mockito.mock(MockableBean1.class);
        Mockito.when(mock.greet("Stuart")).thenReturn("A mock for Stuart");
        QuarkusMock.installMockForType(mock, MockableBean1.class);  <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Test
    public void testBeforeAll() {
        Assertions.assertEquals("A mock for Stuart", mockableBean1.greet("Stuart"));
        Assertions.assertEquals("Hello Stuart", mockableBean2.greet("Stuart"));
    }

    @Test
    public void testPerTestMock() {
        QuarkusMock.installMockForInstance(new BonjourGreeter(), mockableBean2); <i class="conum" data-value="2"></i><b>(2)</b>
        Assertions.assertEquals("A mock for Stuart", mockableBean1.greet("Stuart"));
        Assertions.assertEquals("Bonjour Stuart", mockableBean2.greet("Stuart"));
    }

    @ApplicationScoped
    public static class MockableBean1 {

        public String greet(String name) {
            return "Hello " + name;
        }
    }

    @ApplicationScoped
    public static class MockableBean2 {

        public String greet(String name) {
            return "Hello " + name;
        }
    }

    public static class BonjourGreeter extends MockableBean2 {
        @Override
        public String greet(String name) {
            return "Bonjour " + name;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>インジェクションされたインスタンスはここでは利用できないので、 <code>installMockForType</code> を使用します。このモックは両方のテストメソッドに使用されます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>私たちは <code>installMockForInstance</code> を使用して注入されたBeanを置き換えます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mockitoには依存しないことに注意してください。好きなモッキングライブラリを使うことができますし、必要な動作を提供するためにオブジェクトを手動でオーバーライドすることもできます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@Inject</code> を使用すると、インストールしたモックインスタンスへの CDI プロキシーが取得されますが、これは <code>Mockito.verify</code> などのメソッドに渡すのには適していません。
これらのメソッドはモックインスタンスそのものを要求するためです。
したがって、 <code>verify</code> などのメソッドを呼び出す必要がある場合は、テストでモックインスタンスを保持するか、 <code>@io.quarkus.test.InjectMock</code> を使用する必要があります。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="further-simplification-with-injectmock"><a class="anchor" href="#further-simplification-with-injectmock"></a>12.2.1. <code>@InjectMock</code> での更なる単純化</h4>
<div class="paragraph">
<p><code>QuarkusMock</code> が提供する機能を基に構築されている Quarkus では、ユーザーが <a href="https://site.mockito.org/">Mockito</a> を簡単に利用して、 <code>QuarkusMock</code> でサポートされている Bean をモックすることもできます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>この機能は、 <code>quarkus-junit5-mockito</code> 依存関係が存在する場合にのみ、 <code>@io.quarkus.test.InjectMock</code> アノテーションで利用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit5-mockito&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@InjectMock</code> を使用すると、先ほどの例は次のように書くことができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class MockTestCase {

    @InjectMock
    MockableBean1 mockableBean1; <i class="conum" data-value="1"></i><b>(1)</b>

    @InjectMock
    MockableBean2 mockableBean2;

    @BeforeEach
    public void setup() {
        Mockito.when(mockableBean1.greet("Stuart")).thenReturn("A mock for Stuart"); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    @Test
    public void firstTest() {
        Assertions.assertEquals("A mock for Stuart", mockableBean1.greet("Stuart"));
        Assertions.assertEquals(null, mockableBean2.greet("Stuart")); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Test
    public void secondTest() {
        Mockito.when(mockableBean2.greet("Stuart")).thenReturn("Bonjour Stuart"); <i class="conum" data-value="4"></i><b>(4)</b>
        Assertions.assertEquals("A mock for Stuart", mockableBean1.greet("Stuart"));
        Assertions.assertEquals("Bonjour Stuart", mockableBean2.greet("Stuart"));
    }

    @ApplicationScoped
    public static class MockableBean1 {

        public String greet(String name) {
            return "Hello " + name;
        }
    }

    @ApplicationScoped
    public static class MockableBean2 {

        public String greet(String name) {
            return "Hello " + name;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@InjectMock</code> を使用すると、Mockitoのモックが作成され、テストクラスのテストメソッドで利用できるようになります（他のテストクラスはこの影響を <strong>受けません</strong> ）。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>クラスのすべてのテストメソッドに対して <code>mockableBean1</code> が設定されています。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>mockableBean2</code> のモックが設定されていないので、デフォルトの Mockito レスポンスを返します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>このテストでは、 <code>mockableBean2</code> が設定されているので、設定されたレスポンスを返します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上のテストは <code>@InjectMock</code> の機能を示す場合に適していますが、実際のテストを上手く表してはいません。実際のテストでは、ほとんどの場合、モックを設定し、モックされた Bean を使用する Bean をテストします。以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class MockGreetingServiceTest {

    @InjectMock
    GreetingService greetingService;

    @Test
    public void testGreeting() {
        when(greetingService.greet()).thenReturn("hi");
        given()
                .when().get("/greeting")
                .then()
                .statusCode(200)
                .body(is("hi")); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Path("greeting")
    public static class GreetingResource {

        final GreetingService greetingService;

        public GreetingResource(GreetingService greetingService) {
            this.greetingService = greetingService;
        }

        @GET
        @Produces("text/plain")
        public String greet() {
            return greetingService.greet();
        }
    }

    @ApplicationScoped
    public static class GreetingService {
        public String greet(){
            return "hello";
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>greetingService</code> をモックとして設定したので、 <code>GreetingService</code> Beanを使用する <code>GreetingResource</code> は、通常の <code>GreetingService</code> Beanのレスポンスの代わりにモックされたレスポンスを取得します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>デフォルトでは、 <code>@InjectMock</code> アノテーションは、通常の CDI スコープ Bean (例: <code>@ApplicationScoped</code>、 <code>@RequestScoped</code>) に使用できます。
<code>@Singleton</code> Bean のモック化は、 <code>@MockitoConfig(convertScopes = true)</code> アノテーションを追加することで実行できます。
これにより、テストのために <code>@Singleton</code> Bean が <code>@ApplicationScoped</code> Bean に変換されます。</p>
</div>
<div class="paragraph">
<p>これは高度なオプションと見なされ、Bean のスコープを変更することで引き起こされる結果を完全に理解している場合にのみ実行する必要があります。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-spies-instead-of-mocks-with-injectspy"><a class="anchor" href="#using-spies-instead-of-mocks-with-injectspy"></a>12.2.2. <code>@InjectSpy</code> で、モックの代わりにスパイを使用する</h4>
<div class="paragraph">
<p><code>InjectMock</code> で提供されている機能をベースに、 <code>QuarkusMock</code> でサポートされているBeanをスパイするために <a href="https://site.mockito.org/">Mockito</a> を簡単に利用できるようにしました。この機能は、 <code>quarkus-junit5-mockito</code> 依存関係で利用可能な <code>@io.quarkus.test.junit.mockito.InjectSpy</code> アノテーションを介して利用できます。</p>
</div>
<div class="paragraph">
<p>テストの際に、特定の論理パスが通ったことを確認するだけでよい場合や、Spyされたクローン上の残りのメソッドを実行したまま、単一のメソッドのレスポンスをスタブアウトするだけでよい場合があります。Spy部分モックの詳細については、 <a href="https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#13">Mockitoドキュメント - Spying on real objects</a> を参照してください。いずれの場合も、オブジェクトのSpyを使用することが望ましいです。 <code>@InjectSpy</code> を使うと、先ほどの例は次のように書くことができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class SpyGreetingServiceTest {

    @InjectSpy
    GreetingService greetingService;

    @Test
    public void testDefaultGreeting() {
        given()
                .when().get("/greeting")
                .then()
                .statusCode(200)
                .body(is("hello"));

        Mockito.verify(greetingService, Mockito.times(1)).greet(); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Test
    public void testOverrideGreeting() {
        doReturn("hi").when(greetingService).greet(); <i class="conum" data-value="2"></i><b>(2)</b>
        given()
                .when().get("/greeting")
                .then()
                .statusCode(200)
                .body(is("hi")); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Path("greeting")
    public static class GreetingResource {

        final GreetingService greetingService;

        public GreetingResource(GreetingService greetingService) {
            this.greetingService = greetingService;
        }

        @GET
        @Produces("text/plain")
        public String greet() {
            return greetingService.greet();
        }
    }

    @ApplicationScoped
    public static class GreetingService {
        public String greet(){
            return "hello";
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>値をオーバーライドするのではなく、 <code>GreetingService</code> の greet メソッドがこのテストで呼び出されたことを確認したいだけです。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ここでは、Spyに "hello "の代わりに "hi "を返すように指示しています。 <code>GreetingResource</code> が <code>GreetingService</code> に挨拶を要求すると、通常の <code>GreetingService</code> Bean の応答の代わりに、モックされた応答が返ってきます。スパイをスタブするために <code>when(Object)</code> を使用することが不可能であったり、現実的でなかったりすることがあります。したがって、spyを使用する場合は、スタブ用のメソッドである <code>doReturn|Answer|Throw()</code> ファミリーを検討してください。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>私たちは、スパイからのモックされた応答を得ることを検証しています。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-injectmock-with-restclient"><a class="anchor" href="#using-injectmock-with-restclient"></a>12.2.3. <code>@InjectMock</code> との併用 <code>@RestClient</code></h4>
<div class="paragraph">
<p><code>@RegisterRestClient</code> は、ランタイムに REST Client の実装を登録します。Beanは通常のスコープである必要があるため、インターフェイスに <code>@ApplicationScoped</code> アノテーションを付ける必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/")
@ApplicationScoped
@RegisterRestClient
public interface GreetingService {

    @GET
    @Path("/hello")
    @Produces(MediaType.TEXT_PLAIN)
    String hello();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>テストクラスの例です:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class GreetingResourceTest {

    @InjectMock
    @RestClient <i class="conum" data-value="1"></i><b>(1)</b>
    GreetingService greetingService;

    @Test
    public void testHelloEndpoint() {
        Mockito.when(greetingService.hello()).thenReturn("hello from mockito");

        given()
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("hello from mockito"));
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>この注入ポイントが <code>RestClient</code> のインスタンスを使用することを意味していることを示します。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mocking-with-panache"><a class="anchor" href="#mocking-with-panache"></a>12.3. Mocking with Panache</h3>
<div class="paragraph">
<p><code>quarkus-hibernate-orm-panache</code> や <code>quarkus-mongodb-panache</code> のエクステンションを使っている場合は、<a href="hibernate-orm-panache#mocking">Hibernate ORM with Panache モック</a> および <a href="mongodb-panache#mocking">MongoDB with Panache モック</a>のドキュメントをチェックして、データアクセスをモックする最も簡単な方法を確認してください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-security"><a class="anchor" href="#testing-security"></a>13. セキュリティーのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus Securityを使用している場合、アプリケーションのセキュリティー機能を簡単にテストする方法については、<a href="security-testing">セキュリティーのテスト</a> のセクションをご覧ください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quarkus-test-resource"><a class="anchor" href="#quarkus-test-resource"></a>14. Quarkus アプリケーションの開始前にサービスを開始する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>非常に一般的なニーズとして、Quarkus アプリケーションをテスト用に起動する前に、Quarkus アプリケーションが依存するいくつかのサービスを起動することが挙げられます。このニーズに対応するために、Quarkusでは、 <code>@io.quarkus.test.common.QuarkusTestResource</code> と <code>io.quarkus.test.common.QuarkusTestResourceLifecycleManager</code> を提供します。</p>
</div>
<div class="paragraph">
<p>テストスイート内の任意のテストに <code>@QuarkusTestResource</code> というアノテーションを付けるだけで、Quarkus はテストが実行される前に、対応する <code>QuarkusTestResourceLifecycleManager</code> を実行します。
テストスイートでは、複数の <code>@QuarkusTestResource</code> アノテーションを自由に利用することもできます。その場合、対応するすべての <code>QuarkusTestResourceLifecycleManager</code> オブジェクトがテストの前に実行されます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
テストリソースは、テストクラスまたはカスタムプロファイルで定義されている場合でもグローバルです。つまり、重複を削除しても、すべてのテストですべてアクティブになります。
単一のテストクラスまたはテストプロファイルに限定してテストリソースを有効にする場合は、 <code>@QuarkusTestResource(restrictToAnnotatedClass = true)</code> を使用できます。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
複数のテストリソースを使用する場合、それらを同時に開始できます。そのためには、 <code>@QuarkusTestResource(parallel = true)</code> を設定する必要があります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Quarkus では、 <code>QuarkusTestResourceLifecycleManager</code> の実装がいくつか提供されていますが (H2 データベースを起動する <code>io.quarkus.test.h2.H2DatabaseTestResource</code> や、モック Kubernetes API サーバーを起動する <code>io.quarkus.test.kubernetes.client.KubernetesServerTestResource</code> を参照)、
特定のアプリケーションのニーズに対応するためにカスタム実装を作成するのが一般的です。
一般的なケースとしては、<a href="https://www.testcontainers.org/">Testcontainers</a> を使用した docker コンテナーの起動 (その例は <a href="https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java">こちら</a> を参照)、
<a href="https://wiremock.org/">Wiremock</a> を使用したモック HTTP サーバの起動 (その例は <a href="https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java">こちら</a> を参照) などがあります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>QuarkusTestResourceLifecycleManager</code> は CDI Bean ではないため、これを実装するクラスには <code>@Inject</code> で注入されたフィールドを含めることはできません。 <code>String propertyName = ConfigProvider.getConfig().getValue("quarkus.my-config-group.myconfig", String.class);</code> を使用できます。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="altering-the-test-class"><a class="anchor" href="#altering-the-test-class"></a>14.1. テストクラスの変更</h3>
<div class="paragraph">
<p>テストクラスに何かを注入する必要があるカスタムの <code>QuarkusTestResourceLifecycleManager</code> を作成する場合、 <code>inject</code> メソッドを使用できます。
たとえば、次のようなテストがある場合などです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
@QuarkusTestResource(MyWireMockResource.class)
public class MyTest {

    @InjectWireMock // this a custom annotation you are defining in your own application
    WireMockServer wireMockServer;

    @Test
    public someTest() {
        // control wiremock in some way and perform test
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次のコードスニペットの <code>inject</code> メソッドに示すように、 <code>MyWireMockResource</code> に <code>wireMockServer</code> フィールドを注入させることができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyWireMockResource implements QuarkusTestResourceLifecycleManager {

    WireMockServer wireMockServer;

    @Override
    public Map&lt;String, String&gt; start() {
        wireMockServer = new WireMockServer(8090);
        wireMockServer.start();

        // create some stubs

        return Map.of("some.service.url", "localhost:" + wireMockServer.port());
    }

    @Override
    public synchronized void stop() {
        if (wireMockServer != null) {
            wireMockServer.stop();
            wireMockServer = null;
        }
    }

    @Override
    public void inject(TestInjector testInjector) {
        testInjector.injectIntoFields(wireMockServer, new TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
テストクラスへのこの注入は CDI の制御下になく、CDI がテストクラスへの必要な注入を実行した後に発生することは言及に値します。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="annotation-based-test-resources"><a class="anchor" href="#annotation-based-test-resources"></a>14.2. アノテーションベースのテストリソース</h3>
<div class="paragraph">
<p>アノテーションを使用して有効化および設定されたテストリソースを作成することができます。これは、テストリソースの有効化と設定に使用されるアノテーション に <code>@QuarkusTestResource</code> を配置することで可能になります。</p>
</div>
<div class="paragraph">
<p>たとえば、これは <code>@WithKubernetesTestServer</code> アノテーションを定義します。これは、テストで <code>KubernetesServerTestResource</code> をアクティブ化するために使用できますが、アノテーションが付けられたテストクラスに限定されます。これは <code>QuarkusTestProfile</code> テストプロファイルに配置することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTestResource(KubernetesServerTestResource.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface WithKubernetesTestServer {
    /**
     * Start it with HTTPS
     */
    boolean https() default false;

    /**
     * Start it in CRUD mode
     */
    boolean crud() default true;

    /**
     * Port to use, defaults to any available port
     */
    int port() default 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>KubernetesServerTestResource</code> クラスは、前のアノテーションを使用して設定するために、 <code>QuarkusTestResourceConfigurableLifecycleManager</code> インターフェイスを実装する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class KubernetesServerTestResource
        implements QuarkusTestResourceConfigurableLifecycleManager&lt;WithKubernetesTestServer&gt; {

    private boolean https = false;
    private boolean crud = true;
    private int port = 0;

    @Override
    public void init(WithKubernetesTestServer annotation) {
        this.https = annotation.https();
        this.crud = annotation.crud();
        this.port = annotation.port();
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>アノテーションを繰り返し使えるようにするには、包含するアノテーション型に <code>@QuarkusTestResourceRepeatable</code> を付ける必要があります。例えば、この場合、繰り返し使える <code>@WithRepeatableTestResource</code> アノテーションを定義することになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTestResource(KubernetesServerTestResource.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Repeatable(WithRepeatableTestResource.List.class)
public @interface WithRepeatableTestResource {

    String key() default "";

    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @QuarkusTestResourceRepeatable(WithRepeatableTestResource.class)
    @interface List {
        WithRepeatableTestResource[] value();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="usage-of-withtestresource"><a class="anchor" href="#usage-of-withtestresource"></a>14.3. <code>@WithTestResource</code> の使用法</h3>
<div class="paragraph">
<p><code>@QuarkusTestResource</code> によって提供されるテストリソースは、グローバルに使用できるか、またはアノテーション付きテストクラス (<code>restrictToAnnotatedClass</code>) に制限されますが、アノテーション <code>@WithTestResource</code> を使用すると、実行用にテストリソース別にテストをさらにグループ化できます。
<code>@WithTestResource</code> には、 <code>TestResourceScope</code> 列挙値を取る <code>scope</code> プロパティーがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TestResourceScope.MATCHING_RESOURCES</code> (デフォルト): Quarkus は同じテストリソースを持つテストをグループ化し、まとめてに実行します。グループが実行されると、すべてのテストリソースが停止され、次のグループが実行されます。</p>
</li>
<li>
<p><code>TestResourceScope.RESTRICTED_TO_CLASS</code>: テストリソースは、アノテーションが付けられたテストクラスでのみ使用でき、テストクラスが実行されると停止されます。</p>
</li>
<li>
<p><code>TestResourceScope.GLOBAL</code>: テストリソースはテストスイート内のすべてのテストに適用されます</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次のいずれかに該当する場合は、Quarkus を再起動する必要があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>現在のテストのテストリソースの少なくとも 1 つが、テストクラスに制限されている</p>
</li>
<li>
<p>次のテストのテストリソースの少なくとも 1 つが、テストクラスに制限されている</p>
</li>
<li>
<p>異なる <code>MATCHING_RESOURCES</code> スコープのテストリソースが使用されている</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hang-detection"><a class="anchor" href="#hang-detection"></a>15. ハング検出</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>@QuarkusTest</code> は、予期しないハングを診断するために使用できるハング検出をサポートしています。指定された時間内に進捗がない場合 (つまり、JUnit コールバックが呼び出されない場合)、Quarkus はスタックトレースをコンソールに出力して、ハングの診断を助けます。このタイムアウトのデフォルト値は 10 分です。</p>
</div>
<div class="paragraph">
<p>これ以上のアクションは実行されず、テストは通常どおり (通常は CI がタイムアウトするまで) 続行されますが、出力されたスタックトレースは、ビルドが失敗した理由を診断するのに役立ちます。このタイムアウトは、 <code>quarkus.test.hang-detection-timeout</code> システムプロパティーで制御できます (これは application.properties でも設定できますが、Quarkus が起動するまで読み取られないため、Quarkus の起動タイムアウトはデフォルトの 10 分です)。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="native-executable-testing"><a class="anchor" href="#native-executable-testing"></a>16. ネイティブ実行可能ファイルテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>@QuarkusIntegrationTest</code> を使用してネイティブ実行可能ファイルをテストすることも可能です。これは、テストに注入すること (そして、ネイティブ実行可能ファイルは別の非 JVM プロセスで実行されることーこれは実際には可能ではありません) を除いて、このガイドで述べたすべての機能をサポートしています。</p>
</div>
<div class="paragraph">
<p>これについては、<a href="building-native-image">ネイティブ実行可能ファイルガイド</a> で説明されています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quarkus-integration-test"><a class="anchor" href="#quarkus-integration-test"></a>17. <code>@QuarkusIntegrationTest</code> の使用</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>@QuarkusIntegrationTest</code> は、Quarkus ビルドによって生成されたアーティファクトを起動およびテストするために使用する必要があり、jar (タイプを問わず)、ネイティブイメージ、またはコンテナーイメージのテストをサポートします。
簡単に言えば、Quarkus ビルド (<code>mvn package</code> または <code>gradle build</code>) の結果が jar である場合、その jar は <code>java -jar &#8230;&#8203;</code> として起動され、それに対して実行がテストされることを意味します。
代わりにネイティブイメージがビルドされた場合、アプリケーションは <code>./application &#8230;&#8203;</code> として起動され、実行中のアプリケーションに対して実行がテストされます。
最後に、ビルド中に (<code>quarkus-container-image-jib</code>、 <code>quarkus-container-image-docker</code> または <code>container-image-podman</code> エクステンションを含め、 <code>quarkus.container-image.build=true</code> プロパティーを設定することで) コンテナーイメージが作成された場合、コンテナーが作成されて実行されます (これには、 <code>docker</code> または <code>podman</code> の実行可能ファイルが存在する必要があります)。</p>
</div>
<div class="paragraph">
<p>これは、同じ機能セットをサポートし、同じ制限を持つブラックボックステストです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@QuarkusIntegrationTest</code> でアノテーションが付けられたテストはビルドの結果をテストするため、統合テストスイートの一部として実行する必要があります。 - 例えば、Maven を使用している場合は <code>-DskipITs=false</code> を設定し、Gradle を
使用している場合は <code>quarkusIntTest</code> タスクを設定します。これらのテストは、Quarkus がまだ最終のアーティファクトを作成していないため、 <code>@QuarkusTest</code> と同じフェーズで実行すると <strong>機能しません</strong>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>pom.xml</code> ファイルには以下が含まれます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
    &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;integration-test&lt;/goal&gt;
                &lt;goal&gt;verify&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;systemPropertyVariables&gt;
                    &lt;native.image.path&gt;${project.build.directory}/${project.build.finalName}-runner&lt;/native.image.path&gt;
                    &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;
                    &lt;maven.home&gt;${maven.home}&lt;/maven.home&gt;
                &lt;/systemPropertyVariables&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、failsafe-maven-plugin に統合テストを実行するように指示します。</p>
</div>
<div class="paragraph">
<p>次に、 <code>src/test/java/org/acme/quickstart/GreetingResourceIT.java</code> を開きます。次の内容が含まれています:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quickstart;


import io.quarkus.test.junit.QuarkusIntegrationTest;

@QuarkusIntegrationTest <i class="conum" data-value="1"></i><b>(1)</b>
public class GreetingResourceIT extends GreetingResourceTest { <i class="conum" data-value="2"></i><b>(2)</b>

    // Run the same tests

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>テストの前にネイティブファイルからアプリケーションを起動する別のテストランナーを使用します。実行可能ファイルは、<em>Failsafe Maven Plugin</em> によって取得されます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>便宜上、以前のテストを拡張していますが、独自のテストを実装することもできます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>詳細については、次のリンクを参照してください: <a href="building-native-image#testing-the-native-executable">Testing the native executable Guide</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@QuarkusIntegrationTest</code> を使ってアプリケーションをテストすると、 <code>prod</code> の設定プロファイルを使って起動しますが、これは <code>quarkus.test.integration-test-profile</code> プロパティを使って変更することができます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>src/test/resources/application.properties</code> を使用してテスト固有の設定プロパティーを追加する際 (<code>main</code> ではなく <code>test</code> があることに注意)、
ユニットテストは可能ですが、インテグレーションテストは不可能です。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="debugging-quarkusintegrationtest"><a class="anchor" href="#debugging-quarkusintegrationtest"></a>17.1. Debugging <code>@QuarkusIntegrationTest</code></h3>
<div class="paragraph">
<p>Debugging a failed <code>@QuarkusInterationTest</code> is trickier than debugging a <code>@QuarkusTest</code> because the Quarkus application
is launched as a separate process.</p>
</div>
<div class="paragraph">
<p>The test code itself can be easily debugged with any of the well known methods (like launching the test from the IDE, adding <code>-Dmaven.failsafe.debug</code> if the test is launched via Maven, etc.),
but the application under test needs to have the necessary flags passed to it via <code>quarkus.test.arg-line</code> to enable debugging. For testing an application
packaged as <strong>jar</strong>, you can use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">-Dquarkus.test.arg-line="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005"</code></pre>
</div>
</div>
<div class="paragraph">
<p>as an argument to Maven/Gradle when launching the test. This will make the application wait until a remote JVM debugger is connected to port <code>5005</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="launching-containers"><a class="anchor" href="#launching-containers"></a>17.2. コンテナーの起動</h3>
<div class="paragraph">
<p><code>@QuarkusIntegrationTest</code> によってコンテナーが起動されると (<code>quarkus.container-image.build</code> が <code>true</code> に設定されているためにアプリケーションがビルドされたため)、コンテナーは予測可能なコンテナーネットワーク上で起動されます。これにより、アプリケーションをサポートするためにサービスを起動する必要があるインテグレーションテストの作成が容易になります。
これは、 <code>@QuarkusIntegrationTest</code> が、<a href="dev-services">Dev Services</a> を介して起動されたコンテナーでそのまま機能することを意味しますが、追加のコンテナーを起動する <a href="#quarkus-test-resource">QuarkusTestLifecycleManager</a> リソースを使用して有効化することも意味します。
これは、 <code>QuarkusTestLifecycleManager</code> に <code>io.quarkus.test.common.DevServicesContext.ContextAware</code> を実装することで実現できます。以下は、その簡単な例です。</p>
</div>
<div class="paragraph">
<p>テストするリソースを実行しているコンテナー (たとえば Testcontainers を介した PostgreSQL) には、コンテナーのネットワークから IP アドレスが割り当てられます。コンテナーのネットワークからの「パブリック」IP と「マップされていない」ポート番号を使用してサービスに接続します。Testcontainers ライブラリーは通常、コンテナーネットワークを尊重せずに接続文字列を返すため、コンテナーネットワーク上のコンテナーの IP と_マップされていない_ポート番号を使用して Quarkus に正しい接続文字列を提供するには、追加のコードが必要です。</p>
</div>
<div class="paragraph">
<p>次の例は PostgreSQL での使用法を示していますが、このアプローチはすべてのコンテナーに適用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.test.common.DevServicesContext;
import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;

import org.testcontainers.containers.JdbcDatabaseContainer;
import org.testcontainers.containers.PostgreSQLContainer;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class CustomResource implements QuarkusTestResourceLifecycleManager, DevServicesContext.ContextAware {

    private Optional&lt;String&gt; containerNetworkId;
    private JdbcDatabaseContainer container;

    @Override
    public void setIntegrationTestContext(DevServicesContext context) {
        containerNetworkId = context.containerNetworkId();
    }

    @Override
    public Map&lt;String, String&gt; start() {
        // start a container making sure to call withNetworkMode() with the value of containerNetworkId if present
        container = new PostgreSQLContainer&lt;&gt;("postgres:latest").withLogConsumer(outputFrame -&gt; {});

        // apply the network to the container
        containerNetworkId.ifPresent(container::withNetworkMode);

        // start container before retrieving its URL or other properties
        container.start();

        String jdbcUrl = container.getJdbcUrl();
        if (containerNetworkId.isPresent()) {
            // Replace hostname + port in the provided JDBC URL with the hostname of the Docker container
            // running PostgreSQL and the listening port.
            jdbcUrl = fixJdbcUrl(jdbcUrl);
        }

        // return a map containing the configuration the application needs to use the service
        return ImmutableMap.of(
            "quarkus.datasource.username", container.getUsername(),
            "quarkus.datasource.password", container.getPassword(),
            "quarkus.datasource.jdbc.url", jdbcUrl);
    }

    private String fixJdbcUrl(String jdbcUrl) {
        // Part of the JDBC URL to replace
        String hostPort = container.getHost() + ':' + container.getMappedPort(PostgreSQLContainer.POSTGRESQL_PORT);

        // Host/IP on the container network plus the unmapped port
        String networkHostPort =
            container.getCurrentContainerInfo().getConfig().getHostName()
            + ':'
            + PostgreSQLContainer.POSTGRESQL_PORT;

        return jdbcUrl.replace(hostPort, networkHostPort);
    }

    @Override
    public void stop() {
        // close container
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このドキュメントの対応するセクションで説明されているように、 <code>CustomResource</code> は <code>@QuarkusTestResource</code> を使用して <code>@QuarkusIntegrationTest</code> でアクティブ化されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="executing-against-a-running-application"><a class="anchor" href="#executing-against-a-running-application"></a>17.3. 実行中のアプリケーションに対するテストの実行</h3>
<div class="paragraph">
<p><code>@QuarkusIntegrationTest</code> は、アプリケーションのすでに実行中のインスタンスに対するテストの実行をサポートします。これは、テストの実行時に
 <code>quarkus.http.test-host</code> システムプロパティーを設定することで実現できます。</p>
</div>
<div class="paragraph">
<p>次の Maven コマンドはその使用例で、 <code>@QuarkusIntegrationTest</code> を強制的に実行し、 <code><a href="http://1.2.3.4:4321" class="bare">http://1.2.3.4:4321</a></code> からアクセスできます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw verify -Dquarkus.http.test-host=1.2.3.4 -Dquarkus.http.test-port=4321</code></pre>
</div>
</div>
<div class="paragraph">
<p>To test against a running instance that only accepts SSL/TLS connection (example: <code><a href="https://1.2.3.4:4321" class="bare">https://1.2.3.4:4321</a></code>) set the system property <code>quarkus.http.test-ssl-enabled</code> to <code>true</code> and <code>quarkus.http.test-ssl-port</code> to the target HTTPS port.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mixing-quarkustest-with-other-type-of-tests"><a class="anchor" href="#mixing-quarkustest-with-other-type-of-tests"></a>18. <code>@QuarkusTest</code> と他のタイプのテストを混合</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>@QuarkusTest</code> でアノテーションが付けられたテストと、 <code>@QuarkusDevModeTest</code>、 <code>@QuarkusProdModeTest</code>、 <code>@QuarkusUnitTest</code> のいずれかでアノテーションが付けられたテストを、1 回の実行 (たとえば、1 回の Maven Surefire プラグインの実行) で混合することはできません。ただし、後者の 3 つは共存できます。</p>
</div>
<div class="paragraph">
<p>この制限の理由は、 <code>@QuarkusTest</code> がテスト実行の期間全体にわたって Quarkus サーバーを起動するため、他のテストが独自の Quarkus サーバーを起動できないようにするためです。</p>
</div>
<div class="paragraph">
<p>この制限を緩和するために、 <code>@QuarkusTest</code> アノテーションは JUnit5 <code>@Tag</code> を定義します: <code>io.quarkus.test.junit.QuarkusTest</code> 。このタグを使用して、特定の実行 で <code>@QuarkusTest</code> テストを分離できます。以下は Maven Surefire プラグインを使用した例です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;default-test&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;test&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;excludedGroups&gt;io.quarkus.test.junit.QuarkusTest&lt;/excludedGroups&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;quarkus-test&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;test&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;groups&gt;io.quarkus.test.junit.QuarkusTest&lt;/groups&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;systemProperties&gt;
            &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;
        &lt;/systemProperties&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>現在、 <code>@QuarkusTest</code> と <code>@QuarkusIntegrationTest</code> を同じテストランで実行しないでください。</p>
</div>
<div class="paragraph">
<p>Maven の場合、前者は surefire プラグインによって、後者は failsafe プラグインによって実行される必要があることを意味します。</p>
</div>
<div class="paragraph">
<p>Gradle の場合、これは 2 種類のテストが異なるソースセットに属する必要があることを意味します。</p>
</div>
<details>
<summary class="title">ソースセットの設定例</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">/** custom source sets
 *
 * io.quarkus.gradle.QuarkusPlugin
 * io.quarkus.test.junit.IntegrationTestUtil
 *
 * to work around
 *  https://github.com/quarkusio/quarkus/issues/43796
 *  https://github.com/quarkusio/quarkus/issues/43804
 */

sourceSets {
    create("intTest") {
        compileClasspath += sourceSets.main.get().output
        runtimeClasspath += sourceSets.main.get().output
    }
    create("e2eTest") {
        compileClasspath += sourceSets.main.get().output
        runtimeClasspath += sourceSets.main.get().output
    }
}

configurations {
    getByName("intTestImplementation") {
        extendsFrom(configurations.testImplementation.get())
    }
    getByName("intTestRuntimeOnly") {
        extendsFrom(configurations.testRuntimeOnly.get())
    }
    getByName("e2eTestImplementation") {
        extendsFrom(configurations.testImplementation.get())
    }
    getByName("e2eTestRuntimeOnly") {
        extendsFrom(configurations.testRuntimeOnly.get())
    }
}

tasks.register&lt;Test&gt;("intTest") {
    group = "verification"
    description = "Runs integration tests"

    testClassesDirs = sourceSets["intTest"].output.classesDirs
    classpath = sourceSets["intTest"].runtimeClasspath

    systemProperty("build.output.directory", "build")
    systemProperty("quarkus.profile", "intTest")
}

tasks.register&lt;Test&gt;("e2eTest") {
    group = "verification"
    description = "Runs e2e tests"

    val quarkusBuild = tasks.getByName("quarkusBuild")
    dependsOn(quarkusBuild)

    testClassesDirs = sourceSets["e2eTest"].output.classesDirs
    classpath = sourceSets["e2eTest"].runtimeClasspath

    systemProperty("build.output.directory", "build")
}

idea.module {
    testSources.from(sourceSets["intTest"].kotlin.srcDirs)
    testSources.from(sourceSets["e2eTest"].kotlin.srcDirs)
}</code></pre>
</div>
</div>
</div>
</details>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test-from-ide"><a class="anchor" href="#test-from-ide"></a>19. IDE から <code>@QuarkusTest</code> を実行する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ほとんどの IDE では、選択したクラスを JUnit テストとして直接実行できるようになっています。そのためには、選択した IDE の設定でいくつかのプロパティーを設定する必要があります:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.logging.manager</code> (<a href="logging">ロギングガイド</a> を参照)</p>
</li>
<li>
<p><code>maven.home</code> (<code>${maven.home}/conf/settings.xml</code> にカスタム設定がある場合のみ)、<a href="maven-tooling">Maven Guide</a> を参照)</p>
</li>
<li>
<p><code>maven.settings</code> (カスタム版の <code>settings.xml</code> ファイルをテストに使用する場合)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="eclipse-separate-jre-definition"><a class="anchor" href="#eclipse-separate-jre-definition"></a>19.1. Eclipse の別個の JRE 定義</h3>
<div class="paragraph">
<p>現在の"Installed JRE"定義を新しい定義にコピーし、新しいVMの引数としてプロパティーを追加します:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-Djava.util.logging.manager=org.jboss.logmanager.LogManager</code></p>
</li>
<li>
<p><code>-Dmaven.home=&lt;path-to-your-maven-installation&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>このJRE定義をQuarkusプロジェクトのターゲットランタイムとして使用すると、「Run as JUnit」設定に回避策が適用されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="vscode-run-with-configuration"><a class="anchor" href="#vscode-run-with-configuration"></a>19.2. VSCode "run with" 設定</h3>
<div class="paragraph">
<p>プロジェクトディレクトリーやワークスペースのルートにある <code>settings.json</code> には、テスト設定で次の回避策が必要です:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"java.test.config": [
    {
        "name": "quarkusConfiguration",
        "vmargs": [ "-Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dmaven.home=&lt;path-to-your-maven-installation&gt; ..." ],
        ...
    },
  ...
]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="intellij-idea-junit-template"><a class="anchor" href="#intellij-idea-junit-template"></a>19.3. IntelliJ IDEA JUnit テンプレート</h3>
<div class="paragraph">
<p>IntelliJ IDEA では何も必要ありません。なぜなら、IDEは <code>systemPropertyVariables</code> を <code>pom.xml</code> の surefire プラグイン設定から取得するからです。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-dev-services"><a class="anchor" href="#testing-dev-services"></a>20. 開発サービスのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>デフォルトでは、テストは <a href="dev-services">Dev Services</a> でのみ機能するはずですが、一部のユースケースでは、テストで自動的に設定されたプロパティーにアクセスする必要がある場合があります。</p>
</div>
<div class="paragraph">
<p>これは、 <code>@QuarkusTest</code> または <code>@QuarkusIntegrationTest</code> に直接注入できる <code>io.quarkus.test.common.DevServicesContext</code> を使用して行うことができます。タイプ <code>DevServicesContext</code> のフィールドを定義するだけで、自動的に注入されます。これを使用して、設定されている任意のプロパティーを取得できます。通常、これは、テスト自体からリソースに直接接続するために使用されます。たとえば、kafka に接続して、テスト対象のアプリケーションにメッセージを送信するために使用されます。</p>
</div>
<div class="paragraph">
<p><code>io.quarkus.test.common.DevServicesContext.ContextAware</code> を実装するオブジェクトへの注入もサポートされています。 <code>io.quarkus.test.common.DevServicesContext.ContextAware</code> を実装するフィールドがある場合、Quarkus は ` setIntegrationTestContext` メソッドを呼び出して、コンテキストをこのオブジェクトに渡します。これにより、クライアントロジックをユーティリティークラスにカプセル化できます。</p>
</div>
<div class="paragraph">
<p><code>QuarkusTestResourceLifecycleManager</code> 実装は、 <code>ContextAware</code> を実装してこれらのプロパティーにアクセスすることもできます。これにより、Quarkus が起動する前にリソースを設定できます (たとえば、KeyCloak インスタンスの設定、データベースへのデータの追加など)。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>アプリケーションをコンテナーとしてランチャーにする <code>@QuarkusIntegrationTest</code> テストの場合、 <code>io.quarkus.test.common.DevServicesContext</code> は、アプリケーションコンテナーが起動されたコンテナーネットワークの ID へのアクセスも提供します (<code>containerNetworkId</code> メソッドを使用)。これは、アプリケーションが通信する追加のコンテナーを起動する必要がある <code>QuarkusTestResourceLifecycleManager</code> で使用できます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-components"><a class="anchor" href="#testing-components"></a>21. コンポーネントのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus は、コンポーネントのテストと依存関係のモック作成を容易にする JUnit エクステンションである <code>QuarkusComponentTestExtension</code> を提供します。
この JUnit エクステンションは、 <code>quarkus-junit5-component</code> 依存関係で利用できます。</p>
</div>
<div class="paragraph">
<p>2 つの注入ポイントを持つ CDI Bean であるコンポーネント <code>Foo</code> があるとします。</p>
</div>
<div class="listingblock">
<div class="title"><code>Foo</code> コンポーネント</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped <i class="conum" data-value="1"></i><b>(1)</b>
public class Foo {

    @Inject
    Charlie charlie; <i class="conum" data-value="2"></i><b>(2)</b>

    @ConfigProperty(name = "bar")
    boolean bar; <i class="conum" data-value="3"></i><b>(3)</b>

    public String ping() {
        return bar ? charlie.ping() : "nok";
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Foo</code> は <code>@ApplicationScoped</code> CDI Bean です。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Foo</code> は、メソッド <code>ping()</code> を宣言する <code>Charlie</code> に依存します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Foo</code> は設定プロパティー <code>bar</code> に依存します。 <code>@Inject</code> は CDI 修飾子も宣言するため、この注入ポイントには必要ありません。これは Quarkus 固有の機能です。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この場合、コンポーネントテストは次のようになります。</p>
</div>
<div class="listingblock">
<div class="title">シンプルなコンポーネントテスト</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.junit.jupiter.api.Assertions.assertEquals;

import jakarta.inject.Inject;
import io.quarkus.test.InjectMock;
import io.quarkus.test.component.TestConfigProperty;
import io.quarkus.test.component.QuarkusComponentTest;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

@QuarkusComponentTest <i class="conum" data-value="1"></i><b>(1)</b>
@TestConfigProperty(key = "bar", value = "true") <i class="conum" data-value="2"></i><b>(2)</b>
public class FooTest {

    @Inject
    Foo foo; <i class="conum" data-value="3"></i><b>(3)</b>

    @InjectMock
    Charlie charlieMock; <i class="conum" data-value="4"></i><b>(4)</b>

    @Test
    public void testPing() {
        Mockito.when(charlieMock.ping()).thenReturn("OK"); <i class="conum" data-value="5"></i><b>(5)</b>
        assertEquals("OK", foo.ping());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuarkusComponentTest</code> アノテーションは JUnit エクステンションを登録します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>テストの設定プロパティーを設定します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>このテストはテスト対象のコンポーネントを注入します。 <code>@Inject</code> でアノテーションが付けられたすべてのフィールドの型が、テスト対象のコンポーネント型とみなされます。 <code>@QuarkusComponentTest#value()</code> を使用して追加のコンポーネントクラスを指定することもできます。さらに、テストクラスで宣言された静的ネストクラスもコンポーネントです。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>このテストは <code>Charlie</code> のモックも挿入します。 <code>Charlie</code> は、 <code>@Singleton</code> 合成 Bean が自動的に登録される、<em>満たされていない</em> 依存関係です。挿入される参照は、"未設定" の Mockito モックです。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>テストメソッドで Mockito API を活用して動作を設定できます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>さらに多くの例とヒントについては、 <a href="testing-components">テストコンポーネントリファレンスガイド</a> を参照してください。</p>
</div>
</div>
</div>
    </div>
    <div class="grid__item width-4-12 width-12-12-m tocwrapper">
      <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#prerequisites">1. 要件</a></li>
<li><a href="#architecture">2. アーキテクチャー</a></li>
<li><a href="#solution">3. ソリューション</a></li>
<li><a href="#recap-of-http-based-testing-in-jvm-mode">4. JVM モードでの HTTP ベースのテストの要約</a>
<ul class="sectlevel2">
<li><a href="#controlling-the-test-port">4.1. テストポートの制御</a></li>
<li><a href="#controlling-http-interaction-timeout">4.2. HTTP インタラクションタイムアウトの制御</a></li>
<li><a href="#injecting-a-uri">4.3. URI の挿入</a></li>
</ul>
</li>
<li><a href="#testing-a-specific-endpoint">5. 特定のエンドポイントのテスト</a>
<ul class="sectlevel2">
<li><a href="#testhttpresource">5.1. テストHTTPリソース</a></li>
<li><a href="#restassured">5.2. RESTassured</a></li>
</ul>
</li>
<li><a href="#injection-into-tests">6. テストへの注入</a></li>
<li><a href="#applying-interceptors-to-tests">7. テストへのインターセプターの適用</a></li>
<li><a href="#tests-and-transactions">8. テストとトランザクション</a></li>
<li><a href="#enrichment-via-quarkustestcallback">9. QuarkusTest* コールバックによる強化</a></li>
<li><a href="#testing_different_profiles">10. 異なるプロファイルのテスト</a>
<ul class="sectlevel2">
<li><a href="#writing-a-profile">10.1. プロフィールの書き方</a></li>
<li><a href="#running-specific-tests">10.2. 特定のテストの実行</a></li>
</ul>
</li>
<li><a href="#nested-tests">11. ネストしたテスト</a></li>
<li><a href="#mock-support">12. モックサポート</a>
<ul class="sectlevel2">
<li><a href="#cdi-alternative-mechanism">12.1. CDI <code>@Alternative</code> メカニズム</a></li>
<li><a href="#quarkus_mock">12.2. QuarkusMock を使用したモッキング</a></li>
<li><a href="#mocking-with-panache">12.3. Mocking with Panache</a></li>
</ul>
</li>
<li><a href="#testing-security">13. セキュリティーのテスト</a></li>
<li><a href="#quarkus-test-resource">14. Quarkus アプリケーションの開始前にサービスを開始する</a>
<ul class="sectlevel2">
<li><a href="#altering-the-test-class">14.1. テストクラスの変更</a></li>
<li><a href="#annotation-based-test-resources">14.2. アノテーションベースのテストリソース</a></li>
<li><a href="#usage-of-withtestresource">14.3. <code>@WithTestResource</code> の使用法</a></li>
</ul>
</li>
<li><a href="#hang-detection">15. ハング検出</a></li>
<li><a href="#native-executable-testing">16. ネイティブ実行可能ファイルテスト</a></li>
<li><a href="#quarkus-integration-test">17. <code>@QuarkusIntegrationTest</code> の使用</a>
<ul class="sectlevel2">
<li><a href="#debugging-quarkusintegrationtest">17.1. Debugging <code>@QuarkusIntegrationTest</code></a></li>
<li><a href="#launching-containers">17.2. コンテナーの起動</a></li>
<li><a href="#executing-against-a-running-application">17.3. 実行中のアプリケーションに対するテストの実行</a></li>
</ul>
</li>
<li><a href="#mixing-quarkustest-with-other-type-of-tests">18. <code>@QuarkusTest</code> と他のタイプのテストを混合</a></li>
<li><a href="#test-from-ide">19. IDE から <code>@QuarkusTest</code> を実行する</a>
<ul class="sectlevel2">
<li><a href="#eclipse-separate-jre-definition">19.1. Eclipse の別個の JRE 定義</a></li>
<li><a href="#vscode-run-with-configuration">19.2. VSCode "run with" 設定</a></li>
<li><a href="#intellij-idea-junit-template">19.3. IntelliJ IDEA JUnit テンプレート</a></li>
</ul>
</li>
<li><a href="#testing-dev-services">20. 開発サービスのテスト</a></li>
<li><a href="#testing-components">21. コンポーネントのテスト</a></li>
</ul></div>
    </div>
  </div>
  <h2>関連コンテンツ</h2>
  <div class="grid-wrapper relations">
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じトピックについて</h3>
      <ul class="related-content">
      
        
        <li class="guide"><a href="/guides/continuous-testing">継続的テスト</a></li>
      
        
        <li class="guide"><a href="/guides/tests-with-coverage">テストカバレッジの測定</a></li>
      
        
        <li class="guide"><a href="/guides/testing-components">コンポーネントのテスト</a></li>
      
        
        <li class="guide"><a href="/guides/cli-tooling">Quarkus コマンドラインインターフェイス (CLI) を使用した Quarkus アプリの構築</a></li>
      
        
        <li class="guide"><a href="/guides/compose-dev-services">Compose Dev Services</a></li>
      
        
        <li class="guide"><a href="/guides/upx">UPXでネイティブ実行可能ファイルを圧縮</a></li>
      
        
        <li class="tutorial"><a href="/guides/getting-started">初めてのアプリケーションの作成</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-dev-services">OpenID Connect (OIDC)のDev ServicesとDev UI</a></li>
      
        
        <li class="guide"><a href="/guides/amqp-dev-services">Dev Services for AMQP</a></li>
      
        
        <li class="guide"><a href="/guides/apicurio-registry-dev-services">Dev Services for Apicurio Registry</a></li>
      
        
        <li class="guide"><a href="/guides/databases-dev-services">Dev Services for Databases</a></li>
      
        
        <li class="guide"><a href="/guides/elasticsearch-dev-services">Dev Services for Elasticsearch</a></li>
      
        
        <li class="guide"><a href="/guides/infinispan-dev-services">Dev Services for Infinispan</a></li>
      
        
        <li class="guide"><a href="/guides/kafka-dev-services">Dev Services for Kafka</a></li>
      
        
        <li class="guide"><a href="/guides/kubernetes-dev-services">Dev Services for Kubernetes</a></li>
      
        
        <li class="guide"><a href="/guides/pulsar-dev-services">Dev Services for Pulsar</a></li>
      
        
        <li class="guide"><a href="/guides/rabbitmq-dev-services">Dev Services for RabbitMQ</a></li>
      
        
        <li class="guide"><a href="/guides/redis-dev-services">Dev Services for Redis</a></li>
      
        
        <li class="guide"><a href="/guides/dev-services">Dev Servicesの概要</a></li>
      
        
        <li class="guide"><a href="/guides/dev-ui">Dev UI</a></li>
      </ul>
    </div>
    </div>
  </div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license. <i class='fab fa-creative-commons'></i><i class='fab fa-creative-commons-by'></i> <a href='https://creativecommons.org/licenses/by/3.0/' target='_blank'>CC by 3.0</a><br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>GitHub Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
          
            <li><a href="/" target="_blank">ホーム</a></li>
          
          
          
            <li><a href="/about" target="_blank">Quarkusについて</a></li>
          
          
          
            <li><a href="/blog" target="_blank">ブログ</a></li>
          
          
          
            <li><a href="/insights" target="_blank">ポッドキャスト</a></li>
          
          
          
            <li><a href="/events" target="_blank">イベント</a></li>
          
          
          
            <li><a href="/newsletter" target="_blank">ニュースレター</a></li>
          
          
          
            <li><a href="/userstories" target="_blank">ユーザーストーリー</a></li>
          
          
          
            <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" target="_blank">ロードマップ</a></li>
          
          
          
            <li><a href="/security" target="_blank">セキュリティ&nbsp;ポリシー</a></li>
          
          
          
            <li><a href="/usage" target="_blank">使用方法</a></li>
          
          
          
            <li><a href="/brand" target="_blank">Brand</a></li>
          
          
          
            <li><a href="/desktopwallpapers" target="_blank">Wallpapers</a></li>
          
          
          
            <li><a href="https://www.redhat.com/en/about/privacy-policy" target="_blank">Privacy Policy</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォローする</span>
        <ul class="footer-links">
          
          
            <li><a href="https://x.com/quarkusio" target="_blank">X</a></li>
          
          
          
            <li><a href="https://bsky.app/profile/quarkus.io" target="_blank">Bluesky</a></li>
          
          
          
            <li><a rel="me" href="https://fosstodon.org/@quarkusio" target="_blank">Mastodon</a></li>
            
          
          
            <li><a href="https://www.threads.com/@quarkusio" target="_blank">Threads</a></li>
          
          
          
            <li><a href="https://www.facebook.com/quarkusio" target="_blank">Facebook</a></li>
          
          
          
            <li><a href="https://www.linkedin.com/company/quarkusio/" target="_blank">Linkedin</a></li>
          
          
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg" target="_blank">Youtube</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio" target="_blank">GitHub</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
          
            <li><a href="/support" target="_blank">サポート</a></li>
          
          
          
            <li><a href="/guides" target="_blank">ガイド</a></li>
          
          
          
            <li><a href="/faq" target="_blank">FAQ</a></li>
          
          
          
            <li><a href="/get-started" target="_blank">入門</a></li>
          
          
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus" target="_blank">Stack Overflow</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions" target="_blank">ディスカッション</a></li>
          
          
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev" target="_blank">開発メーリングリスト</a></li>
          
          
          
            <li><a href="https://stats.uptimerobot.com/ze1PfweT2p" target="_blank">Quarkus Service Status</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>言語</span>
        <ul class="footer-links">
          
          
            <li><a href=" https://quarkus.io/ " target="_blank">English</a></li>
          
          
          
            <li><a href="https://pt.quarkus.io/" target="_blank">Português&nbsp;(Brasileiro)</a></li>
          
          
          
            <li><a href=" https://es.quarkus.io/ " target="_blank">Español</a></li>
          
          
          
            <li><a href="https://cn.quarkus.io/" target="_blank">简体中文</a></li>
          
          
          
            <li><a href=" https://ja.quarkus.io/ " target="_blank">日本語</a></li>
          
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています</span>
        <ul class="footer-links">
          
            <li><a blah href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a blah href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a blah href="https://hibernate.org" target="_blank">Hibernate ORM</a></li>
          
            <li><a blah href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a blah href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a blah href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a blah href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a blah href="https://code.quarkus.io/" target="_blank">その他多数...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content cf-footer">
  <div class="flexcontainer">
    <div class="cf-logo">
      <a class="cf-logo" href="https://www.commonhaus.org/" target="_blank"><img src="https://raw.githubusercontent.com/commonhaus/artwork/main/foundation/brand/svg/CF_logo_horizontal_single_reverse.svg"/></a>
    </div>
    <div class="license">
      Copyright © Quarkus. All rights reserved. For details on our trademarks, please visit our <a href="https://www.commonhaus.org/policies/trademark-policy/">Trademark Policy</a> and <a href="https://www.commonhaus.org/trademarks/">Trademark List</a>. Trademarks of third parties are owned by their respective holders and their mention here does not suggest any endorsement or association.
    </div>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
  <script src="/assets/javascript/future-date.js" type="text/javascript"></script>
  <script src="/assets/javascript/randomize.js" type="text/javascript"></script>
  <script src="/assets/javascript/time.js" type="text/javascript"></script>
</body>

</html>
