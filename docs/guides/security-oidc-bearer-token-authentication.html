<!DOCTYPE html>
<html lang="ja">







<head>
  <title>OpenID Connect (OIDC) ベアラートークン認証 - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="
  connect-src 'self' https://dpm.demdex.net https://adobedc.demdex.net https://analytics.ossupstream.org/ https://search.quarkus.io https://smetrics.redhat.com https://ajax.googleapis.com; 
  script-src 'self' 'unsafe-inline' 'unsafe-eval'
      
      https://assets.adobedtm.com
      js.bizographics.com
      https://www.redhat.com
      https://static.redhat.com
      https://app.requestly.io/
      jsonip.com
      https://ajax.googleapis.com
      https://use.fontawesome.com
      http://www.youtube.com
      http://www.googleadservices.com
      https://googleads.g.doubleclick.net
      https://giscus.app
      https://analytics.ossupstream.org/
      https://app.mailjet.com;

  style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; 
  img-src 'self' * data:; 
  media-src 'self'; 
  frame-src https://redhat.demdex.net https://www.youtube.com https://player.restream.io https://app.mailjet.com http://xy0p2.mjt.lu https://mj.quarkus.io https://giscus.app; 
  base-uri 'none'; 
  object-src 'none'; 
  form-action 'none'; 
  font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />

  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/guides/security-oidc-bearer-token-authentication" />
  <meta property="og:title" content="OpenID Connect (OIDC) ベアラートークン認証" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/security-oidc-bearer-token-authentication">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />  
  <script src="/assets/javascript/tracking.js"></script>
  
  <script src="/assets/javascript/colormode.js" type="text/javascript"></script>

</head>

<body class="guides">

  


<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io/guides/security-oidc-bearer-token-authentication">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
        <div class="logo-wrapper">
           <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
        </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="#">Why<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/performance" class="">パフォーマンス</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
          <li><a href="/versatility" class="">多用途性</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/spring" class="">USING SPRING?</a></li>
          <li class="tertiarydropdown">
            <span href="#">AI<i class="fas fa-chevron-down"></i></span>
            <ul class="tertiarymenu">
              <li><a href="/ai" class="">AI OVERVIEW</a></li>
              <li><a href="/java-for-ai" class="">JAVA FOR AI</a></li>
              <li><a href="/quarkus-for-ai" class="">WHY QUARKUS FOR AI</a></li>
              <li><a href="/ai-blueprints" class="">AI BLUEPRINTS</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Learn<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ドキュメント</a></li>
          <li><a href="/userstories/" class="">ユーザーストーリー</a></li>  
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="#">Extensions<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          
          <!-- Note that quarkus.io is hardcoded here, because it is the only url which supports extensions -->
<li><a href="https://quarkus.io/extensions/" class="">エクステンションを探す</a></li>
          <li><a href="/faq/#what-is-a-quarkus-extension" class="">エクステンションの使用</a></li>
          <li><a href="/guides/writing-extensions" class="">エクステンションの作成</a></li>
          <li><a href="https://hub.quarkiverse.io" class="">エクステンションの共有</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Community<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/working-groups" class="">ワーキンググループ</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="">ロードマップ</a></li>
          <li><a href="/benefactors" class="">BENEFACTORS</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/guides/security-oidc-bearer-token-authentication" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://pt.quarkus.io/guides/security-oidc-bearer-token-authentication">ポルトガル（BR）</a></li>
          <li><a href="https://es.quarkus.io/guides/security-oidc-bearer-token-authentication">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/guides/security-oidc-bearer-token-authentication">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/guides/security-oidc-bearer-token-authentication">日本語</a></li>
          </ul>
      </li>
      <li>
        <span href="#" class="modeswitcher" id='theme-toggle'><i class="fas
fa-sun"></i><i class="fas fa-moon"></i><i class="fas fa-cog"></i></span>
      </li>
    </ul>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    







<section class="full-width-version-bg flexfilterbar guides">
  <div class="guideflexcontainer">
    <div class="docslink">
      <a class="returnlink" href="/guides/"> Back to Guides</a>
    </div>
    <div class="flexlabel">
      <label>バージョン:</label>
    </div>
    <div class="guidepulldown version">
    <select id="guide-version-dropdown">
      
        
        
        <option value="main" >Main - SNAPSHOT</option>
        
        
        
        <option value="latest" selected>3.31.3 - Latest</option>
        
        
        
        <option value="3.27" >3.27</option>
        
        
        
        <option value="3.20" >3.20</option>
        
        
        
        <option value="3.15" >3.15</option>
        
        
        
        <option value="3.8" >3.8</option>
        </select>
    </div>
  </div>
</section>

<div class="guide">
  <div class="grid-wrapper">
    <div class="grid__item width-8-12 width-12-12-m">
      
      <a class="editlink" href="https://github.com/quarkusio/quarkus/edit/main/docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc">このページを編集</a>
      
      <h1 class="text-caps">OpenID Connect (OIDC) ベアラートークン認証 </h1>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus OpenID Connect（OIDC）エクステンションを使用することで、ベアラートークン認証を使って、アプリケーション内のJakarta REST（旧称JAX-RS）エンドポイントへのHTTPアクセスを保護できます。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview-of-the-bearer-token-authentication-mechanism-in-quarkus"><a class="anchor" href="#overview-of-the-bearer-token-authentication-mechanism-in-quarkus"></a>Quarkusのベアラートークン認証メカニズムの概要</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkusは、Quarkus OpenID Connect（OIDC）エクステンションを通じて、ベアラートークン認証メカニズムをサポートしています。</p>
</div>
<div class="paragraph">
<p>ベアラートークンは、 <a href="https://www.keycloak.org">Keycloak</a> などのOIDCやOAuth2.0に準拠した認可サーバーで発行されます。</p>
</div>
<div class="paragraph">
<p>ベアラートークン認証は、ベアラートークンの存在と有効性に基づいて HTTP リクエストを認可するプロセスです。
ベアラートークンは、呼び出しの主体に関する情報を提供します。この情報は、HTTP リソースにアクセスできるかどうかを判断するために使用されます。</p>
</div>
<div class="paragraph">
<p>以下の図に、Quarkusのベアラートークン認証メカニズムの概要を示します：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/guides/images/security-bearer-token-authorization-mechanism-1.png" alt="Bearer token authentication" width="60%">
</div>
<div class="title">Figure 1. Quarkus のベアラー認証メカニズムとシングルページアプリケーション</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Quarkus サービスが、OIDC プロバイダーから検証キーを取得します。
検証キーは、ベアラーアクセストークンの署名を検証するために使用されます。</p>
</li>
<li>
<p>Quarkus ユーザーが、シングルページアプリケーション (SPA) にアクセスします。</p>
</li>
<li>
<p>シングルページアプリケーションが、認可コードフローを使用してユーザーを認証し、OIDC プロバイダーからトークンを取得します。</p>
</li>
<li>
<p>シングルページアプリケーションが、アクセストークンを使用して、Quarkus サービスからサービスデータを取得します。</p>
</li>
<li>
<p>Quarkus サービスが、検証キーを使用してベアラーアクセストークンの署名を検証し、トークンの有効期限やその他のクレームをチェックします。トークンが有効であればリクエストの続行を許可し、シングルページアプリケーションにサービスレスポンスを返します。</p>
</li>
<li>
<p>シングルページアプリケーションが、Quarkus ユーザーに同じデータを返します。</p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/guides/images/security-bearer-token-authorization-mechanism-2.png" alt="Bearer token authentication" width="60%">
</div>
<div class="title">Figure 2. Quarkus のベアラートークン認証メカニズムとJava またはコマンドラインクライアント</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Quarkus サービスが、OIDC プロバイダーから検証キーを取得します。
検証キーは、ベアラーアクセストークンの署名を検証するために使用されます。</p>
</li>
<li>
<p>クライアントが、 <code>client_credentials</code> かパスワードグラントを使用して、OIDC プロバイダーからアクセストークンを取得します。client_credentials には、クライアント ID とシークレットが必要です。パスワードグラントには、クライアント ID、シークレット、ユーザー名、およびパスワードが必要です。</p>
</li>
<li>
<p>クライアントがアクセストークンを使用して、Quarkus サービスからサービスデータを取得します。</p>
</li>
<li>
<p>Quarkus サービスが、検証キーを使用してベアラーアクセストークンの署名を検証し、トークンの有効期限やその他のクレームをチェックします。トークンが有効であればリクエストの続行を許可し、サービスレスポンスをクライアントに返します。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>OIDC 認可コードフローを使用してユーザーを認証および認可する必要がある場合は、Quarkus の <a href="security-oidc-code-flow-authentication">Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム</a> ガイドを参照してください。
また、Keycloak とベアラートークンを使用する場合は、Quarkus <a href="security-keycloak-authorization">Keycloak を使用した認可の一元化</a> ガイドを参照してください。</p>
</div>
<div class="paragraph">
<p>OIDC ベアラートークン認証を使用してサービスアプリケーションを保護する方法については、次のチュートリアルを参照してください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="security-oidc-bearer-token-authentication-tutorial">OpenID Connect（OIDC）ベアラートークン認証によるサービスアプリケーションの保護</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>マルチテナントをサポートする方法については、Quarkus <a href="security-openid-connect-multitenancy">OpenID Connect マルチテナンシーの使用</a> ガイドを参照してください。</p>
</div>
<div class="sect2">
<h3 id="accessing-jwt-claims"><a class="anchor" href="#accessing-jwt-claims"></a>JWT クレームへのアクセス</h3>
<div class="paragraph">
<p>JWT トークンクレームにアクセスする必要がある場合は、 <code>JsonWebToken</code> を注入できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import org.eclipse.microprofile.jwt.JsonWebToken;
import jakarta.inject.Inject;
import jakarta.annotation.security.RolesAllowed;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/api/admin")
public class AdminResource {

    @Inject
    JsonWebToken jwt;

    @GET
    @RolesAllowed("admin")
    @Produces(MediaType.TEXT_PLAIN)
    public String admin() {
        return "Access for subject " + jwt.getSubject() + " is granted";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>JsonWebToken</code> の注入は、 <code>@ApplicationScoped</code>、 <code>@Singleton</code>、および <code>@RequestScoped</code> スコープでサポートされています。
ただし、個々のクレームが単純型として挿入される場合は、 <code>@RequestScoped</code> を使用する必要があります。
詳細は、Quarkus の「JWT RBAC の使用」ガイドの <a href="security-jwt#supported-injection-scopes">サポートされている注入スコープ</a> セクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-user-info"><a class="anchor" href="#bearer-token-user-info"></a><code>UserInfo</code></h3>
<div class="paragraph">
<p>OIDC <code>UserInfo</code> エンドポイントから UserInfo JSON オブジェクトをリクエストする必要がある場合は、 <code>quarkus.oidc.authentication.user-info-required=true</code> を設定します。
OIDC プロバイダーの <code>UserInfo</code> エンドポイントにリクエストが送信され、 <code>io.quarkus.oidc.UserInfo</code> (単純な <code>javax.json.JsonObject</code> ラッパー) オブジェクトが作成されます。
<code>io.quarkus.oidc.UserInfo</code> は、 <code>SecurityIdentity</code> <code>userinfo</code> 属性として注入またはアクセスできます。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.user-info-required</code> は、次のいずれかの条件が満たされた場合に自動的に有効になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.oidc.roles.source</code> が <code>userinfo</code> に設定されている場合、または <code>quarkus.oidc.token.verify-access-token-with-user-info</code> が <code>true</code> に設定されている場合、または <code>quarkus.oidc.authentication.id-token-required</code> が <code>false</code> に設定されている場合。このような場合、現在の OIDC テナントが UserInfo エンドポイントをサポートしている必要があります。</p>
</li>
<li>
<p><code>io.quarkus.oidc.UserInfo</code> インジェクションポイントが検出された場合。ただし、有効になるのは、現在の OIDC テナントが UserInfo エンドポイントをサポートしている場合だけです。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-config-metadata"><a class="anchor" href="#bearer-token-config-metadata"></a>設定メタデータ</h3>
<div class="paragraph">
<p>現在のテナントの検出された <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID Connect 設定メタデータ</a> は、 <code>io.quarkus.oidc.OidcConfigurationMetadata</code> で表され、 <code>SecurityIdentity</code> <code>configuration-metadata</code> 属性として注入またはアクセスできます。</p>
</div>
<div class="paragraph">
<p>エンドポイントがパブリックの場合、デフォルトのテナントの <code>OidcConfigurationMetadata</code> が注入されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="token-claims-and-security-identity-roles"><a class="anchor" href="#token-claims-and-security-identity-roles"></a>トークンクレームと SecurityIdentity ロール</h3>
<div class="paragraph">
<p><code>SecurityIdentity</code> ロールは、次のように、検証済みの JWT アクセストークンからマッピングすることができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.oidc.roles.role-claim-path</code> プロパティーが設定されており、一致する配列または文字列のクレームが見つかった場合、そのクレームからロールが抽出されます。
たとえば、 <code>customroles</code>、 <code>customroles/array</code>、 <code>scope</code>、 <code>"http://namespace-qualified-custom-claim"/roles</code>、 <code>"http://namespace-qualified-roles"</code> などです。</p>
</li>
<li>
<p><code>groups</code> クレームが利用可能な場合は、その値が使用されます。</p>
</li>
<li>
<p><code>realm_access/roles</code> または <code>resource_access/client_id/roles</code> (<code>client_id</code> は <code>quarkus.oidc.client-id</code> プロパティーの値) クレームが利用可能な場合は、その値が使用されます。
このチェックは、Keycloak が発行するトークンをサポートします。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>たとえば、次の JWT トークンには、ロールが含まれている <code>roles</code> 配列を含む複雑な <code>groups</code> クレームがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "iss": "https://server.example.com",
    "sub": "24400320",
    "upn": "jdoe@example.com",
    "preferred_username": "jdoe",
    "exp": 1311281970,
    "iat": 1311280970,
    "groups": {
        "roles": [
          "microprofile_jwt_user"
        ],
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>microprofile_jwt_user</code> ロールは、 <code>SecurityIdentity</code> ロールにマップする必要があります。これは、 <code>quarkus.oidc.roles.role-claim-path=groups/roles</code> 設定で実行できます。</p>
</div>
<div class="paragraph">
<p>トークンが不透明 (バイナリー) の場合は、リモートトークンイントロスペクションレスポンスの <code>scope</code> プロパティーが使用されます。</p>
</div>
<div class="paragraph">
<p><code>UserInfo</code> がロールのソースである場合は、 <code>quarkus.oidc.authentication.user-info-required=true</code> および <code>quarkus.oidc.roles.source=userinfo</code> を設定し、必要に応じて <code>quarkus.oidc.roles.role-claim-path</code> を設定します。</p>
</div>
<div class="paragraph">
<p>さらに、カスタムの <code>SecurityIdentityAugmentor</code> を使用してロールを追加することもできます。
詳細は、Quarkus の「セキュリティーに関するヒントとコツ」ガイドの <a href="security-customization#security-identity-customization">セキュリティーアイデンティティーのカスタマイズ</a> セクションを参照してください。</p>
</div>
<div class="paragraph">
<p>また、<a href="security-authorize-web-endpoints-reference#map-security-identity-roles">HTTP セキュリティーポリシー</a> を使用して、トークンクレームから作成された <code>SecurityIdentity</code> ロールをデプロイメント固有のロールにマップすることもできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="token-scopes-and-security-identity-permissions"><a class="anchor" href="#token-scopes-and-security-identity-permissions"></a>トークンのスコープと SecurityIdentity の権限</h3>
<div class="paragraph">
<p><code>SecurityIdentity</code> 権限は、 <code>io.quarkus.security.StringPermission</code> の形式で、<a href="#token-claims-and-security-identity-roles">source of the roles</a> のスコープパラメーターから、同じクレームセパレーターを使用してマッピングされます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.List;
import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.jwt.Claims;
import org.eclipse.microprofile.jwt.JsonWebToken;

import io.quarkus.security.PermissionsAllowed;

@Path("/service")
public class ProtectedResource {

    @Inject
    JsonWebToken accessToken;

    @PermissionsAllowed("email") <i class="conum" data-value="1"></i><b>(1)</b>
    @GET
    @Path("/email")
    public Boolean isUserEmailAddressVerifiedByUser() {
        return accessToken.getClaim(Claims.email_verified.name());
    }

    @PermissionsAllowed("orders_read") <i class="conum" data-value="2"></i><b>(2)</b>
    @GET
    @Path("/order")
    public List&lt;Order&gt; listOrders() {
        return List.of(new Order("1"));
    }

    public static class Order {
        String id;
        public Order() {
        }
        public Order(String id) {
            this.id = id;
        }
        public String getId() {
            return id;
        }
        public void setId() {
            this.id = id;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>OpenID Connect スコープ <code>email</code> を持つリクエストのみにアクセスが許可されます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>読み取りアクセスは、 <code>orders_read</code> スコープを持つクライアントリクエストに制限されます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>io.quarkus.security.PermissionsAllowed</code> アノテーションの詳細は、「Web エンドポイントの認可」ガイドの <a href="security-authorize-web-endpoints-reference#permission-annotation">権限アノテーション</a> セクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-token-verification-introspection"><a class="anchor" href="#bearer-token-token-verification-introspection"></a>トークン検証およびイントロスペクション</h3>
<div class="paragraph">
<p>トークンが JWT トークンの場合、デフォルトでは、OIDC プロバイダーの JWK エンドポイントから取得されたローカルの <code>JsonWebKeySet</code> の <code>JsonWebKey</code> (JWK) キーを使用してトークンが検証されます。
トークンのキー識別子 (<code>kid</code>) ヘッダー値は、一致する JWK キーを検出するために使用されます。
一致する <code>JWK</code> がローカルで利用できない場合は、JWK エンドポイントから現在のキーセットが取得され、 <code>JsonWebKeySet</code> が更新されます。
<code>JsonWebKeySet</code> の更新は、 <code>quarkus.oidc.token.forced-jwk-refresh-interval</code> の有効期限が切れた後にのみ繰り返すことができます。
デフォルトの有効期限は 10 分です。
一致する <code>JWK</code> が更新後に利用できない場合は、JWT トークンが OIDC プロバイダーのトークンイントロスペクションエンドポイントに送信されます。</p>
</div>
<div class="paragraph">
<p>トークンが不透明である場合、つまりバイナリートークンまたは暗号化された JWT トークンである場合、そのトークンは常に OIDC プロバイダーのトークンイントロスペクションエンドポイントに送信されます。</p>
</div>
<div class="paragraph">
<p>JWT トークンのみを使用しており、一致する <code>JsonWebKey</code> が常に使用可能であることが予想される場合 (たとえば、キーセットを更新した後)、次の例に示すように、トークンイントロスペクションを無効にする必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.token.allow-jwt-introspection=false
quarkus.oidc.token.allow-opaque-token-introspection=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>場合によっては、JWT トークンをイントロスペクションのみで検証しなければならないことがあります。これは、イントロスペクションエンドポイントアドレスのみを設定することで強制できます。
次のプロパティー設定は、これを Keycloak を使用して実現する方法の例を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.discovery-enabled=false
# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/tokens/introspect
quarkus.oidc.introspection-path=/protocol/openid-connect/tokens/introspect</code></pre>
</div>
</div>
<div class="paragraph">
<p>JWT トークンのイントロスペクションをリモートで間接的に実施することには、利点と欠点があります。
利点は、2 つのリモート呼び出し (リモート OIDC メタデータ検出呼び出しと、それに続く使用されない検証キーを取得するための別のリモート呼び出し) が不要になることです。
欠点は、ユーザーがイントロスペクションエンドポイントアドレスを確認して、手動で設定する必要があることです。</p>
</div>
<div class="paragraph">
<p>別の方法としては、デフォルトオプションである OIDC メタデータ検出を許可しながら、リモート JWT イントロスペクションのみを実行するよう要求する方法があります。次の例を参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.token.require-jwt-introspection-only=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>この方法の利点は、設定がよりシンプルで理解しやすいことです。
欠点は、検証キーが取得されない場合でも、イントロスペクションエンドポイントアドレスを検出するためにリモート OIDC メタデータ検出呼び出しが必要になることです。</p>
</div>
<div class="paragraph">
<p><code>io.quarkus.oidc.TokenIntrospection</code> (シンプルな <code>jakarta.json.JsonObject</code> ラッパーオブジェクト) が作成されます。
このオブジェクトは、JWT または不透明トークンどちらかのイントロスペクションが成功した場合、 <code>SecurityIdentity</code> <code>introspection</code> 属性として注入またはアクセスできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-token-introspection-userinfo-cache"><a class="anchor" href="#bearer-token-token-introspection-userinfo-cache"></a>トークンのイントロスペクションと <code>UserInfo</code> キャッシュ</h3>
<div class="paragraph">
<p>不透明アクセストークンは、すべてリモートでイントロスペクトする必要があります。
場合によっては、JWT アクセストークンをイントロスペクトする必要もあります。
<code>UserInfo</code> も必要な場合は、OIDC プロバイダーへの後続のリモート呼び出しで同じアクセストークンが使用されます。
したがって、 <code>UserInfo</code> が必要で、現在のアクセストークンが不透明トークンである場合、そのトークンごとに 2 つのリモート呼び出しが行われます。1 つのリモート呼び出しはトークンをイントロスペクトするためのもので、もう 1 つは <code>UserInfo</code> を取得するためのものです。
トークンが JWT の場合は、トークンをイントロスペクトする必要がなければ、 <code>UserInfo</code> を取得するための 1 つのリモート呼び出しだけで済みます。</p>
</div>
<div class="paragraph">
<p>場合によっては、着信ベアラーまたはコードフローアクセストークンごとに最大 2 つのリモート呼び出しを行うコストが問題になります。</p>
</div>
<div class="paragraph">
<p>これが本番環境に当てはまる場合は、トークンイントロスペクションと <code>UserInfo</code> データを短期間 (たとえば 3 分から 5 分) キャッシュすることを検討してください。</p>
</div>
<div class="paragraph">
<p><code>quarkus-oidc</code> は、 <code>quarkus.oidc.TokenIntrospectionCache</code> および <code>quarkus.oidc.UserInfoCache</code> インターフェイスを提供します。
これらは <code>@ApplicationScoped</code> キャッシュ実装に使用できます。次の例に示すように、 <code>@ApplicationScoped</code> キャッシュ実装を使用して、 <code>quarkus.oidc.TokenIntrospection</code> オブジェクトや <code>quarkus.oidc.UserInfo</code> オブジェクトを保存および取得します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@Alternative
@Priority(1)
public class CustomIntrospectionUserInfoCache implements TokenIntrospectionCache, UserInfoCache {
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>各 OIDC テナントは、 <code>quarkus.oidc.TokenIntrospection</code> データ、 <code>quarkus.oidc.UserInfo</code> データ、またはその両方の保存を許可または拒否できます。これには、ブール値の <code>quarkus.oidc."tenant".allow-token-introspection-cache</code> プロパティーと <code>quarkus.oidc."tenant".allow-user-info-cache</code> プロパティーを使用します。</p>
</div>
<div class="paragraph">
<p>さらに、 <code>quarkus-oidc</code> は、 <code>quarkus.oidc.TokenIntrospectionCache</code> と <code>quarkus.oidc.UserInfoCache</code> の両方のインターフェイスを実装する、シンプルなデフォルトのメモリーベースのトークンキャッシュを提供します。</p>
</div>
<div class="paragraph">
<p>デフォルトの OIDC トークンキャッシュは、次のように設定すると、有効にできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># 'max-size' is 0 by default, so the cache can be activated by setting 'max-size' to a positive value:
quarkus.oidc.token-cache.max-size=1000
# 'time-to-live' specifies how long a cache entry can be valid for and will be used by a cleanup timer:
quarkus.oidc.token-cache.time-to-live=3M
# 'clean-up-timer-interval' is not set by default, so the cleanup timer can be activated by setting 'clean-up-timer-interval':
quarkus.oidc.token-cache.clean-up-timer-interval=1M</code></pre>
</div>
</div>
<div class="paragraph">
<p>デフォルトのキャッシュは、トークンをキーとして使用します。各エントリーには、 <code>TokenIntrospection</code>、 <code>UserInfo</code>、またはその両方が含まれます。
最大で <code>max-size</code> 個のエントリーのみが保持されます。
新しいエントリーを追加するときにキャッシュがすでにいっぱいになっている場合は、期限切れのエントリーを 1 つ削除して領域を確保する試みが行われます。
さらに、クリーンアップタイマーを有効にすると、期限切れのエントリーが定期的にチェックされ、削除されます。</p>
</div>
<div class="paragraph">
<p>デフォルトのキャッシュ実装を試すことも、カスタムのキャッシュ実装を登録することもできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-jwt-claim-verification"><a class="anchor" href="#bearer-token-jwt-claim-verification"></a>JSON Web トークンのクレーム検証</h3>
<div class="paragraph">
<p>ベアラーの JWT トークンの署名が検証され、その <code>expires at</code> (<code>exp</code>) クレームがチェックされると、次に <code>iss</code> (<code>issuer</code>) クレーム値が検証されます。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、 <code>iss</code> クレーム値は、既知のプロバイダー設定で検出された <code>issuer</code> プロパティーと比較されます。
ただし、 <code>quarkus.oidc.token.issuer</code> プロパティーが設定されている場合は、代わりにそのプロパティーと <code>iss</code> クレーム値が比較されます。</p>
</div>
<div class="paragraph">
<p>場合によっては、この <code>iss</code> クレーム検証がうまくいかないことがあります。
たとえば、検出された <code>issuer</code> プロパティーには内部の HTTP/IP アドレスが含まれているのに、トークン <code>iss</code> クレーム値には外部の HTTP/IP アドレスが含まれている場合などです。
または、検出された <code>issuer</code> プロパティーにはテンプレートテナント変数が含まれているのに、トークン <code>iss</code> クレーム値には完全なテナント固有の発行者の値が含まれている場合などです。</p>
</div>
<div class="paragraph">
<p>このような場合は、 <code>quarkus.oidc.token.issuer=any</code> を設定して発行者の検証をスキップすることを検討してください。
発行者の検証のスキップは、他の方法を利用できない場合にのみ行ってください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keycloak を使用していて、ホストアドレスが異なるために発行者検証エラーが発生する場合は、Keycloak に <code>KEYCLOAK_FRONTEND_URL</code> プロパティーを設定して、同じホストアドレスを使用してください。</p>
</li>
<li>
<p>マルチテナントデプロイメントで <code>iss</code> プロパティーがテナント固有のものである場合は、 <code>SecurityIdentity</code> <code>tenant-id</code> 属性を使用して、エンドポイントまたはカスタム Jakarta フィルターで発行者が正しいことを確認します。
以下に例を示します。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.ext.Provider;

import org.eclipse.microprofile.jwt.JsonWebToken;
import io.quarkus.oidc.OidcConfigurationMetadata;
import io.quarkus.security.identity.SecurityIdentity;

@Provider
public class IssuerValidator implements ContainerRequestFilter {
    @Inject
    OidcConfigurationMetadata configMetadata;

    @Inject JsonWebToken jwt;
    @Inject SecurityIdentity identity;

    public void filter(ContainerRequestContext requestContext) {
        String issuer = configMetadata.getIssuer().replace("{tenant-id}", identity.getAttribute("tenant-id"));
        if (!issuer.equals(jwt.getIssuer())) {
            requestContext.abortWith(Response.status(401).build());
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>トークンの <code>aud</code> (<code>audience</code>) クレーム値を検証するために、 <code>quarkus.oidc.token.audience</code> プロパティーを使用することを検討してください。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jose4j-validator-bearer"><a class="anchor" href="#jose4j-validator-bearer"></a>Jose4j Validator</h3>
<div class="paragraph">
<p><code>org.eclipse.microprofile.jwt.JsonWebToken</code> が初期化される前に、カスタム <a href="https://www.javadoc.io/doc/org.bitbucket.b_c/jose4j/latest/org/jose4j/jwt/consumer/class-use/Validator.html">Jose4j Validator</a> を登録して、JWT クレーム検証プロセスをカスタマイズできます。
以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import static org.eclipse.microprofile.jwt.Claims.iss;

import io.quarkus.arc.Unremovable;
import jakarta.enterprise.context.ApplicationScoped;

import org.jose4j.jwt.MalformedClaimException;
import org.jose4j.jwt.consumer.JwtContext;
import org.jose4j.jwt.consumer.Validator;

@Unremovable
@ApplicationScoped
public class IssuerValidator implements Validator { <i class="conum" data-value="1"></i><b>(1)</b>

    @Override
    public String validate(JwtContext jwtContext) throws MalformedClaimException {
        if (jwtContext.getJwtClaims().hasClaim(iss.name())
                &amp;&amp; "my-issuer".equals(jwtContext.getJwtClaims().getClaimValueAsString(iss.name()))) {
            return "wrong issuer"; <i class="conum" data-value="2"></i><b>(2)</b>
        }
        return null; <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>すべての OIDC テナントの JWT トークンを検証するために、Jose4j Validator を登録します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>クレーム検証エラーの説明を返します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>この Validator がトークンを正常に検証したことを確認するために、 <code>null</code> を返します。</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
カスタム Validator を特定の OIDC テナントにのみバインドするには、 <code>@quarkus.oidc.TenantFeature</code> アノテーションを使用します。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="single-page-applications"><a class="anchor" href="#single-page-applications"></a>シングルページアプリケーション</h3>
<div class="paragraph">
<p>シングルページアプリケーション (SPA) は、通常、 <code>XMLHttpRequest</code> (XHR) と OIDC プロバイダーが提供する JavaScript ユーティリティーコードを使用してベアラートークンを取得し、Quarkus <code>service</code> アプリケーションにアクセスします。</p>
</div>
<div class="paragraph">
<p>たとえば、Keycloak を使用する場合は、 <code>keycloak.js</code> を使用してユーザーを認証し、SPA から期限切れのトークンを更新できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;keycloak-spa&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;
    &lt;script type="importmap"&gt;
        {
            "imports": {
                "keycloak-js": "https://cdn.jsdelivr.net/npm/keycloak-js@26.0.7/lib/keycloak.js"
            }
        }
    &lt;/script&gt;
    &lt;script type="module"&gt;
        import Keycloak from "keycloak-js";

        const keycloak = new Keycloak({
            url: 'http://localhost:8180',
            realm: 'quarkus',
            clientId: 'quarkus-app'
        });

        await keycloak.init({onLoad: 'login-required'}).then(function () {
            console.log('User is now authenticated.');
        }).catch(function () {
            console.log('User is NOT authenticated.');
        });

        function makeAjaxRequest() {
            axios.get("/api/hello", {
                headers: {
                    'Authorization': 'Bearer ' + keycloak.token
                }
            })
            .then( function (response) {
                console.log("Response: ", response.status);
            }).catch(function (error) {
                console.log('refreshing');
                keycloak.updateToken(5).then(function () {
                    console.log('Token refreshed');
                }).catch(function () {
                    console.log('Failed to refresh token');
                    window.location.reload();
                });
            });
        }

        let button = document.getElementById('ajax-request');
        button.addEventListener('click', makeAjaxRequest);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id="ajax-request"&gt;Request&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>この SPA Keycloak の例で認証を有効にするには、 <strong>クライアント認証</strong> を無効にし、 <strong>Web origins</strong> を次のように設定します。 <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code> .これらの設定により、KeycloakのCORSポリシーがQuarkusアプリケーションと通信できるようになります。このコードでは、Keycloakと統合されたQuarkusのシングルページアプリケーションを構築する例を示します。Keycloakを統合したシングルページアプリケーションの作成の詳細については、 <a href="https://www.keycloak.org/securing-apps/javascript-adapter">Keycloak JavaScriptアダプター</a>の 公式 <a href="https://www.keycloak.org/securing-apps/javascript-adapter">ドキュメント</a>を 参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cross-origin-resource-sharing"><a class="anchor" href="#cross-origin-resource-sharing"></a>クロスオリジンリソース共有</h3>
<div class="paragraph">
<p>別のドメインで実行されているシングルページアプリケーションから OIDC <code>service</code> アプリケーションを使用する予定の場合は、クロスオリジンリソース共有 (CORS) を設定する必要があります。
詳細は、「クロスオリジンリソース共有」ガイドの <a href="security-cors#cors-filter">CORS フィルター</a> セクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="provider-endpoint-configuration"><a class="anchor" href="#provider-endpoint-configuration"></a>プロバイダーエンドポイント設定</h3>
<div class="paragraph">
<p>OIDC <code>service</code> アプリケーションは、OIDC プロバイダーのトークン、 <code>JsonWebKey</code> (JWK) セット、場合によっては <code>UserInfo</code> やイントロスペクションのエンドポイントアドレスを確認する必要があります。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、これらのエンドポイントアドレスは、設定された <code>quarkus.oidc.auth-server-url</code> に <code>/.well-known/openid-configuration</code> パスを追加することで検出されます。</p>
</div>
<div class="paragraph">
<p>検出エンドポイントが利用できない場合や、検出エンドポイントのラウンドトリップのコストを節約する場合は、検出を無効にして、エンドポイントアドレスを相対パス値で設定することができます。
以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.discovery-enabled=false
# Token endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/token
quarkus.oidc.token-path=/protocol/openid-connect/token
# JWK set endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/certs
quarkus.oidc.jwks-path=/protocol/openid-connect/certs
# UserInfo endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/userinfo
quarkus.oidc.user-info-path=/protocol/openid-connect/userinfo
# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/tokens/introspect
quarkus.oidc.introspection-path=/protocol/openid-connect/tokens/introspect</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="token-propagation"><a class="anchor" href="#token-propagation"></a>トークンの伝播</h3>
<div class="paragraph">
<p>ダウンストリームサービスへのベアラーアクセストークンの伝播については、Quarkus の「OpenID Connect (OIDC) および OAuth2 クライアントとフィルターのリファレンス」ガイドの <a href="security-openid-connect-client-reference#token-propagation-rest">トークンの伝播</a> セクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="jwt-token-certificate-chain"><a class="anchor" href="#jwt-token-certificate-chain"></a>JWT トークン証明書チェーン</h3>
<div class="paragraph">
<p>場合によっては、JWT ベアラートークンに <code>x5c</code> ヘッダーがあり、このヘッダーは X509 証明書チェーンを表します。この証明書チェーンのリーフ証明書には、トークンの署名の検証に使用する必要がある公開鍵が含まれています。
まず証明書チェーンを検証してから、この公開鍵を受け入れて署名を検証する必要があります。
証明書チェーンの検証にはいくつかの手順が含まれます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ルート証明書以外のすべての証明書が親証明書によって署名されていることを確認します。</p>
</li>
<li>
<p>チェーンのルート証明書もトラストストアにインポートされていることを確認します。</p>
</li>
<li>
<p>チェーンのリーフ証明書を検証します。リーフ証明書の共通名が設定されている場合は、チェーンのリーフ証明書の共通名がその共通名に一致する必要があります。それ以外の場合は、1 つ以上のカスタム <code>TokenCertificateValidator</code> 実装が登録されていない限り、チェーンのリーフ証明書もトラストストアで使用可能である必要があります。</p>
</li>
<li>
<p><code>quarkus.oidc.TokenCertificateValidator</code> を使用すると、カスタム証明書チェーン検証手順を追加できます。これは、証明書チェーンを持つトークンを要求するすべてのテナント、または <code>@quarkus.oidc.TenantFeature</code> アノテーションを使用して特定の OIDC テナントにバインドされたすべてのテナントで使用できます。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>たとえば、 <code>quarkus.oidc.TokenCertificateValidator</code> を使用せずにトークンの証明書チェーンを検証するように Quarkus OIDC を設定する方法は次のとおりです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.certificate-chain.trust-store-file=truststore-rootcert.p12 <i class="conum" data-value="1"></i><b>(1)</b>
quarkus.oidc.certificate-chain.trust-store-password=storepassword
quarkus.oidc.certificate-chain.leaf-certificate-name=www.quarkusio.com <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>トラストストアに証明書チェーンのルート証明書が含まれている必要があります。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>証明書チェーンのリーフ証明書の共通名は <code>www.quarkusio.com</code> にする必要があります。このプロパティーが設定されていない場合は、1 つ以上のカスタム <code>TokenCertificateValidator</code> 実装が登録されていない限り、トラストストアに証明書チェーンのリーフ証明書が含まれている必要があります。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>カスタムの <code>quarkus.oidc.TokenCertificateValidator</code> を登録することで、カスタムの証明書チェーン検証ステップを追加できます。次に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.List;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.OidcTenantConfig;
import io.quarkus.oidc.TokenCertificateValidator;
import io.quarkus.oidc.runtime.TrustStoreUtils;
import io.vertx.core.json.JsonObject;

@ApplicationScoped
@Unremovable
public class BearerGlobalTokenChainValidator implements TokenCertificateValidator {

    @Override
    public void validate(OidcTenantConfig oidcConfig, List&lt;X509Certificate&gt; chain, String tokenClaims) throws CertificateException {
        String rootCertificateThumbprint = TrustStoreUtils.calculateThumprint(chain.get(chain.size() - 1));
        JsonObject claims = new JsonObject(tokenClaims);
        if (!rootCertificateThumbprint.equals(claims.getString("root-certificate-thumbprint"))) { <i class="conum" data-value="1"></i><b>(1)</b>
            throw new CertificateException("Invalid root certificate");
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>証明書チェーンのルート証明書がカスタム JWT トークンのクレームにバインドされていることを確認します。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="oidc-provider-client-authentication"><a class="anchor" href="#oidc-provider-client-authentication"></a>OIDC プロバイダーのクライアント認証</h3>
<div class="paragraph">
<p><code>quarkus.oidc.runtime.OidcProviderClient</code> は、OIDC プロバイダーへのリモートリクエストが必要な場合に使用されます。
ベアラートークンのイントロスペクションが必要な場合は、 <code>OidcProviderClient</code> が OIDC プロバイダーに対して認証する必要があります。
サポートされている認証オプションの詳細は、Quarkus の「Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム」ガイドの <a href="security-oidc-code-flow-authentication#oidc-provider-client-authentication">OIDC プロバイダーのクライアント認証</a> セクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="bearer-token-integration-testing"><a class="anchor" href="#bearer-token-integration-testing"></a>テスト</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="security-keycloak-authorization">Keycloak 認証</a> を必要とする Quarkus OIDC サービスエンドポイントをテストする必要がある場合は、<a href="security-keycloak-authorization#testing">Keycloak 認証のテスト</a> セクションに従ってください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次の依存関係をテストプロジェクトに追加することで、テストを開始できます。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;
    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.rest-assured:rest-assured")
testImplementation("io.quarkus:quarkus-junit")</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-keycloak-devservices"><a class="anchor" href="#bearer-token-integration-testing-keycloak-devservices"></a>Dev Services for Keycloak</h4>
<div class="paragraph">
<p>The preferred approach for integration testing against Keycloak is <a href="security-openid-connect-dev-services">Dev Services for Keycloak</a>.
<code>Dev Services for Keycloak</code> will start and initialize a test container.
Then, it will create a <code>quarkus</code> realm and a <code>quarkus-app</code> client with <code>secret</code> as the client secret. It will also add two users: <code>alice</code> with both <code>admin</code> and <code>user</code> roles, and <code>bob</code> with the <code>user</code> role. All of these properties can be customized.</p>
</div>
<div class="paragraph">
<p>まず、次の依存関係を追加します。この依存関係は、アクセストークンを取得するテストで使用できるユーティリティークラス <code>io.quarkus.test.keycloak.client.KeycloakTestClient</code> を提供します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-keycloak-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-keycloak-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、 <code>application.properties</code> 設定ファイルを準備します。
空の <code>application.properties</code> ファイルから開始できます。 <code>Dev Services for Keycloak</code> が <code>quarkus.oidc.auth-server-url</code> を登録し、その参照先として実行中のテストコンテナー、 <code>quarkus.oidc.client-id=quarkus-app</code>、および <code>quarkus.oidc.credentials.secret=secret</code> を設定するためです。</p>
</div>
<div class="paragraph">
<p>However, if you have already configured the required <code>quarkus-oidc</code> properties, then you only need to associate <code>quarkus.oidc.auth-server-url</code> with the <code>prod</code> profile for <code>Dev Services for Keycloak</code> to start a container, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus</code></pre>
</div>
</div>
<div class="paragraph">
<p>テストを実行する前にカスタムレルムファイルを Keycloak にインポートする必要がある場合は、次のように <code>Dev Services for Keycloak</code> を設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.keycloak.devservices.realm-path=quarkus-realm.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後に、次の例に示すようにテストを記述します。このテストは JVM モードで実行されます。</p>
</div>
<div class="listingblock">
<div class="title">JVM モードで実行されるテストの例:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.keycloak.client.KeycloakTestClient;
import io.restassured.RestAssured;
import org.junit.jupiter.api.Test;

@QuarkusTest
public class BearerTokenAuthenticationTest {

    KeycloakTestClient keycloakClient = new KeycloakTestClient();

    @Test
    public void testAdminAccess() {
        RestAssured.given().auth().oauth2(getAccessToken("alice"))
                .when().get("/api/admin")
                .then()
                .statusCode(200);
        RestAssured.given().auth().oauth2(getAccessToken("bob"))
                .when().get("/api/admin")
                .then()
                .statusCode(403);
    }

    protected String getAccessToken(String userName) {
        return keycloakClient.getAccessToken(userName);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ネイティブモードで実行されるテストの例:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.openid.connect;

import io.quarkus.test.junit.QuarkusIntegrationTest;

@QuarkusIntegrationTest
public class NativeBearerTokenAuthenticationIT extends BearerTokenAuthenticationTest {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dev Services for Keycloak の初期化と設定の詳細は、<a href="security-openid-connect-dev-services">Dev Services for Keycloak</a> ガイドを参照してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-wiremock"><a class="anchor" href="#bearer-token-integration-testing-wiremock"></a>WireMock</h4>
<div class="paragraph">
<p>テストプロジェクトに以下の依存関係を追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-oidc-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-oidc-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>REST テストエンドポイントを準備し、 <code>application.properties</code> を設定します。
以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># keycloak.url is set by OidcWiremockTestResource
quarkus.oidc.auth-server-url=${keycloak.url:replaced-by-test-resource}/realms/quarkus/
quarkus.oidc.client-id=quarkus-service-app
quarkus.oidc.application-type=service</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後にテストコードを記述します。
以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.hamcrest.Matchers.equalTo;

import java.util.Set;

import org.junit.jupiter.api.Test;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.server.OidcWiremockTestResource;
import io.restassured.RestAssured;
import io.smallrye.jwt.build.Jwt;

@QuarkusTest
@QuarkusTestResource(OidcWiremockTestResource.class)
public class BearerTokenAuthorizationTest {

    @Test
    public void testBearerToken() {
        RestAssured.given().auth().oauth2(getAccessToken("alice", Set.of("user")))
            .when().get("/api/users/me")
            .then()
            .statusCode(200)
            // The test endpoint returns the name extracted from the injected `SecurityIdentity` principal.
            .body("userName", equalTo("alice"));
    }

    private String getAccessToken(String userName, Set&lt;String&gt; groups) {
        return Jwt.preferredUserName(userName)
                .groups(groups)
                .issuer("https://server.example.com")
                .audience("https://service.example.com")
                .sign();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>quarkus-test-oidc-server</code> エクステンションは、 <code>JSON Web Key</code> (<code>JWK</code>) フォーマットの署名 RSA 秘密鍵ファイルを含んでおり、 <code>smallrye.jwt.sign.key.location</code> 設定プロパティーでそのファイルを参照します。
このエクステンションを使用すると、引数なしの <code>sign()</code> 操作を使用してトークンに署名できます。</p>
</div>
<div class="paragraph">
<p><code>OidcWiremockTestResource</code> を使用して <code>quarkus-oidc</code> <code>service</code> アプリケーションをテストすると、通信チャネルも WireMock HTTP スタブに対してテストされるため、最大のカバレッジを得ることができます。
<code>OidcWiremockTestResource</code> でまだサポートされていない WireMock スタブを使用してテストを実行する必要がある場合は、次の例に示すように、テストクラスに <code>WireMockServer</code> インスタンスを挿入できます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>OidcWiremockTestResource</code> は、Docker コンテナーに対する <code>@QuarkusIntegrationTest</code> では機能しません。WireMock サーバーが、テストを実行する JVM で実行されるためです。その JVM には、Quarkus アプリケーションを実行する Docker コンテナーからはアクセスできません。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import static com.github.tomakehurst.wiremock.client.WireMock.matching;
import static org.hamcrest.Matchers.equalTo;

import org.junit.jupiter.api.Test;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.client.WireMock;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.server.OidcWireMock;
import io.restassured.RestAssured;

@QuarkusTest
public class CustomOidcWireMockStubTest {

    @OidcWireMock
    WireMockServer wireMockServer;

    @Test
    public void testInvalidBearerToken() {
        wireMockServer.stubFor(WireMock.post("/auth/realms/quarkus/protocol/openid-connect/token/introspect")
                .withRequestBody(matching(".*token=invalid_token.*"))
                .willReturn(WireMock.aResponse().withStatus(400)));

        RestAssured.given().auth().oauth2("invalid_token").when()
                .get("/api/users/me/bearer")
                .then()
                .statusCode(401)
                .header("WWW-Authenticate", equalTo("Bearer"));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-oidc-test-client"><a class="anchor" href="#integration-testing-oidc-test-client"></a><code>OidcTestClient</code></h4>
<div class="paragraph">
<p>SaaS OIDC プロバイダー (<code>Auth0</code> など) を使用していて、テスト (開発) ドメインに対してテストを実行したり、リモート Keycloak テストレルムに対してテストを実行したりする場合、 <code>quarkus.oidc.auth-server-url</code> がすでに設定されていれば、 <code>OidcTestClient</code> を使用できます。</p>
</div>
<div class="paragraph">
<p>たとえば、次のような設定があるとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%test.quarkus.oidc.auth-server-url=https://dev-123456.eu.auth0.com/
%test.quarkus.oidc.client-id=test-auth0-client
%test.quarkus.oidc.credentials.secret=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>まず、<a href="#bearer-token-integration-testing-wiremock">WireMock</a> セクションの説明に従って、同じ依存関係 <code>quarkus-test-oidc-server</code> を追加します。</p>
</div>
<div class="paragraph">
<p>次に、以下のようにテストコードを記述します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import org.junit.jupiter.api.AfterAll;
import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

import java.util.Map;

import org.junit.jupiter.api.Test;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.client.OidcTestClient;

@QuarkusTest
public class GreetingResourceTest {

    static OidcTestClient oidcTestClient = new OidcTestClient();

    @AfterAll
    public static void close() {
        oidcTestClient.close();
    }

    @Test
    public void testHelloEndpoint() {
        given()
          .auth().oauth2(getAccessToken("alice", "alice"))
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("Hello, Alice"));
    }

    private String getAccessToken(String name, String secret) {
        return oidcTestClient.getAccessToken(name, secret,
            Map.of("audience", "https://dev-123456.eu.auth0.com/api/v2/",
	           "scope", "profile"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このテストコードは、クライアント ID が <code>test-auth0-client</code> のアプリケーションを登録し、パスワードが <code>alice</code> のユーザー <code>alice</code> を作成したテスト <code>Auth0</code> ドメインから <code>password</code> 許可を使用してトークンを取得します。
このようなテストを機能させるには、テスト <code>Auth0</code> アプリケーションで <code>password</code> グラントが有効になっている必要があります。
このサンプルコードでは、追加のパラメーターを渡す方法も示しています。 <code>Auth0</code> の場合、これらは <code>audience</code> および <code>scope</code> パラメーターです。</p>
</div>
<div class="sect4">
<h5 id="test-oidc-devservice"><a class="anchor" href="#test-oidc-devservice"></a>OIDC DevService のテスト</h5>
<div class="paragraph">
<p>また、 <code>OidcTestClient</code> を使用して、<a href="security-openid-connect-dev-services#dev-services-for-oidc">OIDC 用 Dev Services</a> でサポートされている Quarkus エンドポイントをテストすることもできます。
<code>application.properties</code> ファイルでの設定は必要ありません。Quarkus が <code>OidcTestClient</code> を設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Test;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.client.OidcTestClient;

@QuarkusTest
public class GreetingResourceTest {

    static final OidcTestClient oidcTestClient = new OidcTestClient();

    @AfterAll
    public static void close() {
        oidcTestClient.close();
    }

    @Test
    public void testHelloEndpoint() {
        String accessToken = oidcTestClient.getAccessToken("alice", "alice");
        given()
          .auth().oauth2(accessToken)
          .when().get("/hello")
          .then()
             .statusCode(200)
             .body(is("Hello, Alice"));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-keycloak"><a class="anchor" href="#bearer-token-integration-testing-keycloak"></a><code>KeycloakTestResourceLifecycleManager</code></h4>
<div class="paragraph">
<p>Keycloak との結合テストには <code>KeycloakTestResourceLifecycleManager</code> を使用することもできます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>KeycloakTestResourceLifecycleManager</code> を使用する特別な要件がない限り、Keycloak との結合テストには、 <code>KeycloakTestResourceLifecycleManager</code> ではなく <a href="#bearer-token-integration-testing-keycloak-devservices">Dev Services for Keycloak</a> を使用してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>まず、以下の依存関係を追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-keycloak-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-keycloak-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、Keycloak コンテナーを起動する <code>io.quarkus.test.common.QuarkusTestResourceLifecycleManager</code> の実装である`io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager` を提供します。</p>
</div>
<div class="paragraph">
<p>Maven Surefire プラグインを次のように設定します。または、ネイティブイメージテストの <code>maven.failsafe.plugin</code> と同様に設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;systemPropertyVariables&gt;
            &lt;!-- Or, alternatively, configure 'keycloak.version' --&gt;
            &lt;keycloak.docker.image&gt;${keycloak.docker.image}&lt;/keycloak.docker.image&gt;
            &lt;!--
              Disable HTTPS if required:
              &lt;keycloak.use.https&gt;false&lt;/keycloak.use.https&gt;
            --&gt;
        &lt;/systemPropertyVariables&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>REST テストエンドポイントを準備し、次の例に示すように <code>application.properties</code> を設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># keycloak.url is set by KeycloakTestResourceLifecycleManager
quarkus.oidc.auth-server-url=${keycloak.url:replaced-by-test-resource}/realms/quarkus/
quarkus.oidc.client-id=quarkus-service-app
quarkus.oidc.credentials=secret
quarkus.oidc.application-type=service</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後にテストコードを記述します。
以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager.getAccessToken;
import static org.hamcrest.Matchers.equalTo;

import org.junit.jupiter.api.Test;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager;
import io.restassured.RestAssured;

@QuarkusTest
@QuarkusTestResource(KeycloakTestResourceLifecycleManager.class)
public class BearerTokenAuthorizationTest {

    @Test
    public void testBearerToken() {
        RestAssured.given().auth().oauth2(getAccessToken("alice"))
            .when().get("/api/users/preferredUserName")
            .then()
            .statusCode(200)
            // The test endpoint returns the name extracted from the injected SecurityIdentity Principal
            .body("userName", equalTo("alice"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">概要</div>
<p>上記の例では、 <code>KeycloakTestResourceLifecycleManager</code> が <code>alice</code> と <code>admin</code> の 2 人のユーザーを登録します。
デフォルトでは、* ユーザー <code>alice</code> には <code>user</code> ロールがあります。このロールは、 <code>keycloak.token.user-roles</code> システムプロパティーを使用してカスタマイズできます。
* ユーザー <code>admin</code> には <code>user</code> と <code>admin</code> の両方のロールがあります。これらのロールは、 <code>keycloak.token.admin-roles</code> システムプロパティーを使用してカスタマイズできます。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、 <code>KeycloakTestResourceLifecycleManager</code> は HTTPS を使用して Keycloak インスタンスを初期化します。これは <code>keycloak.use.https=false</code> を使用して無効にできます。
デフォルトのレルム名は <code>quarkus</code> で、クライアント ID は <code>quarkus-service-app</code> です。
これらの値をカスタマイズする場合は、 <code>keycloak.realm</code> および <code>keycloak.service.client</code> システムプロパティーを設定します。</p>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-public-key"><a class="anchor" href="#integration-testing-public-key"></a>ローカル公開鍵</h4>
<div class="paragraph">
<p>次の例に示すように、 <code>quarkus-oidc</code> <code>service</code> アプリケーションをテストするために、ローカルのインライン公開鍵を使用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.client-id=test
quarkus.oidc.public-key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlivFI8qB4D0y2jy0CfEqFyy46R0o7S8TKpsx5xbHKoU1VWg6QkQm+ntyIv1p4kE1sPEQO73+HY8+Bzs75XwRTYL1BmR1w8J5hmjVWjc6R2BTBGAYRPFRhor3kpM6ni2SPmNNhurEAHw7TaqszP5eUF/F9+KEBWkwVta+PZ37bwqSE4sCb1soZFrVz/UT/LF4tYpuVYt3YbqToZ3pZOZ9AX2o1GCG3xwOjkc4x0W7ezbQZdC9iftPxVHR8irOijJRRjcPDtA6vPKpzLl6CyYnsIYPd99ltwxTHjr3npfv/3Lw50bAkbT4HeLFxTx4flEoZLKO/g0bAoV2uqBhkA9xnQIDAQAB

smallrye.jwt.sign.key.location=/privateKey.pem</code></pre>
</div>
</div>
<div class="paragraph">
<p>JWT トークンを生成するには、 <code>main</code> Quarkus リポジトリーの <code>integration-tests/oidc-tenancy</code> から <code>privateKey.pem</code> をコピーし、前述の <a href="#bearer-token-integration-testing-wiremock">WireMock</a> セクションと同様のテストコードを使用します。
必要に応じて、独自のテストキーを使用することもできます。</p>
</div>
<div class="paragraph">
<p>この方法では、WireMock 方法と比較してカバレッジが制限されます。
たとえば、リモート通信コードはカバーされません。</p>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-integration-testing-security-annotation"><a class="anchor" href="#bearer-token-integration-testing-security-annotation"></a>TestSecurity アノテーション</h4>
<div class="paragraph">
<p><code>@TestSecurity</code> および <code>@OidcSecurity</code> アノテーションを使用して、 <code>service</code> アプリケーションエンドポイントのコードをテストできます。このコードは、次の注入のいずれか 1 つまたは 3 つすべてに依存します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JsonWebToken</code></p>
</li>
<li>
<p><code>UserInfo</code></p>
</li>
<li>
<p><code>OidcConfigurationMetadata</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>まず、以下の依存関係を追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-security-oidc&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-security-oidc")</code></pre>
</div>
</div>
<div class="paragraph">
<p>次の例に示すようにテストコードを記述します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.hamcrest.Matchers.is;
import org.junit.jupiter.api.Test;
import io.quarkus.test.common.http.TestHTTPEndpoint;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.security.TestSecurity;
import io.quarkus.test.security.oidc.Claim;
import io.quarkus.test.security.oidc.ConfigMetadata;
import io.quarkus.test.security.oidc.OidcSecurity;
import io.quarkus.test.security.oidc.UserInfo;
import io.restassured.RestAssured;

@QuarkusTest
@TestHTTPEndpoint(ProtectedResource.class)
public class TestSecurityAuthTest {

    @Test
    @TestSecurity(user = "userOidc", roles = "viewer")
    public void testOidc() {
        RestAssured.when().get("test-security-oidc").then()
                .body(is("userOidc:viewer"));
    }

    @Test
    @TestSecurity(user = "userOidc", roles = "viewer")
    @OidcSecurity(claims = {
            @Claim(key = "email", value = "user@gmail.com")
    }, userinfo = {
            @UserInfo(key = "sub", value = "subject")
    }, config = {
            @ConfigMetadata(key = "issuer", value = "issuer")
    })
    public void testOidcWithClaimsUserInfoAndMetadata() {
        RestAssured.when().get("test-security-oidc-claims-userinfo-metadata").then()
                .body(is("userOidc:viewer:user@gmail.com:subject:issuer"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコード例で使用されている <code>ProtectedResource</code> クラスは次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.quarkus.oidc.OidcConfigurationMetadata;
import io.quarkus.oidc.UserInfo;
import io.quarkus.security.Authenticated;

import org.eclipse.microprofile.jwt.JsonWebToken;

@Path("/service")
@Authenticated
public class ProtectedResource {

    @Inject
    JsonWebToken accessToken;
    @Inject
    UserInfo userInfo;
    @Inject
    OidcConfigurationMetadata configMetadata;

    @GET
    @Path("test-security-oidc")
    public String testSecurityOidc() {
        return accessToken.getName() + ":" + accessToken.getGroups().iterator().next();
    }

    @GET
    @Path("test-security-oidc-claims-userinfo-metadata")
    public String testSecurityOidcWithClaimsUserInfoMetadata() {
        return accessToken.getName() + ":" + accessToken.getGroups().iterator().next()
                + ":" + accessToken.getClaim("email")
                + ":" + userInfo.getString("sub")
                + ":" + configMetadata.get("issuer");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@TestSecurity</code> アノテーションは常に使用する必要があります。
その <code>user</code> プロパティーは <code>JsonWebToken.getName()</code> として返され、その <code>roles</code> プロパティーは <code>JsonWebToken.getGroups()</code> として返されます。
<code>@OidcSecurity</code> アノテーションは任意です。これを使用すると、追加のトークンクレームと <code>UserInfo</code> および <code>OidcConfigurationMetadata</code> プロパティーを設定できます。
さらに、 <code>quarkus.oidc.token.issuer</code> プロパティーが設定されている場合、 <code>OidcConfigurationMetadata</code> <code>issuer</code> プロパティー値として使用されます。</p>
</div>
<div class="paragraph">
<p>不透明トークンを使用する場合は、次のコード例に示す方法でトークンをテストできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.hamcrest.Matchers.is;
import org.junit.jupiter.api.Test;
import io.quarkus.test.common.http.TestHTTPEndpoint;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.security.TestSecurity;
import io.quarkus.test.security.oidc.OidcSecurity;
import io.quarkus.test.security.oidc.TokenIntrospection;
import io.restassured.RestAssured;

@QuarkusTest
@TestHTTPEndpoint(ProtectedResource.class)
public class TestSecurityAuthTest {

    @Test
    @TestSecurity(user = "userOidc", roles = "viewer")
    @OidcSecurity(introspectionRequired = true,
        introspection = {
            @TokenIntrospection(key = "email", value = "user@gmail.com")
        }
    )
    public void testOidcWithClaimsUserInfoAndMetadata() {
        RestAssured.when().get("test-security-oidc-opaque-token").then()
                .body(is("userOidc:viewer:userOidc:viewer:user@gmail.com"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコード例で使用されている <code>ProtectedResource</code> クラスは次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.quarkus.oidc.TokenIntrospection;
import io.quarkus.security.Authenticated;
import io.quarkus.security.identity.SecurityIdentity;

@Path("/service")
@Authenticated
public class ProtectedResource {

    @Inject
    SecurityIdentity securityIdentity;
    @Inject
    TokenIntrospection introspection;

    @GET
    @Path("test-security-oidc-opaque-token")
    public String testSecurityOidcOpaqueToken() {
        return securityIdentity.getPrincipal().getName() + ":" + securityIdentity.getRoles().iterator().next()
            + ":" + introspection.getString("username")
            + ":" + introspection.getString("scope")
            + ":" + introspection.getString("email");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@TestSecurity</code>、 <code>user</code>、および <code>roles</code> 属性は、 <code>TokenIntrospection</code>、 <code>username</code>、および <code>scope</code> プロパティーとして使用できます。
<code>io.quarkus.test.security.oidc.TokenIntrospection</code> を使用して、 <code>email</code> などの追加のイントロスペクションレスポンスプロパティーを追加します。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@TestSecurity</code> と <code>@OidcSecurity</code> は、メタアノテーションで組み合わせることができます。次の例を参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @TestSecurity(user = "userOidc", roles = "viewer")
    @OidcSecurity(introspectionRequired = true,
        introspection = {
            @TokenIntrospection(key = "email", value = "user@gmail.com")
        }
    )
    public @interface TestSecurityMetaAnnotation {

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、複数のテスト方法で同じセキュリティー設定セットを使用する必要がある場合に特に便利です。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="check-errors-in-the-logs"><a class="anchor" href="#check-errors-in-the-logs"></a>ログでのエラーの確認</h3>
<div class="paragraph">
<p>トークン検証エラーの詳細を確認するには、 <code>io.quarkus.oidc.runtime.OidcProvider</code> および <code>TRACE</code> レベルのロギングを有効にします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".level=TRACE
quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".min-level=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OidcProvider</code> クライアント初期化エラーの詳細を確認するには、次のように <code>io.quarkus.oidc.runtime.OidcRecorder</code> および <code>TRACE</code> レベルのロギングを有効にします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.oidc.runtime.OidcRecorder".level=TRACE
quarkus.log.category."io.quarkus.oidc.runtime.OidcRecorder".min-level=TRACE</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="external-and-internal-access-to-oidc-providers"><a class="anchor" href="#external-and-internal-access-to-oidc-providers"></a>OIDC プロバイダーへの外部および内部アクセス</h3>
<div class="paragraph">
<p>OIDC プロバイダーおよびその他のエンドポイントの外部からアクセス可能なトークンは、自動検出された URL や <code>quarkus.oidc.auth-server-url</code> 内部 URL を基準に設定された URL とは異なる HTTP(S) URL を持っている可能性があります。
たとえば、SPA が外部トークンエンドポイントアドレスからトークンを取得し、それをベアラートークンとして Quarkus に送信するとします。
その場合、エンドポイントから発行者の検証の失敗が報告される可能性があります。</p>
</div>
<div class="paragraph">
<p>このような場合に Keycloak を使用する場合は、 <code>KEYCLOAK_FRONTEND_URL</code> システムプロパティーを外部からアクセス可能なベース URL に設定して Keycloak を起動してください。
他の OIDC プロバイダーを使用する場合は、プロバイダーのドキュメントを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="using-client-id"><a class="anchor" href="#using-client-id"></a>`client-id`プロパティーの使用</h3>
<div class="paragraph">
<p><code>quarkus.oidc.client-id</code> プロパティーは、現在のベアラートークンをリクエストした OIDC クライアントを特定します。
OIDC クライアントは、ブラウザーで実行される SPA アプリケーション、または Quarkus <code>service</code> アプリケーションにアクセストークンを伝播する Quarkus <code>web-app</code> 機密クライアントアプリケーションです。</p>
</div>
<div class="paragraph">
<p>このプロパティーは、 <code>service</code> アプリケーションがトークンをリモートでイントロスペクトすることが予想される場合に必要です。これは、不透明トークンの場合は常に当てはまります。
このプロパティーは、ローカル JSON Web Token (JWT) 検証の場合にのみ省略可能です。</p>
</div>
<div class="paragraph">
<p>エンドポイントがリモートイントロスペクションエンドポイントへのアクセスを必要としない場合でも、 <code>quarkus.oidc.client-id</code> プロパティーを設定することを推奨します。
これは、 <code>client-id</code> が設定されている場合、それを使用してトークンオーディエンスを検証できるためです。
また、トークンの検証が失敗した場合にも client-id がログに含まれるため、特定のクライアントに発行されたトークンのトレーサビリティーが向上し、より長い期間にわたる分析が可能になります。</p>
</div>
<div class="paragraph">
<p>たとえば、OIDC プロバイダーでトークンオーディエンスを設定する場合は、次の設定パターンを検討してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Set client-id
quarkus.oidc.client-id=quarkus-app
# Token audience claim must contain 'quarkus-app'
quarkus.oidc.token.audience=${quarkus.oidc.client-id}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.client-id</code> を設定したが、いずれかの OIDC プロバイダーエンドポイントへのリモートアクセスがエンドポイントに必要ない場合 (イントロスペクション、トークンの取得など)、 <code>quarkus.oidc.credentials</code> または同様のプロパティーを使用してクライアントシークレットを設定しないでください。その場合、クライアントシークレットは使用されないためです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quarkus <code>web-app</code> アプリケーションには、常に <code>quarkus.oidc.client-id</code> プロパティーが必要です。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sender-constraining-access-tokens"><a class="anchor" href="#sender-constraining-access-tokens"></a>送信者制限アクセストークン</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="demonstrating-proof-of-possession-dpop"><a class="anchor" href="#demonstrating-proof-of-possession-dpop"></a>Demonstrating Proof of Possession (DPoP)</h3>
<div class="paragraph">
<p><a href="https://datatracker.ietf.org/doc/html/rfc9449">RFC9449</a>は 、アクセストークンを現在のクライアントに暗号的にバインドし、アクセストークンの紛失やリプレイを防ぐためのDemonstrating Proof of Possession（DPoP）メカニズムについて記述しています。</p>
</div>
<div class="paragraph">
<p>シングル・ページ・アプリケーション（SPA）のパブリック・クライアントはDPoPプルーフ・トークンを生成し、DPoPプルーフに暗号学的にバインドされたアクセストークンの取得と提出に使用します。</p>
</div>
<div class="paragraph">
<p>QuarkusでDPoPサポートを有効にするには、1つのプロパティが必要です。</p>
</div>
<div class="paragraph">
<p>例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=${your_oidc_provider_url}
quarkus.oidc.token.authorization-scheme=dpop <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>HTTP <code>Authorization DPoP</code> スキーム値を使用してアクセストークンが提供されることを要求します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このようなトークンを受け入れた後、Quarkusは <a href="https://datatracker.ietf.org/doc/html/rfc9449#name-checking-dpop-proofs">DPoPトークン</a>の 完全な <a href="https://datatracker.ietf.org/doc/html/rfc9449#name-checking-dpop-proofs">検証プロセス</a>を 行います。</p>
</div>
<div class="paragraph">
<p>カスタムDPoP nonceプロバイダのサポートは将来提供されるかもしれません。</p>
</div>
</div>
<div class="sect2">
<h3 id="mutual-tls-token-binding"><a class="anchor" href="#mutual-tls-token-binding"></a>相互 TLS トークンバインディング</h3>
<div class="paragraph">
<p><a href="https://datatracker.ietf.org/doc/html/rfc8705">RFC8705</a> では、アクセストークンを Mutual TLS (mTLS) クライアント認証証明書にバインドするメカニズムについて説明しています。
クライアント証明書の SHA256 サムプリントが JWT トークンまたはトークンイントロスペクション確認 <code>x5t#S256</code> 証明書サムプリントと一致する必要があります。</p>
</div>
<div class="paragraph">
<p>たとえば、 <a href="https://datatracker.ietf.org/doc/html/rfc8705">RFC8705</a> の <a href="https://datatracker.ietf.org/doc/html/rfc8705#section-3.1">JWT 証明書のサムプリントの確認方法</a> および <a href="https://datatracker.ietf.org/doc/html/rfc8705#section-3.2">トークンイントロスペクションの確認方法</a> セクションを参照してください。</p>
</div>
<div class="paragraph">
<p>MTLS トークンバインディングは <code>キーの所有者</code> の概念をサポートしており、現在のアクセストークンがこのトークンを提示する現在の認証済みクライアントに発行されたことを確認するために使用できます。</p>
</div>
<div class="paragraph">
<p>mTLS と OIDC ベアラー認証メカニズムの両方を使用する場合、Quarkus エンドポイントと Quarkus OIDC で mTLS の使用を要求するように設定した後、強制的にアクセストークンが単一のプロパティーで証明書にバインドされるように指定できます。</p>
</div>
<div class="paragraph">
<p>例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=${your_oidc_provider_url}
quarkus.oidc.token.binding.certificate=true <i class="conum" data-value="1"></i><b>(1)</b>
quarkus.oidc.tls.tls-configuration-name=oidc-client-tls <i class="conum" data-value="2"></i><b>(2)</b>

quarkus.tls.oidc-client-tls.key-store.p12.path=target/certificates/oidc-client-keystore.p12 <i class="conum" data-value="2"></i><b>(2)</b>
quarkus.tls.oidc-client-tls.key-store.p12.password=password
quarkus.tls.oidc-client-tls.trust-store.p12.path=target/certificates/oidc-client-truststore.p12
quarkus.tls.oidc-client-tls.trust-store.p12.password=password

quarkus.http.tls-configuration-name=oidc-server-mtls <i class="conum" data-value="3"></i><b>(3)</b>
quarkus.tls.oidc-server-mtls.key-store.p12.path=target/certificates/oidc-keystore.p12
quarkus.tls.oidc-server-mtls.key-store.p12.password=password
quarkus.tls.oidc-server-mtls.trust-store.p12.path=target/certificates/oidc-server-truststore.p12
quarkus.tls.oidc-server-mtls.trust-store.p12.password=password</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ベアラーアクセストークンをクライアント証明書にバインドする必要があることを必須にします。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Quarkus OIDC の TLS レジストリー設定により、MTLS 経由で OIDC プロバイダーと通信できるようになります。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>外部クライアントが MTLS 経由での Quarkus エンドポイントの認証を必須にする TLS レジストリー設定</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上記の設定を使用すると、OIDC ベアラートークンをクライアント証明書にバインドすることが必須にできます。</p>
</div>
<div class="paragraph">
<p>次に、mTLS と OIDC ベアラーセキュリティーアイデンティティーの両方にアクセスする必要がある場合は、 <code>quarkus.http.auth.inclusive=true</code> を使用して <a href="security-authentication-mechanisms#combining-authentication-mechanisms">統合認証</a> を有効にすることを検討してください。</p>
</div>
<div class="paragraph">
<p>次のようにして、MTLS と OIDC の両方のセキュリティーアイデンティティーにアクセスできるようになりました。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.jwt.JsonWebToken;
import io.quarkus.security.Authenticated;
import io.quarkus.security.credential.CertificateCredential;
import io.quarkus.security.identity.SecurityIdentity;

@Path("/service")
@Authenticated
public class OidcMtlsEndpoint {

    @Inject
    SecurityIdentity mtlsIdentity; <i class="conum" data-value="1"></i><b>(1)</b>

    @Inject
    JsonWebToken oidcAccessToken; <i class="conum" data-value="2"></i><b>(2)</b>

    @GET
    public String getIdentities() {
        var cred = identity.getCredential(CertificateCredential.class).getCertificate();
        return "Identities: " + cred.getSubjectX500Principal().getName().split(",")[0]
                + ", " + accessToken.getName();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>mTLS が使用され、統合認証が有効になっている場合、 <code>SecurityIdentity</code> は常にプライマリー mTLS 認証を表します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>統合認証を有効にするには、登録されているすべてのメカニズムでセキュリティーアイデンティティーを生成する必要があるため、OIDC セキュリティーアイデンティティーも利用できます。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="authentication-after-an-http-request-has-completed"><a class="anchor" href="#authentication-after-an-http-request-has-completed"></a>HTTP リクエストが完了した後の認証</h2>
<div class="sectionbody">
<div class="paragraph">
<p>場合によっては、アクティブな HTTP リクエストコンテキストが存在しない場合に、特定のトークンの <code>SecurityIdentity</code> を作成する必要があります。
<code>quarkus-oidc</code> エクステンションは、トークンを <code>SecurityIdentity</code> インスタンスに変換するための <code>io.quarkus.oidc.TenantIdentityProvider</code> を提供します。
たとえば、HTTP リクエストが完了した後にトークンを検証する必要がある状況の 1 つとして、<a href="vertx#event-bus">Vert.x イベントバス</a> を使用してメッセージを処理する場合があります。
以下の例では、さまざまな CDI リクエストコンテキスト内で 'product-order' メッセージを使用しています。
したがって、注入された <code>SecurityIdentity</code> は、検証されたアイデンティティーを正しく表さず、匿名になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quickstart.oidc;

import static jakarta.ws.rs.core.HttpHeaders.AUTHORIZATION;

import jakarta.inject.Inject;
import jakarta.ws.rs.HeaderParam;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import io.vertx.core.eventbus.EventBus;

@Path("order")
public class OrderResource {

    @Inject
    EventBus eventBus;

    @POST
    public void order(String product, @HeaderParam(AUTHORIZATION) String bearer) {
        String rawToken = bearer.substring("Bearer ".length()); <i class="conum" data-value="1"></i><b>(1)</b>
        eventBus.publish("product-order", new Product(product, rawToken));
    }

    public static class Product {
         public String product;
         public String customerAccessToken;
         public Product() {
         }
         public Product(String product, String customerAccessToken) {
             this.product = product;
             this.customerAccessToken = customerAccessToken;
         }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>この時点では、プロアクティブ認証が無効な場合、トークンは検証されません。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quickstart.oidc;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import io.quarkus.oidc.AccessTokenCredential;
import io.quarkus.oidc.Tenant;
import io.quarkus.oidc.TenantIdentityProvider;
import io.quarkus.security.identity.SecurityIdentity;
import io.quarkus.vertx.ConsumeEvent;
import io.smallrye.common.annotation.Blocking;

@ApplicationScoped
public class OrderService {

    @Tenant("tenantId")
    @Inject
    TenantIdentityProvider identityProvider;

    @Inject
    TenantIdentityProvider defaultIdentityProvider; <i class="conum" data-value="1"></i><b>(1)</b>

    @Blocking
    @ConsumeEvent("product-order")
    void processOrder(OrderResource.Product product) {
        AccessTokenCredential tokenCredential = new AccessTokenCredential(product.customerAccessToken);
        SecurityIdentity securityIdentity = identityProvider.authenticate(tokenCredential).await().indefinitely(); <i class="conum" data-value="2"></i><b>(2)</b>
        ...
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>デフォルトのテナントの場合、 <code>Tenant</code> 修飾子は任意です。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>トークンの検証を実行し、トークンを <code>SecurityIdentity</code> に変換します。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>HTTP リクエスト中にプロバイダーが使用される場合、テナント設定を解決できます。
<a href="security-openid-connect-multitenancy">OpenID Connect マルチテナンシーの使用</a> ガイドの説明を参照してください。
ただし、アクティブな HTTP リクエストがない場合は、 <code>io.quarkus.oidc.Tenant</code> 修飾子を使用してテナントを明示的に選択する必要があります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="security-openid-connect-multitenancy#tenant-config-resolver">動的テナント設定解決</a> は現在サポートされていません。
動的テナントを必要とする認証は失敗します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bearer-token-oidc-request-filters"><a class="anchor" href="#bearer-token-oidc-request-filters"></a>OIDC リクエストフィルター</h2>
<div class="sectionbody">
<div class="paragraph">
<p>1 つ以上の <code>OidcRequestFilter</code> 実装を登録すると、Quarkus から OIDC プロバイダーに対して行われた OIDC リクエストをフィルタリングできます。この実装により、新しいリクエストヘッダーを更新または追加したり、リクエストをログに記録したりできます。
詳細は、<a href="security-oidc-code-flow-authentication#code-flow-oidc-request-filters">OIDC リクエストフィルター</a> を参照してください。</p>
</div>
<div class="sect2">
<h3 id="bearer-token-oidc-response-filters"><a class="anchor" href="#bearer-token-oidc-response-filters"></a>OIDC レスポンスフィルター</h3>
<div class="paragraph">
<p>1 つ以上の <code>OidcResponseFilter</code> 実装を登録することで、OIDC プロバイダーからのレスポンスをフィルタリングできます。これにより、レスポンスのステータス、ヘッダー、本文をチェックして、ログに記録したり、その他のアクションを実行したりできます。</p>
</div>
<div class="paragraph">
<p>すべての OIDC レスポンスをインターセプトする単一のフィルターを使用することも、 <code>@OidcEndpoint</code> アノテーションを使用してこのフィルターを特定のエンドポイントレスポンスにのみ適用することもできます。例: </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.logging.Log;
import io.quarkus.oidc.common.OidcEndpoint;
import io.quarkus.oidc.common.OidcEndpoint.Type;
import io.quarkus.oidc.common.OidcResponseFilter;
import io.smallrye.mutiny.Uni;
import io.quarkus.oidc.common.runtime.OidcConstants;
import io.quarkus.oidc.runtime.OidcUtils;

@ApplicationScoped
@Unremovable
@OidcEndpoint(value = Type.DISCOVERY) <i class="conum" data-value="1"></i><b>(1)</b>
public class DiscoveryEndpointResponseFilter implements OidcResponseFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcResponseFilterContext rc) {
        String contentType = rc.responseHeaders().get("Content-Type"); <i class="conum" data-value="2"></i><b>(2)</b>
        if (contentType.equals("application/json") {
            String tenantId = rc.requestProperties().get(OidcUtils.TENANT_ID_ATTRIBUTE); <i class="conum" data-value="3"></i><b>(3)</b>
            String metadata = rc.responseBody().toString(); <i class="conum" data-value="4"></i><b>(4)</b>
            Log.debugf("Tenant %s OIDC metadata: %s", tenantId, metadata);
        }
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>このフィルターを、OIDC 検出エンドポイントのみを対象とするリクエストに制限します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>レスポンスの <code>Content-Type</code> ヘッダーを確認します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>テナント ID を取得するには、 <code>OidcRequestContextProperties</code> リクエストプロパティーを使用します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>レスポンスデータを文字列として取得します。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="restrict-oidc-filter-to-bearer-auth-flow"><a class="anchor" href="#restrict-oidc-filter-to-bearer-auth-flow"></a>Restricting OIDC request and response filters to bearer token flow</h3>
<div class="paragraph">
<p>When you have both the bearer access token and <a href="security-oidc-code-flow-authentication">authorization code</a> flows supported by <a href="security-openid-connect-multitenancy">multiple OIDC tenants</a> and the filters have to deal with a flow specific logic, you can instead have them restricted to the bearer token flow with the <code>io.quarkus.oidc.BearerTokenAuthentication</code> annotation and <a href="security-oidc-code-flow-authentication#restrict-oidc-filter-to-code-flow">the authorization code flow with the 'io.quarkus.oidc.AuthorizationCodeFlow' annotation</a>.</p>
</div>
<div class="paragraph">
<p>例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.BearerTokenAuthentication;
import io.quarkus.oidc.common.OidcRequestFilter;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;

@BearerTokenAuthentication
@ApplicationScoped
@Unremovable
public class CustomOidcRequestFilter implements OidcRequestFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcRequestFilterContext requestContext) {
        requestContext.request().putHeader("custom-header-name", "custom-header-value");
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="programmatic-oidc-start-up"><a class="anchor" href="#programmatic-oidc-start-up"></a>プログラムによる OIDC のスタートアップ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>OIDC テナントは、次の例のようにプログラムで作成できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import io.quarkus.oidc.Oidc;
import jakarta.enterprise.event.Observes;

public class OidcStartup {

    void observe(@Observes Oidc oidc) {
        oidc.createServiceApp("http://localhost:8180/realms/quarkus");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記のコードは、 <code>application.properties</code> ファイル内の次の設定とプログラム的に同等です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus</code></pre>
</div>
</div>
<div class="paragraph">
<p>さらに多くの OIDC テナントプロパティーを設定する必要がある場合は、次の例のように <code>OidcTenantConfig</code> ビルダーを使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import io.quarkus.oidc.Oidc;
import io.quarkus.oidc.OidcTenantConfig;
import jakarta.enterprise.event.Observes;

public class OidcStartup {

    void createDefaultTenant(@Observes Oidc oidc) {
        var defaultTenant = OidcTenantConfig
                .authServerUrl("http://localhost:8180/realms/quarkus")
                .token().requireJwtIntrospectionOnly().end()
                .build();
        oidc.create(defaultTenant);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>複数のテナントが関係するより複雑な設定については、OpenID Connect マルチテナンシーガイドの <a href="security-openid-connect-multitenancy#programmatic-startup">マルチテナントアプリケーション用のプログラムによる OIDC の起動</a> 
セクションを参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="step-up-authentication"><a class="anchor" href="#step-up-authentication"></a>Step Up Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>io.quarkus.oidc.AuthenticationContext</code> annotation can be used to list one or more Authentication Context Class Reference (ACR) values to enforce a required authentication level for the Jakarta REST resource classes and methods.
The <a href="https://datatracker.ietf.org/doc/rfc9470/">OAuth 2.0 Step Up Authentication Challenge Protocol</a> introduces a mechanism for resource servers to request stronger authentication methods when the token does not have expected Authentication Context Class Reference (ACR) values.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import io.quarkus.oidc.AuthenticationContext;
import io.quarkus.oidc.BearerTokenAuthentication;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@BearerTokenAuthentication
@Path("/")
public class GreetingsResource {

    @Path("hello")
    @AuthenticationContext("myACR") <i class="conum" data-value="1"></i><b>(1)</b>
    @GET
    public String hello() {
        return "hello";
    }

    @Path("hi")
    @AuthenticationContext(value = "myACR", maxAge = "PT120m") <i class="conum" data-value="2"></i><b>(2)</b>
    @GET
    public String hi() {
        return "hi";
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bearer access token must have an <code>acr</code> claim with the <code>myACR</code> ACR value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Bearer access token must have an <code>acr</code> claim with the <code>myACR</code> ACR value and be in use for no longer than 120 minutes since the authentication time.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.http.auth.proactive=false <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Disable proactive authentication so that the <code>@AuthenticationContext</code> annotation can be matched with the endpoint before Quarkus authenticates incoming requests.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the bearer access token claim <code>acr</code> does not contain <code>myACR</code>, Quarkus returns an authentication requirements challenge indicating required <code>acr_values</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error="insufficient_user_authentication",
 error_description="A different authentication level is required",
 acr_values="myACR"</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a client such as Single-page application (SPA) receives a challenge with the <code>insufficient_user_authentication</code> error code, it must parse <code>acr_values</code>, request a new user login which must meet the <code>acr_values</code> constraints, and use a new access token to access Quarkus.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>io.quarkus.oidc.AuthenticationContext</code> annotation can also be used to enforce required authentication level for a WebSockets Next server endpoint.
The annotation must be placed on the endpoint class, because the <code>SecurityIdentity</code> is created before the HTTP connection is upgraded to a WebSocket connection.
For more information about the HTTP upgrade security, see the <a href="websockets-next-reference#secure-http-upgrade">Secure HTTP upgrade</a> section of the Quarkus "WebSockets Next reference" guide.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is also possible to enforce the required authentication level for an OIDC tenant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.hr.token.required-claims.acr=myACR</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, if you need more flexibility, write a <a href="#jose4j-validator-bearer">Jose4j Validator</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import java.util.Collections;
import java.util.List;
import java.util.Map;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.jwt.Claims;
import org.jose4j.jwt.MalformedClaimException;
import org.jose4j.jwt.consumer.JwtContext;
import org.jose4j.jwt.consumer.Validator;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.TenantFeature;
import io.quarkus.oidc.common.runtime.OidcConstants;
import io.quarkus.security.AuthenticationFailedException;

@Unremovable
@ApplicationScoped
@TenantFeature("hr")
public class AcrValueValidator implements Validator {

    @Override
    public String validate(JwtContext jwtContext) throws MalformedClaimException {
        var jwtClaims = jwtContext.getJwtClaims();
        var acrClaimName = Claims.acr.name();

        if (jwtClaims.hasClaim(acrClaimName)) {
            // The claim 'acr' could be a String or a list
            List&lt;String&gt; acrClaimValues;
            if (jwtClaims.isClaimValueStringList(acrClaimName)) {
               acrClaimValues = jwtClaims.getStringListClaimValue(acrClaimName);
            } else if (jwtClaims.isClaimValueString(acrClaimName)) {
               acrClaimValues = List.of(jwtClaims.getStringClaimValue(acrClaimName));
            } else {
                throw new MalformedClaimException("Claim '" + acrClaimName + "' is not a String or List of Strings.");
            }
            if (acrClaimValues.contains("myACR") &amp;&amp; acrClaimValues.contains("yourACR")) {
                return null;
            }
        }
        String requiredAcrValues = "myACR,yourACR";
        throw new AuthenticationFailedException(Map.of(OidcConstants.ACR_VALUES, requiredAcrValues));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references"><a class="anchor" href="#references"></a>参考資料</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="security-oidc-configuration-properties-reference">OIDC 設定プロパティー</a></p>
</li>
<li>
<p><a href="security-oidc-expanded-configuration">Expanded OIDC Configuration Reference</a></p>
</li>
<li>
<p><a href="security-oidc-bearer-token-authentication-tutorial">OIDCベアラートークン認証によるサービスアプリケーションの保護</a></p>
</li>
<li>
<p><a href="security-openid-connect-client-reference">OpenID Connect および OAuth2 クライアントとフィルターのリファレンスガイド</a></p>
</li>
<li>
<p><a href="security-openid-connect-dev-services">Dev Services for Keycloak</a></p>
</li>
<li>
<p><a href="security-jwt-build">JSONウェブトークン (JWT) のビルド、署名、暗号化</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms#oidc-jwt-oauth2-comparison">OpenID Connect、SmallRye JWT、OAuth2 の認証メカニズムの選択</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms#combining-authentication-mechanisms">認証メカニズムの組み合わせ</a></p>
</li>
<li>
<p><a href="security-overview">Quarkus Security の概要</a></p>
</li>
<li>
<p><a href="security-keycloak-admin-client">Quarkus Keycloak Adminクライアント</a></p>
</li>
<li>
<p><a href="security-openid-connect-multitenancy">OpenID Connect マルチテナンシーの使用</a></p>
</li>
<li>
<p><a href="https://www.keycloak.org/documentation.html">Keycloak ドキュメント</a></p>
</li>
<li>
<p><a href="https://openid.net/connect/">OpenID Connect</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a></p>
</li>
</ul>
</div>
</div>
</div>
    </div>
    <div class="grid__item width-4-12 width-12-12-m tocwrapper">
      <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#overview-of-the-bearer-token-authentication-mechanism-in-quarkus">Quarkusのベアラートークン認証メカニズムの概要</a>
<ul class="sectlevel2">
<li><a href="#accessing-jwt-claims">JWT クレームへのアクセス</a></li>
<li><a href="#bearer-token-user-info"><code>UserInfo</code></a></li>
<li><a href="#bearer-token-config-metadata">設定メタデータ</a></li>
<li><a href="#token-claims-and-security-identity-roles">トークンクレームと SecurityIdentity ロール</a></li>
<li><a href="#token-scopes-and-security-identity-permissions">トークンのスコープと SecurityIdentity の権限</a></li>
<li><a href="#bearer-token-token-verification-introspection">トークン検証およびイントロスペクション</a></li>
<li><a href="#bearer-token-token-introspection-userinfo-cache">トークンのイントロスペクションと <code>UserInfo</code> キャッシュ</a></li>
<li><a href="#bearer-token-jwt-claim-verification">JSON Web トークンのクレーム検証</a></li>
<li><a href="#jose4j-validator-bearer">Jose4j Validator</a></li>
<li><a href="#single-page-applications">シングルページアプリケーション</a></li>
<li><a href="#cross-origin-resource-sharing">クロスオリジンリソース共有</a></li>
<li><a href="#provider-endpoint-configuration">プロバイダーエンドポイント設定</a></li>
<li><a href="#token-propagation">トークンの伝播</a></li>
<li><a href="#jwt-token-certificate-chain">JWT トークン証明書チェーン</a></li>
<li><a href="#oidc-provider-client-authentication">OIDC プロバイダーのクライアント認証</a></li>
<li><a href="#bearer-token-integration-testing">テスト</a></li>
<li><a href="#check-errors-in-the-logs">ログでのエラーの確認</a></li>
<li><a href="#external-and-internal-access-to-oidc-providers">OIDC プロバイダーへの外部および内部アクセス</a></li>
<li><a href="#using-client-id">`client-id`プロパティーの使用</a></li>
</ul>
</li>
<li><a href="#sender-constraining-access-tokens">送信者制限アクセストークン</a>
<ul class="sectlevel2">
<li><a href="#demonstrating-proof-of-possession-dpop">Demonstrating Proof of Possession (DPoP)</a></li>
<li><a href="#mutual-tls-token-binding">相互 TLS トークンバインディング</a></li>
</ul>
</li>
<li><a href="#authentication-after-an-http-request-has-completed">HTTP リクエストが完了した後の認証</a></li>
<li><a href="#bearer-token-oidc-request-filters">OIDC リクエストフィルター</a>
<ul class="sectlevel2">
<li><a href="#bearer-token-oidc-response-filters">OIDC レスポンスフィルター</a></li>
<li><a href="#restrict-oidc-filter-to-bearer-auth-flow">Restricting OIDC request and response filters to bearer token flow</a></li>
</ul>
</li>
<li><a href="#programmatic-oidc-start-up">プログラムによる OIDC のスタートアップ</a></li>
<li><a href="#step-up-authentication">Step Up Authentication</a></li>
<li><a href="#references">参考資料</a></li>
</ul></div>
    </div>
  </div>
  <h2>関連コンテンツ</h2>
  <div class="grid-wrapper relations">
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じエクステンションについて</h3>
      <ul class="related-content">
      
        
        <li class="concepts"><a href="/guides/security-openid-connect-providers">よく知られたOpenID Connect プロバイダーの設定</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-dev-services">OpenID Connect (OIDC)のDev ServicesとDev UI</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-vertx-oidc-to-quarkus-oidc-migration">Migrate from Vert.x OIDC to Quarkus OIDC</a></li>
      
        
        <li class="reference"><a href="/guides/security-oidc-configuration-properties-reference">OpenID Connect (OIDC) 設定プロパティ</a></li>
      
        
        <li class="concepts"><a href="/guides/security-oidc-code-flow-authentication">Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-oidc-bearer-token-authentication-tutorial">OpenID Connect（OIDC）ベアラートークン認証によるサービスアプリケーションの保護</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-oidc-code-flow-authentication-tutorial">Quarkus - 認可コードフローのOpenID Connectを使用してWebアプリケーションを保護</a></li>
      
        
        <li class="howto"><a href="/guides/security-keycloak-authorization">OpenID Connect (OIDC)とKeycloakを使用した認可の一元化</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-multitenancy">OpenID Connect (OIDC)のマルチテナンシーの使用</a></li>
      </ul>
    </div>
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じトピックについて</h3>
      <ul class="related-content">
      
        
        <li class="tutorial"><a href="/guides/security-oidc-bearer-token-authentication-tutorial">OpenID Connect（OIDC）ベアラートークン認証によるサービスアプリケーションの保護</a></li>
      
        
        <li class="concepts"><a href="/guides/security-oidc-code-flow-authentication">Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム</a></li>
      
        
        <li class="howto"><a href="/guides/security-keycloak-authorization">OpenID Connect (OIDC)とKeycloakを使用した認可の一元化</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-dev-services">OpenID Connect (OIDC)のDev ServicesとDev UI</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-oidc-code-flow-authentication-tutorial">Quarkus - 認可コードフローのOpenID Connectを使用してWebアプリケーションを保護</a></li>
      
        
        <li class="guide"><a href="/guides/security-keycloak-admin-client">Keycloak Admin Clientの使用</a></li>
      
        
        <li class="concepts"><a href="/guides/security-authentication-mechanisms">Quarkusの認証メカニズム</a></li>
      
        
        <li class="concepts"><a href="/guides/security-basic-authentication">Basic認証</a></li>
      
        
        <li class="concepts"><a href="/guides/security-openid-connect-providers">よく知られたOpenID Connect プロバイダーの設定</a></li>
      
        
        <li class="howto"><a href="/guides/security-basic-authentication-howto">ベーシック認証の有効化</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-getting-started-tutorial">Basic認証とJakarta Persistenceを使用したセキュリティの入門</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-vertx-oidc-to-quarkus-oidc-migration">Migrate from Vert.x OIDC to Quarkus OIDC</a></li>
      
        
        <li class="reference"><a href="/guides/security-openid-connect-client-reference">OpenID Connect (OIDC) と OAuth2 クライアントおよびフィルター</a></li>
      
        
        <li class="reference"><a href="/guides/security-openid-connect-client-registration">OpenID Connect (OIDC) と OAuth2 の動的クライアント登録</a></li>
      
        
        <li class="reference"><a href="/guides/security-oidc-configuration-properties-reference">OpenID Connect (OIDC) 設定プロパティ</a></li>
      
        
        <li class="tutorial"><a href="/guides/security-openid-connect-client">OpenID Connectクライアントとトークン伝搬クイックスタート</a></li>
      
        
        <li class="concepts"><a href="/guides/security-proactive-authentication">プロアクティブ認証</a></li>
      
        
        <li class="howto"><a href="/guides/security-openid-connect-multitenancy">OpenID Connect (OIDC)のマルチテナンシーの使用</a></li>
      
        
        <li class="reference"><a href="/guides/security-authorize-web-endpoints-reference">ウェブエンドポイントの認可</a></li>
      
        
        <li class="guide"><a href="/guides/security-jwt-build">JSON Web トークン (JWT) のビルド、署名、暗号化</a></li>
      </ul>
    </div>
    </div>
  </div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license. <i class='fab fa-creative-commons'></i><i class='fab fa-creative-commons-by'></i> <a href='https://creativecommons.org/licenses/by/3.0/' target='_blank'>CC by 3.0</a><br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>GitHub Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
          
            <li><a href="/" target="_blank">ホーム</a></li>
          
          
          
            <li><a href="/about" target="_blank">Quarkusについて</a></li>
          
          
          
            <li><a href="/blog" target="_blank">ブログ</a></li>
          
          
          
            <li><a href="/insights" target="_blank">ポッドキャスト</a></li>
          
          
          
            <li><a href="/events" target="_blank">イベント</a></li>
          
          
          
            <li><a href="/newsletter" target="_blank">ニュースレター</a></li>
          
          
          
            <li><a href="/userstories" target="_blank">ユーザーストーリー</a></li>
          
          
          
            <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" target="_blank">ロードマップ</a></li>
          
          
          
            <li><a href="/security" target="_blank">セキュリティ&nbsp;ポリシー</a></li>
          
          
          
            <li><a href="/usage" target="_blank">使用方法</a></li>
          
          
          
            <li><a href="https://github.com/commonhaus/artwork/tree/main/projects/quarkus" target="_blank">Brand</a></li>
          
          
          
            <li><a href="/desktopwallpapers" target="_blank">Wallpapers</a></li>
          
          
          
            <li><a href="https://www.redhat.com/en/about/privacy-policy" target="_blank">Privacy Policy</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォローする</span>
        <ul class="footer-links">
          
          
            <li><a href="https://x.com/quarkusio" target="_blank">X</a></li>
          
          
          
            <li><a href="https://bsky.app/profile/quarkus.io" target="_blank">Bluesky</a></li>
          
          
          
            <li><a rel="me" href="https://fosstodon.org/@quarkusio" target="_blank">Mastodon</a></li>
            
          
          
            <li><a href="https://www.threads.com/@quarkusio" target="_blank">Threads</a></li>
          
          
          
            <li><a href="https://www.facebook.com/quarkusio" target="_blank">Facebook</a></li>
          
          
          
            <li><a href="https://www.linkedin.com/company/quarkusio/" target="_blank">Linkedin</a></li>
          
          
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg" target="_blank">Youtube</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio" target="_blank">GitHub</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
          
            <li><a href="/support" target="_blank">サポート</a></li>
          
          
          
            <li><a href="/guides" target="_blank">ガイド</a></li>
          
          
          
            <li><a href="/faq" target="_blank">FAQ</a></li>
          
          
          
            <li><a href="/get-started" target="_blank">入門</a></li>
          
          
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus" target="_blank">Stack Overflow</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions" target="_blank">ディスカッション</a></li>
          
          
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev" target="_blank">開発メーリングリスト</a></li>
          
          
          
            <li><a href="https://stats.uptimerobot.com/ze1PfweT2p" target="_blank">Quarkus Service Status</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>言語</span>
        <ul class="footer-links">
          
          
            <li><a href=" https://quarkus.io/ " target="_blank">English</a></li>
          
          
          
            <li><a href="https://pt.quarkus.io/" target="_blank">Português&nbsp;(Brasileiro)</a></li>
          
          
          
            <li><a href=" https://es.quarkus.io/ " target="_blank">Español</a></li>
          
          
          
            <li><a href="https://cn.quarkus.io/" target="_blank">简体中文</a></li>
          
          
          
            <li><a href=" https://ja.quarkus.io/ " target="_blank">日本語</a></li>
          
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています</span>
        <ul class="footer-links">
          
            <li><a blah href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a blah href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a blah href="https://hibernate.org" target="_blank">Hibernate ORM</a></li>
          
            <li><a blah href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a blah href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a blah href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a blah href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a blah href="https://code.quarkus.io/" target="_blank">その他多数...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content cf-footer">
  <div class="flexcontainer">
    <div class="cf-logo">
      <a class="cf-logo" href="https://www.commonhaus.org/" target="_blank"><img src="https://raw.githubusercontent.com/commonhaus/artwork/main/foundation/brand/svg/CF_logo_horizontal_single_reverse.svg"/></a>
    </div>
    <div class="license">
      Copyright © Quarkus. All rights reserved. For details on our trademarks, please visit our <a href="https://www.commonhaus.org/policies/trademark-policy/">Trademark Policy</a> and <a href="https://www.commonhaus.org/trademarks/">Trademark List</a>. Trademarks of third parties are owned by their respective holders and their mention here does not suggest any endorsement or association.
    </div>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
  <script src="/assets/javascript/future-date.js" type="text/javascript"></script>
  <script src="/assets/javascript/randomize.js" type="text/javascript"></script>
  <script src="/assets/javascript/time.js" type="text/javascript"></script>
</body>

</html>
