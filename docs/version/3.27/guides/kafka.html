<!DOCTYPE html>
<html lang="ja">







<head>
  <title>Apache Kafka リファレンスガイド - 3.27 - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="
  connect-src 'self' https://dpm.demdex.net https://adobedc.demdex.net https://analytics.ossupstream.org/ https://search.quarkus.io https://smetrics.redhat.com; 
  script-src 'self' 'unsafe-inline' 'unsafe-eval'
      
      https://assets.adobedtm.com
      js.bizographics.com
      https://www.redhat.com
      https://static.redhat.com
      https://app.requestly.io/
      jsonip.com
      https://ajax.googleapis.com
      https://use.fontawesome.com
      http://www.youtube.com
      http://www.googleadservices.com
      https://googleads.g.doubleclick.net
      https://giscus.app
      https://analytics.ossupstream.org/
      https://app.mailjet.com;

  style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; 
  img-src 'self' * data:; 
  media-src 'self'; 
  frame-src https://redhat.demdex.net https://www.youtube.com https://player.restream.io https://app.mailjet.com http://xy0p2.mjt.lu https://mj.quarkus.io https://giscus.app; 
  base-uri 'none'; 
  object-src 'none'; 
  form-action 'none'; 
  font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/version/3.27/guides/kafka" />
  <meta property="og:title" content="Apache Kafka リファレンスガイド - 3.27" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/kafka">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />  
  <script src="/assets/javascript/tracking.js"></script>
  
  <script src="/assets/javascript/colormode.js" type="text/javascript"></script>

</head>

<body class="guides">

  


<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io/version/3.27/guides/kafka">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
        <div class="logo-wrapper">
           <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
        </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="#">Why<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/performance" class="">パフォーマンス</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
          <li><a href="/versatility" class="">多用途性</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/spring" class="">USING SPRING?</a></li>
          <li class="tertiarydropdown">
            <span href="#">AI<i class="fas fa-chevron-down"></i></span>
            <ul class="tertiarymenu">
              <li><a href="/ai" class="">AI OVERVIEW</a></li>
              <li><a href="/java-for-ai" class="">JAVA FOR AI</a></li>
              <li><a href="/quarkus-for-ai" class="">WHY QUARKUS FOR AI</a></li>
              <li><a href="/ai-blueprints" class="">AI BLUEPRINTS</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Learn<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ドキュメント</a></li>
          <li><a href="/userstories/" class="">ユーザーストーリー</a></li>  
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="#">Extensions<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          
          <!-- Note that quarkus.io is hardcoded here, because it is the only url which supports extensions -->
<li><a href="https://quarkus.io/extensions/" class="">エクステンションを探す</a></li>
          <li><a href="/faq/#what-is-a-quarkus-extension" class="">エクステンションの使用</a></li>
          <li><a href="/guides/writing-extensions" class="">エクステンションの作成</a></li>
          <li><a href="https://hub.quarkiverse.io" class="">エクステンションの共有</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Community<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/working-groups" class="">ワーキンググループ</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="">ロードマップ</a></li>
          <li><a href="/benefactors" class="">BENEFACTORS</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/version/3.27/guides/kafka" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://pt.quarkus.io/version/3.27/guides/kafka">ポルトガル（BR）</a></li>
          <li><a href="https://es.quarkus.io/version/3.27/guides/kafka">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/version/3.27/guides/kafka">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/version/3.27/guides/kafka">日本語</a></li>
          </ul>
      </li>
      <li>
        <span href="#" class="modeswitcher" id='theme-toggle'><i class="fas
fa-sun"></i><i class="fas fa-moon"></i><i class="fas fa-cog"></i></span>
      </li>
    </ul>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    







<section class="full-width-version-bg flexfilterbar guides">
  <div class="guideflexcontainer">
    <div class="docslink">
      <a class="returnlink" href="/version/3.27/guides/"> Back to Guides</a>
    </div>
    <div class="flexlabel">
      <label>バージョン:</label>
    </div>
    <div class="guidepulldown version">
    <select id="guide-version-dropdown">
      
        
        
        <option value="main" >Main - SNAPSHOT</option>
        
        
        
        <option value="latest" >3.28.4 - Latest</option>
        
        
        
        <option value="3.27" selected>3.27</option>
        
        
        
        <option value="3.20" >3.20</option>
        
        
        
        <option value="3.15" >3.15</option>
        
        
        
        <option value="3.8" >3.8</option>
        </select>
    </div>
  </div>
</section>

<div class="guide">
  <div class="grid-wrapper">
    <div class="grid__item width-8-12 width-12-12-m">
      
      <h1 class="text-caps">Apache Kafka リファレンスガイド </h1>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>このリファレンスガイドでは、Quarkus アプリケーションが Quarkus Messaging を利用して Apache Kafka と対話する仕組みを説明します。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>1. はじめに</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://kafka.apache.org">Apache Kafka</a>は、人気の高いオープンソースの分散型イベントストリーミングプラットフォームです。高性能なデータパイプライン、ストリーミング分析、データ統合、ミッションクリティカルなアプリケーションなどによく利用されています。メッセージキューやエンタープライズメッセージングプラットフォームに似ており、以下のことが可能です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>レコード</em> と呼ばれるイベントのストリームを <strong>発行</strong> （書き込み）したり、 <strong>購読</strong> （読み込み）したりすることができます。
</p>
</li>
<li>
<p>記録のストリームを <em>トピック</em> 内に永続的かつ確実に *保存し*ます。
</p>
</li>
<li>
<p>記録のストリームを発生時または遡及的に <strong>処理</strong> します。
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>そして、これらの機能はすべて、分散型で、拡張性が高く、弾力性があり、耐障害性があり、安全な方法で提供されます。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quarkus-extension-for-apache-kafka"><a class="anchor" href="#quarkus-extension-for-apache-kafka"></a>2. Apache Kafka のための Quarkus エクステンション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus は、 <a href="https://smallrye.io/smallrye-reactive-messaging/">SmallRye Reactive Messaging</a> フレームワークを通じて Apache Kafka のサポートを提供します。Eclipse MicroProfile Reactive Messaging 仕様 2.0 に基づいて、CDI とイベント駆動型を橋渡しする柔軟なプログラミングモデルを提案します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このガイドでは、Apache Kafka と SmallRye Reactive Messaging フレームワークについて詳しく説明します。
クイックスタートについては、<a href="kafka-getting-started">Apache Kafka を使用した Quarkus Messaging 入門</a> を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>プロジェクトのベースディレクトリーで次のコマンドを実行すると、 <code>messaging-kafka</code> エクステンションをプロジェクトに追加できます。</p>
</div>
<div class="listingblock primary asciidoc-tabs-sync-cli">
<div class="title">コマンドラインインタフェース</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">quarkus extension add messaging-kafka</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-sync-maven">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw quarkus:add-extension -Dextensions='messaging-kafka'</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-sync-gradle">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./gradlew addExtension --extensions='messaging-kafka'</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、 <code>pom.xml</code> に以下が追加されます:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-messaging-kafka")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このエクステンションには、 <code>kafka-clients</code> バージョン 3.2.1 が推移的依存関係として含まれており、Kafka ブローカーバージョン 2.x と互換性があります。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuring-smallrye-kafka-connector"><a class="anchor" href="#configuring-smallrye-kafka-connector"></a>3. SmallRye Kafka コネクターの設定</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Smallrye Reactive Messaging フレームワークは、Apache Kafka、AMQP、Apache Camel、JMS、MQTT など、さまざまなメッセージングバックエンドをサポートしているため、汎用的な語彙を使用しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>アプリケーションは <strong>メッセージ</strong> を送受信します。メッセージは <em>payload</em> をラップし、いくつかの <em>metadata</em> で拡張できます。Kafka コネクターを使用すると、<em>メッセージ</em> は Kafka <em>レコード</em> に対応します。</p>
</li>
<li>
<p>メッセージは <strong>チャネル</strong> を通過します。アプリケーションコンポーネントはチャネルに接続して、メッセージを公開および消費します。Kafka コネクターは <em>チャネル</em> を Kafka <em>トピック</em> にマップします。</p>
</li>
<li>
<p>チャネルは、 <strong>コネクター</strong> を使用してメッセージバックエンドに接続されます。コネクターは、着信メッセージを特定のチャネル (アプリケーションによって消費される) にマッピングし、特定のチャネルに送信された発信メッセージを収集するように設定されています。各コネクターは、特定のメッセージングテクノロジーに特化しています。たとえば、Kafka を処理するコネクターの名前は <code>smallrye-kafka</code> となっています。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>着信チャンネルを持つ Kafka コネクターの最小設定は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.kafka.bootstrap.servers=kafka:9092 <i class="conum" data-value="1"></i><b>(1)</b>
mp.messaging.incoming.prices.connector=smallrye-kafka <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>プロダクションプロファイルのブローカーの場所を設定します。 <code>mp.messaging.incoming.$channel.bootstrap.servers</code> プロパティーを使用して、グローバルまたはチャネルごとに設定できます。dev モードとテスト実行時には、<a href="#kafka-dev-services">Dev Services for Kafka</a> が自動的に Kafka ブローカーを開始します。指定しない場合、このプロパティーのデフォルトは <code>localhost:9092</code> になります。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>prices チャネルを管理するようにコネクターを設定します。デフォルトでは、トピック名はチャネル名と同じです。トピック属性を設定することで、それを上書きすることができます。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>%prod</code> 接頭辞は、アプリケーションが prod モードで実行されている場合にのみプロパティーが使用されることを示します (つまり、dev または test モードでは使用されません)。詳細は、<a href="config-reference#profiles">プロファイルに関するドキュメント</a> を参照してください。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">コネクターの自動取り付け</div>
<div class="paragraph">
<p>クラスパスに単一のコネクターがある場合は、 <code>connector</code> 属性の設定を省略できます。Quarkus は、<em>orphan</em> チャネルをクラスパスにある (一意の) コネクターに自動的に関連付けます。<em>Orphans</em> チャネルは、ダウンストリームコンシューマーのない outgoing チャネル、またはアップストリームプロデューサーのない incoming チャネルです。</p>
</div>
<div class="paragraph">
<p>この自動取り付けは、以下を使用して無効にできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.messaging.auto-connector-attachment=false</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="receiving-messages-from-kafka"><a class="anchor" href="#receiving-messages-from-kafka"></a>4. Kafka からのメッセージの受信</h2>
<div class="sectionbody">
<div class="paragraph">
<p>直前の最小設定によって、Quarkus アプリケーションはすぐにメッセージペイロードを受信できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.eclipse.microprofile.reactive.messaging.Incoming;

import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class PriceConsumer {

    @Incoming("prices")
    public void consume(double price) {
        // process your price.
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>アプリケーションが受信したメッセージを消費する方法は、他にもいくつかあります。</p>
</div>
<div class="listingblock">
<div class="title">Message</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
public CompletionStage&lt;Void&gt; consume(Message&lt;Double&gt; msg) {
    // access record metadata
    var metadata = msg.getMetadata(IncomingKafkaRecordMetadata.class).orElseThrow();
    // process the message payload.
    double price = msg.getPayload();
    // Acknowledge the incoming message (commit the offset)
    return msg.ack();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Message</code> タイプを使用すると、消費するメソッドは着信メッセージのメタデータにアクセスし、確認応答を手動で処理することができます。<a href="#commit-strategies">コミットストラテジー</a> で、さまざまな確認応答ストラテジーを検討します。</p>
</div>
<div class="paragraph">
<p>Kafka レコードオブジェクトに直接アクセスする場合は、次を使用します。</p>
</div>
<div class="listingblock">
<div class="title">ConsumerRecord</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
public void consume(ConsumerRecord&lt;String, Double&gt; record) {
    String key = record.key(); // Can be `null` if the incoming record has no key
    String value = record.value(); // Can be `null` if the incoming record has no value
    String topic = record.topic();
    int partition = record.partition();
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ConsumerRecord</code> は、基盤となる Kafka クライアントによって提供され、コンシューマーメソッドに直接注入することができます。 <code>Record</code> の使用に際して、以下のような別の簡単なアプローチがあります。</p>
</div>
<div class="listingblock">
<div class="title">Record</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
public void consume(Record&lt;String, Double&gt; record) {
    String key = record.key(); // Can be `null` if the incoming record has no key
    String value = record.value(); // Can be `null` if the incoming record has no value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Record</code> は、着信 Kafka レコードのキーとペイロードの単純なラッパーです。</p>
</div>
<div class="paragraph">
<div class="title">@Channel</div>
<p>または、以下の例のように、アプリケーションで Bean に <code>Multi</code> を注入し、そのイベントをサブスクライブすることもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Channel;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import org.jboss.resteasy.reactive.RestStreamElementType;

@Path("/prices")
public class PriceResource {

    @Inject
    @Channel("prices")
    Multi&lt;Double&gt; prices;

    @GET
    @Path("/prices")
    @RestStreamElementType(MediaType.TEXT_PLAIN)
    public Multi&lt;Double&gt; stream() {
        return prices;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、Kafka コンシューマーを別のダウンストリームと統合する方法の良い例で、この例では Server-Sent Events エンドポイントとして公開しています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Channel</code> でメッセージを消費する場合、アプリケーションコードがサブスクリプションを行います。
上記の例では、Quarkus REST (旧称 RESTEasy Reactive) エンドポイントがサブスクリプションを処理します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>チャンネルとして注入できるのは、以下のタイプです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject @Channel("prices") Multi&lt;Double&gt; streamOfPayloads;

@Inject @Channel("prices") Multi&lt;Message&lt;Double&gt;&gt; streamOfMessages;

@Inject @Channel("prices") Publisher&lt;Double&gt; publisherOfPayloads;

@Inject @Channel("prices") Publisher&lt;Message&lt;Double&gt;&gt; publisherOfMessages;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前出の <code>Message</code> の例と同様に、注入されたチャネルがペイロードを受信した場合 (<code>Multi&lt;T&gt;</code>)、メッセージを自動的に確認応答し、複数のサブスクライバーをサポートします。注入したチャネルが Message (<code>Multi&lt;Message&lt;T&gt;&gt;</code>) を受信した場合は、確認応答とブロードキャストを行う必要があります。ブロードキャストメッセージの送信については、<a href="#broadcasting-messages-on-multiple-consumers">複数のコンシューマーでのメッセージのブロードキャスト</a> で説明します。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Channel("prices")</code> を注入したり、 <code>@Incoming("prices")</code> を持っていたりしても、Kafka からのメッセージを消費するようにアプリケーションが自動的に設定されるわけではありません。 <code>mp.messaging.incoming.prices...</code> を使用してインバウンドコネクターを設定するか、アプリケーションのどこかに <code>@Outgoing("prices")</code> メソッドを持っている必要があります (その場合、 <code>prices</code> はインメモリーチャネルになります)。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="blocking-processing"><a class="anchor" href="#blocking-processing"></a>4.1. ブロッキング処理</h3>
<div class="paragraph">
<p>リアクティブメッセージングは、I/O スレッドでメソッドを呼び出します。このトピックの詳細については、x<a href="quarkus-reactive-architecture">Quarkus リアクティブアーキテクチャーのドキュメント</a> を参照してください。ただし、多くの場合、リアクティブメッセージングとデータベースインタラクションなどのブロック処理を組み合わせる必要があります。このためには、処理が <em>ブロッキング</em> であり、呼び出し元のスレッドで実行するべきではないことを示す <code>@Blocking</code> アノテーションを使用する必要があります。</p>
</div>
<div class="paragraph">
<p>例えば、以下のコードは、Hibernate with Panacheを 使用してデータベースに受信ペイロードを格納する方法を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.transaction.Transactional;

@ApplicationScoped
public class PriceStorage {

    @Incoming("prices")
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完全な例は、 <code>kafka-panache-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/3.27/kafka-panache-quickstart">ディレクトリー</a> で入手可能です。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Blocking</code> アノテーションは 2 つあります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>io.smallrye.reactive.messaging.annotations.Blocking</code></p>
</li>
<li>
<p><code>io.smallrye.common.annotation.Blocking</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>効果はどちらも同じです。したがって、両方を使うことができます。最初のものは、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2 番目のものは、Quarkus の他のリアクティブ機能でも使用され、デフォルトのワーカープールを使用し、順序を保持します。</p>
</div>
<div class="paragraph">
<p><code>@Blocking</code> アノテーションの使用法の詳細については、 <a href="https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html">SmallRye Reactive Messaging – Handling blocking execution</a> を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">@RunOnVirtualThread</div>
<div class="paragraph">
<p>Java <em>仮想スレッドでの</em> ブロッキング処理の実行については、 <a href="messaging-virtual-threads">Quarkus Virtual Thread support with Reactive Messagingのドキュメント</a> を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">@Transactional</div>
<div class="paragraph">
<p>メソッドに <code>@Transactional</code> アノテーションが付けられている場合、メソッドに <code>@Blocking</code> アノテーションが付けられていなくても、自動的に <em>blocking</em> と見なされます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="acknowledgment-strategies"><a class="anchor" href="#acknowledgment-strategies"></a>4.2. 確認戦略</h3>
<div class="paragraph">
<p>コンシューマーが受信したすべてのメッセージは確認応答する必要があります。確認応答されない場合、処理はエラーと見なされます。コンシューマーメソッドが <code>Record</code> またはペイロードを受信した場合、メッセージはメソッドの戻り時に確認応答されます。これは、 <code>Strategy.POST_PROCESSING</code> としても知られています。コンシューマーメソッドが別のリアクティブストリームまたは <code>CompletionStage</code> を返す場合、ダウンストリームメッセージが確認応答されたときにメッセージが確認応答されます。以下の例のように、デフォルトの動作をオーバーライドして、到着時にメッセージを確認応答する (<code>Strategy.PRE_PROCESSING</code>) か、コンシューマーメソッドでメッセージをまったく確認応答しない (<code>Strategy.NONE</code>) ことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
@Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING)
public void process(double price) {
    // process price
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>コンシューマーメソッドが <code>Message</code> を受信した場合、確認応答ストラテジーは <code>Strategy.MANUAL</code> で、コンシューマーメソッドがメッセージの ack/nack を行います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
public CompletionStage&lt;Void&gt; process(Message&lt;Double&gt; msg) {
    // process price
    return msg.ack();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前述のように、このメソッドは確認応答ストラテジーを <code>PRE_PROCESSING</code> または <code>NONE</code> にオーバーライドすることも可能です。</p>
</div>
</div>
<div class="sect2">
<h3 id="commit-strategies"><a class="anchor" href="#commit-strategies"></a>4.3. コミットストラテジー</h3>
<div class="paragraph">
<p>Kafka レコードから生成されたメッセージが確認応答されると、コネクターはコミットストラテジーを呼び出します。これらのストラテジーは、特定のトピック/パーティションのコンシューマーオフセットがいつコミットされるかを決定します。オフセットをコミットすると、以前のすべてのレコードが処理されたことを示します。また、これは、クラッシュリカバリーまたは再起動後にアプリケーションが処理を再開する位置でもあります。</p>
</div>
<div class="paragraph">
<p>オフセットを毎回コミットすることは、Kafkaのオフセット管理のオーバーヘッドを増やすため、パフォーマンスペナルティにつながります。ただし、オフセットを十分な頻度でコミットしないと、2 つのコミットの間にアプリケーションがクラッシュした場合に、メッセージが重複する可能性があります。</p>
</div>
<div class="paragraph">
<p>Kafka コネクターは、以下の 3 つのストラテジーをサポートします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>throttled</code> は受信したメッセージを追跡し、最新の確認応答済みメッセージのオフセットを順番にコミットします (つまり、以前のすべてのメッセージも確認応答済みです)。このストラテジーは、チャネルが非同期処理を実行する場合でも、少なくとも 1 回の配信を保証します。コネクターは受信したレコードを追跡し、定期的に (<code>auto.commit.interval.ms</code> で指定された期間、デフォルト: 5000 ms) 最大の連続オフセットをコミットします。レコードに関連付けられたメッセージが <code>throttled.unprocessed-record-max-age.ms</code> (デフォルト: 60000 ms) で確認応答されない場合、コネクターは異常としてマークされます。実際、このストラテジーでは、1 つのレコード処理が失敗してすぐにオフセットをコミットすることはできません (処理失敗時の動作を設定するには、<a href="#error-handling">エラー処理戦略</a> を参照)。 <code>throttled.unprocessed-record-max-age.ms</code> が <code>0</code> 以下に設定されている場合、ヘルスチェックの検証は実行されません。このような設定では、(決して確認応答されない) "poison pill" メッセージがある場合、メモリーが不足する可能性があります。 <code>enable.auto.commit</code> が明示的に true に設定されていない場合、このストラテジーがデフォルトになります。</p>
</li>
<li>
<p><code>checkpoint</code> を使用すると、コンシューマーオフセットを Kafka ブローカーにコミットするのではなく、<strong>ステートストア</strong> に永続化できます。
<code>CheckpointMetadata</code> API を使用すると、コンシューマーコードはレコードオフセットを使用して <em>処理ステート</em> を永続化し、コンシューマーの進行状況をマークできます。
処理が以前に永続化されたオフセットから続行される場合、Kafka コンシューマーをそのオフセットまでシークし、永続化されたステートを復元して、中断したところからステートフル処理を続行します。
チェックポイントストラテジーは、最新のオフセットに関連付けられた処理ステートをローカルに保持し、それを定期的にステートストアに永続化されます (期間は <code>auto.commit.interval.ms</code> で指定されます (デフォルト: 5000))。
処理ステートが <code>checkpoint.unsynced-state-max-age.ms</code> のステートストアに永続化されていない場合、コネクターは unhealthy とマークされます (デフォルト: 10000)。
<code>checkpoint.unsynced-state-max-age.ms</code> が 0 以下に設定されている場合、ヘルスチェック検証は実行されません。
詳細は、<a href="#stateful-processing-checkpointing">チェックポイントによるステートフル処理</a> を参照してください。</p>
</li>
<li>
<p><code>latest</code> は、関連するメッセージが確認応答されるとすぐに、Kafka コンシューマーが受信したレコードオフセットをコミットします (そのオフセットが以前にコミットされたオフセットよりも高い場合)。
このストラテジーは、チャネルがメッセージを非同期処理なしで処理する場合、少なくと1 回の配信 (at-least-once delivery) を提供します。具体的には、最も最近確認応答されたメッセージのオフセットは、
処理が終了していない古いメッセージがあっても、常にコミットされます。クラッシュなどのインシデントが発生した場合、処理は最後のコミット後に再開されるため、
古いメッセージが正常かつ完全に処理されず、メッセージが失われたように見えることがあります。
このストラテジーは、オフセットコミットが高コストであるため、高負荷環境では使用しないでください。ただし、重複のリスクは軽減されます。</p>
</li>
<li>
<p><code>ignore</code> はコミットを実行しません。このストラテジーは、コンシューマーが <code>enable.auto.commit</code> を true に明示的に設定されている場合のデフォルトのストラテジーです。これは、オフセットコミットを基盤となる Kafka クライアントに委任します。 <code>enable.auto.commit</code> が <code>true</code> の場合、このストラテジーは少なくとも 1 回の配信を<strong>保証しません</strong>。SmallRye Reactive Messaging はレコードを非同期で処理するため、ポーリングされたがまだ処理されていないレコードに対してオフセットがコミットされる場合があります。エラーが発生した場合、まだコミットされていないレコードのみが再処理されます。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Kafka コネクターは、明示的に有効にされていない場合、Kafka 自動コミットを無効にします。この動作は、従来の Kafka コンシューマーとは異なります。高スループットが重要であり、ダウンストリームに制限されていない場合は、次のいずれかをお勧めします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>throttled</code> ポリシーの使用</p>
</li>
<li>
<p>または、 <code>enable.auto.commit</code> を true に設定し、消費メソッドに <code>@Acknowledgment(Acknowledgment.Strategy.NONE)</code> のアノテーションを付けます。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Smallrye Reactive Messaging を使用すると、カスタムコミットストラテジーを実装できます。
詳細は、 <a href="https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement">SmallRye Reactive Messaging ドキュメント</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="error-handling"><a class="anchor" href="#error-handling"></a>4.4. エラー処理戦略</h3>
<div class="paragraph">
<p>Kafka レコードから生成されたメッセージが nack された場合、エラーストラテジーが適用されます。Kafka コネクターは、次の 3 つのストラテジーをサポートしています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fail</code>: アプリケーションを失敗させ、それ以上のレコードは処理されません (デフォルトストラテジー)。正しく処理されなかったレコードのオフセットはコミットされません。</p>
</li>
<li>
<p><code>ignore</code>: エラーはログに記録されますが、処理は続行されます。正しく処理されなかったレコードのオフセットがコミットされます。</p>
</li>
<li>
<p><code>dead-letter-queue</code>: 正しく処理されなかったレコードのオフセットはコミットされますが、レコードは Kafka デッドレタートピックに書き込まれます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ストラテジーは <code>failure-strategy</code> 属性を使用して選択します。</p>
</div>
<div class="paragraph">
<p><code>dead-letter-queue</code> の場合、以下の属性を設定することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dead-letter-queue.topic</code>: 正しく処理されなかったレコードを書き込むために使用するトピック。デフォルトは <code>dead-letter-topic-$channel</code> で、 <code>$channel</code> はチャンネルの名前になります。</p>
</li>
<li>
<p><code>dead-letter-queue.key.serializer</code>: デッドレターキューにレコードキーを書き込むために使用されるシリアライザー。デフォルトでは、キーデシリアライザーからシリアライザーを推測します。</p>
</li>
<li>
<p><code>dead-letter-queue.value.serializer</code>: デッドレターキューにレコード値を書き込むために使用されるシリアライザー。デフォルトでは、値デシリアライザーからシリアライザーを推測します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>デッドレターキューに書き込まれたレコードには、元のレコードに関する一連の追加ヘッダーが含まれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>dead-letter-reason</strong>: 失敗の理由
</p>
</li>
<li>
<p><strong>dead-letter-cause</strong>: エラーの原因 (エラーがある場合)
</p>
</li>
<li>
<p><strong>dead-letter-topic</strong>: 記録の元のトピック
</p>
</li>
<li>
<p><strong>dead-letter-partition</strong>: レコードの元のパーティション (String にマップされた integer)
</p>
</li>
<li>
<p><strong>dead-letter-offset</strong>: レコードの元のオフセット (String にマップされた long)
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Smallrye Reactive Messaging を使用すると、カスタム 失敗戦略を実装できます。詳細は、 <a href="https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement">SmallRye Reactive Messaging のドキュメント</a> を参照してください。</p>
</div>
<div class="sect3">
<h4 id="retrying-processing"><a class="anchor" href="#retrying-processing"></a>4.4.1. 処理のリトライ</h4>
<div class="paragraph">
<p>Reactive Messaging を <a href="https://github.com/smallrye/smallrye-fault-tolerance">SmallRye Fault Tolerance</a> と組み合わせて、失敗した場合は処理をリトライできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("kafka")
@Retry(delay = 10, maxRetries = 5)
public void consume(String v) {
   // ... retry if this method throws an exception
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>遅延、再試行回数、ジッターなどを設定できます。</p>
</div>
<div class="paragraph">
<p>メソッドが <code>Uni</code> または <code>CompletionStage</code> を返す場合は、 <code>@NonBlocking</code> アノテーションを追加する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("kafka")
@Retry(delay = 10, maxRetries = 5)
@NonBlocking
public Uni&lt;String&gt; consume(String v) {
   // ... retry if this method throws an exception or the returned Uni produce a failure
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
`@NonBlocking`アノテーションは、 SmallRye Fault Tolerance 5.1.0 以前でのみ必要です。SmallRye Fault Tolerance 5.2.0 以降 (Quarkus 2.1.0.Final 以降で使用可能) では必要ありません。詳細は、 <a href="https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode">SmallRye Fault Tolerance documentation</a> を参照してください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>着信メッセージは、処理が正常に完了したときにのみ確認応答されます。したがって、着信メッセージは、処理が成功した後にオフセットをコミットします。それでも処理が失敗する場合は、すべての再試行後でも、メッセージは <em>nack</em> され、エラーストラテジーが適用されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="handling-deserialization-failures"><a class="anchor" href="#handling-deserialization-failures"></a>4.4.2. デシリアライゼーション失敗時の処理</h4>
<div class="paragraph">
<p>デシリアライゼーションがエラーが発生したとき、それをインターセプトしてエラーストラテジーを提供することができます。これを実現するには、 <code>DeserializationFailureHandler&lt;T&gt;</code> インターフェイスを実装した Bean を作成する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@Identifier("failure-retry") // Set the name of the failure handler
public class MyDeserializationFailureHandler
    implements DeserializationFailureHandler&lt;JsonObject&gt; { // Specify the expected type

    @Override
    public JsonObject decorateDeserialization(Uni&lt;JsonObject&gt; deserialization, String topic, boolean isKey,
            String deserializer, byte[] data, Headers headers) {
        return deserialization
                    .onFailure().retry().atMost(3)
                    .await().atMost(Duration.ofMillis(200));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このエラーハンドラーを使用するには、Bean を <code>@Identifier</code> 修飾子で公開し、コネクター設定で属性 <code>mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler</code> を指定する必要があります (キーまたは値のデシリアライザー用)。</p>
</div>
<div class="paragraph">
<p>ハンドラーは、 <code>Uni&lt;T&gt;</code> として表されるアクションを含む、デシリアライゼーションの詳細とともに呼び出されます。再試行などのデシリアライゼーション <code>Uni</code> エラーストラテジーでは、フォールバック値の提供やタイムアウトの適用を実装することができます。</p>
</div>
<div class="paragraph">
<p>デシリアライゼーションエラーハンドラーを設定していない場合に、デシリアライゼーションエラーが発生した場合、アプリケーションは unhealthy とマークされます。
エラーを無視することもできます。その場合、例外がログに記録され、 <code>null</code> 値が生成されます。
この動作を有効にするには、 <code>mp.messaging.incoming.$channel.fail-on-deserialization-failure</code> 属性を <code>false</code> に設定します。</p>
</div>
<div class="paragraph">
<p><code>fail-on-deserialization-failure</code> 属性が <code>false</code> に設定され、 <code>failure-strategy</code> 属性が <code>dead-letter-queue</code> の場合、失敗したレコードは対応する <strong>デッドレターキュー</strong> トピックに送信されます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="consumer-groups"><a class="anchor" href="#consumer-groups"></a>4.5. コンシューマーグループ</h3>
<div class="paragraph">
<p>Kafka では、コンシューマーグループは、トピックからのデータを消費するために協力する一連のコンシューマーです。トピックは一連のパーティションに分割されます。トピックのパーティションは、グループ内のコンシューマー間で割り当てられ、消費スループットを効果的にスケーリングできます。各パーティションは、グループからの単一のコンシューマーに割り当てられることに注意してください。ただし、パーティションの数がグループ内のコンシューマーの数よりも多い場合は、コンシューマーに複数のパーティションを割り当てることができます。</p>
</div>
<div class="paragraph">
<p>ここでは、さまざまなプロデューサー/コンシューマーパターンと、Quarkus を使用したその実装方法について簡単に説明します。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>コンシューマーグループ内の単一のコンシューマースレッド</strong>
</p>
<div class="paragraph">
<p>これは、Kafka トピックをサブスクライブするアプリケーションのデフォルトの動作です。各 Kafka コネクターは、単一のコンシューマースレッドを作成し、それを単一のコンシューマーグループ内に配置します。コンシューマグループ ID のデフォルトは、 <code>quarkus.application.name</code> 設定プロパティーで設定されたアプリケーション名です。これは、 <code>kafka.group.id</code> プロパティーを使用して設定することもできます。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/kafka-one-app-one-consumer.png" alt="Architecture" width="60%">
</div>
</div>
</li>
<li>
<p><strong>コンシューマーグループ内の複数のコンシューマースレッド</strong>
</p>
<div class="paragraph">
<p>特定のアプリケーションインスタンスの場合、コンシューマーグループ内のコンシューマーの数は、 <code>mp.messaging.incoming.$channel.concurrency</code> プロパティーを使用して設定できます。
サブスクライブされたトピックのパーティションは、コンシューマースレッド間で分割されます。
<code>concurrency</code> の値がトピックのパーティションの数を超える場合、一部のコンシューマスレッドにはパーティションが割り当てられないことに注意してください。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/kafka-one-app-two-consumers.png" alt="Architecture" width="60%">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">非推奨</div>
<div class="paragraph">
<p><a href="https://smallrye.io/smallrye-reactive-messaging/latest/concepts/incoming-concurrency/">concurrency 属性</a> は、ブロッキングしない並列チャネルのためのコネクターに依存しない方法を提供し、Kafka コネクター固有の <code>partitions</code> 属性を置き換えます。
そのため <code>partitions</code> 属性は非推奨となり、今後のリリースで削除される予定です。</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><strong>コンシューマーグループ内の複数のコンシューマーアプリケーション</strong>
</p>
<div class="paragraph">
<p>前の例と同様に、アプリケーションの複数のインスタンスは、 <code>mp.messaging.incoming.$channel.group.id</code> プロパティーを介して設定された単一のコンシューマーグループにサブスクライブすることも、アプリケーション名をデフォルトのままにすることもできます。これにより、トピックのパーティションがアプリケーションインスタンス間で分割されます。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/kafka-two-app-one-consumer-group.png" alt="Architecture" width="60%">
</div>
</div>
</li>
<li>
<p><strong>Pub/Sub: トピックにサブスクライブしている複数のコンシューマーグループ</strong>
</p>
<div class="paragraph">
<p>最後に、異なるアプリケーションは、異なる <strong>コンシューマーグループ ID</strong> を使用して同じトピックに個別にサブスクライブすることができます。たとえば、<em>orders</em> というトピックに公開されたメッセージは、2 つのコンシューマーアプリケーションで個別に消費することができます。1 つは <code>mp.messaging.incoming.orders.group.id=invoicing</code> で、もう 1 つは <code>mp.messaging.incoming.orders.group.id=shipping</code> で消費されます。したがって、さまざまなコンシューマーグループが、メッセージの消費要件に応じて独立してスケーリングすることができます。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/kafka-two-app-two-consumer-groups.png" alt="Architecture" width="60%">
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一般的なビジネス要件は、Kafka レコードを順番に消費して処理することです。Kafka ブローカーは、トピック内ではなく、パーティション内のレコードの順序を保持します。したがって、レコードがトピック内でどのようにパーティショニングされるかを考えることが重要となります。デフォルトのパーティショナーは、レコードキーハッシュを使用してレコードのパーティションを計算するか、キーが定義されていない場合は、バッチまたはレコードごとにランダムにパーティションを選択します。</p>
</div>
<div class="paragraph">
<p>通常の操作中、Kafka コンシューマーは、割り当てられた各パーティション内のレコードの順序を保持します。
SmallRye Reactive Messaging は、 <code>@Blocking(ordered = false)</code> が使用されていない限り、この順序を処理のために保持します (<a href="#blocking-processing">ブロッキング処理</a> を参照)。</p>
</div>
<div class="paragraph">
<p>コンシューマーのリバランスにより、Kafka コンシューマーは、単一レコードの少なくとも 1 回の処理のみを保証します。つまり、コミットされていないレコードは、コンシューマーによって再度処理 <em>できます</em> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="consumer-rebalance-listener"><a class="anchor" href="#consumer-rebalance-listener"></a>4.5.1. コンシューマーリバランスリスナー</h4>
<div class="paragraph">
<p>コンシューマーグループ内では、新しいグループメンバーが到着し、古いメンバーが離れると、パーティションが再割り当てされ、各メンバーにパーティションが比例配分されます。これは、グループのリバランスとして知られています。オフセットコミットとパーティション割り当てを自分で処理するために、コンシューマーリバランスリスナーを提供することができます。これを実現するには、 <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> インターフェイスを実装し、 <code>@Idenfier</code> 修飾子を使用して CDI Bean として公開します。一般的な使用例として、オフセットを別のデータストアに格納して exactly-once セマンティックを実装したり、特定のオフセットで処理を開始したりすることが挙げられます。</p>
</div>
<div class="paragraph">
<p>リスナーは、コンシューマートピック/パーティションの割り当てが変更されるたびに呼び出されます。たとえば、アプリケーションが起動すると、コンシューマーに関連付けられたトピック/パーティションの初期セットを使用して <code>partitionsAssigned</code> コールバックが呼び出されます。後でこのセットが変更された場合、 <code>partitionsRevoked</code> および <code>partitionsAssigned</code> コールバックが再度呼び出されるため、カスタムロジックを実装することができます。</p>
</div>
<div class="paragraph">
<p>リバランスリスナーメソッドは Kafka ポーリングスレッドから呼び出され、完了するまで呼び出し元のスレッドを<strong>ブロック</strong>することに注意してください。これは、リバランスプロトコルに同期バリアがあり、リバランスリスナーで非同期コードを使用すると、同期バリアの後に実行される可能性があるためです。</p>
</div>
<div class="paragraph">
<p>トピック/パーティションがコンシューマーから割り当てられるか取り消されると、メッセージの配信が一時停止され、リバランスが完了すると再開されます。</p>
</div>
<div class="paragraph">
<p>リバランスリスナーがユーザーに代わってオフセットコミットを処理する場合 ( <code>NONE</code> コミットストラテジーを使用)、リバランスリスナーは partitionsRevoked コールバックでオフセットを同期的にコミットする必要があります。また、アプリケーションが停止したときに同じロジックを適用することをお勧めします。</p>
</div>
<div class="paragraph">
<p>Apache Kafka の <code>ConsumerRebalanceListener</code> とは異なり、 <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> メソッドは、Kafka コンシューマーとトピック/パーティションのセットを渡します。</p>
</div>
<div class="paragraph">
<p>以下の例では、最大 10 分前 (またはオフセット 0) からのメッセージで常に開始するコンシューマーを設定します。まず、 <code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> を実装し、 <code>io.smallrye.common.annotation.Identifier</code> でアノテーションが付けられた Bean を提供する必要があります。次に、この Bean を使用するようにインバウンドコネクターを設定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package inbound;

import io.smallrye.common.annotation.Identifier;
import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;
import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.OffsetAndTimestamp;
import org.apache.kafka.clients.consumer.TopicPartition;

import jakarta.enterprise.context.ApplicationScoped;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

@ApplicationScoped
@Identifier("rebalanced-example.rebalancer")
public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {

    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());

    /**
     * When receiving a list of partitions, will search for the earliest offset within 10 minutes
     * and seek the consumer to it.
     *
     * @param consumer   underlying consumer
     * @param partitions set of assigned topic partitions
     */
    @Override
    public void onPartitionsAssigned(Consumer&lt;?, ?&gt; consumer, Collection&lt;TopicPartition&gt; partitions) {
        long now = System.currentTimeMillis();
        long shouldStartAt = now - 600_000L; //10 minute ago

        Map&lt;TopicPartition, Long&gt; request = new HashMap&lt;&gt;();
        for (TopicPartition partition : partitions) {
            LOGGER.info("Assigned " + partition);
            request.put(partition, shouldStartAt);
        }
        Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsets = consumer.offsetsForTimes(request);
        for (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; position : offsets.entrySet()) {
            long target = position.getValue() == null ? 0L : position.getValue().offset();
            LOGGER.info("Seeking position " + target + " for " + position.getKey());
            consumer.seek(position.getKey(), target);
        }
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package inbound;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Message;

import jakarta.enterprise.context.ApplicationScoped;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

@ApplicationScoped
public class KafkaRebalancedConsumer {

    @Incoming("rebalanced-example")
    @Acknowledgment(Acknowledgment.Strategy.NONE)
    public CompletionStage&lt;Void&gt; consume(Message&lt;ConsumerRecord&lt;Integer, String&gt;&gt; message) {
        // We don't need to ACK messages because in this example,
        // we set offset during consumer rebalance
        return CompletableFuture.completedFuture(null);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供されたリスナーを使用するようにインバウンドコネクターを設定するには、コンシューマリバランスリスナーの識別子を設定します: <code>mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer</code></p>
</div>
<div class="paragraph">
<p>または、リスナーの名前をグループ ID と同じにします:</p>
</div>
<div class="paragraph">
<p><code>mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer</code></p>
</div>
<div class="paragraph">
<p>コンシューマーリバランスリスナーの名前の設定は、グループ ID の使用よりも優先されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-unique-consumer-groups"><a class="anchor" href="#using-unique-consumer-groups"></a>4.5.2. 一意のコンシューマーグループの活用</h4>
<div class="paragraph">
<p>あるトピックの (先頭からの) すべてのレコードを処理したい場合は、以下を実行してください。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>auto.offset.reset = earliest</code> の設定</p>
</li>
<li>
<p>他のアプリケーションで使用されていないコンシューマーグループへのコンシューマーの割り当て</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Quarkus は、実行のたびに変更される UUID を生成します (dev モードを含む)。したがって、他のコンシューマーがそれを使用していないことを確認すると、アプリケーションが起動するたびに新しい一意のグループ ID を受け取ることになります。</p>
</div>
<div class="paragraph">
<p>その生成された UUID をコンシューマーグループとして、以下のように使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.your-channel.auto.offset.reset=earliest
mp.messaging.incoming.your-channel.group.id=${quarkus.uuid}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>group.id</code> 属性が設定されていない場合、 <code>quarkus.application.name</code> 設定プロパティーがデフォルトになります。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="manual-topic-partition-assignment"><a class="anchor" href="#manual-topic-partition-assignment"></a>4.5.3. topic-partition の手動割り当て</h4>
<div class="paragraph">
<p><code>assign-seek</code> チャネル属性を使用すると、topic-partition を Kafka の着信チャネルに手動で割り当て、
オプションで指定したオフセットをシークしてレコードの消費を開始します。
<code>assign-seek</code> が使用されると、コンシューマーはトピックに動的にサブスクライブされることはなく、
代わりに記述されたパーティションが静的に割り当てられます。
手動で topic-partition のリバランスは行われないため、リバランスリスナーは呼び出されません。</p>
</div>
<div class="paragraph">
<p>この属性は、コンマで区切られた 3 つの文字のリストを受け取ります: <code>&lt;topic&gt;:&lt;partition&gt;:&lt;offset&gt;</code></p>
</div>
<div class="paragraph">
<p>たとえば、以下の設定は、</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.data.assign-seek=topic1:0:10, topic2:1:20</code></pre>
</div>
</div>
<div class="paragraph">
<p>コンシューマーを以下に割り当てます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>トピック 'topic1' のパーティション 0。初期位置をオフセット 10 に設定します。</p>
</li>
<li>
<p>トピック 'topic2' のパーティション 1。初期位置をオフセット 20 に設定します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>各トリプレットのトピック、パーティション、オフセットには、以下のようなバリエーションがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>トピックが省略された場合、設定されたトピックが使用されます。</p>
</li>
<li>
<p>オフセットが省略された場合、パーティションはコンシューマーに割り当てられますが、オフセットはシークされません。</p>
</li>
<li>
<p>オフセットが 0 の場合、topic-partition の先頭をシークします。</p>
</li>
<li>
<p>オフセットが -1 の場合、topic-partition の末尾をシークします。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="receiving-kafka-records-in-batches"><a class="anchor" href="#receiving-kafka-records-in-batches"></a>4.6. バッチでの Kafka レコードの受信</h3>
<div class="paragraph">
<p>デフォルトでは、着信メソッドは各 Kafka レコードを個別に受信します。内部的には、Kafka コンシューマークライアントはブローカーを絶えずポーリングし、 <code>ConsumerRecords</code> コンテナー内に表示されるレコードをバッチで受信します。</p>
</div>
<div class="paragraph">
<p><strong>バッチ</strong> モードでは、アプリケーションは、コンシューマー <strong>ポーリング</strong> から返されたすべてのレコードを一度に受信できます。</p>
</div>
<div class="paragraph">
<p>これを実現するには、すべてのデータを受信するための互換性のあるコンテナータイプを指定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
public void consume(List&lt;Double&gt; prices) {
    for (double price : prices) {
        // process price
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>受信メソッドは、 <code>Message&lt;List&lt;Payload&gt;&gt;</code>、 <code>Message&lt;ConsumerRecords&lt;Key, Payload&gt;&gt;</code>、 <code>ConsumerRecords&lt;Key, Payload&gt;</code> タイプも受け取ることができます。
これらは、オフセットやタイムスタンプなどのレコードの詳細情報へのアクセスを提供します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("prices")
public CompletionStage&lt;Void&gt; consumeMessage(Message&lt;ConsumerRecords&lt;String, Double&gt;&gt; records) {
    for (ConsumerRecord&lt;String, Double&gt; record : records.getPayload()) {
        String payload = record.getPayload();
        String topic = record.getTopic();
        // process messages
    }
    // ack will commit the latest offsets (per partition) of the batch.
    return records.ack();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>着信レコードバッチの処理が成功すると、バッチ内で受信した各パーティションの最新のオフセットがコミットされることに注意してください。設定されたコミットストラテジーは、これらのレコードにのみ適用されます。</p>
</div>
<div class="paragraph">
<p>逆に、処理が例外をスローした場合、すべてのメッセージは <em>nack</em> され、バッチ内のすべてのレコードにエラーストラテジーが適用されます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quarkus は、着信チャネルのバッチタイプを自動検出し、バッチ設定を自動的に設定します。 <code>mp.messaging.incoming.$channel.batch</code> プロパティーを使用して、バッチモードを明示的に設定できます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="stateful-processing-checkpointing"><a class="anchor" href="#stateful-processing-checkpointing"></a>4.7. チェックポイントによるステートフル処理</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>checkpoint</code> コミットストラテジーは実験的な API であり、将来変更される可能性があります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>SmallRye Reactive Messaging <code>checkpoint</code> コミットストラテジーは、コンシューマーアプリケーションがステートフルにメッセージを処理できるようにし、同時に Kafka コンシューマーのスケーラビリティーも尊重します。
<code>checkpoint</code> コミットストラテジーを使用する着信チャンネルは、コンシューマーのオフセットをリレーショナルデータベースや key-value ストアなどの外部 <a href="#state-stores">state store</a> に永続化します。
消費されたレコードの処理結果として、コンシューマーアプリケーションは Kafka コンシューマーに割り当てられた topic-partition ごとに内部ステートを蓄積できます。
このローカルステートは定期的にステートストアに永続化され、それを生成したレコードのオフセットに関連付けられます。</p>
</div>
<div class="paragraph">
<p>この戦略では、Kafkaブローカーにオフセットをコミットしないため、新しいパーティションがコンシューマーに割り当てられたとき、つまりコンシューマーの再起動やコンシューマーグループのインスタンスがスケールしたときに、コンシューマーは保存した状態で最新の <em>チェックポイント済み</em> オフセットから処理を再開する。</p>
</div>
<div class="paragraph">
<p><code>@Incoming</code> チャネルのコンシューマーコードは、 <code>CheckpointMetadata</code> API を通して処理状態を操作することができます。例えば、Kafkaトピックで受信した価格の移動平均を計算するコンシューマは、以下のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import java.util.concurrent.CompletionStage;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Message;

import io.smallrye.reactive.messaging.kafka.KafkaRecord;
import io.smallrye.reactive.messaging.kafka.commit.CheckpointMetadata;

@ApplicationScoped
public class MeanCheckpointConsumer {

    @Incoming("prices")
    public CompletionStage&lt;Void&gt; consume(Message&lt;Double&gt; record) {
        // Get the `CheckpointMetadata` from the incoming message
        CheckpointMetadata&lt;AveragePrice&gt; checkpoint = CheckpointMetadata.fromMessage(record);

        // `CheckpointMetadata` allows transforming the processing state
        // Applies the given function, starting from the value `0.0` when no previous state exists
        checkpoint.transform(new AveragePrice(), average -&gt; average.update(record.getPayload()), /* persistOnAck */ true);

        // `persistOnAck` flag set to true, ack will persist the processing state
        // associated with the latest offset (per partition).
        return record.ack();
    }

    static class AveragePrice {
        long count;
        double mean;

        AveragePrice update(double newPrice) {
            mean += ((newPrice - mean) / ++count);
            return this;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>transform</code> メソッドは、現在の状態に変換関数を適用し、変更された状態を生成して、チェックポイントのためにローカルに登録します。デフォルトでは、ローカルの状態は、 <code>auto.commit.interval.ms</code> で指定された期間、定期的にステートストアに永続化されます（デフォルト：5000）。 <code>persistOnAck</code> フラグが与えられている場合、最新の状態は、メッセージの確認応答時にステートストアにeagerlyに永続化されます。 <code>setNext</code> メソッドも同様に、最新の状態を直接設定するように動作します。</p>
</div>
<div class="paragraph">
<p>チェックポイントコミット戦略は、各トピックパーティションの処理状態が最後に永続化されたタイミングを追跡します。未解決の状態変更が <code>checkpoint.unsynced-state-max-age.ms</code> (デフォルト: 10000) の間、永続化できない場合、チャネルは不健全とマークされます。</p>
</div>
<div class="sect3">
<h4 id="state-stores"><a class="anchor" href="#state-stores"></a>4.7.1. ステートストア</h4>
<div class="paragraph">
<p>ステートストアの実装は、処理状態をどこに、どのように永続化するかを決定します。これは、 <code>mp.messaging.incoming.[channel-name].checkpoint.state-store</code> プロパティによって設定されます。ステートオブジェクトのシリアライゼーションは、ステートストアの実装に依存します。ステートストアにシリアライズを指示するためには、 <code>mp.messaging.incoming.[channel-name].checkpoint.state-type</code> プロパティを使用してステートオブジェクトのクラス名を設定する必要があります。</p>
</div>
<div class="paragraph">
<p>Quarkusは、以下のステートストアの実装を提供しています：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-redis</code>: 処理ステートを永続化するために <a href="redis-reference"><code>quarkus-redis-client</code></a> エクステンションを使用します。
Jackson は、処理ステートを Json でシリアル化するために使用されます。複雑なオブジェクトの場合は、オブジェクトのクラス名を使用して <code>checkpoint.state-type</code> プロパティーを設定する必要があります。
デフォルトでは、ステートストアはデフォルトの redis クライアントを使用しますが、<a href="redis-reference#default-and-named-clients">名前付きクライアント</a> を使用する場合は、 <code>mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name</code> プロパティーを使用してクライアント名を指定できます。
処理ステートは、キー命名スキーム <code>[consumer-group-id]:[topic]:[partition]</code> を使用して Redis に保存されます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例えば先のコードの設定は次のようになります：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.prices.group.id=prices-checkpoint
# ...
mp.messaging.incoming.prices.commit-strategy=checkpoint
mp.messaging.incoming.prices.checkpoint.state-store=quarkus-redis
mp.messaging.incoming.prices.checkpoint.state-type=org.acme.MeanCheckpointConsumer.AveragePrice
# ...
# if using a named redis client
mp.messaging.incoming.prices.checkpoint.quarkus-redis.client-name=my-redis
quarkus.redis.my-redis.hosts=redis://localhost:7000
quarkus.redis.my-redis.password=&lt;redis-pwd&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-hibernate-reactive</code>: <a href="hibernate-reactive"><code>quarkus-hibernate-reactive</code></a>エクステンションを使用して処理ステートを永続化します。
処理ステートオブジェクトは、Jakarta Persistence エンティティーであり、 <code>CheckpointEntity`クラスを拡張する必要があります。
このクラスは、コンシューマーグループ ID、トピック、パーティションが含まれるオブジェクト識別子を処理します。
したがって、エンティティーのクラス名は、 `checkpoint.state-type</code> プロパティーを使用して設定する必要があります。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例えば先のコードの設定は次のようになります：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.prices.group.id=prices-checkpoint
# ...
mp.messaging.incoming.prices.commit-strategy=checkpoint
mp.messaging.incoming.prices.checkpoint.state-store=quarkus-hibernate-reactive
mp.messaging.incoming.prices.checkpoint.state-type=org.acme.AveragePriceEntity</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AveragePriceEntity</code> は <code>CheckpointEntity</code> を拡張する Jakarta Persistence エンティティーであるため、以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.persistence.Entity;

import io.quarkus.smallrye.reactivemessaging.kafka.CheckpointEntity;

@Entity
public class AveragePriceEntity extends CheckpointEntity {
    public long count;
    public double mean;

    public AveragePriceEntity update(double newPrice) {
        mean += ((newPrice - mean) / ++count);
        return this;
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-hibernate-orm</code> : <a href="hibernate-orm.html"><code>quarkus-hibernate-orm</code></a> エクステンションを使用して、処理状態を永続化します。先ほどのステートストアと似ていますが、Hibernate Reactiveの代わりにHibernate ORMを使用します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>設定されている場合、チェックポイントの状態保存に名前付き <code>persistence-unit</code> を使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.prices.commit-strategy=checkpoint
mp.messaging.incoming.prices.checkpoint.state-store=quarkus-hibernate-orm
mp.messaging.incoming.prices.checkpoint.state-type=org.acme.AveragePriceEntity
mp.messaging.incoming.prices.checkpoint.quarkus-hibernate-orm.persistence-unit=prices
# ... Setup "prices" persistence unit
quarkus.datasource."prices".db-kind=postgresql
quarkus.datasource."prices".username=&lt;your username&gt;
quarkus.datasource."prices".password=&lt;your password&gt;
quarkus.datasource."prices".jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.hibernate-orm."prices".datasource=prices
quarkus.hibernate-orm."prices".packages=org.acme</code></pre>
</div>
</div>
<div class="paragraph">
<p>カスタムステートストアの実装方法については、 <a href="https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores">Implementing State Stores</a>を参照してください。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sending-messages-to-kafka"><a class="anchor" href="#sending-messages-to-kafka"></a>5. Kafka へのメッセージの送信</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafka コネクターの送信チャネルの設定は、受信の設定と似ています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.kafka.bootstrap.servers=kafka:9092 <i class="conum" data-value="1"></i><b>(1)</b>
mp.messaging.outgoing.prices-out.connector=smallrye-kafka <i class="conum" data-value="2"></i><b>(2)</b>
mp.messaging.outgoing.prices-out.topic=prices <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>プロダクションプロファイルのブローカーの場所を設定します。 <code>mp.messaging.outgoing.$channel.bootstrap.servers</code> プロパティーを使用して、グローバルまたはチャネルごとに設定できます。dev モードとテスト実行時には、<a href="#kafka-dev-services">Dev Services for Kafka</a> が自動的に Kafka ブローカーを開始します。指定しない場合、このプロパティーのデフォルトは <code>localhost:9092</code> になります。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>prices-out</code> チャネルを管理するためのコネクターを設定します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>デフォルトでは、トピック名はチャネル名と同じです。トピック属性を設定することで、それを上書きすることができます。</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>アプリケーション設定内では、チャネル名は一意です。したがって、同じトピックで着信チャネルと送信チャネルを設定する場合は、チャネルに異なる名前を付ける必要があります (たとえば、このガイドの例のように、 <code>mp.messaging.incoming.prices</code> と <code>mp.messaging.outgoing.prices-out</code> など)。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次に、アプリケーションはメッセージを生成し、それらを <code>prices-out</code> チャネルに公開できます。以下のスニペットのように、 <code>double</code> ペイロードを使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import jakarta.enterprise.context.ApplicationScoped;
import java.time.Duration;
import java.util.Random;

@ApplicationScoped
public class KafkaPriceProducer {

    private final Random random = new Random();

    @Outgoing("prices-out")
    public Multi&lt;Double&gt; generate() {
        // Build an infinite stream of random prices
        // It emits a price every second
        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))
            .map(x -&gt; random.nextDouble());
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>コードから直接 <code>@Incoming</code> や <code>@Outgoing</code> のアノテーションが付けられたメソッドを呼び出さないでください。これらはフレームワークによって呼び出されます。ユーザーコードがそれらを呼び出すと、期待された結果にはなりません。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>generate</code> メソッドは <code>Multi&lt;Double&gt;</code> を返すことに注意してください。これは、Reactive Streams <code>Publisher</code> インターフェイスを実装します。このパブリッシャーは、メッセージを生成し、設定された Kafka トピックに送信するためにフレームワークによって使用されます。</p>
</div>
<div class="paragraph">
<p>ペイロードを返す代わりに、 <code>io.smallrye.reactive.messaging.kafka.Record</code> を返して、キーと値のペアを送信できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Outgoing("out")
public Multi&lt;Record&lt;String, Double&gt;&gt; generate() {
    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))
        .map(x -&gt; Record.of("my-key", random.nextDouble()));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ペイロードを <code>org.eclipse.microprofile.reactive.messaging.Message</code> 内にラップして、書き込まれたレコードをより詳細に制御できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Outgoing("generated-price")
public Multi&lt;Message&lt;Double&gt;&gt; generate() {
    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))
            .map(x -&gt; Message.of(random.nextDouble())
                    .addMetadata(OutgoingKafkaRecordMetadata.&lt;String&gt;builder()
                            .withKey("my-key")
                            .withTopic("my-key-prices")
                            .withHeaders(new RecordHeaders().add("my-header", "value".getBytes()))
                            .build()));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OutgoingKafkaRecordMetadata</code> を使用すると、Kafka レコードのメタデータ属性 (<code>key</code>、 <code>topic</code>、 <code>partition</code>、 <code>timestamp</code> など) を設定できます。1 つの使用例は、メッセージの宛先トピックを動的に選択することです。この場合、アプリケーション設定ファイル内でトピックを設定する代わりに、送信メタデータを使用してトピックの名前を設定する必要があります。</p>
</div>
<div class="paragraph">
<p>Reactive Stream <code>Publisher</code> (<code>Multi</code> が <code>Publisher</code> の実装) を返すメソッドシグネチャー以外に、送信メソッドは単一のメッセージを返すこともできます。この場合、プロデューサーはこのメソッドをジェネレーターとして使用して、無限のストリームを作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Outgoing("prices-out") T generate(); // T excluding void

@Outgoing("prices-out") Message&lt;T&gt; generate();

@Outgoing("prices-out") Uni&lt;T&gt; generate();

@Outgoing("prices-out") Uni&lt;Message&lt;T&gt;&gt; generate();

@Outgoing("prices-out") CompletionStage&lt;T&gt; generate();

@Outgoing("prices-out") CompletionStage&lt;Message&lt;T&gt;&gt; generate();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="sending-messages-with-emitter"><a class="anchor" href="#sending-messages-with-emitter"></a>5.1. Emitter を使ったメッセージの送信</h3>
<div class="paragraph">
<p>時には、命令的な方法でメッセージを送ることが必要になる場合もあります。</p>
</div>
<div class="paragraph">
<p>たとえば、REST エンドポイント内で POST リクエストを受信した際に、ストリームにメッセージを送信する必要があるとします。この場合、メソッドにパラメーターがあるため、 <code>@Outgoing</code> を使用することはできません。</p>
</div>
<div class="paragraph">
<p>この場合には <code>Emitter</code> が利用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.core.MediaType;

@Path("/prices")
public class PriceResource {

    @Inject
    @Channel("price-create")
    Emitter&lt;Double&gt; priceEmitter;

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        CompletionStage&lt;Void&gt; ack = priceEmitter.send(price);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ペイロードを送信すると、メッセージが確認されたときに完了する <code>CompletionStage</code> が返されます。メッセージの送信が失敗した場合、nack の理由を伴って例外扱いで <code>CompletionStage</code> が完了します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Emitter</code> の設定は、 <code>@Incoming</code> と <code>@Outgoing</code> で使用される他のストリーム設定と同じ方法で行われます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Emitter</code> を使用すると、命令型コードから Reactive Messaging にメッセージを送信します。これらのメッセージは送信されるまでキューに保存されます。Kafka プロデューサークライアントが Kafka に送信しようとするメッセージに対応できない場合、このキューはメモリを大量に消費し、メモリ不足になる可能性があります。 <code>@OnOverflow</code> を使用して、バックプレッシャーストラテジーを設定することができます。これにより、キューのサイズ（デフォルトは 256）およびバッファーサイズに達したときに適用するストラテジーを設定できます。利用可能なストラテジーは、 <code>DROP</code>、 <code>LATEST</code>、 <code>FAIL</code>、 <code>BUFFER</code>、 <code>UNBOUNDED_BUFFER</code> および <code>NONE</code> です。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Emitter</code> API を使用すると、 <code>Message&lt;T&gt;</code> 内に送信ペイロードをカプセル化することもできます。前出の例のように、 <code>Message</code> では、ack/nack のケースを異なる方法で処理することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.concurrent.CompletableFuture;
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.core.MediaType;

@Path("/prices")
public class PriceResource {

    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(Message.of(price)
            .withAck(() -&gt; {
                // Called when the message is acked
                return CompletableFuture.completedFuture(null);
            })
            .withNack(throwable -&gt; {
                // Called when the message is nacked
                return CompletableFuture.completedFuture(null);
            }));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reactive Stream API を使いたい場合は、 <code>send</code> メソッドから <code>Uni&lt;Void&gt;</code> を返す <code>MutinyEmitter</code> を使用することができます。これにより、Mutiny API を使用してダウンストリームのメッセージとエラーを処理することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.eclipse.microprofile.reactive.messaging.Channel;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.core.MediaType;

import io.smallrye.reactive.messaging.MutinyEmitter;

@Path("/prices")
public class PriceResource {

    @Inject
    @Channel("price-create")
    MutinyEmitter&lt;Double&gt; priceEmitter;

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public Uni&lt;String&gt; addPrice(Double price) {
        return quoteRequestEmitter.send(price)
                .map(x -&gt; "ok")
                .onFailure().recoverWithItem("ko");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sendAndAwait</code> メソッドを使用して、イベントをエミッターに送信することをブロックすることもできます。受信者がイベントを ack または nack したときのみ、このメソッドから戻ります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">非推奨</div>
<div class="paragraph">
<p><code>io.smallrye.reactive.messaging.annotations.Emitter</code>、 <code>io.smallrye.reactive.messaging.annotations.Channel</code>、 <code>io.smallrye.reactive.messaging.annotations.OnOverflow</code> クラスは現在非推奨となっており、以下のように置き換えられています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.eclipse.microprofile.reactive.messaging.Emitter</code></p>
</li>
<li>
<p><code>org.eclipse.microprofile.reactive.messaging.Channel</code></p>
</li>
<li>
<p><code>org.eclipse.microprofile.reactive.messaging.OnOverflow</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>新しい <code>Emitter.send</code> メソッドは、生成されたメッセージが確認されると、 <code>CompletionStage</code> の完了を返します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">非推奨</div>
<div class="paragraph">
<p>MutinyEmitter#send(Message msg)` メソッドは非推奨となり、以下のメソッドが <code>Message</code> を受信して発信するようになりました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;M extends Message&lt;? extends T&gt;&gt; Uni&lt;Void&gt; sendMessage(M msg)</code></p>
</li>
<li>
<p><code>&lt;M extends Message&lt;? extends T&gt;&gt; void sendMessageAndAwait(M msg)</code></p>
</li>
<li>
<p><code>&lt;M extends Message&lt;? extends T&gt;&gt; Cancellable sendMessageAndForget(M msg)</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Emitter</code> の使用方法の詳細については、 <a href="https://smallrye.io/smallrye-reactive-messaging/latest/concepts/emitter/">SmallRye Reactive Messaging – Emitters and Channels</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="write-acknowledgement"><a class="anchor" href="#write-acknowledgement"></a>5.2. 確認応答の書き込み</h3>
<div class="paragraph">
<p>Kafka ブローカーがレコードを受信すると、設定に応じてその確認応答に時間がかかることがあります。また、書き込めないレコードをインメモリーに保存します。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、コネクターは Kafka がレコードを確認応答するのを待ち、処理を続行します (受信したメッセージの確認応答)。これを無効にするには、 <code>waitForWriteCompletion</code> 属性を <code>false</code> に設定します。</p>
</div>
<div class="paragraph">
<p><code>acks</code> 属性は、レコードの確認応答に大きく影響することに注意してください。</p>
</div>
<div class="paragraph">
<p>レコードを書き込めない場合は、メッセージは nack になります。</p>
</div>
</div>
<div class="sect2">
<h3 id="backpressure"><a class="anchor" href="#backpressure"></a>5.3. バックプレッシャー</h3>
<div class="paragraph">
<p>Kafka アウトバウンドコネクターはバックプレッシャーを処理し、Kafka ブローカーへの書き込みを待機しているインフライトメッセージの数を監視します。インフライトメッセージの数は、 <code>max-inflight-messages</code> 属性を使用して設定され、デフォルトは 1024 になります。</p>
</div>
<div class="paragraph">
<p>コネクターは、その量のメッセージのみを同時に送信します。少なくとも 1 つのインフライトメッセージがブローカーによって確認応答されるまで、他のメッセージは送信されません。次に、ブローカーのインフライトメッセージの 1 つが確認応答されると、コネクターは Kafka に新しいメッセージを書き込みます。それに応じて、Kafka の <code>batch.size</code> と <code>linger.ms</code> を設定してください。</p>
</div>
<div class="paragraph">
<p><code>max-inflight-messages</code> を <code>0</code> に設定することで、インフライトメッセージの制限を解除することもできます。ただし、リクエスト数が <code>max.in.flight.requests.per.connection</code> に達すると、Kafka プロデューサーがブロックする可能性があることに注意してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="retrying-message-dispatch"><a class="anchor" href="#retrying-message-dispatch"></a>5.4. メッセージディスパッチの再試行</h3>
<div class="paragraph">
<p>Kafka プロデューサーがサーバーからエラーを受信した場合、それが一時的な回復可能なエラーである場合、クライアントはメッセージのバッチの送信を再試行します。この動作は、 <code>retries</code> および <code>retry.backoff.ms</code> パラメーターによって制御されます。これに加えて、SmallRye Reactive Messaging は、 <code>retries</code> および <code>delivery.timeout.ms</code> パラメーターに応じて、回復可能なエラーで個々のメッセージを再試行します。</p>
</div>
<div class="paragraph">
<p>信頼性の高いシステムにおいては再試行するのがベストプラクティスですが、 <code>max.in.flight.requests.per.connection</code> パラメーターのデフォルトは <code>5</code> で、これはメッセージの順序が保証されていないことを意味する点に注意してください。使用例でメッセージの順序が必須である場合、 <code>max.in.flight.requests.per.connection</code> を <code>1</code> に設定すると、一度に送信されるメッセージのバッチが 1 つになり、その分プロデューサーのスループットが制限されることになります。</p>
</div>
<div class="paragraph">
<p>エラーの処理に再試行メカニズムを適用する場合は、 <a href="#処理のリトライ">[処理のリトライ]</a> のセクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="handling-serialization-failures"><a class="anchor" href="#handling-serialization-failures"></a>5.5. シリアライゼーション失敗時の処理</h3>
<div class="paragraph">
<p>Kafka プロデューサーの場合、クライアントのシリアライゼーションのエラーは回復できないため、メッセージディスパッチは再試行されません。このような場合、シリアライザーのエラーストラテジーを適用する必要があるかもしれません。これを実現するには、 <code>SerializationFailureHandler&lt;T&gt;</code> インターフェイスを実装する Bean を作成する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@Identifier("failure-fallback") // Set the name of the failure handler
public class MySerializationFailureHandler
    implements SerializationFailureHandler&lt;JsonObject&gt; { // Specify the expected type

    @Override
    public byte[] decorateSerialization(Uni&lt;byte[]&gt; serialization, String topic, boolean isKey,
        String serializer, Object data, Headers headers) {
        return serialization
                    .onFailure().retry().atMost(3)
                    .await().indefinitely();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このエラーハンドラーを使用するには、Bean を <code>@Identifier</code> 修飾子で公開し、コネクター設定で属性 <code>mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler</code> を指定する必要があります (キーまたは値のデシリアライザー用)。</p>
</div>
<div class="paragraph">
<p>ハンドラーは、 <code>Uni&lt;byte[]&gt;</code> として表されるアクションを含むシリアライゼーションの詳細とともに呼び出されます。メソッドは結果を待機し、シリアライズされたバイト配列を返す必要があることに注意してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="in-memory-channels"><a class="anchor" href="#in-memory-channels"></a>5.6. インメモリーチャンネル</h3>
<div class="paragraph">
<p>ユースケースによっては、メッセージングパターンを使って同じアプリケーション内でメッセージを転送することが便利な場合があります。Kafka のようなメッセージングバックエンドにチャネルを接続しない場合、すべてがインメモリーで行われ、ストリームはメソッドをチェーンすることで作成されます。各チェーンは依然としてリアクティブストリームであり、バックプレッシャープロトコルが適用されます。</p>
</div>
<div class="paragraph">
<p>フレームワークは、プロデューサー/コンシューマーチェーンが完全であることを確認します。つまり、アプリケーションがメッセージをインメモリーチャネルに書き込む場合 (<code>@Outgoing</code> のみを持つメソッド、または <code>Emitter</code> を使用)、アプリケーション内からメッセージを消費する必要もあります (<code>@Incoming</code> のみを持つメソッド、またはアンマネージドストリームを使用)。</p>
</div>
</div>
<div class="sect2">
<h3 id="broadcasting-messages-on-multiple-consumers"><a class="anchor" href="#broadcasting-messages-on-multiple-consumers"></a>5.7. 複数のコンシューマーでのメッセージのブロードキャスト</h3>
<div class="paragraph">
<p>デフォルトでは、 <code>@Incoming</code> メソッドまたは <code>@Channel</code> リアクティブストリームを使用して、チャネルを単一のコンシューマーにリンクすることができます。アプリケーションの起動時に、チャネルが検証され、単一のコンシューマーとプロデューサーを持つコンシューマーとプロデューサーのチェーンが形成されます。この動作は、チャネルで <code>mp.messaging.$channel.broadcast=true</code> を設定することで、オーバーライドすることができます。</p>
</div>
<div class="paragraph">
<p>インメモリーチャネルの場合、 <code>@Broadcast</code> アノテーションを <code>@Outgoing</code> メソッドで使用できます。以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Random;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import io.smallrye.reactive.messaging.annotations.Broadcast;

@ApplicationScoped
public class MultipleConsumer {

    private final Random random = new Random();

    @Outgoing("in-memory-channel")
    @Broadcast
    double generate() {
        return random.nextDouble();
    }

    @Incoming("in-memory-channel")
    void consumeAndLog(double price) {
        System.out.println(price);
    }

    @Incoming("in-memory-channel")
    @Outgoing("prices2")
    double consumeAndSend(double price) {
        return price;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>反対に、 <code>mp.messaging.incoming.$channel.merge=true</code> を設定することにより、同じチャネル上の複数のプロデューサーをマージすることができます。 <code>@Incoming</code> メソッドでは、 <code>@Merge</code> アノテーションを使用して複数のチャネルをマージする方法を制御できます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>送信メソッドや処理メソッドで <code>@Outgoing</code> アノテーションを繰り返すことで、複数の送信チャネルにメッセージをディスパッチする別の方法が可能になる：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Random;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.reactive.messaging.Outgoing;

@ApplicationScoped
public class MultipleProducers {

    private final Random random = new Random();

    @Outgoing("generated")
    @Outgoing("generated-2")
    double priceBroadcast() {
        return random.nextDouble();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前の例では、生成された価格は両方の送信チャネルにブロードキャストされます。
次の例では、 <code>Targeted</code> コンテナーオブジェクトを使用して、複数の送信チャネルにメッセージを選択的に送信します。
このオブジェクトは、キーをチャンネル名、値をメッセージのペイロードとして含んでいます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import io.smallrye.reactive.messaging.Targeted;

@ApplicationScoped
public class TargetedProducers {

    @Incoming("in")
    @Outgoing("out1")
    @Outgoing("out2")
    @Outgoing("out3")
    public Targeted process(double price) {
        Targeted targeted = Targeted.of("out1", "Price: " + price,
                "out2", "Quote: " + price);
        if (price &gt; 90.0) {
            return targeted.with("out3", price);
        }
        return targeted;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#serialization-autodetection">the auto-detection for Kafka serializers</a> は、 <code>Targeted</code> を使用したシグネチャーでは機能しません。</p>
</div>
<div class="paragraph">
<p>複数出庫の詳細については、 <a href="http://smallrye.io/smallrye-reactive-messaging/4.10.0/concepts/outgoings/">SmallRye Reactive Messaging のドキュメント</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="kafka-transactions"><a class="anchor" href="#kafka-transactions"></a>5.8. Kafka トランザクション</h3>
<div class="paragraph">
<p>Kafka トランザクションにより、複数の Kafka トピックおよびパーティションへのアトミックな書き込みが可能になります。Kafka コネクターは、トランザクション内に Kafka レコードを書き込むための <code>KafkaTransactions</code> カスタムエミッターを提供します。これは、通常のエミッター <code>@Channel</code> として注入することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.reactive.messaging.Channel;

import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.KafkaRecord;
import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;

@ApplicationScoped
public class KafkaTransactionalProducer {

    @Channel("tx-out-example")
    KafkaTransactions&lt;String&gt; txProducer;

    public Uni&lt;Void&gt; emitInTransaction() {
        return txProducer.withTransaction(emitter -&gt; {
            emitter.send(KafkaRecord.of(1, "a"));
            emitter.send(KafkaRecord.of(2, "b"));
            emitter.send(KafkaRecord.of(3, "c"));
            return Uni.createFrom().voidItem();
        });
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>withTransaction</code> メソッドに指定された関数は、レコードの生成用に <code>TransactionalEmitter</code> を受け取り、トランザクションの結果を提供する <code>Uni</code> を返します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>処理が正常に完了すると、プロデューサーはフラッシュされ、トランザクションはコミットされます。</p>
</li>
<li>
<p>処理が例外を投げるか、失敗した <code>Uni</code> を返すか、あるいは <code>TransactionalEmitter</code> に中止のマークを付けると、トランザクションは中止されます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kafka トランザクションプロデューサーでは、 <code>acks=all</code> クライアントプロパティーと <code>transactional.id</code> の一意の ID を設定する必要があります。これは、 <code>enable.idempotence=true</code> を意味します。Quarkus が送信チャネルの <code>KafkaTransactions</code> の使用を検出すると、チャンネルでこれらのプロパティーを設定し、 <code>transactional.id</code> プロパティーに <code>"${quarkus.application.name}-${channelName}"</code> のデフォルト値を提供します。</p>
</div>
<div class="paragraph">
<p>本番環境で使用する場合、 <code>transactional.id</code> はすべてのアプリケーションインスタンスで一意である必要があることに注意してください。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常のメッセージエミッターは <code>send</code> メソッドへの同時呼び出しをサポートし、結果として Kafka に書き込まれる送信メッセージをキューに入れますが、 <code>KafkaTransactions</code> エミッターは一度に 1 つのトランザクションのみをサポートします。トランザクションは、 <code>withTransaction</code> の呼び出しから、返された <code>Uni</code> が成功または失敗するまで進行中であると見なされます。トランザクションの進行中に、指定された関数内のネストされたものを含む <code>withTransaction</code> への後続の呼び出しは、 <code>IllegalStateException</code> をスローします。</p>
</div>
<div class="paragraph">
<p>Reactive Messaging では、 <code>@Blocking(ordered = false)</code> が使用されていない限り、処理メソッドの実行はすでにシリアライズされていることに注意してください。
たとえば、REST エンドポイントから <code>withTransaction</code> を同時に呼び出すことができる場合は、実行の同時実行数を制限することが推奨されます。
これは、<a href="smallrye-fault-tolerance"><em>Microprofile Fault Tolerance</em></a> の <code>@Bulkhead</code> アノテーションを使用して実行できます。</p>
</div>
<div class="paragraph">
<p>使用例については、<a href="#chaining-kafka-transactions-with-hibernate-reactive-transactions">Kafka トランザクションと Hibernate Reactive トランザクションとのチェーン</a> を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="transaction-aware-consumers"><a class="anchor" href="#transaction-aware-consumers"></a>5.8.1. トランザクションを意識したコンシューマー</h4>
<div class="paragraph">
<p>Kafka トランザクション内で書き込まれ、コミットされたレコードのみを使用する場合は、着信チャネルの <code>isolation.level</code> プロパティーを以下のように設定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.prices-in.isolation.level=read_committed</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-request-reply"><a class="anchor" href="#kafka-request-reply"></a>6. Kafka request-reply</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafka request-reply パターンを使用すると、リクエストレコードを Kafka トピックに公開し、最初のリクエストに応答する返信レコードを待機できます。
Kafka コネクターは、Kafka 送信チャネルの request-reply パターンのリクエスター (またはクライアント) を実装する <code>KafkaRequestReply</code> カスタムエミッターを提供します。</p>
</div>
<div class="paragraph">
<p>通常のエミッター <code>@Channel</code> として注入できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.reactive.messaging.Channel;

import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.reply.KafkaRequestReply;

@ApplicationScoped
@Path("/kafka")
public class KafkaRequestReplyEmitter {

    @Channel("request-reply")
    KafkaRequestReply&lt;Integer, String&gt; requestReply;

    @POST
    @Path("/req-rep")
    @Produces(MediaType.TEXT_PLAIN)
    public Uni&lt;String&gt; post(Integer request) {
        return requestReply.request(request);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>リクエストメソッドは、レコードを送信チャネルの設定されたターゲットトピックに公開し、
返信レコードを取得するために返信トピック (デフォルトではターゲットトピックに <code>-replies</code> サフィックスを付けたもの) をポーリングします。
返信が受信されると、返された <code>Uni</code> はレコードの値で完了します。
リクエスト送信操作は、<strong>コレレーション ID</strong> を生成し、ヘッダー (デフォルトでは <code>REPLY_CORRELATION_ID</code>) を設定します。これは、返信レコードで返送されることが予想されます。</p>
</div>
<div class="paragraph">
<p>リプライヤーは、Reactive Messaging プロセッサーを使用して実装できます (<a href="#processing-messages">メッセージの処理</a> を参照)。</p>
</div>
<div class="paragraph">
<p>Kafka Request Reply 機能と高度な設定オプションの詳細は、
<a href="https://smallrye.io/smallrye-reactive-messaging/latest/kafka/request-reply/">SmallRye Reactive Messaging ドキュメント</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="processing-messages"><a class="anchor" href="#processing-messages"></a>7. メッセージの処理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>多くの場合、データをストリーミングするアプリケーションは、トピックからいくつかのイベントを消費し、それらを処理して、結果を別のトピックに公開する必要があります。プロセッサーメソッドは、 <code>@Incoming</code> アノテーションと <code>@Outgoing</code> アノテーションの両方を使用して簡単に実装することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class PriceProcessor {

    private static final double CONVERSION_RATE = 0.88;

    @Incoming("price-in")
    @Outgoing("price-out")
    public double process(double price) {
        return price * CONVERSION_RATE;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>process</code> メソッドのパラメーターは着信メッセージのペイロードですが、戻り値は送信メッセージのペイロードとして使用されます。 <code>Message&lt;T&gt;</code> や <code>Record&lt;K, V&gt;</code> など、前述のパラメーターとリターンタイプのシグネチャーもサポートされています。</p>
</div>
<div class="paragraph">
<p>リアクティブストリーム <code>Multi&lt;T&gt;</code> タイプを消費して返すことにより、非同期ストリーム処理を適用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import io.smallrye.mutiny.Multi;

@ApplicationScoped
public class PriceProcessor {

    private static final double CONVERSION_RATE = 0.88;

    @Incoming("price-in")
    @Outgoing("price-out")
    public Multi&lt;Double&gt; process(Multi&lt;Integer&gt; prices) {
        return prices.filter(p -&gt; p &gt; 100).map(p -&gt; p * CONVERSION_RATE);
    }

}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="propagating-record-key"><a class="anchor" href="#propagating-record-key"></a>7.1. レコードキーの伝播</h3>
<div class="paragraph">
<p>メッセージを処理するときに、着信レコードキーを送信レコードに伝播できます。</p>
</div>
<div class="paragraph">
<p><code>mp.messaging.outgoing.$channel.propagate-record-key=true</code> の設定で有効にすると、レコードキーの伝播が受信レコードと同じ <em>key</em> を持つ送信レコードを生成します。</p>
</div>
<div class="paragraph">
<p>送信レコードにすでに <em>key</em> が含まれている場合、着信レコードキーによって <strong>オーバーライドされません</strong> 。着信レコードに <em>null</em> キーがある場合は、 <code>mp.messaging.outgoing.$channel.key</code> プロパティーが使用されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="exactly-once-processing"><a class="anchor" href="#exactly-once-processing"></a>7.2. Exactly-Once 処理</h3>
<div class="paragraph">
<p>Kafka Transactions を使用すると、生成されたメッセージとともに、トランザクション内のコンシューマーオフセットを管理できます。これにより、コンシューマーとトランザクションプロデューサーを <em>consume-transform-produce</em> パターンでカップリングすることができます。これは <strong>exactly-once 処理</strong> としても知られています。</p>
</div>
<div class="paragraph">
<p><code>KafkaTransactions</code> カスタムエミッターは、トランザクション内の着信 Kafka メッセージに exactly-once 処理を適用する方法を提供します。</p>
</div>
<div class="paragraph">
<p>次の例には、トランザクション内の Kafka レコードのバッチが含まれています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Message;
import org.eclipse.microprofile.reactive.messaging.OnOverflow;

import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.KafkaRecord;
import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;

@ApplicationScoped
public class KafkaExactlyOnceProcessor {

    @Channel("prices-out")
    @OnOverflow(value = OnOverflow.Strategy.BUFFER, bufferSize = 500) <i class="conum" data-value="3"></i><b>(3)</b>
    KafkaTransactions&lt;Integer&gt; txProducer;

    @Incoming("prices-in")
    public Uni&lt;Void&gt; emitInTransaction(Message&lt;ConsumerRecords&lt;String, Integer&gt;&gt; batch) { <i class="conum" data-value="1"></i><b>(1)</b>
        return txProducer.withTransactionAndAck(batch, emitter -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            for (ConsumerRecord&lt;String, Integer&gt; record : batch.getPayload()) {
                emitter.send(KafkaRecord.of(record.key(), record.value() + 1)); <i class="conum" data-value="3"></i><b>(3)</b>
            }
            return Uni.createFrom().voidItem();
        });
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>バッチ消費モードと一緒に exactly-once 処理を使用することが推奨されます。単一の Kafka メッセージで使用することは可能ですが、パフォーマンスに大きな影響を与えることになります。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>消費されたメッセージは、オフセットコミットとメッセージ ack を処理するために、 <code>KafkaTransactions#withTransactionAndAck</code> に渡されます。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>send</code> メソッドは、ブローカーからの送信受信を待たずに、トランザクション内で Kafka にレコードを書き込みます。Kafka への書き込みが保留されているメッセージはバッファーリングされ、トランザクションをコミットする前にフラッシュされます。したがって、十分なメッセージ (たとえば、バッチで返されるレコードの最大量である <code>max.poll.records</code>) に適合するように、 <code>@OnOverflow</code> <code>bufferSize</code> を設定することを推奨します。
<div class="ulist">
<ul>
<li>
<p><em>トランザクションをコミットする前に</em> 処理が正常に完了すると、指定されたバッチメッセージのトピックパーティションオフセットがトランザクションにコミットされます。</p>
</li>
<li>
<p><em>トランザクションを中止した後に</em> 、処理を中止する必要がある場合、コンシューマーの位置は最後にコミットされたオフセットにリセットされ、そのオフセットから消費を効果的に再開します。トピックパーティションにコンシューマーオフセットがコミットされていない場合は、<em>オフセットリセットポリシーが <code>latest</code> であっても</em>、コンシューマーの位置はトピックパーティションの先頭にリセットされます。</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>exactly-once 処理を使用する場合、消費されたメッセージオフセットコミットはトランザクションによって処理されるため、アプリケーションは他の方法でオフセットをコミットしてはいけません。コンシューマーには <code>enable.auto.commit=false</code> (デフォルト) があり、明示的に <code>commit-strategy=ignore</code> を設定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.prices-in.commit-strategy=ignore
mp.messaging.incoming.prices-in.failure-strategy=ignore</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="error-handling-for-the-exactly-once-processing"><a class="anchor" href="#error-handling-for-the-exactly-once-processing"></a>7.2.1. exactly-once 処理のエラー処理</h4>
<div class="paragraph">
<p><code>KafkaTransactions#withTransaction</code> から返された <code>Uni</code> は、トランザクションが失敗して中止された場合に失敗します。アプリケーションはエラーケースの処理を選択できますが、失敗した <code>Uni</code> が <code>@Incoming</code> メソッドから返された場合、着信チャネルは事実上失敗し、リアクティブストリームを停止します。</p>
</div>
<div class="paragraph">
<p><code>KafkaTransactions#withTransactionAndAck</code> メソッドはメッセージを確認して nack しますが、失敗した <code>Uni</code> を <strong>返しません</strong> 。nack されたメッセージは、着信チャネルのエラーストラテジーによって処理されます (<a href="#error-handling">エラー処理戦略</a> を参照)。 <code>failure-strategy=ignore</code> を設定すると、Kafka コンシューマーは最後にコミットされたオフセットにリセットされ、そこから消費が再開されます。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-bare-clients"><a class="anchor" href="#kafka-bare-clients"></a>8. Kafka クライアントへの直接アクセス</h2>
<div class="sectionbody">
<div class="paragraph">
<p>まれに、基盤となる Kafka クライアントにアクセスしなければならない場合があります。 <code>KafkaClientService</code> は、 <code>Producer</code> と <code>Consumer</code> へのスレッドセーフなアクセスを提供します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.inject.Inject;

import org.apache.kafka.clients.producer.ProducerRecord;

import io.quarkus.runtime.StartupEvent;
import io.smallrye.reactive.messaging.kafka.KafkaClientService;
import io.smallrye.reactive.messaging.kafka.KafkaConsumer;
import io.smallrye.reactive.messaging.kafka.KafkaProducer;

@ApplicationScoped
public class PriceSender {

    @Inject
    KafkaClientService clientService;

    void onStartup(@Observes StartupEvent startupEvent) {
        KafkaProducer&lt;String, Double&gt; producer = clientService.getProducer("generated-price");
        producer.runOnSendingThread(client -&gt; client.send(new ProducerRecord&lt;&gt;("prices", 2.4)))
            .await().indefinitely();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>KafkaClientService</code> は実験的な API であり、将来変更される可能性があります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kafka 設定をアプリケーションに注入して、Kafka プロデューサー、コンシューマー、および管理クライアントを直接作成することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.common.annotation.Identifier;
import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.KafkaAdminClient;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Inject;
import java.util.HashMap;
import java.util.Map;

@ApplicationScoped
public class KafkaClients {

    @Inject
    @Identifier("default-kafka-broker")
    Map&lt;String, Object&gt; config;

    @Produces
    AdminClient getAdmin() {
        Map&lt;String, Object&gt; copy = new HashMap&lt;&gt;();
        for (Map.Entry&lt;String, Object&gt; entry : config.entrySet()) {
            if (AdminClientConfig.configNames().contains(entry.getKey())) {
                copy.put(entry.getKey(), entry.getValue());
            }
        }
        return KafkaAdminClient.create(copy);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>default-kafka-broker</code> 設定マップには、接頭辞 <code>kafka.</code> または <code>KAFKA_</code> が付いたすべてのアプリケーションプロパティーが含まれています。設定オプションの詳細については、<a href="#kafka-configuration-resolution">Kafka 設定の解決</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-serialization"><a class="anchor" href="#kafka-serialization"></a>9. JSON シリアライゼーション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus には、JSON Kafka メッセージを扱う機能が組み込まれています。</p>
</div>
<div class="paragraph">
<p>以下のように <code>Fruit</code> のデータクラスがあると想像してみてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Fruit {

    public String name;
    public int price;

    public Fruit() {
    }

    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、Kafka からメッセージを受信して、何らかの価格変換を行い、Kafka にメッセージを送り返すために使いたいと考えています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;

import jakarta.enterprise.context.ApplicationScoped;

/**
* A bean consuming data from the "fruit-in" channel and applying some price conversion.
* The result is pushed to the "fruit-out" channel.
*/
@ApplicationScoped
public class FruitProcessor {

    private static final double CONVERSION_RATE = 0.88;

    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そのためには、Jackson や JSON-B で JSON シリアライゼーションを設定する必要があります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
JSON シリアライゼーションが正しく設定されていれば、 <code>Publisher&lt;Fruit&gt;</code> や <code>Emitter&lt;Fruit&gt;</code> も利用できます。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="jackson-serialization"><a class="anchor" href="#jackson-serialization"></a>9.1. Jackson を介したシリアライズ</h3>
<div class="paragraph">
<p>Quarkus には、Jackson に基づく JSON シリアライゼーションとデシリアライゼーションのサポートが組み込まれています。また、シリアライザーとデシリアライザーを <a href="#serialization-generation">生成</a> してくれるため、何も設定する必要がありません。
生成が無効になっている場合は、以下で説明するように、提供されている <code>ObjectMapperSerializer</code> および <code>ObjectMapperDeserializer</code> を使用できます。</p>
</div>
<div class="paragraph">
<p>Jackson を介してすべてのデータオブジェクトをシリアライズするために使用できる既存の <code>ObjectMapperSerializer</code> があります。<a href="#serialization-autodetection">シリアライザー/デシリアライザーの自動検出</a> を使用する場合は、空のサブクラスを作成することができます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
デフォルトでは、 <code>ObjectMapperSerializer</code> は null を <code>"null"</code> 文字列としてシリアライズします。これは、null を <code>null</code> としてシリアライズする Kafka 設定プロパティー <code>json.serialize.null-as-null=true</code> を設定することでカスタマイズできます。これは、圧縮されたトピックを使用する場合に便利です。なぜなら、 <code>null</code> は、圧縮フェーズで削除されるメッセージを知るためのトゥームストーンとし使用されるからです。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>対応するデシリアライザークラスはサブクラス化する必要があります。そこで、 <code>ObjectMapperDeserializer</code> を拡張する <code>FruitDeserializer</code> を作成しましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.fruit.jackson;

import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;

public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer() {
        super(Fruit.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後に、Jackson シリアライザーとデシリアライザーを使用するようにチャンネルを設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer

# Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、Kafka メッセージには、 <code>Fruit</code> データオブジェクトの Jackson シリアライズ表現が含まれます。この場合、<a href="#serialization-autodetection">シリアライザー/デシリアライザーの自動検出</a> がデフォルトで有効になっているので、 <code>deserializer</code> の設定は必要ありません。</p>
</div>
<div class="paragraph">
<p>fruits のリストをデシリアライズしたい場合は、使用する一般的なコレクションを表す Jackson <code>TypeReference</code> を持つデシリアライザーを作成する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.fruit.jackson;

import java.util.List;
import com.fasterxml.jackson.core.type.TypeReference;
import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;

public class ListOfFruitDeserializer extends ObjectMapperDeserializer&lt;List&lt;Fruit&gt;&gt; {
    public ListOfFruitDeserializer() {
        super(new TypeReference&lt;List&lt;Fruit&gt;&gt;() {});
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jsonb-serialization"><a class="anchor" href="#jsonb-serialization"></a>9.2. JSON-B を介したシリアライズ</h3>
<div class="paragraph">
<p>まず、 <code>quarkus-jsonb</code> エクステンションをインクルードする必要があります。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-jsonb")</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON-B を介してすべてのデータオブジェクトをシリアライズするために使用できる既存の <code>JsonbSerializer</code> があります。<a href="#serialization-autodetection">シリアライザー/デシリアライザーの自動検出</a> を使用する場合は、空のサブクラスを作成することができます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
デフォルトでは、 <code>JsonbSerializer</code> は null を <code>"null"</code> 文字列としてシリアライズします。これは、null を <code>null</code> としてシリアライズする Kafka 設定プロパティー <code>json.serialize.null-as-null=true</code> を設定することでカスタマイズできます。これは、圧縮されたトピックを使用する場合に便利です。なぜなら、 <code>null</code> は、圧縮フェーズで削除されるメッセージを知るためのトゥームストーンとし使用されるからです。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>対応するデシリアライザークラスはサブクラス化する必要があります。そこで、一般的な <code>JsonbDeserializer</code> を拡張する <code>FruitDeserializer</code> を作成しましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.fruit.jsonb;

import io.quarkus.kafka.client.serialization.JsonbDeserializer;

public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer() {
        super(Fruit.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後に、JSON-B シリアライザーとデシリアライザーを使用するようにチャネルを設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer

# Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、Kafka のメッセージには、JSON-B でシリアライズされた <code>Fruit</code> データオブジェクトの表現が含まれます。</p>
</div>
<div class="paragraph">
<p>fruits のリストをデシリアライズしたい場合は、使用する一般的なコレクションを表す <code>Type</code> を持つデシリアライザーを作成する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.fruit.jsonb;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import io.quarkus.kafka.client.serialization.JsonbDeserializer;

public class ListOfFruitDeserializer extends JsonbDeserializer&lt;List&lt;Fruit&gt;&gt; {
    public ListOfFruitDeserializer() {
        super(new ArrayList&lt;MyEntity&gt;() {}.getClass().getGenericSuperclass());
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
各データオブジェクトにデシリアライザーを作成したくない場合は、 <code>io.vertx.core.json.JsonObject</code> にデシリアライズする汎用の <code>io.vertx.kafka.client.serialization.JsonObjectDeserializer</code> を使用することができます。対応するシリアライザーの <code>io.vertx.kafka.client.serialization.JsonObjectSerializer</code> も使用できます。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="avro-serialization"><a class="anchor" href="#avro-serialization"></a>10. Avro シリアライゼーション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これは、専用ガイド <a href="kafka-schema-registry-avro">Schema RegistryとAvroと共にApache Kafkaを使用</a> で説明されています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="json-schema-serialization"><a class="anchor" href="#json-schema-serialization"></a>11. JSON スキーマシリアライゼーション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これについては、専用のガイド <a href="kafka-schema-registry-json-schema">スキーマレジストリーと JSON スキーマと共に Apache Kafka を使用する</a> で説明されています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="serialization-autodetection"><a class="anchor" href="#serialization-autodetection"></a>12. シリアライザー/デシリアライザーの自動検出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus Messaging を Kafka (<code>io.quarkus:quarkus-messaging-kafka</code>) と併用する場合、Quarkus は多くの場合、正しいシリアライザーとデシリアライザーのクラスを自動的に検出できます。
この自動検出は、 <code>@Incoming</code> メソッドと <code>@Outgoing</code> メソッドの宣言、および注入された <code>@Channel</code> に基づいています。</p>
</div>
<div class="paragraph">
<p>たとえば、以下のように宣言した場合</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Outgoing("generated-price")
public Multi&lt;Integer&gt; generate() {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定において <code>generated-price</code> チャネルが <code>smallrye-kafka</code> コネクターを使用することを示している場合、Quarkus は自動的に <code>value.serializer</code> を Kafka の組み込みの <code>IntegerSerializer</code> に設定します。</p>
</div>
<div class="paragraph">
<p>同様に、以下を宣言した場合</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Incoming("my-kafka-records")
public void consume(Record&lt;Long, byte[]&gt; record) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定において <code>my-kafka-records</code> チャネルが <code>smallrye-kafka</code> コネクターを使用することを示している場合、Quarkus は自動的に <code>key.deserializer</code> を Kafka の組み込み <code>LongDeserializer</code> に設定し、同様に <code>value.deserializer</code> を <code>ByteArrayDeserializer</code> に設定します。</p>
</div>
<div class="paragraph">
<p>最後に、以下を宣言した場合</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@Channel("price-create")
Emitter&lt;Double&gt; priceEmitter;</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定において <code>price-create</code> チャネルが <code>smallrye-kafka</code> コネクターを使用することを示している場合、Quarkus は自動的に <code>value.serializer</code> を Kafka の組み込みの <code>DoubleSerializer</code> に設定します。</p>
</div>
<div class="paragraph">
<p>シリアライザー/デシリアライザーの自動検出でサポートされるタイプの完全なセットは以下のとおりです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>short</code> および <code>java.lang.Short</code></p>
</li>
<li>
<p><code>int</code> および <code>java.lang.Integer</code></p>
</li>
<li>
<p><code>long</code> および <code>java.lang.Long</code></p>
</li>
<li>
<p><code>float</code> および <code>java.lang.Float</code></p>
</li>
<li>
<p><code>double</code> および`java.lang.Double`</p>
</li>
<li>
<p><code>byte[]</code></p>
</li>
<li>
<p><code>java.lang.String</code></p>
</li>
<li>
<p><code>java.util.UUID</code></p>
</li>
<li>
<p><code>java.nio.ByteBuffer</code></p>
</li>
<li>
<p><code>org.apache.kafka.common.utils.Bytes</code></p>
</li>
<li>
<p><code>io.vertx.core.buffer.Buffer</code></p>
</li>
<li>
<p><code>io.vertx.core.json.JsonObject</code></p>
</li>
<li>
<p><code>io.vertx.core.json.JsonArray</code></p>
</li>
<li>
<p><code>org.apache.kafka.common.serialization.Serializer&lt;T&gt;</code> / <code>org.apache.kafka.common.serialization.Deserializer&lt;T&gt;</code> の直接実装があるクラス。</p>
<div class="ulist">
<ul>
<li>
<p>この実装は、タイプ引数 <code>T</code> を (デ) シリアライズタイプとして指定する必要があります。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Confluent または Apicurio Registry <em>serde</em> が存在する場合、Avro スキーマから生成されるクラスと Avro <code>GenericRecord</code> から生成されるクラス</p>
<div class="ulist">
<ul>
<li>
<p>複数の Avro serde が存在する場合、自動検出は使用できないため、Avro が生成するクラスに対してシリアライザー/デシリアライザーを手動で設定する必要があります</p>
</li>
<li>
<p>Confluent または Apicurio Registry ライブラリーの使用に関する詳細は、 <a href="kafka-schema-registry-avro">Schema RegistryとAvroと共にApache Kafkaを使用</a> を参照してください</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#jackson-serialization">Jackson を介したシリアライズ</a> で説明されているように、 <code>ObjectMapperSerializer</code> / <code>ObjectMapperDeserializer</code> のサブクラスが存在するクラス</p>
<div class="ulist">
<ul>
<li>
<p>技術的には <code>ObjectMapperSerializer</code> をサブクラスにする必要はありませんが、その場合は自動検出ができません</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#jsonb-serialization">JSON-B を介したシリアライズ</a> で説明されているように、 <code>JsonbSerializer</code> / <code>JsonbDeserializer</code> のサブクラスが存在するクラス</p>
<div class="ulist">
<ul>
<li>
<p>技術的には <code>JsonbSerializer</code> をサブクラスにする必要はありませんが、その場合は自動検出ができません</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>シリアライザー/デシリアライザーが設定されている場合、自動検出によって置き換えられることはありません。</p>
</div>
<div class="paragraph">
<p>シリアライザーの自動検出に問題がある場合は、 <code>quarkus.messaging.kafka.serializer-autodetection.enabled=false</code> を設定することで、これを完全にオフにすることができます。
オフにする必要がある場合は、<a href="https://github.com/quarkusio/quarkus/issues">Quarkus issue tracker</a> にバグを報告していただければ、問題を解決します。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="serialization-generation"><a class="anchor" href="#serialization-generation"></a>13. JSON シリアライザー/デシリアライザーの生成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus は、以下の場合のチャネルのシリアライザーおよびデシリアライザーを自動的に生成します。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>シリアライザー/デシリアライザーが設定されていない場合</p>
</li>
<li>
<p>自動検出が、一致するシリアライザー/デシリアライザーを見つけられなかった場合</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>これは、水面下で Jackson を使用しています。</p>
</div>
<div class="paragraph">
<p>この生成を無効にするには、以下を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.messaging.kafka.serializer-generation.enabled=false</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
生成は <code>List&lt;Fruit&gt;</code> などのコレクションをサポートしません。このケースでは、<a href="#jackson-serialization">Jackson を介したシリアライズ</a> を参照して、独自のシリアライザー/デシリアライザーを作成してください。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-schema-registry"><a class="anchor" href="#using-schema-registry"></a>14. スキーマレジストリーの使用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これについては、Avro 専用のガイド <a href="kafka-schema-registry-avro">Schema Registry と Avro と共に Apache Kafka を使用する</a> で説明されています。
JSON スキーマの場合は <a href="kafka-schema-registry-json-schema">Schema Registry と JSON Schem と共に Apache Kafka を使用する</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-health-check"><a class="anchor" href="#kafka-health-check"></a>15. ヘルスチェック</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkusは、Kafkaのヘルスチェックをいくつか提供しています。これらのチェックは、 <code>quarkus-smallrye-health</code> エクステンションと組み合わせて使用します。</p>
</div>
<div class="sect2">
<h3 id="kafka-broker-readiness-check"><a class="anchor" href="#kafka-broker-readiness-check"></a>15.1. Kafka ブローカー rediness チェック</h3>
<div class="paragraph">
<p><code>quarkus-kafka-client</code> エクステンションを使用している場合、 <code>application.properties</code> で <code>quarkus.kafka.health.enabled</code> プロパティーを <code>true</code> に設定することで、<em>readiness</em> ヘルスチェックを有効にすることができます。このチェックでは、<em>default</em> Kafka ブローカー (<code>kafka.bootstrap.servers</code> を使用して設定) とのインタラクションのステータスが報告されます。これには Kafka ブローカーとの <em>admin connection</em> が必要ですが、これはデフォルトでは無効になっています。有効にすると、アプリケーションの <code>/q/health/ready</code> エンドポイントにアクセスしたときに、接続検証のステータスに関する情報が得られます。</p>
</div>
</div>
<div class="sect2">
<h3 id="kafka-reactive-messaging-health-checks"><a class="anchor" href="#kafka-reactive-messaging-health-checks"></a>15.2. Kafka Reactive Messaging ヘルスチェック</h3>
<div class="paragraph">
<p>Reactive Messaging と Kafka コネクターを使用する場合、設定済みの各チャンネル（着信または送信）は、<em>startup</em>、<em>liveness</em>、および <em>readiness</em> チェックを提供します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>startup</em> check は、Kafka クラスターとの通信が確立されていることを確認します。</p>
</li>
<li>
<p><em>liveness</em> チェックは、Kafka との通信中に発生する回復不可能なエラーをキャプチャーします。</p>
</li>
<li>
<p><em>readiness</em> チェックは、Kafka コネクターが設定済みの Kafka トピックに対してメッセージを消費/生成する準備ができていることを確認します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>チャネルごとに、以下を使用してチェックを無効にできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Disable both liveness and readiness checks with `health-enabled=false`:

# Incoming channel (receiving records form Kafka)
mp.messaging.incoming.your-channel.health-enabled=false
# Outgoing channel (writing records to Kafka)
mp.messaging.outgoing.your-channel.health-enabled=false

# Disable only the readiness check with `health-readiness-enabled=false`:

mp.messaging.incoming.your-channel.health-readiness-enabled=false
mp.messaging.outgoing.your-channel.health-readiness-enabled=false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>mp.messaging.incoming|outgoing.$channel.bootstrap.servers</code> プロパティーを使用して、各チャンネルに <code>bootstrap.servers</code> を設定できます。デフォルトは <code>kafka.bootstrap.servers</code> です。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactive Messaging の <em>startup</em> および <em>readiness</em> チェックには、2 つのストラテジーがあります。デフォルトのストラテジーでは、ブローカーとの間にアクティブな接続が確立されていることを確認します。この方法は、組み込みの Kafka クライアントメトリクスに基づいているため、邪魔になることはありません。</p>
</div>
<div class="paragraph">
<p><code>health-topic-verification-enabled=true</code> 属性を使用すると、<em>startup</em> プローブは <em>admin client</em> を使用してトピックのリストをチェックします。<em>readiness</em> プローブの場合、受信チャンネル用は、少なくとも 1 つのパーティションが消費のために割り当てられていることをチェックし、送信チャンネル用は、プロデューサーが使用するトピックがブローカーに存在していることをチェックします。</p>
</div>
<div class="paragraph">
<p>これを行うには、<em>admin connection</em> が必要です。 <code>health-topic-verification-timeout</code> 設定を使用して、ブローカーへのトピック検証呼び出しのタイムアウトを調整することができます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="observability"><a class="anchor" href="#observability"></a>16. Observability</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="opentelemetry">OpenTelemetry エクステンション</a> が存在する場合、
Kafka コネクターチャネルは OpenTelemetry Tracing ですぐに使用できます。
Kafka トピックに書き込まれたメッセージは、現在のトレーシング範囲を伝播します。
着信チャネルでは、消費された Kafka レコードにトレーシング情報が含まれている場合、メッセージ処理はメッセージスパンを親として継承します。</p>
</div>
<div class="paragraph">
<p>トレーシングはチャネルごとに明示的に無効にできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.data.tracing-enabled=false</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="telemetry-micrometer">Micrometer エクステンション</a> が存在する場合、
Kafka プロデューサーおよびコンシューマークライアントのメトリクスは Micrometer メーターとして公開されます。</p>
</div>
<div class="sect2">
<h3 id="channel-metrics"><a class="anchor" href="#channel-metrics"></a>16.1. チャネルメトリクス</h3>
<div class="paragraph">
<p>チャネルごとのメトリクスも収集され、Micrometer メーターとして公開できます。
<em>チャネル</em> タグで識別されるチャネルごとに、次のメトリクスを収集できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.messaging.message.count</code> : 生成または受信したメッセージの数</p>
</li>
<li>
<p><code>quarkus.messaging.message.acks</code> : 正常に処理されたメッセージの数</p>
</li>
<li>
<p><code>quarkus.messaging.message.failures</code> : 処理に失敗したメッセージの数</p>
</li>
<li>
<p><code>quarkus.messaging.message.duration</code>: メッセージの処理時間</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下位互換性のため、チャネルメトリクスはデフォルトでは有効化されていませんが、次の方法で有効化できます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://smallrye.io/smallrye-reactive-messaging/latest/concepts/observability/">メッセージの監視</a> は
メッセージのインターセプトに依存しているため、 <code>IncomingKafkaRecord</code>、 <code>KafkaRecord</code>、 <code>IncomingKafkaRecordBatch</code> または <code>KafkaRecordBatch</code> などの
カスタムメッセージタイプを使用してメッセージを消費するチャネルはサポートされません。</p>
</div>
<div class="paragraph">
<p>メッセージのインターセプトと監視は、汎用の <code>Message</code> タイプを消費するチャネルや、 <a href="https://smallrye.io/smallrye-reactive-messaging/latest/concepts/converters/">コンバーター</a> によって有効化されたカスタムペイロードを使用する場合でも機能します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">smallrye.messaging.observation.enabled=true</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-streams"><a class="anchor" href="#kafka-streams"></a>17. Kafka Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>詳細は、専用ガイドの <a href="kafka-streams">Apache Kafka Streamsの使用</a> で説明されています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-snappy-for-message-compression"><a class="anchor" href="#using-snappy-for-message-compression"></a>18. メッセージ圧縮での Snappy の使用</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>outgoing</em> チャンネルでは、 <code>compression.type</code> 属性を <code>snappy</code> に設定することで、Snappy 圧縮を有効にすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.outgoing.fruit-out.compression.type=snappy</code></pre>
</div>
</div>
<div class="paragraph">
<p>JVM モードでは、そのまますぐに動作します。
ただし、アプリケーションをネイティブ実行可能ファイルにコンパイルするには、
<code>application.properties</code> に <code>quarkus.kafka.snappy.enabled=true</code> を追加する必要があります。</p>
</div>
<div class="paragraph">
<p>ネイティブモードでは、Snappyはデフォルトで無効になっています。Snappyを使用するには、ネイティブライブラリを埋め込み、アプリケーションの起動時にそれを解凍する必要があるからです。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="authentication-with-oauth"><a class="anchor" href="#authentication-with-oauth"></a>19. OAuth を使用した認証</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafka ブローカーが認証メカニズムとして OAuth を使用している場合は、この認証プロセスを有効にするために Kafka コンシューマーを設定する必要があります。まず、以下の依存関係をアプリケーションに追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- if compiling to native you'd need also the following dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-common&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.strimzi:kafka-oauth-client")
// if compiling to native you'd need also the following dependency
implementation("io.strimzi:kafka-oauth-common")</code></pre>
</div>
</div>
<div class="paragraph">
<p>この依存関係は、OAuth ワークフローを処理するために必要なコールバックハンドラーを提供します。そして、 <code>application.properties</code> で追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler

quarkus.ssl.native=true</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>oauth.client.id</code>、 <code>oauth.client.secret</code>、 <code>oauth.token.endpoint.uri</code> の値を更新します。</p>
</div>
<div class="paragraph">
<p>OAuth 認証は、JVM とネイティブモードの両方で動作します。SSL はネイティブモードでデフォルトで有効になっていないため、SSL を使用する JaasClientOauthLoginCallbackHandler をサポートするために、 <code>quarkus.ssl.native=true</code> を追加する必要があります（詳細は、<a href="native-and-ssl">ネイティブイメージでのSSLの利用</a> ガイドを参照）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tls-configuration"><a class="anchor" href="#tls-configuration"></a>20. TLS 設定</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafka クライアントエクステンションは、<a href="./tls-registry-reference">Quarkus TLS レジストリー</a> と統合してクライアントを設定します。</p>
</div>
<div class="paragraph">
<p>デフォルトの Kafka 設定の TLS を設定するには、 <code>application.properties</code> で名前付き TLS 設定を指定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.tls.your-tls-config.trust-store.pem.certs=target/certs/kafka.crt,target/certs/kafka-ca.crt
# ...
kafka.tls-configuration-name=your-tls-config
# enable ssl security protocol
kafka.security.protocol=ssl</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、Kafka クライアントに <code>ssl.engine.factory.class</code> 実装が提供されます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>また、 <code>security.protocol</code> プロパティーを <code>SSL</code> または <code>SASL_SSL</code> に設定して、SSL チャネルセキュリティープロトコルを必ず有効にしてください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Quarkus Messaging チャネルは、特定の TLS 設定を使用するように個別に設定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.your-channel.tls-configuration-name=your-tls-config
mp.messaging.incoming.your-channel.security.protocol=ssl</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-a-kafka-application"><a class="anchor" href="#testing-a-kafka-application"></a>21. Kafka アプリケーションのテスト</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="testing-without-a-broker"><a class="anchor" href="#testing-without-a-broker"></a>21.1. ブローカーなしでのテスト</h3>
<div class="paragraph">
<p>Kafka ブローカーを起動しなくてもアプリケーションをテストできるのは便利です。これを行うには、Kafka コネクターで管理しているチャンネルを <em>インメモリー</em> に <em>切り替え</em> できます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下のプロセッサーアプリケーションをテストするとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class BeverageProcessor {

    @Incoming("orders")
    @Outgoing("beverages")
    Beverage process(Order order) {
        System.out.println("Order received " + order.getProduct());
        Beverage beverage = new Beverage();
        beverage.setBeverage(order.getProduct());
        beverage.setCustomer(order.getCustomer());
        beverage.setOrderId(order.getOrderId());
        beverage.setPreparationState("RECEIVED");
        return beverage;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>まず、以下のテスト依存関係をアプリケーションに追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.smallrye.reactive:smallrye-reactive-messaging-in-memory")</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、以下のように Quarkus Test Resource を作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {

    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");     <i class="conum" data-value="1"></i><b>(1)</b>
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("beverages");  <i class="conum" data-value="2"></i><b>(2)</b>
        env.putAll(props1);
        env.putAll(props2);
        return env;  <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Override
    public void stop() {
        InMemoryConnector.clear();  <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(Kafka からのメッセージが想定される) 受信チャンネル <code>orders</code> をインメモリーに切り替えます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>(Kafka へのメッセージを書き込む) 送信チャネル <code>beverages</code> をインメモリーに切り替えます。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む <code>Map</code> をビルドして返します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>テストが停止したら、 <code>InMemoryConnector</code> をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上記で作成したテストリソースを使用して Quarkus テストを作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.awaitility.Awaitility.await;

@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {

    @Inject
    @Connector("smallrye-in-memory")
    InMemoryConnector connector; <i class="conum" data-value="1"></i><b>(1)</b>

    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; ordersIn = connector.source("orders");     <i class="conum" data-value="2"></i><b>(2)</b>
        InMemorySink&lt;Beverage&gt; beveragesOut = connector.sink("beverages");  <i class="conum" data-value="3"></i><b>(3)</b>

        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");

        ordersIn.send(order);  <i class="conum" data-value="4"></i><b>(4)</b>

        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(beveragesOut::received, t -&gt; t.size() == 1); <i class="conum" data-value="5"></i><b>(5)</b>

        Beverage queuedBeverage = beveragesOut.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>テストクラスにインメモリーコネクタ－を挿入します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>受信チャンネルを取得します (<code>orders</code>) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>送信チャネルを取得します (<code>beverages</code>) - テストリソース内でチャネルがインメモリーに切り替えられている必要があります。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>send</code> メソッドを使用して、 <code>orders</code> チャンネルにメッセージを送信します。アプリケーションはこのメッセージを処理し、 <code>beverages</code> チャンネルにメッセージを送信します。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>beverages</code> チャンネルで <code>received</code> メソッドを使用して、アプリケーションによって生成されたメッセージを確認します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kafka コンシューマーがバッチベースの場合は、手動でメッセージを作成して、バッチメッセージをチャネルに送信する必要があります。</p>
</div>
<div class="paragraph">
<p>例えば</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class BeverageProcessor {

    @Incoming("orders")
    CompletionStage&lt;Void&gt; process(KafkaRecordBatch&lt;String, Order&gt; orders) {
        System.out.println("Order received " + orders.getPayload().size());
        return orders.ack();
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.awaitility.Awaitility.await;

@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {

    @Inject
    @Connector("smallrye-in-memory")

    InMemoryConnector connector;

    @Test
    void testProcessOrder() {
        InMemorySource&lt;IncomingKafkaRecordBatch&lt;String, Order&gt;&gt; ordersIn = connector.source("orders");
        var committed = new AtomicBoolean(false);  <i class="conum" data-value="1"></i><b>(1)</b>
        var commitHandler = new KafkaCommitHandler() {
            @Override
            public &lt;K, V&gt; Uni&lt;Void&gt; handle(IncomingKafkaRecord&lt;K, V&gt; record) {
                committed.set(true);  <i class="conum" data-value="2"></i><b>(2)</b>
                return null;
            }
        };
        var failureHandler = new KafkaFailureHandler() {
            @Override
            public &lt;K, V&gt; Uni&lt;Void&gt; handle(IncomingKafkaRecord&lt;K, V&gt; record, Throwable reason, Metadata metadata) {
                return null;
            }
        };

        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
        var record = new ConsumerRecord&lt;&gt;("topic", 0, 0, "key", order);
        var records = new ConsumerRecords&lt;&gt;(Map.of(new TopicPartition("topic", 1), List.of(record)));
        var batch = new IncomingKafkaRecordBatch&lt;&gt;(
            records, "kafka", 0, commitHandler, failureHandler, false, false);  <i class="conum" data-value="3"></i><b>(3)</b>

        ordersIn.send(batch);

        await().until(committed::get);  <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>バッチがコミットされたか追跡するための <code>AtomicBoolean</code> を作成します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>バッチがコミットされたら <code>committed</code> を更新します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>単一のレコードを含む <code>IncomingKafkaRecordBatch</code> を作成します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>バッチがコミットされるまで待機します。</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>インメモリーチャネルを使用すると、Kafka ブローカーを開始せずにメッセージ処理のアプリケーションコードをテストできました。異なるインメモリーチャネルは独立しており、チャネルコネクターをインメモリーに切り替えても、同じ Kafka トピックに設定されたチャネル間でメッセージ配信をシミュレートしないことに注意してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="context-propagation-with-inmemoryconnector"><a class="anchor" href="#context-propagation-with-inmemoryconnector"></a>21.1.1. InMemoryConnector によるコンテキストの伝播</h4>
<div class="paragraph">
<p>デフォルトでは、メモリー内チャネルは呼び出し元スレッド (ユニットテストのメインスレッド) にメッセージをディスパッチします。</p>
</div>
<div class="paragraph">
<p><code>quarkus-test-vertx</code> 依存関係は <code>@io.quarkus.test.vertx.RunOnVertxContext</code> アノテーションを提供します。これをテストメソッドで使用すると、Vert.x コンテキストでテストが実行されます。</p>
</div>
<div class="paragraph">
<p>ただし、他のほとんどのコネクターは、個別の複製された Vert.x コンテキストで、コンテキスト伝播ディスパッチメッセージを処理します。</p>
</div>
<div class="paragraph">
<p>テストがコンテキストの伝播に依存している場合は、
<code>run-on-vertx-context</code> 属性を使用して in-memory コネクターチャネルを設定し、
メッセージや確認応答などのイベントを Vert.x コンテキストにディスパッチできます。
あるいは、 <code>InMemorySource#runOnVertxContext</code> メソッドを使用して、この動作を切り替えることもできます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing-using-a-kafka-broker"><a class="anchor" href="#testing-using-a-kafka-broker"></a>21.2. Kafka ブローカーを使用したテスト</h3>
<div class="paragraph">
<p><a href="#kafka-dev-services">Dev Services for Kafka</a> を使用している場合、 <code>%test</code> プロファイルで無効になっていない限り、Kafka ブローカーが起動し、テスト全体で利用することができます。Kafka Clients API を使用してこのブローカーに接続することは可能ですが、 <a href="https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/">Kafka Companion Library</a> では、Kafka ブローカーと対話し、テスト内でコンシューマー、プロデューサー、および管理アクションを作成する簡単な方法を提案しています。</p>
</div>
<div class="paragraph">
<p>テストで <code>KafkaCompanion</code> API を使用するには、以下の依存関係を追加して開始します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-kafka-companion&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、 <code>io.quarkus.test.kafka.KafkaCompanionResource</code> (<code>io.quarkus.test.common.QuarkusTestResourceLifecycleManager</code> の実装) を提供します。</p>
</div>
<div class="paragraph">
<p>次に、 <code>@QuarkusTestResource</code> を使用して、テストで Kafka Companion を設定します。以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.UUID;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.junit.jupiter.api.Test;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.kafka.InjectKafkaCompanion;
import io.quarkus.test.kafka.KafkaCompanionResource;
import io.smallrye.reactive.messaging.kafka.companion.ConsumerTask;
import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;

@QuarkusTest
@QuarkusTestResource(KafkaCompanionResource.class)
public class OrderProcessorTest {

    @InjectKafkaCompanion <i class="conum" data-value="1"></i><b>(1)</b>
    KafkaCompanion companion;

    @Test
    void testProcessor() {
        companion.produceStrings().usingGenerator(i -&gt; new ProducerRecord&lt;&gt;("orders", UUID.randomUUID().toString())); <i class="conum" data-value="2"></i><b>(2)</b>

        // Expect that the tested application processes orders from 'orders' topic and write to 'orders-processed' topic

        ConsumerTask&lt;String, String&gt; orders = companion.consumeStrings().fromTopics("orders-processed", 10); <i class="conum" data-value="3"></i><b>(3)</b>
        orders.awaitCompletion(); <i class="conum" data-value="4"></i><b>(4)</b>
        assertEquals(10, orders.count());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@InjectKafkaCompanion</code> は、テスト用に作成された Kafka ブローカーにアクセスするように設定された <code>KafkaCompanion</code> インスタンスを注入します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>KafkaCompanion</code> を使用して、10 のレコードを 'orders' トピックに書き込むプロデューサータスクを作成します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>'orders-processed' トピックをサブスクライブし、10 のレコードを消費するコンシューマータスクを作成します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>コンシューマタスクの完了を待ちます。</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下を設定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.orders.connector=smallrye-kafka
mp.messaging.incoming.orders.auto.offset.reset=earliest</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定しない場合、&lt;4&gt; で <code>java.lang.AssertionError: No completion (or failure) event received in the last 10000 ms</code> が表示す。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>テスト中に Kafka Dev Service が利用可能な場合、 <code>KafkaCompanionResource</code> は作成された Kafka ブローカーを使用します。そうでない場合は、 <a href="https://github.com/strimzi/test-container">Strimzi Test Container</a> を使用して Kafka ブローカーを作成します。</p>
</div>
<div class="paragraph">
<p>作成された Kafka ブローカーの設定は、 <code>@ResourceArg</code> を使用してカスタマイズすることができます。以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTestResource(value = KafkaCompanionResource.class, initArgs = {
        @ResourceArg(name = "strimzi.kafka.image", value = "quay.io/strimzi-test-container/test-container:0.106.0-kafka-3.7.0"), // Image name
        @ResourceArg(name = "kafka.port", value = "9092"), // Fixed port for kafka, by default it will be exposed on a random port
        @ResourceArg(name = "kraft", value = "true"), // Enable Kraft mode
        @ResourceArg(name = "num.partitions", value = "3"), // Other custom broker configurations
})
public class OrderProcessorTest {
    // ...
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="custom-test-resource"><a class="anchor" href="#custom-test-resource"></a>21.2.1. カスタムテストリソース</h4>
<div class="paragraph">
<p>あるいは、テストリソースで Kafka ブローカを起動することもできます。次のスニペットは、 <a href="https://www.testcontainers.org/modules/kafka/">Testcontainers</a> 使用して Kafka ブローカを起動するテストリソースを示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class KafkaResource implements QuarkusTestResourceLifecycleManager {

    private final KafkaContainer kafka = new KafkaContainer();

    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    public void stop() {
        kafka.close();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>アプリケーションがこのブローカーに接続するように、Kafka ブートストラップの場所を設定します。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-dev-services"><a class="anchor" href="#kafka-dev-services"></a>22. Dev Services for Kafka</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafka関連のエクステンション（例： <code>quarkus-messaging-kafka</code> ）がある場合、Dev Services for Kafkaは開発モードやテスト実行時に自動的にKafkaブローカーを起動します。
そのため、手動でブローカーを起動する必要はありません。
アプリケーションは自動的に設定されます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Kafkaブローカーの起動には時間がかかることがあるため、Dev Services for Kafkaは、~1秒で起動するKafka互換ブローカーである <a href="https://redpanda.com">Redpanda</a> を使用しています。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="enabling-disabling-dev-services-for-kafka"><a class="anchor" href="#enabling-disabling-dev-services-for-kafka"></a>22.1. KafkaのDev Servicesの有効化／無効化</h3>
<div class="paragraph">
<p>以下の場合を除き、Dev Services for Kafkaが自動的に有効になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.kafka.devservices.enabled</code> が <code>false</code> に設定されている場合</p>
</li>
<li>
<p><code>kafka.bootstrap.servers</code> が設定されている場合</p>
</li>
<li>
<p>すべてのReactive Messaging Kafkaチャンネルに <code>bootstrap.servers</code> 属性が設定されている場合</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dev Services for Kafkaでは、ブローカーの起動にDockerを使用しています。お使いの環境でDockerがサポートされていない場合は、ブローカーを手動で起動するか、すでに稼働しているブローカーに接続する必要があります。ブローカーのアドレスは、 <code>kafka.bootstrap.servers</code> を使用して設定できます。</p>
</div>
</div>
<div class="sect2">
<h3 id="shared-broker"><a class="anchor" href="#shared-broker"></a>22.2. 共有ブローカー</h3>
<div class="paragraph">
<p>ほとんどの場合、アプリケーション間でブローカーを共有する必要があります。Dev Services for Kafkaは、 <em>開発</em> モードで動作する複数のQuarkusアプリケーションが1つのブローカーを共有するための <em>サービス発見</em> メカニズムを実装しています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kafka向けDev Services は、コンテナを識別するために使用される <code>quarkus-dev-service-kafka</code> のラベルでコンテナを開始します。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>複数の（共有）ブローカーが必要な場合は、 <code>quarkus.kafka.devservices.service-name</code> 属性を設定し、ブローカー名を示します。同じ値のコンテナを探し、見つからない場合は新しいコンテナを開始します。デフォルトのサービス名は <code>kafka</code> です。</p>
</div>
<div class="paragraph">
<p>共有は、devモードではデフォルトで有効ですが、testモードでは無効です。 <code>quarkus.kafka.devservices.shared=false</code> で共有を無効に設定可能です。</p>
</div>
</div>
<div class="sect2">
<h3 id="setting-the-port"><a class="anchor" href="#setting-the-port"></a>22.3. ポートの設定</h3>
<div class="paragraph">
<p>デフォルトでは、Kafka向けDev Services はランダムなポートを選択してアプリケーションを構成します。ポートは、 <code>quarkus.kafka.devservices.port</code> プロパティを構成することで設定できます。</p>
</div>
<div class="paragraph">
<p>Kafkaのアドバタイズドアドレスは、選択したポートで自動的に設定されることに注意してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-the-image"><a class="anchor" href="#configuring-the-image"></a>22.4. イメージの設定</h3>
<div class="paragraph">
<p>Dev Services for Kafkaは <a href="https://redpanda.com">Redpanda</a> 、 <a href="https://github.com/ozangunalp/kafka-native">kafka-native</a> 、 <a href="https://strimzi.io">Strimzi</a> （ <a href="https://github.com/apache/kafka/blob/trunk/config/kraft/README.md">Kraft</a> モード）のイメージをサポートします。</p>
</div>
<div class="paragraph">
<p><strong>Redpanda</strong> は Kafka 互換のイベントストリーミングプラットフォームです。高速な起動時間を提供するため、Dev Services はデフォルトで <code>redpandadata/redpanda</code> からの Redpanda イメージを使用します。 <a href="https://hub.docker.com/r/redpandadata/redpanda" class="bare">https://hub.docker.com/r/redpandadata/redpanda</a> から任意のバージョンを選択できます。</p>
</div>
<div class="paragraph">
<p><strong>kafka-native</strong> はQuarkusとGraalVMを使用してネイティブバイナリにコンパイルされた通常のApache Kafkaディストリビューションのイメージを提供します。
まだ <em>experimental</em> ですが、非常に高速な起動時間と小さなフットプリントを提供します。</p>
</div>
<div class="paragraph">
<p>次のようにイメージの種類を設定することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kafka.devservices.provider=kafka-native</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Strimzi</strong> は、Kubernetes上でApache Kafkaを動作させるためのコンテナイメージとOperatorを提供します。
StrimziはKubernetesに最適化されていますが、イメージは従来のコンテナ環境でも完全に動作します。
Strimziのコンテナイメージは、JVM上で “純正の” Kafkaブローカーを動作させますが、起動が遅くなっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kafka.devservices.provider=strimzi</code></pre>
</div>
</div>
<div class="paragraph">
<p>Strimzi では、Kafka のバージョンが Kraft に対応しているもの（2.8.1 以上）であれば、 <a href="https://quay.io/repository/strimzi-test-container/test-container?tab=tags" class="bare">https://quay.io/repository/strimzi-test-container/test-container?tab=tags</a> から任意のイメージを選択することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kafka.devservices.image-name=quay.io/strimzi-test-container/test-container:0.106.0-kafka-3.7.0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-kafka-topics"><a class="anchor" href="#configuring-kafka-topics"></a>22.5. Kafkaトピックの設定</h3>
<div class="paragraph">
<p>You can configure the Dev Services for Kafka to create topics once the broker is started.
Topics are created with given number of partitions and 1 replica.
The syntax is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kafka.devservices.topic-partitions.&lt;topic-name&gt;=&lt;number-of-partitions&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example creates a topic named <code>test</code> with three partitions, and a second topic named <code>messages</code> with two partitions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kafka.devservices.topic-partitions.test=3
quarkus.kafka.devservices.topic-partitions.messages=2</code></pre>
</div>
</div>
<div class="paragraph">
<p>指定された名前のトピックがすでに存在する場合、既存のトピックを異なる数のパーティションに再分割しようとはせず、作成はスキップされます。</p>
</div>
<div class="paragraph">
<p><code>quarkus.kafka.devservices.topic-partitions-timeout</code> を使用して、トピック作成時に使用される Kafka admin クライアント呼び出しのタイムアウトを設定できます。デフォルトは 2 秒です。</p>
</div>
</div>
<div class="sect2">
<h3 id="redpanda-transactions"><a class="anchor" href="#redpanda-transactions"></a>22.6. トランザクションとべき等プロデューサーのサポート</h3>
<div class="paragraph">
<p>デフォルトではRedpanda ブローカーはトランザクションと冪等機能を有効化するように設定されています。 
以下の設定でそれらを無効にすることができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kafka.devservices.redpanda.transaction-enabled=false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Redpandaのトランザクションは正確に一回(exactly once)の処理をサポートしません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="Compose"><a class="anchor" href="#Compose"></a>22.7. Compose</h3>
<div class="paragraph">
<p>The Kafka Dev Services supports <a href="compose-dev-services">Compose Dev Services</a>.
It relies on a <code>compose-devservices.yml</code>, such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: &lt;application name&gt;
services:
  kafka:
    image: apache/kafka-native:3.9.0
    restart: "no"
    ports:
      - '9092'
    labels:
      io.quarkus.devservices.compose.exposed_ports: /etc/kafka/docker/ports
    environment:
      KAFKA_NODE_ID: 1
      KAFKA_PROCESS_ROLES: broker,controller
      KAFKA_LISTENERS: PLAINTEXT://:9092,CONTROLLER://:9093
      KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_CONTROLLER_QUORUM_VOTERS: 1@localhost:9093
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
      KAFKA_NUM_PARTITIONS: 3
    command: "/kafka.sh"
    volumes:
      - './kafka.sh:/kafka.sh'</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the broker to advertise its externally accessible address to clients, it requires an additional file <code>kafka.sh</code> as described in <a href="compose-dev-services#exposing-port-mappings-to-running-containers">Exposing port mappings to running containers</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-reference-devservices"><a class="anchor" href="#configuration-reference-devservices"></a>22.8. 設定リファレンス</h3>
<div class="paragraph configuration-legend">
<p><span class="icon"><i class="fa fa-lock" title="ビルド時に固定"></i></span> ビルド時に固定される設定プロパティ - その他の設定プロパティは実行時にオーバーライド可能です。</p>
</div>
<table class="tableblock frame-all grid-all stretch configuration-reference configuration-reference-all-rows">
<colgroup>
<col style="width: 80%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><span class="header-title">Configuration property</span></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock">型</p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock">デフォルト</p></th>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc odd">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-enabled"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-enabled"><code>quarkus.kafka.devservices.enabled</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.enabled' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-1" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>If Dev Services for Kafka has been explicitly enabled or disabled. Dev Services are generally enabled by default, unless there is an existing configuration present. For Kafka, Dev Services starts a broker unless <code>kafka.bootstrap.servers</code> is set or if all the Reactive Messaging Kafka channel are configured with a <code>bootstrap.servers</code>.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55090">QUARKUS_KAFKA_DEVSERVICES_ENABLED</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55090" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-port"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-port"><code>quarkus.kafka.devservices.port</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.port' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-2" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Optional fixed port the dev service will listen to.</p>
</div>
<div class="paragraph">
<p>If not defined, the port will be chosen randomly.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55091">QUARKUS_KAFKA_DEVSERVICES_PORT</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55091" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc odd">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-provider"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-provider"><code>quarkus.kafka.devservices.provider</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.provider' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-3" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Kafka dev service container type.</p>
</div>
<div class="paragraph">
<p>Redpanda, Strimzi and kafka-native container providers are supported. Default is redpanda.</p>
</div>
<div class="paragraph">
<p>For Redpanda: See <a href="https://docs.redpanda.com/current/get-started/quick-start/" class="bare">https://docs.redpanda.com/current/get-started/quick-start/</a> and <a href="https://hub.docker.com/r/redpandadata/redpanda" class="bare">https://hub.docker.com/r/redpandadata/redpanda</a></p>
</div>
<div class="paragraph">
<p>For Strimzi: See <a href="https://github.com/strimzi/test-container" class="bare">https://github.com/strimzi/test-container</a> and <a href="https://quay.io/repository/strimzi-test-container/test-container" class="bare">https://quay.io/repository/strimzi-test-container/test-container</a></p>
</div>
<div class="paragraph">
<p>For Kafka Native: See <a href="https://github.com/ozangunalp/kafka-native" class="bare">https://github.com/ozangunalp/kafka-native</a> and <a href="https://quay.io/repository/ogunalp/kafka-native" class="bare">https://quay.io/repository/ogunalp/kafka-native</a></p>
</div>
<div class="paragraph">
<p>Note that Strimzi and Kafka Native images are launched in Kraft mode.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55092">QUARKUS_KAFKA_DEVSERVICES_PROVIDER</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55092" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><div class="paragraph">
<p><code>redpanda</code>, <code>strimzi</code>, <code>kafka-native</code></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code>redpanda</code></p></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-image-name"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-image-name"><code>quarkus.kafka.devservices.image-name</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.image-name' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-4" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>The Kafka container image to use.</p>
</div>
<div class="paragraph">
<p>Dependent on the provider.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55093">QUARKUS_KAFKA_DEVSERVICES_IMAGE_NAME</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55093" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc odd">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-shared"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-shared"><code>quarkus.kafka.devservices.shared</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.shared' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-5" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Indicates if the Kafka broker managed by Quarkus Dev Services is shared. When shared, Quarkus looks for running containers using label-based service discovery. If a matching container is found, it is used, and so a second one is not started. Otherwise, Dev Services for Kafka starts a new container.</p>
</div>
<div class="paragraph">
<p>The discovery uses the <code>quarkus-dev-service-kafka</code> label. The value is configured using the <code>service-name</code> property.</p>
</div>
<div class="paragraph">
<p>Container sharing is only used in dev mode.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55094">QUARKUS_KAFKA_DEVSERVICES_SHARED</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55094" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-service-name"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-service-name"><code>quarkus.kafka.devservices.service-name</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.service-name' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-6" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>The value of the <code>quarkus-dev-service-kafka</code> label attached to the started container. This property is used when <code>shared</code> is set to <code>true</code>. In this case, before starting a container, Dev Services for Kafka looks for a container with the <code>quarkus-dev-service-kafka</code> label set to the configured value. If found, it will use this container instead of starting a new one. Otherwise, it starts a new container with the <code>quarkus-dev-service-kafka</code> label set to the specified value.</p>
</div>
<div class="paragraph">
<p>This property is used when you need multiple shared Kafka brokers.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55095">QUARKUS_KAFKA_DEVSERVICES_SERVICE_NAME</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55095" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code>kafka</code></p></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc odd">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-topic-partitions-topic-name"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-topic-partitions-topic-name"><code>quarkus.kafka.devservices.topic-partitions."topic-name"</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.topic-partitions."topic-name"' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-7" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>The topic-partition pairs to create in the Dev Services Kafka broker. After the broker is started, given topics with partitions are created, skipping already existing topics. For example, <code>quarkus.kafka.devservices.topic-partitions.my-topic=2</code> will create a topic named <code>test</code> with 2 partitions.</p>
</div>
<div class="paragraph">
<p>The topic creation will not try to re-partition existing topics with different number of partitions.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55096">QUARKUS_KAFKA_DEVSERVICES_TOPIC_PARTITIONS__TOPIC_NAME_</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55096" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Map&lt;String,Integer&gt;</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-topic-partitions-timeout"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-topic-partitions-timeout"><code>quarkus.kafka.devservices.topic-partitions-timeout</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.topic-partitions-timeout' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-8" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Timeout for admin client calls used in topic creation.</p>
</div>
<div class="paragraph">
<p>Defaults to 2 seconds.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55097">QUARKUS_KAFKA_DEVSERVICES_TOPIC_PARTITIONS_TIMEOUT</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55097" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Duration.html">Duration</a> <a href="#duration-note-anchor-quarkus-kafka-client_quarkus-kafka-devservices"><span class="icon"><i class="fa fa-question-circle" title="More information about the Duration format"></i></span></a></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code>2S</code></p></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc odd">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-container-env-environment-variable-name"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-container-env-environment-variable-name"><code>quarkus.kafka.devservices.container-env."environment-variable-name"</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.container-env."environment-variable-name"' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-9" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Environment variables that are passed to the container.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55098">QUARKUS_KAFKA_DEVSERVICES_CONTAINER_ENV__ENVIRONMENT_VARIABLE_NAME_</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55098" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Map&lt;String,String&gt;</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-redpanda-transaction-enabled"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-redpanda-transaction-enabled"><code>quarkus.kafka.devservices.redpanda.transaction-enabled</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.redpanda.transaction-enabled' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-10" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Enables transaction support. Also enables the producer idempotence. Find more info about Redpanda transaction support on <a href="https://vectorized.io/blog/fast-transactions/">https://vectorized.io/blog/fast-transactions/</a>. Notice that <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-447%3A+Producer+scalability+for+exactly+once+semantics">KIP-447 (producer scalability for exactly once semantic)</a> and <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=89068820">KIP-360 (Improve reliability of idempotent/transactional producer)</a> are <em>not</em> supported.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55099">QUARKUS_KAFKA_DEVSERVICES_REDPANDA_TRANSACTION_ENABLED</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55099" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr class="row-collapsible row-collapsed row-with-desc odd">
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><span class="icon"><i class="fa fa-lock" title="Fixed at build time"></i></span> <a id="quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-redpanda-proxy-port"></a> <span class="property-path"><a href="#quarkus-kafka-client_quarkus-kafka-devservices_quarkus-kafka-devservices-redpanda-proxy-port"><code>quarkus.kafka.devservices.redpanda.proxy-port</code></a></span>
<button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-text='quarkus.kafka.devservices.redpanda.proxy-port' title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
<div id="conf-collapsible-desc-11" class="openblock description description-collapsed">
<div class="content">
<div class="paragraph">
<p>Port to access the Redpanda HTTP Proxy (<a href="https://docs.redpanda.com/current/develop/http-proxy/">pandaproxy</a>).</p>
</div>
<div class="paragraph">
<p>If not defined, the port will be chosen randomly.</p>
</div>
<div class="paragraph">
<p>Environment variable: <code id="env-var-55100">QUARKUS_KAFKA_DEVSERVICES_REDPANDA_PROXY_PORT</code><button class="btn-copy fa fa-clipboard inline-btn-copy" data-clipboard-action="copy" data-clipboard-target="#env-var-55100" title="Copy to clipboard" do-not-collapse="true"></button></p>
</div>
</div>
</div>
<div class="paragraph description-decoration">
<p><i class="fa fa-chevron-down"></i><span>Show more</span></p>
</div></div></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
</tbody>
</table>
<div id="duration-note-anchor-quarkus-kafka-client_quarkus-kafka-devservices" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">期間フォーマットについて</div>
<div class="paragraph">
<p>期間の値を書くには、標準の <code>java.time.Duration</code> フォーマットを使います。
詳細は <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)">Duration#parse() Java API documentation</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>数字で始まる簡略化した書式を使うこともできます:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数値のみの場合は、秒単位の時間を表します。</p>
</li>
<li>
<p>数値の後に <code>ms</code> が続く場合は、ミリ秒単位の時間を表します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>その他の場合は、簡略化されたフォーマットが解析のために <code>java.time.Duration</code> フォーマットに変換されます：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数値の後に <code>h</code> 、 <code>m</code> 、 <code>s</code> が続く場合は、その前に <code>PT</code> が付けられます。</p>
</li>
<li>
<p>数値の後に <code>d</code> が続く場合は、その前に <code>P</code> が付けられます。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-dev-ui"><a class="anchor" href="#kafka-dev-ui"></a>23. Kafka Dev UI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafka関連のエクステンションがある場合（例： <code>quarkus-messaging-kafka</code> ）、Quarkus Dev UIはKafkaブローカー管理UIで拡張されます。
アプリケーション用に設定されたKafkaブローカーに自動的に接続されます。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/kafka-dev-ui-link.png" alt="Kafka Dev UI link" width="25%">
</div>
</div>
<div class="paragraph">
<p><strong>Kafka Dev UI</strong> を使用すると、Kafkaクラスターを直接管理し、次のようなタスクを実行することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>トピックの一覧表示と作成</p>
</li>
<li>
<p>レコードの可視化</p>
</li>
<li>
<p>新レコードの公開</p>
</li>
<li>
<p>コンシューマーグループの一覧とその消費ラグの閲覧</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/kafka-dev-ui-records.png" alt="Kafka Dev UI records" width="80%">
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Kafka Dev UIはQuarkus Dev UIの一部で、開発モードでのみ利用可能です。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kubernetes-service-bindings"><a class="anchor" href="#kubernetes-service-bindings"></a>24. Kubernetes サービスバインディング</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus Kafka エクステンションは、<a href="deploying-to-kubernetes">Service Binding Specification for Kubernetes</a> をサポートしています。アプリケーションに <code>quarkus-kubernetes-service-binding</code> エクステンションを追加することで、これを有効にすることができます。</p>
</div>
<div class="paragraph">
<p>適切に設定された Kubernetes クラスターで実行すると、Kafka エクステンションはユーザー設定を必要とせずに、クラスター内で利用可能なサービスバインディングから Kafka ブローカー接続設定を取得します。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="execution-model"><a class="anchor" href="#execution-model"></a>25. 実行モデル</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactive Messaging は、I/O スレッドでユーザーのメソッドを呼び出します。したがって、デフォルトではメソッドはブロックされません。<a href="#blocking-processing">ブロッキング処理</a> で説明されているように、このメソッドが呼び出し元スレッドをブロックする場合は、メソッドに <code>@Blocking</code> アノテーションを追加する必要があります。</p>
</div>
<div class="paragraph">
<p>このトピックの詳細については、<a href="quarkus-reactive-architecture">Quarkus リアクティブアーキテクチャのドキュメント</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="channel-decorators"><a class="anchor" href="#channel-decorators"></a>26. チャンネルデコレーター</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SmallRye Reactive Messagingは、監視、トレース、メッセージの傍受などの横断的な関心事を実装するために、送受信チャネルのデコレータをサポートしています。デコレータやメッセージインターセプタの実装に関する詳細は、 <a href="http://smallrye.io/smallrye-reactive-messaging/latest/concepts/decorators/">SmallRye Reactive Messagingのドキュメント</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kafka-configuration"><a class="anchor" href="#kafka-configuration"></a>27. 設定リファレンス</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SmallRye Reactive Messaging 設定に関する詳細は、 <a href="https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html">SmallRye Reactive Messaging - Kafka Connector Documentation</a> を参照してください。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>各チャネルは、以下を使用した設定で無効にできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.[incoming|outgoing].[channel].enabled=false</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最も重要な属性を以下の表に記載しています。</p>
</div>
<div class="sect2">
<h3 id="incoming-channel-configuration-polling-from-kafka"><a class="anchor" href="#incoming-channel-configuration-polling-from-kafka"></a>27.1. 着信チャネル設定 (Kafka からのポーリング)</h3>
<div class="paragraph">
<p>以下の属性は以下のように設定します:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.your-channel-name.attribute=value</code></pre>
</div>
</div>
<div class="paragraph">
<p>一部のプロパティには、グローバルに設定可能なエイリアスがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">kafka.bootstrap.servers=...</code></pre>
</div>
</div>
<div class="paragraph">
<p>基盤となる <a href="https://kafka.apache.org/documentation/#consumerconfigs">Kafka consumer</a> でサポートされる任意のプロパティーを渡すこともできます。</p>
</div>
<div class="paragraph">
<p>たとえば、 <code>max.poll.records</code> プロパティーを設定するには、次を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.[channel].max.poll.records=1000</code></pre>
</div>
</div>
<div class="paragraph">
<p>一部のコンシューマクライアントプロパティーは、適切なデフォルト値に設定されています。</p>
</div>
<div class="paragraph">
<p>設定されていない場合、切断時の高負荷を回避するために、 <code>reconnect.backoff.max.ms</code> は <code>10000</code> に設定されます。</p>
</div>
<div class="paragraph">
<p>設定されていない場合、 <code>key.deserializer</code> は <code>org.apache.kafka.common.serialization.StringDeserializer</code> に設定されます。</p>
</div>
<div class="paragraph">
<p>コンシューマーの <code>client.id</code> は、 <code>mp.messaging.incoming.[channel].partitions</code> プロパティーを使用して作成するクライアントの数に応じて設定されます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>client.id</code> が指定されている場合は、そのまま使用されるか、 <code>partitions</code> プロパティーが設定されている場合はクライアントインデックスの接尾辞が付けられます。</p>
</li>
<li>
<p><code>client.id</code> が指定されていない場合、 <code>[client-id-prefix][channel-name][-index]</code>. として生成されます。</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 'smallrye-kafka' connector の Incoming 属性</caption>
<colgroup>
<col style="width: 27.7777%;">
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 22.2224%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性 (<em>alias</em>)</th>
<th class="tableblock halign-left valign-top">説明</th>
<th class="tableblock halign-left valign-top">必須</th>
<th class="tableblock halign-left valign-top">デフォルト</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>bootstrap.servers</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(kafka.bootstrap.servers)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka クラスターへの初期接続を確立するために使用する host:port のコンマ区切りリスト</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localhost:9092</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>topic</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">消費/投入されるKafkaトピック。このプロパティも <code>topics</code> のプロパティも設定されていない場合は、チャネル名が使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ヘルスレポートが有効（デフォルト）か無効か</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-readiness-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レディネスレポートが有効（デフォルト）か無効か</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-readiness-topic-verification</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>deprecated</em> - レディネスチェックでトピックがブローカーに存在することを確認する必要があるかどうか。デフォルトは false です。有効にするには、管理者接続が必要です。非推奨: 代わりに health-topic-verification-enabled を使用します。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-readiness-timeout</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>deprecated</em> - レディネスヘルスチェック中に、コネクターはブローカーに接続し、トピックのリストを取得します。この属性は、取得の最大期間 (ミリ秒単位) を指定します。超過した場合、チャネルは準備ができていないと見なされます。非推奨: 代わりに health-topic-verification-timeout を使用します。</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-topic-verification-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ブローカーにトピックが存在するかどうかをスタートアップおよび レディネスチェックで確認するかどうか。デフォルトは false です。これを有効にするには、admin 接続が必要です。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-topic-verification-timeout</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">スタートアップおよび Readines チェックの間、コネクタはブローカーに接続し、トピックのリストを取得します。この属性では、検索にかける最大時間 （ms） を指定します。これを超えると、チャネルは準備ができていないとみなされます。</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>tracing-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">トレースを有効（デフォルト）にするか、無効にするか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>client-id-prefix</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka クライアント <code>client.id</code> 属性のプレフィックス。定義されている場合は、設定されたか自動生成された <code>client.id</code> にプリフィックスされます。そうでない場合は <code>kafka-consumer-</code> がプレフィックスとなります。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>checkpoint.state-store</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>checkpoint</code> コミット戦略を使用している間、 <code>io.smallrye.reactive.messaging.kafka.StateStore.Factory</code> を実装する Bean の <code>@Identifier</code> に設定された名前は、状態ストアの実装を指定します。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>checkpoint.state-type</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>checkpoint</code> commit-strategy を使用する場合、ステートストアに永続化するステートオブジェクトの完全修飾型名を指定します。指定されると、処理ステートオブジェクトの永続化を助けるために、ステートストア実装によって使用されることができます。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>checkpoint.unsynced-state-max-age.ms</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkpoint` コミット戦略を使用する場合、コネクタが不健全とマークされる前に処理状態を保持する必要がある最大時間をミリ秒単位で指定します。この属性を <code>0</code> に設定すると、この監視を無効にすることができます。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">クラウド イベント サポートを有効（デフォルト）または無効にします。 <em>incoming</em> チャネルで有効にすると、コネクタは受信レコードを分析し、Cloud Event メタデータの作成を試みます。 <em>outgoing</em> 側で有効にすると、メッセージに Cloud Event Metadata が含まれている場合、コネクタはoutgoingメッセージを Cloud Event として送信します。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>kafka-configuration</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">このチャネルのデフォルトの Kafka コンシューマー/プロデューサー設定を提供する CDIBean の ID。チャネル設定は、引き続き任意の属性をオーバーライドできます。Bean には、ある種のマップ&lt;String, Object&gt; が必要です。また、識別子を設定するには、@io.smallrye.common.annotation.Identifier 修飾子を使用する必要があります。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>topics</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">消費されるトピックのコンマ区切りのリスト。 <code>topic</code> または <code>pattern</code> のプロパティとは併用できません。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>pattern</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>topic</code> プロパティが正規表現であることを示す。 <code>topic</code> プロパティと併用する必要があります。 <code>topics</code> プロパティとは併用できません。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>key.deserializer</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードのキーをデシリアライズするために使用されるデシリアライザのクラス名</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.apache.kafka.common.serialization.StringDeserializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>lazy-client</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafkaクライアントを遅延作成するか(lazy)、即時作成するか(eagerly)。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>value.deserializer</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードの値のデシリアライズに使用されるデシリアライザのクラス名</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>fetch.min.bytes</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フェッチ・リクエストに対してサーバーが返すべきデータの最小量。デフォルトの1バイトの設定は、1バイトのデータが利用可能になるか、データの到着を待ってフェッチリクエストがタイムアウトするとすぐにフェッチリクエストに応答することを意味します。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>group.id</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">アプリケーションが所属するコンシューマーグループを識別するための一意の文字列。</p>
<p class="tableblock">設定されていない場合、デフォルトでは、 <code>quarkus.application.name</code> 設定プロパティで設定されたアプリケーション名になります。</p>
<p class="tableblock">それも設定されていない場合は、生成された一意のIDが使用されます。</p>
<p class="tableblock">常に <code>group.id</code> を定義することをお勧めします。自動生成は、開発用の便利機能にすぎません。
このプロパティを <code>${quarkus.uuid}</code> に設定することで、自動的に生成される一意の ID を明示的に要求することができます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>enable.auto.commit</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">この設定を有効にすると、コンシューマーのオフセットは、レコードの実際の処理結果を無視して、基礎となるKafkaクライアントによってバックグラウンドで定期的にコミットされます。この設定を有効にしないで、Reactive Messaging にコミットを任せることをお勧めします。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>retry</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">障害発生時にブローカーへの接続を再試行するかどうか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>retry-attempts</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">失敗するまでの最大再接続回数を指定します。-1は無限再試行を意味します。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>retry-max-wait</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2回の再接続の間の最大遅延時間（秒）</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>broadcast</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka レコードを複数のコンシューマーにディスパッチする必要があるかどうか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>auto.offset.reset</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka に初期オフセットがない場合の対処方法受け入れられる値は、earliest、latest、none</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>latest</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>failure-strategy</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードから生成されたメッセージが否定的に確認された（nack）場合に適用する失敗戦略を指定します。値は、 <code>fail</code> （デフォルト）、 <code>ignore</code> 、または <code>dead-letter-queue</code></p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fail</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>commit-strategy</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードから生成されたメッセージが確認されたときに適用するコミットストラテジーを指定します。値は、 <code>latest</code> 、 <code>ignore</code> 、 <code>throttled</code> のいずれかです。 <code>enable.auto.commit</code> がtrueであれば、デフォルトは <code>ignore</code> です。そうでなければ <code>throttled</code> です。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>throttled.unprocessed-record-max-age.ms</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>throttled</code> commit-strategy を使用している場合の、コネクタが不健全であるとマークされるまでの未処理メッセージの最大時間をミリ秒単位で指定します。この属性を 0 に設定すると、このモニタリングが無効になります。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>60000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>dead-letter-queue.topic</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>failure-strategy</code> に <code>dead-letter-queue</code> が設定されている場合、どのトピックにレコードが送信されるかを示します。デフォルトは <code>dead-letter-topic-$channel</code></p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>dead-letter-queue.key.serializer</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>failure-strategy</code> に <code>dead-letter-queue</code> が設定されている場合、 使用するキーシリアライザを示します。設定されていない場合は、キーデシリアライザに関連付けられたシリアライザが使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>dead-letter-queue.value.serializer</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>failure-strategy</code> に <code>dead-letter-queue</code> が設定されている場合、使用する値のシリアライザを示します。設定されていない場合は、値のデシリアライザに関連付けられたシリアライザが使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>partitions</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">同時に消費されるパーティションの数です。コネクタは、指定された数のKafkaコンシューマーを作成します。これは、対象となるトピックのパーティション数と一致する必要があります。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>requests</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>partitions</code> が 1 より大きい場合、この属性を使用すると、各コンシューマーが毎回要求するレコードの数を設定できます。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>128</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>consumer-rebalance-listener.name</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener</code> を実装する Bean の <code>@Identifier</code> で設定された名前です。設定された場合、このリバランスリスナーはコンシューマーに適用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>key-deserialization-failure-handler</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler</code> を実装する Beanの <code>@Identifier</code> で設定された名前です。設定されている場合、キーをデシリアライズする際に起こるデシリアライズの失敗は、フォールバック値を再試行または提供することができるこのハンドラに委ねられます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>value-deserialization-failure-handler</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler</code> を実装する Beanの <code>@Identifier</code> で設定された名前です。設定されている場合、値をデシリアライズする際に起こるデシリアライズの失敗は、フォールバック値を再試行または提供することができるこのハンドラに委ねられます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>fail-on-deserialization-failure</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">デシリアライズ失敗ハンドラーが設定されておらず、デシリアライズ失敗が発生した場合は、失敗を報告し、アプリケーションを異常としてマークします。 <code>false</code> に設定され、逆シリアル化の失敗が発生した場合、 <code>null</code> 値が転送されます。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>graceful-shutdown</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">アプリケーションの終了時に、グレースフルシャットダウンを行うかどうか。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>poll-timeout</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ミリ秒単位のポーリングタイムアウト。レコードをポーリングする場合、ポーリングは最大でその期間待機してからレコードを返します。デフォルトは 1000ms です</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>pause-if-no-requests</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">アプリケーションがアイテムを要求しないときにポーリングを一時停止し、要求したときに再開する必要があるかどうか。これにより、アプリケーションの容量に基づいてバックプレッシャを実装できます。ポーリングは停止されませんが、一時停止されたときにレコードを取得しないことに注意してください。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>batch</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka レコードがバッチで消費されるかどうか。チャネルインジェクションポイントは、 <code>List&lt;Payload&gt;</code> または <code>KafkaRecordBatch&lt;Payload&gt;</code> などの互換性のあるタイプを消費する必要があります。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>max-queue-size-factor</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>max.poll.records</code> * <code>max-queue-size-factor</code> を使用して、処理のためにキューに入れられるレコードの最大数を決定する乗数係数。デフォルトは 2 です。 <code>batch</code> モードでは、 <code>max.poll.records</code> は <code>1</code> と見なされます。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="outgoing-channel-configuration-writing-to-kafka"><a class="anchor" href="#outgoing-channel-configuration-writing-to-kafka"></a>27.2. outgoingチャンネルの設定（Kafkaへの書き込み)</h3>
<div class="paragraph">
<p>以下の属性は以下のように設定します:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.outgoing.your-channel-name.attribute=value</code></pre>
</div>
</div>
<div class="paragraph">
<p>一部のプロパティには、グローバルに設定可能なエイリアスがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">kafka.bootstrap.servers=...</code></pre>
</div>
</div>
<div class="paragraph">
<p>基盤となる <a href="https://kafka.apache.org/documentation/#producerconfigs">Kafka producer</a> でサポートされている任意のプロパティーを渡すこともできます。</p>
</div>
<div class="paragraph">
<p>たとえば、 <code>max.block.ms</code> プロパティーを設定するには、次を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.[channel].max.block.ms=10000</code></pre>
</div>
</div>
<div class="paragraph">
<p>一部のプロデューサークライアントプロパティーは、適切なデフォルト値に設定されています。</p>
</div>
<div class="paragraph">
<p>設定されていない場合、切断時の高負荷を回避するために、 <code>reconnect.backoff.max.ms</code> は <code>10000</code> に設定されます。</p>
</div>
<div class="paragraph">
<p>設定されていない場合、 <code>key.serializer</code> は <code>org.apache.kafka.common.serialization.StringSerializer</code> に設定されます。</p>
</div>
<div class="paragraph">
<p>設定されていない場合、プロデューサー <code>client.id</code> は <code>[client-id-prefix][channel-name]</code> として生成されます。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. 'smallrye-kafka' connector の Outgoing 属性</caption>
<colgroup>
<col style="width: 27.7777%;">
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 22.2224%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性 (<em>alias</em>)</th>
<th class="tableblock halign-left valign-top">説明</th>
<th class="tableblock halign-left valign-top">必須</th>
<th class="tableblock halign-left valign-top">デフォルト</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>acks</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">リクエストを完了とみなす前に、プロデューサーがリーダーに受信したことを要求する確認応答の数。これは、送信されるレコードの耐久性を制御します。許容される値は 0 、 1 、 または all です。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>bootstrap.servers</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(kafka.bootstrap.servers)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka クラスターへの初期接続を確立するために使用する host:port のコンマ区切りリスト</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localhost:9092</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>client-id-prefix</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka クライアント <code>client.id</code> 属性のプレフィックス。定義されている場合は、設定されたか自動生成された <code>client.id</code> にプリフィックスされます。そうでない場合は <code>kafka-producer-</code> がプレフィックスとなります。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>buffer.memory</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">サーバーへの送信待ちのレコードをバッファリングするために、プロデューサーが使用できるメモリの総バイト数</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>33554432</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>close-timeout</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafkaプロデューサーのグレースフルシャットダウンを待つミリ秒の量</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">クラウド イベント サポートを有効（デフォルト）または無効にします。 <em>incoming</em> チャネルで有効にすると、コネクタは受信レコードを分析し、Cloud Event メタデータの作成を試みます。 <em>outgoing</em> 側で有効にすると、メッセージに Cloud Event Metadata が含まれている場合、コネクタはoutgoingメッセージを Cloud Event として送信します。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-data-content-type</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(cloud-events-default-data-content-type)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">outgoing Cloud Eventのデフォルトの <code>datacontenttype</code> 属性を設定します。 <code>cloud-events</code> に <code>true</code> を設定する必要があります。この値は、メッセージが <code>datacontenttype</code> 属性を設定していない場合に使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-data-schema</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(cloud-events-default-data-schema)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">outgoing Cloud Eventのデフォルトの <code>dataschema</code> 属性を設定します。 <code>cloud-events</code> に <code>true</code> を設定する必要があります。この値は、メッセージが <code>dataschema</code> 属性を設定していない場合に使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-insert-timestamp</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(cloud-events-default-timestamp)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">コネクターが、送信するクラウドイベントに自動的に <code>time</code> 属性を挿入するかどうかを指定します。 <code>cloud-events</code> が <code>true</code> に設定されていることが必要です。この値は、メッセージに <code>time</code> 属性が設定されていない場合に使用されます。</p>
<p class="tableblock">タイプ: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-mode</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud Eventのモード（ <code>structured</code> または <code>binary</code> （デフォルト））。outgoing レコードにCloud Eventをどのように書き込むかを示します</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>binary</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-source</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(cloud-events-default-source)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">outgoing Cloud Eventのデフォルトの <code>source</code> 属性を設定します。 <code>cloud-events</code> に <code>true</code> を設定する必要があります。この値は、メッセージが <code>source</code> 属性を設定していない場合に使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-subject</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(cloud-events-default-subject)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">outgoing Cloud Eventのデフォルトの <code>subject</code> 属性を設定します。 <code>cloud-events</code> に <code>true</code> を設定する必要があります。この値は、メッセージが <code>subject</code> 属性を設定していない場合に使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>cloud-events-type</strong></span></p>
<p class="tableblock"><span class="no-hyphens"><em>(cloud-events-default-type)</em></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">outgoing Cloud Eventのデフォルトの <code>type</code> 属性を設定します。 <code>cloud-events</code> に <code>true</code> を設定する必要があります。この値は、メッセージが <code>type</code> 属性を設定していない場合に使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ヘルスレポートが有効（デフォルト）か無効か</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-readiness-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レディネスレポートが有効（デフォルト）か無効か</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-readiness-timeout</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>deprecated</em> - レディネスヘルスチェック中に、コネクターはブローカーに接続し、トピックのリストを取得します。この属性は、取得の最大期間 (ミリ秒単位) を指定します。超過した場合、チャネルは準備ができていないと見なされます。非推奨: 代わりに health-topic-verification-timeout を使用します。</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-readiness-topic-verification</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>deprecated</em> - レディネスチェックでトピックがブローカーに存在することを確認する必要があるかどうか。デフォルトは false です。有効にするには、管理者接続が必要です。非推奨: 代わりに health-topic-verification-enabled を使用します。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-topic-verification-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ブローカーにトピックが存在するかどうかをスタートアップおよび レディネスチェックで確認するかどうか。デフォルトは false です。これを有効にするには、admin 接続が必要です。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>health-topic-verification-timeout</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">スタートアップおよび Readines チェックの間、コネクタはブローカーに接続し、トピックのリストを取得します。この属性では、検索にかける最大時間 （ms） を指定します。これを超えると、チャネルは準備ができていないとみなされます。</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>kafka-configuration</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">このチャネルのデフォルトの Kafka コンシューマー/プロデューサー設定を提供する CDIBean の ID。チャネル設定は、引き続き任意の属性をオーバーライドできます。Bean には、ある種のマップ&lt;String, Object&gt; が必要です。また、識別子を設定するには、@io.smallrye.common.annotation.Identifier 修飾子を使用する必要があります。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>key</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードを書き込む際に使用するキー</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>key-serialization-failure-handler</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.smallrye.reactive.messaging.kafka.SerializationFailureHandler</code> を実装する Bean の <code>@Identifier</code> で設定された名前です。設定されている場合、キーをシリアライズする際に起こるシリアライズの失敗は、フォールバック値を再試行または提供することができるこのハンドラに委ねられます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>key.serializer</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードのキーをシリアライズするために使用されるシリアライザのクラス名</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.apache.kafka.common.serialization.StringSerializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>lazy-client</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafkaクライアントを遅延作成するか(lazy)、即時作成するか(eagerly)。</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>max-inflight-messages</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafkaに同時に書き込まれるメッセージの最大数。ブローカーが書き込みと確認を待っているメッセージの数を制限します。この属性を <code>0</code> に設定することで、制限を取り除くことができます。</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1024</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>merge</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">コネクタが複数のアップストリームを許可するかどうか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>partition</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">対象のパーティション ID 。 -1 を設定すると、クライアントがパーティションを決定します。</p>
<p class="tableblock">Type: <em>int</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>propagate-headers</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信レコードに伝搬される、受信レコードヘッダーのカンマ区切りのリスト</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>propagate-record-key</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">受信レコードのキーを送信レコードに伝搬させるかどうか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>retries</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正の数を設定すると、コネクターは、正常に配信されなかったレコード ( 一過性のエラーが発生する可能性があります ) を、再試行回数に達するまで再送しようとします。 0 に設定すると、再試行は無効になります。設定されていない場合、コネクターは、 <code>delivery.timeout.ms</code> で設定された時間の間、 ( 潜在的な一時的エラーのために ) 配信に失敗したすべてのレコードの再送を試みます。</p>
<p class="tableblock">Type: <em>long</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2147483647</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>topic</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">消費/投入されるKafkaトピック。このプロパティも <code>topics</code> のプロパティも設定されていない場合は、チャネル名が使用されます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>tracing-enabled</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">トレースを有効（デフォルト）にするか、無効にするか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>value-serialization-failure-handler</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.smallrye.reactive.messaging.kafka.SerializationFailureHandler</code> を実装する Bean の <code>@Identifier</code> で設定された名前です。設定されている場合、値をシリアライズする際に起こるシリアライズの失敗は、フォールバック値を再試行または提供することができるこのハンドラに委ねられます。</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>value.serializer</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">レコードの値のシリアライズに使用されるシリアライザのクラス名</p>
<p class="tableblock">Type: <em>string</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="no-hyphens"><strong>waitForWriteCompletion</strong></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">クライアントがメッセージを確認する前に、Kafkaが書き込まれた記録を確認するのを待つかどうか</p>
<p class="tableblock">Type: <em>boolean</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="kafka-configuration-resolution"><a class="anchor" href="#kafka-configuration-resolution"></a>27.3. Kafka 設定の解決</h3>
<div class="paragraph">
<p>Quarkus は、 <code>default-kafka-broker</code> 名の設定マップ内に接頭辞 <code>kafka.</code> または <code>KAFKA_</code> が付いたすべての Kafka 関連アプリケーションプロパティーを公開します。この設定は、Kafka ブローカーとの接続を確立するために使用されます。</p>
</div>
<div class="paragraph">
<p>このデフォルト設定に加えて、 <code>kafka-configuration</code> 属性を使用して <code>Map</code> プロデューサーの名前を設定することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.my-channel.connector=smallrye-kafka
mp.messaging.incoming.my-channel.kafka-configuration=my-configuration</code></pre>
</div>
</div>
<div class="paragraph">
<p>この場合、コネクターは <code>my-configuration</code> 名に関連付けられた <code>Map</code> を探します。 <code>kafka-configuration</code> が設定されていない場合、チャネル名 (前の例では <code>my-channel</code>) で公開された <code>Map</code> のオプションの検索が実行されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Produces
@ApplicationScoped
@Identifier("my-configuration")
Map&lt;String, Object&gt; outgoing() {
    return Map.ofEntries(
            Map.entry("value.serializer", ObjectMapperSerializer.class.getName())
    );
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>kafka-configuration</code> が設定されていて、 <code>Map</code> が見つからない場合、デプロイメントは失敗します。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>属性値は次のように解決されます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>属性はチャネル設定に直接設定されます (<code>mp.messaging.incoming.my-channel.attribute=value</code>)。</p>
</li>
<li>
<p>設定されていない場合、コネクターはチャネル名または設定された <code>kafka-configuration</code> (設定されている場合) を含む <code>Map</code> を検索し、その <code>Map</code> から値を取得します。</p>
</li>
<li>
<p>解決された <code>Map</code> に値が含まれていない場合、デフォルトの <code>Map</code> が使用されます (<code>default-kafka-broker</code> 名で公開)</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="conditionally-configure-channels"><a class="anchor" href="#conditionally-configure-channels"></a>27.4. 条件付きでチャンネルを設定する</h3>
<div class="paragraph">
<p>特定のプロファイルを使用してチャンネルを設定できます。
そのため、指定したプロファイルが有効な場合にのみ、チャンネルが設定されます（アプリケーションに追加されます）。</p>
</div>
<div class="paragraph">
<p>これを実現するには、以下を実行する必要があります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>mp.messaging.[incoming|outgoing].$channel</code> エントリーに <code>%my-profile</code> を接頭辞として付け、たとえば、 <code>%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value</code> のようにします。</p>
</li>
<li>
<p>プロファイルが有効な場合にのみ有効にする必要がある <code>@Incoming(channel)</code> と <code>@Outgoing(channel)</code> アノテーションを含む CDI Bean で、 <code>@IfBuildProfile("my-profile")</code> を使用します。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>リアクティブメッセージングでは、グラフが完全であることを確認することに注意してください。
したがって、このような条件付き設定を使用する場合は、プロファイルの有効化の有無に関係なく、アプリケーションが動作することを確認してください。</p>
</div>
<div class="paragraph">
<p>このアプローチは、プロファイルに基づいてチャネル設定を変更する場合にも使用できることに注意してください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integrating-with-kafka-common-patterns"><a class="anchor" href="#integrating-with-kafka-common-patterns"></a>28. Kafka との統合 - 一般的なパターン</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="writing-to-kafka-from-an-http-endpoint"><a class="anchor" href="#writing-to-kafka-from-an-http-endpoint"></a>28.1. HTTP エンドポイントから Kafka への書き込み</h3>
<div class="paragraph">
<p>HTTP エンドポイントから Kafka にメッセージを送信するには、エンドポイントに <code>Emitter</code> (または <code>MutinyEmitter</code>) を注入します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import java.util.concurrent.CompletionStage;

import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;

@Path("/")
public class ResourceSendingToKafka {

    @Channel("kafka") Emitter&lt;String&gt; emitter;          <i class="conum" data-value="1"></i><b>(1)</b>

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    public CompletionStage&lt;Void&gt; send(String payload) { <i class="conum" data-value="2"></i><b>(2)</b>
        return emitter.send(payload);                   <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Emitter&lt;String&gt;</code> を注入</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>HTTPメソッドはメッセージがKafkaに書き込まれると、ペイロードを受け取り、 <code>CompletionStage</code> の完了を返します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>メッセージをKafkaに送信し、 <code>send</code> メソッドは <code>CompletionStage</code> を返却します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>エンドポイントは、渡されたペイロードを (<code>POST</code> HTTP リクエストから) エミッターに送信します。エミッターのチャネルは、 <code>application.properties</code> ファイルの Kafka トピックにマップされます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.outgoing.kafka.connector=smallrye-kafka
mp.messaging.outgoing.kafka.topic=my-topic</code></pre>
</div>
</div>
<div class="paragraph">
<p>エンドポイントは、メソッドの非同期性を示す <code>CompletionStage</code> を返します。 <code>emitter.send</code> メソッドは <code>CompletionStage&lt;Void&gt;</code> を返します。メッセージが Kafka に書き込まれると、返される future は完了します。書き込みが失敗した場合、返された <code>CompletionStage</code> が例外扱いで完了します。</p>
</div>
<div class="paragraph">
<p>エンドポイントが <code>CompletionStage</code> を返さない場合、メッセージが Kafka に送信される前に HTTP 応答が書き込まれる可能性があるため、ユーザーに失敗が報告されることはありません。</p>
</div>
<div class="paragraph">
<p>Kafka レコードを送信する必要がある場合は、次を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import java.util.concurrent.CompletionStage;

import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;

import io.smallrye.reactive.messaging.kafka.Record;

@Path("/")
public class ResourceSendingToKafka {

    @Channel("kafka") Emitter&lt;Record&lt;String,String&gt;&gt; emitter;  <i class="conum" data-value="1"></i><b>(1)</b>


    @POST
    @Produces(MediaType.TEXT_PLAIN)
    public CompletionStage&lt;Void&gt; send(String payload) {
        return emitter.send(Record.of("my-key", payload));    <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Emitter&lt;Record&lt;K, V&gt;&gt;</code> の使用法に注意してください</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Record.of(k, v)</code> を使用してレコードを作成します</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="persisting-kafka-messages-with-hibernate-with-panache"><a class="anchor" href="#persisting-kafka-messages-with-hibernate-with-panache"></a>28.2. Hibernate with Panache での Kafka メッセージの永続化</h3>
<div class="paragraph">
<p>Kafka から受信したオブジェクトをデータベースに永続化するには、Hibernate with Panache を使用することができます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate Reactive を使用する場合は、<a href="#persisting-kafka-messages-with-hibernate-reactive">Hibernate Reactive を使用した Kafka メッセージの永続化</a> を参照してください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Fruit</code> オブジェクトを受け取ったと想像してみましょう。簡単にするために、 <code>Fruit</code> クラスは非常に単純です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.persistence.Entity;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

@Entity
public class Fruit extends PanacheEntity {

    public String name;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kafka トピックに保存されている <code>Fruit</code> インスタンスを消費し、それらをデータベースに永続化するには、次のアプローチを使用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.transaction.Transactional;

import org.eclipse.microprofile.reactive.messaging.Incoming;

import io.smallrye.common.annotation.Blocking;

@ApplicationScoped
public class FruitConsumer {

    @Incoming("fruits")                                     <i class="conum" data-value="1"></i><b>(1)</b>
    @Transactional                                          <i class="conum" data-value="2"></i><b>(2)</b>
    public void persistFruits(Fruit fruit) {                <i class="conum" data-value="3"></i><b>(3)</b>
        fruit.persist();                                    <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>着信チャネルの設定。このチャンネルは Kafka から読み取ります。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>データベースに書き込んでいるので、トランザクション内である必要があります。このアノテーションは新しいトランザクションを開始し、メソッドが返されたときにそれをコミットします。Quarkus は、このメソッドを自動的に <em>blocking</em> と見なします。実際、従来の Hibernate を使用したデータベースへの書き込みはブロックされています。そこで、Quarkus は、ブロックできるワーカースレッド (I/O スレッドではない) でメソッドを呼び出します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>メソッドは各 Fruit を受け取ります。Kafka レコードから Fruit インスタンスを再構築するには、デシリアライザーが必要になることに注意してください。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>受信した <code>fruit</code> オブジェクトを永続化します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上記 &lt;4&gt; で述べたように、レコードから <code>Fruit</code> を作成できるデシリアライザーが必要です。これは、Jackson デシリアライザーを使用して実行できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;

public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer() {
        super(Fruit.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>関連する設定は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.fruits.connector=smallrye-kafka
mp.messaging.incoming.fruits.value.deserializer=org.acme.FruitDeserializer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kafka を使用した Jackson の使い方の詳細については、<a href="#jackson-serialization">Jackson を介したシリアライズ</a> を確認してください。また、Avro を使用することもできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="persisting-kafka-messages-with-hibernate-reactive"><a class="anchor" href="#persisting-kafka-messages-with-hibernate-reactive"></a>28.3. Hibernate Reactive を使用した Kafka メッセージの永続化</h3>
<div class="paragraph">
<p>Kafka から受信したオブジェクトをデータベースに永続化するには、Hibernate Reactive with Panache を使用することができます。</p>
</div>
<div class="paragraph">
<p><code>Fruit</code> オブジェクトを受け取ったと想像してみましょう。簡単にするために、 <code>Fruit</code> クラスは非常に単純です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.persistence.Entity;

import io.quarkus.hibernate.reactive.panache.PanacheEntity;  <i class="conum" data-value="1"></i><b>(1)</b>

@Entity
public class Fruit extends PanacheEntity {

    public String name;

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>必ずリアクティブバリアントを使用してください</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kafka トピックに保存されている <code>Fruit</code> インスタンスを消費し、それらをデータベースに永続化するには、次のアプローチを使用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.context.control.ActivateRequestContext;

import org.eclipse.microprofile.reactive.messaging.Incoming;

import io.quarkus.hibernate.reactive.panache.Panache;
import io.smallrye.mutiny.Uni;

@ApplicationScoped
public class FruitStore {

    @Inject
    Mutiny.Session session;                    <i class="conum" data-value="1"></i><b>(1)</b>

    @Incoming("in")
    @ActivateRequestContext <i class="conum" data-value="2"></i><b>(2)</b>
    public Uni&lt;Void&gt; consume(Fruit entity) {
        return session.withTransaction(t -&gt; {  <i class="conum" data-value="3"></i><b>(3)</b>
            return entity.persistAndFlush()    <i class="conum" data-value="4"></i><b>(4)</b>
                    .replaceWithVoid();        <i class="conum" data-value="5"></i><b>(5)</b>
        }).onTermination().call(() -&gt; session.close()); <i class="conum" data-value="6"></i><b>(6)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hibernate Reactive <code>Session</code> を注入します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Hibernate Reactive <code>Session</code> および <code>Panache</code> API は、アクティブな CDI リクエストコンテキストを必要とします。 <code>@ActivateRequestContext</code> アノテーションは新しいリクエストコンテキストを作成し、メソッドから返された <code>Uni</code> が完了すると、それを破棄します。 <code>Panache</code> を使用しない場合は、 <code>Mutiny.SessionFactory</code> を注入して同様に使用することができ、 リクエストコンテキストをアクティブにしたりセッションを手動で閉じたりする必要はありません。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>新しいトランザクションを要求します。渡されたアクションが完了すると、トランザクションが完了します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>エンティティーを永続化します。これは <code>Uni&lt;Fruit&gt;</code> を返します。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>Uni&lt;Void&gt;</code> に切り替えます。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>セッションを閉じる - これは、データベースとの接続を閉じることです。その後、接続を再利用することができます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>classic</em> Hibernate とは異なり、 <code>@Transactional</code> は使用できません。代わりに、 <code>session.withTransaction</code> を使用して、エンティティーを永続化します。 <code>map</code> は、 <code>Uni&lt;Fruit&gt;</code> ではなく <code>Uni&lt;Void&gt;</code> を返すために使用されます。</p>
</div>
<div class="paragraph">
<p>レコードから <code>Fruit</code> を作成できるデシリアライザーが必要です。これは、Jackson デシリアライザーを使用して実行できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;

public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer() {
        super(Fruit.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>関連する設定は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.fruits.connector=smallrye-kafka
mp.messaging.incoming.fruits.value.deserializer=org.acme.FruitDeserializer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kafka を使用した Jackson の使い方の詳細については、<a href="#jackson-serialization">Jackson を介したシリアライズ</a> を確認してください。また、Avro を使用することもできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="writing-entities-managed-by-hibernate-to-kafka"><a class="anchor" href="#writing-entities-managed-by-hibernate-to-kafka"></a>28.4. Hibernate が管理するエンティティーの Kafka への書き込み</h3>
<div class="paragraph">
<p>以下のプロセスを想像してみましょう。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ペイロードを含む HTTP リクエストを受信します。</p>
</li>
<li>
<p>このペイロードから Hibernate エンティティーインスタンスを作成します。</p>
</li>
<li>
<p>そのエンティティーをデータベースに永続化します。</p>
</li>
<li>
<p>エンティティーを Kafka トピックに送信します。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate Reactive を使用する場合は、<a href="#writing-entities-managed-by-hibernate-reactive-to-kafka">Hibernate Reactive が管理するエンティティーの Kafka への書き込み</a> を参照してください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>データベースに書き込むため、このメソッドはトランザクション内で実行する必要があります。
ただし、エンティティーの Kafka への送信は非同期で行われます。
これを実現するには、 <code>MutinyEmitter</code> で <code>.sendAndAwait()</code> または <code>.sendAndForget()</code> を使用するか、 <code>Emitter</code> で <code>.send().toCompletableFuture().join()</code> を使用します。</p>
</div>
<div class="paragraph">
<p>このプロセスを実装するには、次のアプローチが必要です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import java.util.concurrent.CompletionStage;

import jakarta.transaction.Transactional;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.reactive.messaging.Channel;
import io.smallrye.reactive.messaging.MutinyEmitter;

@Path("/")
public class ResourceSendingToKafka {

    @Channel("kafka") MutinyEmitter&lt;Fruit&gt; emitter;

    @POST
    @Path("/fruits")
    @Transactional                                               <i class="conum" data-value="1"></i><b>(1)</b>
    public void storeAndSendToKafka(Fruit fruit) {               <i class="conum" data-value="2"></i><b>(2)</b>
        fruit.persist();
        emitter.sendAndAwait(new FruitDto(fruit));               <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>データベースに書き込んでいるときは、トランザクション内で実行していることを確認してください</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>メソッドは、永続化するためにために fruit インスタンスを受け取ります。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>管理対象エンティティーをデータ転送オブジェクト内にラップし、Kafka に送信します。
これにより、管理対象エンティティーが Kafka のシリアライゼーションの影響を受けなくなります。
その後、操作が完了するまで待ってから戻ります。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@Transactional</code> を使用する場合は、すべてのトランザクションコミットが単一のスレッドで行われ、パフォーマンスに影響するため、 <code>CompletionStage</code> または <code>Uni</code> を返さないでください。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-entities-managed-by-hibernate-reactive-to-kafka"><a class="anchor" href="#writing-entities-managed-by-hibernate-reactive-to-kafka"></a>28.5. Hibernate Reactive が管理するエンティティーの Kafka への書き込み</h3>
<div class="paragraph">
<p>Hibernate Reactive によって管理されている Kafka エンティティーに送信するには、以下を使用することをお勧めします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP リクエストを処理する Quarkus REST</p>
</li>
<li>
<p>チャネルにメッセージを送信するための <code>MutinyEmitter</code> 。これにより、Hibernate Reactive または Hibernate Reactive with Panache によって公開される Mutiny API と簡単に統合できます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次の例は、ペイロードを受信し、Hibernate Reactive with Panache を使用してデータベースに保存し、永続化されたエンティティーを Kafka に送信する方法を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.reactive.messaging.Channel;

import io.quarkus.hibernate.reactive.panache.Panache;
import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.MutinyEmitter;

@Path("/")
public class ReactiveGreetingResource {

    @Channel("kafka") MutinyEmitter&lt;Fruit&gt; emitter;     <i class="conum" data-value="1"></i><b>(1)</b>

    @POST
    @Path("/fruits")
    public Uni&lt;Void&gt; sendToKafka(Fruit fruit) {         <i class="conum" data-value="2"></i><b>(2)</b>
        return Panache.withTransaction(() -&gt;            <i class="conum" data-value="3"></i><b>(3)</b>
            fruit.&lt;Fruit&gt;persist()
        )
            .chain(f -&gt; emitter.send(f));               <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Mutiny API を公開する <code>MutinyEmitter</code> を注入します。これにより、Hibernate Reactive with Panache によって公開された Mutiny API との統合が簡素化されます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ペイロードを受信する HTTP メソッドは <code>Uni&lt;Void&gt;</code> を返します。HTTP 応答は、操作が完了すると書き込まれます (エンティティーは永続化され、Kafka に書き込まれます)。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>トランザクションでエンティティーをデータベースに書き込む必要があります。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>永続化操作が完了すると、エンティティーを Kafka に送信します。 <code>send</code> メソッドは <code>Uni&lt;Void&gt;</code> を返します。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="streaming-kafka-topics-as-server-sent-events"><a class="anchor" href="#streaming-kafka-topics-as-server-sent-events"></a>28.6. サーバー送信イベントとしての Kafka トピックのストリーミング</h3>
<div class="paragraph">
<p>Kafka トピックをサーバー送信イベント (SSE) としてストリーミングするのは簡単です。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Kafka トピックを表すチャネルを HTTP エンドポイントに注入します</p>
</li>
<li>
<p>そのチャネルを HTTP メソッドから <code>Publisher</code> または <code>Multi</code> として返します</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下のコードはその一例です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Channel("fruits")
Multi&lt;Fruit&gt; fruits;

@GET
@Produces(MediaType.SERVER_SENT_EVENTS)
public Multi&lt;Fruit&gt; stream() {
    return fruits;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一部の環境では、十分なアクティビティーがない場合に SSE 接続が切断されます。回避策として、定期的に <em>ping</em> メッセージ (または空のオブジェクト) を送信することが挙げられます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Channel("fruits")
Multi&lt;Fruit&gt; fruits;

@Inject
ObjectMapper mapper;

@GET
@Produces(MediaType.SERVER_SENT_EVENTS)
public Multi&lt;String&gt; stream() {
    return Multi.createBy().merging()
            .streams(
                    fruits.map(this::toJson),
                    emitAPeriodicPing()
            );
}

Multi&lt;String&gt; emitAPeriodicPing() {
    return Multi.createFrom().ticks().every(Duration.ofSeconds(10))
            .onItem().transform(x -&gt; "{}");
}

private String toJson(Fruit f) {
    try {
        return mapper.writeValueAsString(f);
    } catch (JsonProcessingException e) {
        throw new RuntimeException(e);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kafka からの fruits を送信する以外に、定期的に ping を送信する必要があるため、回避策は少し複雑になっています。これを実現するために、Kafka からのストリームと、10 秒ごとに <code>{}</code> を放出する定期的なストリームをマージします。</p>
</div>
</div>
<div class="sect2">
<h3 id="chaining-kafka-transactions-with-hibernate-reactive-transactions"><a class="anchor" href="#chaining-kafka-transactions-with-hibernate-reactive-transactions"></a>28.7. Kafka トランザクションと Hibernate Reactive トランザクションとのチェーン</h3>
<div class="paragraph">
<p>Kafka トランザクションを Hibernate Reactive トランザクションとチェーンすることにより、Kafka トランザクションにレコードを送信し、データベースの更新を実行して、データベーストランザクションが成功した場合にのみ Kafka トランザクションをコミットすることができます。</p>
</div>
<div class="paragraph">
<p>以下の例は、次のことを示しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Quarkus REST を使用して HTTP リクエストを処理し、ペイロードを受信します。</p>
</li>
<li>
<p>Smallrye Fault Tolerance を使用して、その HTTP エンドポイントの同時実行を制限します。</p>
</li>
<li>
<p>Kafka トランザクションを開始し、ペイロードを Kafka レコードに送信します。</p>
</li>
<li>
<p>Hibernate Reactive with Panache を使用して、ペイロードをデータベースに保存します。</p>
</li>
<li>
<p>エンティティーが正常に永続化された場合にのみ、Kafka トランザクションをコミットします。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.faulttolerance.Bulkhead;
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.hibernate.reactive.mutiny.Mutiny;

import io.quarkus.hibernate.reactive.panache.Panache;
import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;

@Path("/")
public class FruitProducer {

    @Channel("kafka") KafkaTransactions&lt;Fruit&gt; kafkaTx; <i class="conum" data-value="1"></i><b>(1)</b>

    @POST
    @Path("/fruits")
    @Consumes(MediaType.APPLICATION_JSON)
    @Bulkhead(1) <i class="conum" data-value="2"></i><b>(2)</b>
    public Uni&lt;Void&gt; post(Fruit fruit) { <i class="conum" data-value="3"></i><b>(3)</b>
        return kafkaTx.withTransaction(emitter -&gt; { <i class="conum" data-value="4"></i><b>(4)</b>
            emitter.send(fruit); <i class="conum" data-value="5"></i><b>(5)</b>
            return Panache.withTransaction(() -&gt; { <i class="conum" data-value="6"></i><b>(6)</b>
                return fruit.&lt;Fruit&gt;persist(); <i class="conum" data-value="7"></i><b>(7)</b>
            });
        }).replaceWithVoid();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Mutiny API を公開する <code>KafkaTransactions</code> を注入します。これにより、Hibernate Reactive with Panache によって公開された Mutiny API との統合が可能になります。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>HTTP エンドポイントの同時実行を "1" に制限し、特定の時間に複数のトランザクションを開始しないようにします。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ペイロードを受信する HTTP メソッドは <code>Uni&lt;Void&gt;</code> を返します。HTTP 応答は、操作が完了すると書き込まれます (エンティティーは永続化され、Kafka トランザクションはコミットされます)。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Kafka トランザクションを開始します。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Kafka トランザクション内でペイロードを Kafka に送信します。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Hibernate Reactive トランザクションでエンティティーをデータベースに永続化します。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>永続化操作が完了し、エラーが発生しない場合は、Kafka トランザクションがコミットされます。結果は省略され、HTTP 応答として返されます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>前の例では、データベーストランザクション (内部) がコミットされ、続いて Kafka トランザクション (外部) がコミットされます。最初に Kafka トランザクションをコミットし、次にデータベーストランザクションをコミットしたい場合は、それらを逆の順序でネストする必要があります。</p>
</div>
<div class="paragraph">
<p>以下は、Hibernate Reactive API (Panache なし) を使用する場合の例になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.faulttolerance.Bulkhead;
import org.eclipse.microprofile.reactive.messaging.Channel;
import org.hibernate.reactive.mutiny.Mutiny;

import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;
import io.vertx.mutiny.core.Context;
import io.vertx.mutiny.core.Vertx;

@Path("/")
public class FruitProducer {

    @Channel("kafka") KafkaTransactions&lt;Fruit&gt; kafkaTx;

    @Inject Mutiny.SessionFactory sf; <i class="conum" data-value="1"></i><b>(1)</b>

    @POST
    @Path("/fruits")
    @Consumes(MediaType.APPLICATION_JSON)
    @Bulkhead(1)
    public Uni&lt;Void&gt; post(Fruit fruit) {
        return sf.withTransaction(session -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
                kafkaTx.withTransaction(emitter -&gt; <i class="conum" data-value="3"></i><b>(3)</b>
                        session.persist(fruit).invoke(() -&gt; emitter.send(fruit)) <i class="conum" data-value="4"></i><b>(4)</b>
                ));
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hibernate Reactive <code>SessionFactory</code> を注入します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Hibernate Reactive トランザクションを開始します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Kafka トランザクションを開始します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>ペイロードを永続化し、エンティティーを Kafka に送信します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>あるいは、 <code>@WithTransaction</code> アノテーションを使用してトランザクションを開始し、メソッドが返ったときにコミットすることもできます：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.faulttolerance.Bulkhead;
import org.eclipse.microprofile.reactive.messaging.Channel;

import io.quarkus.hibernate.reactive.panache.common.WithTransaction;
import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;

@Path("/")
public class FruitProducer {

    @Channel("kafka") KafkaTransactions&lt;Fruit&gt; kafkaTx;

    @POST
    @Path("/fruits")
    @Consumes(MediaType.APPLICATION_JSON)
    @Bulkhead(1)
    @WithTransaction <i class="conum" data-value="1"></i><b>(1)</b>
    public Uni&lt;Void&gt; post(Fruit fruit) {
        return kafkaTx.withTransaction(emitter -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            fruit.persist().invoke(() -&gt; emitter.send(fruit)) <i class="conum" data-value="3"></i><b>(3)</b>
        );
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hibernate Reactive トランザクションを開始し、メソッドが返ったらコミットします。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Kafka トランザクションを開始します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ペイロードを永続化し、エンティティーを Kafka に送信します。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="chaining-kafka-transactions-with-hibernate-orm-transactions"><a class="anchor" href="#chaining-kafka-transactions-with-hibernate-orm-transactions"></a>28.8. KafkaトランザクションとHibernate ORMトランザクションのチェーン</h3>
<div class="paragraph">
<p><code>KafkaTransactions</code> はKafkaトランザクションを管理するためにMutinyの上にリアクティブAPIを提供していますが、KafkaトランザクションをブロッキングHibernate ORMトランザクションとチェーンさせることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.transaction.Transactional;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.reactive.messaging.Channel;

import io.quarkus.logging.Log;
import io.smallrye.mutiny.Uni;
import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;

@Path("/")
public class FruitProducer {

    @Channel("kafka") KafkaTransactions&lt;Pet&gt; emitter;

    @POST
    @Path("/fruits")
    @Consumes(MediaType.APPLICATION_JSON)
    @Bulkhead(1)
    @Transactional <i class="conum" data-value="1"></i><b>(1)</b>
    public void post(Fruit fruit) {
        emitter.withTransaction(e -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            // if id is attributed by the database, will need to flush to get it
            // fruit.persistAndFlush();
            fruit.persist(); <i class="conum" data-value="3"></i><b>(3)</b>
            Log.infov("Persisted fruit {0}", p);
            e.send(p); <i class="conum" data-value="4"></i><b>(4)</b>
            return Uni.createFrom().voidItem();
        }).await().indefinitely(); <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hibernate ORM トランザクションを開始します。トランザクションは、メソッドが返されたときにコミットされます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Kafka トランザクションを開始します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ペイロードを永続化させます。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Kafka トランザクション内で Kafka にエンティティを送信します。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>返された <code>Uni</code> で Kafka トランザクションが完了するまで待ちます。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging"><a class="anchor" href="#logging"></a>29. ロギング</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kafkaクライアントによって書き込まれるログの量を減らすために、Quarkusは以下のログカテゴリーのレベルを <code>WARNING</code> に設定しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.apache.kafka.clients</code></p>
</li>
<li>
<p><code>org.apache.kafka.common.utils</code></p>
</li>
<li>
<p><code>org.apache.kafka.common.metrics</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下の行を <code>application.properties</code> に追加することで、設定を上書きすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."org.apache.kafka.clients".level=INFO
quarkus.log.category."org.apache.kafka.common.utils".level=INFO
quarkus.log.category."org.apache.kafka.common.metrics".level=INFO</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connecting-to-managed-kafka-clusters"><a class="anchor" href="#connecting-to-managed-kafka-clusters"></a>30. マネージド Kafka クラスターへの接続</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このセクションでは、ちょっとクセのある Kafka Cloud Services に接続する方法について説明します。</p>
</div>
<div class="sect2">
<h3 id="azure-event-hub"><a class="anchor" href="#azure-event-hub"></a>30.1. Azure Event Hub</h3>
<div class="paragraph">
<p><a href="https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview">Azure Event Hub</a> は、Apache Kafka と互換性のあるエンドポイントを提供します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Azure Event Hubs for Kafka は、<em>basic</em> 層では使用できません。Kafka を使用するには、少なくとも <em>standard</em> 層が必要です。他のオプションについては、 <a href="https://azure.microsoft.com/en-us/pricing/details/event-hubs/">Azure Event Hubs Pricing</a> を参照してください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TLS で Kafka プロトコルを使用して Azure Event Hub に接続するには、以下の設定が必要です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">kafka.bootstrap.servers=my-event-hub.servicebus.windows.net:9093 <i class="conum" data-value="1"></i><b>(1)</b>
kafka.security.protocol=SASL_SSL
kafka.sasl.mechanism=PLAIN
kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \ <i class="conum" data-value="2"></i><b>(2)</b>
    username="$ConnectionString" \ <i class="conum" data-value="3"></i><b>(3)</b>
    password="&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;"; <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ポートは <code>9093</code> です。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>JAAS の <code>PlainLoginModule</code> を使用する必要があります。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ユーザー名は <code>$ConnectionString</code> 文字列になります。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Azure が提供する Event Hub 接続文字列。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>&lt;YOUR.EVENTHUBS.CONNECTION.STRING&gt;</code> を Event Hubs 名前空間の接続文字列に置き換えます。接続文字列を取得する手順については、 <a href="https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string">Get an Event Hubs connection string</a> を参照してください。結果は、以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
    username="$ConnectionString" \
    password="Endpoint=sb://my-event-hub.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=XXXXXXXXXXXXXXXX";</code></pre>
</div>
</div>
<div class="paragraph">
<p>この設定は、(上記のように) グローバルにすることも、チャネル設定で設定することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.incoming.$channel.bootstrap.servers=my-event-hub.servicebus.windows.net:9093
mp.messaging.incoming.$channel.security.protocol=SASL_SSL
mp.messaging.incoming.$channel.sasl.mechanism=PLAIN
mp.messaging.incoming.$channel.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
    username="$ConnectionString" \
    password="Endpoint=sb://my-event-hub.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=...";</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="red-hat-openshift-streams-for-apache-kafka"><a class="anchor" href="#red-hat-openshift-streams-for-apache-kafka"></a>30.2. Red Hat OpenShift Streams for Apache Kafka</h3>
<div class="paragraph">
<p><a href="https://cloud.redhat.com/">Red Hat OpenShift Streams for Apache Kafka</a> は、マネージド Kafka ブローカーを提供します。まず、 <a href="https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3">Getting started with the <code>rhoas</code> CLI for Red Hat OpenShift Streams for Apache Kafka</a> の指示に従い、Kafka ブローカーインスタンスを作成します。作成した <em>ServiceAccount</em> に関連付けられているクライアント ID とクライアントシークレットをコピーしたことを確認してください。</p>
</div>
<div class="paragraph">
<p>続いて、以下のようにブローカーに接続するように Quarkus アプリケーションを設定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">kafka.bootstrap.servers=&lt;connection url&gt; <i class="conum" data-value="1"></i><b>(1)</b>
kafka.security.protocol=SASL_SSL
kafka.sasl.mechanism=PLAIN
kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
  username="${KAFKA_USERNAME}" \ <i class="conum" data-value="2"></i><b>(2)</b>
  password="${KAFKA_PASSWORD}"; <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>管理コンソールに指定されている接続文字列 (例: <code>demo-c&#8212;&#8203;bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443</code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>kafka ユーザー名 (サービスアカウントのクライアント ID)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>kafka パスワード (サービスアカウントからのクライアントシークレット)</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
一般に、これらのプロパティーには <code>%prod</code> という接頭辞を付け、本番モードで動作しているときのみ有効化します。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<a href="https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3">Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka</a> で説明されているように、Red Hat OpenShift Streams for Apache Kafka を使用するには、事前にトピックを作成し、<em>Service Account</em> を作成し、そのサービスアカウントからトピックの読み取りと書き込みを行うためのパーミッションを提供する必要があります。認証データ (クライアント ID とシークレット) はサービスアカウントに関連しています。つまり、詳細なアクセスパーミッションを実装し、トピックへのアクセスを制限できます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kubernetes を使用する場合は、クライアント ID とシークレットを Kubernetes シークレットに設定することをお勧めします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
  name: kafka-credentials
stringData:
  KAFKA_USERNAME: "..."
  KAFKA_PASSWORD: "..."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quarkus アプリケーションがそのシークレットを使用できるようにするには、 <code>application.properties</code> ファイルに以下の行を追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.openshift.env.secrets=kafka-credentials</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="red-hat-openshift-service-registry"><a class="anchor" href="#red-hat-openshift-service-registry"></a>30.2.1. Red Hat OpenShift Service Registry</h4>
<div class="paragraph">
<p><a href="https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry">Red Hat OpenShift Service Registry</a> は、Kafka スキーマを処理するためのフルマネージドサービスレジストリーを提供します。</p>
</div>
<div class="paragraph">
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d">Getting started with Red Hat OpenShift Service Registry</a> の説明に従って、または <code>rhoas</code> CLI を使用して、新しいサービスレジストリーのインスタンスを作成することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">rhoas service-registry create --name my-schema-registry</code></pre>
</div>
</div>
<div class="paragraph">
<p>作成されたインスタンスの <em>Registry URL</em> を書き留めてください。認証には、以前に作成したものと同じ <em>ServiceAccount</em> を使用できます。サービスレジストリーにアクセスするために必要なパーミッションがあることを確認する必要があります。</p>
</div>
<div class="paragraph">
<p>たとえば、 <code>rhoas</code> CLI を使用して、サービスアカウントに <code>MANAGER</code> ロールを付与することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">rhoas service-registry role add --role manager --service-account [SERVICE_ACCOUNT_CLIENT_ID]</code></pre>
</div>
</div>
<div class="paragraph">
<p>続いて、以下のようにスキーマレジストリーに接続するように Quarkus アプリケーションを設定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">mp.messaging.connector.smallrye-kafka.apicurio.registry.url=${RHOAS_SERVICE_REGISTRY_URL} <i class="conum" data-value="1"></i><b>(1)</b>
mp.messaging.connector.smallrye-kafka.apicurio.auth.service.token.endpoint=${RHOAS_OAUTH_TOKEN_ENDPOINT} <i class="conum" data-value="2"></i><b>(2)</b>
mp.messaging.connector.smallrye-kafka.apicurio.auth.client.id=${RHOAS_CLIENT_ID} <i class="conum" data-value="3"></i><b>(3)</b>
mp.messaging.connector.smallrye-kafka.apicurio.auth.client.secret=${RHOAS_CLIENT_ID} <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>管理コンソールで指定されているサービスレジストリーの URL (例: <code><a href="https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2" class="bare">https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2</a></code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>OAuth トークンエンドポイント URL (例: <code><a href="https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token" class="bare">https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token</a></code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>クライアント ID (サービスアカウントから)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>クライアントシークレット (サービスアカウントから)</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="binding-red-hat-openshift-managed-services-to-quarkus-application-using-the-service-binding-operator"><a class="anchor" href="#binding-red-hat-openshift-managed-services-to-quarkus-application-using-the-service-binding-operator"></a>30.2.2. Service Binding Operator を使用した Red Hat OpenShift マネージドサービスの Quarkus アプリケーションへのバインド</h4>
<div class="paragraph">
<p>Quarkus アプリケーションが、<a href="https://github.com/redhat-developer/service-binding-operator">Service Binding Operator</a> および <a href="https://github.com/redhat-developer/app-services-operator/tree/main/docs">OpenShift Application Services</a> オペレーターをインストールした Kubernetes または OpenShift クラスターにデプロイされている場合、Red Hat OpenShift Streams for Apache Kafka と Service Registry へのアクセスに必要な設定は、<a href="deploying-to-kubernetes#service_binding">Kubernetes Service Binding</a> を使用してアプリケーションに注入することができます。</p>
</div>
<div class="paragraph">
<p>Service Binding をセットアップするには、最初に OpenShift マネージドサービスをクラスターに接続する必要があります。OpenShift クラスターの場合は、<a href="https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster">Connecting a Kafka and Service Registry instance to your OpenShift cluster</a> の指示に従います。</p>
</div>
<div class="paragraph">
<p>クラスタとRHOAS KafkaおよびService Registryインスタンスを接続したら、新しく作成したサービスアカウントに必要なパーミッションが付与されていることを確認してください。</p>
</div>
<div class="paragraph">
<p>次に、<a href="deploying-to-kubernetes#service_binding">Kubernetes Service Binding</a> 拡張を使用して、これらのサービス用の <code>ServiceBinding</code> リソースを生成するように Quarkus アプリケーションを構成できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.kubernetes-service-binding.detect-binding-resources=true

quarkus.kubernetes-service-binding.services.kafka.api-version=rhoas.redhat.com/v1alpha1
quarkus.kubernetes-service-binding.services.kafka.kind=KafkaConnection
quarkus.kubernetes-service-binding.services.kafka.name=my-kafka

quarkus.kubernetes-service-binding.services.serviceregistry.api-version=rhoas.redhat.com/v1alpha1
quarkus.kubernetes-service-binding.services.serviceregistry.kind=ServiceRegistryConnection
quarkus.kubernetes-service-binding.services.serviceregistry.name=my-schema-registry</code></pre>
</div>
</div>
<div class="paragraph">
<p>この例では、Quarkus のビルドにより、次の <code>ServiceBinding</code> リソースが生成されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: binding.operators.coreos.com/v1alpha1
kind: ServiceBinding
metadata:
  name: my-app-kafka
spec:
  application:
    group: apps.openshift.io
    name: my-app
    version: v1
    kind: DeploymentConfig
  services:
    - group: rhoas.redhat.com
      version: v1alpha1
      kind: KafkaConnection
      name: my-kafka
  detectBindingResources: true
  bindAsFiles: true
---
apiVersion: binding.operators.coreos.com/v1alpha1
kind: ServiceBinding
metadata:
  name: my-app-serviceregistry
spec:
  application:
    group: apps.openshift.io
    name: my-app
    version: v1
    kind: DeploymentConfig
  services:
    - group: rhoas.redhat.com
      version: v1alpha1
      kind: ServiceRegistryConnection
      name: my-schema-registry
  detectBindingResources: true
  bindAsFiles: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="deploying-to-kubernetes#openshift">Deploying to OpenShift</a>に従って、生成した <code>ServiceBinding</code> リソースを含むアプリケーションをデプロイすることが可能です。  KafkaとSchema Registryのインスタンスにアクセスするために必要な設定プロパティは、デプロイ時に自動的にアプリケーションに注入されます。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="going-further"><a class="anchor" href="#going-further"></a>31. さらに詳しく</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このガイドでは、Quarkus を使用して Kafka と対話する方法を説明しました。
Quarkus Messaging を活用して、データストリーミングアプリケーションを構築します。</p>
</div>
<div class="paragraph">
<p>詳細は、Quarkus で使用される実装 <a href="https://smallrye.io/smallrye-reactive-messaging">SmallRye Reactive Messaging</a> のドキュメントを確認してください。</p>
</div>
</div>
</div>
    </div>
    <div class="grid__item width-4-12 width-12-12-m tocwrapper">
      <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#introduction">1. はじめに</a></li>
<li><a href="#quarkus-extension-for-apache-kafka">2. Apache Kafka のための Quarkus エクステンション</a></li>
<li><a href="#configuring-smallrye-kafka-connector">3. SmallRye Kafka コネクターの設定</a></li>
<li><a href="#receiving-messages-from-kafka">4. Kafka からのメッセージの受信</a>
<ul class="sectlevel2">
<li><a href="#blocking-processing">4.1. ブロッキング処理</a></li>
<li><a href="#acknowledgment-strategies">4.2. 確認戦略</a></li>
<li><a href="#commit-strategies">4.3. コミットストラテジー</a></li>
<li><a href="#error-handling">4.4. エラー処理戦略</a></li>
<li><a href="#consumer-groups">4.5. コンシューマーグループ</a></li>
<li><a href="#receiving-kafka-records-in-batches">4.6. バッチでの Kafka レコードの受信</a></li>
<li><a href="#stateful-processing-checkpointing">4.7. チェックポイントによるステートフル処理</a></li>
</ul>
</li>
<li><a href="#sending-messages-to-kafka">5. Kafka へのメッセージの送信</a>
<ul class="sectlevel2">
<li><a href="#sending-messages-with-emitter">5.1. Emitter を使ったメッセージの送信</a></li>
<li><a href="#write-acknowledgement">5.2. 確認応答の書き込み</a></li>
<li><a href="#backpressure">5.3. バックプレッシャー</a></li>
<li><a href="#retrying-message-dispatch">5.4. メッセージディスパッチの再試行</a></li>
<li><a href="#handling-serialization-failures">5.5. シリアライゼーション失敗時の処理</a></li>
<li><a href="#in-memory-channels">5.6. インメモリーチャンネル</a></li>
<li><a href="#broadcasting-messages-on-multiple-consumers">5.7. 複数のコンシューマーでのメッセージのブロードキャスト</a></li>
<li><a href="#kafka-transactions">5.8. Kafka トランザクション</a></li>
</ul>
</li>
<li><a href="#kafka-request-reply">6. Kafka request-reply</a></li>
<li><a href="#processing-messages">7. メッセージの処理</a>
<ul class="sectlevel2">
<li><a href="#propagating-record-key">7.1. レコードキーの伝播</a></li>
<li><a href="#exactly-once-processing">7.2. Exactly-Once 処理</a></li>
</ul>
</li>
<li><a href="#kafka-bare-clients">8. Kafka クライアントへの直接アクセス</a></li>
<li><a href="#kafka-serialization">9. JSON シリアライゼーション</a>
<ul class="sectlevel2">
<li><a href="#jackson-serialization">9.1. Jackson を介したシリアライズ</a></li>
<li><a href="#jsonb-serialization">9.2. JSON-B を介したシリアライズ</a></li>
</ul>
</li>
<li><a href="#avro-serialization">10. Avro シリアライゼーション</a></li>
<li><a href="#json-schema-serialization">11. JSON スキーマシリアライゼーション</a></li>
<li><a href="#serialization-autodetection">12. シリアライザー/デシリアライザーの自動検出</a></li>
<li><a href="#serialization-generation">13. JSON シリアライザー/デシリアライザーの生成</a></li>
<li><a href="#using-schema-registry">14. スキーマレジストリーの使用</a></li>
<li><a href="#kafka-health-check">15. ヘルスチェック</a>
<ul class="sectlevel2">
<li><a href="#kafka-broker-readiness-check">15.1. Kafka ブローカー rediness チェック</a></li>
<li><a href="#kafka-reactive-messaging-health-checks">15.2. Kafka Reactive Messaging ヘルスチェック</a></li>
</ul>
</li>
<li><a href="#observability">16. Observability</a>
<ul class="sectlevel2">
<li><a href="#channel-metrics">16.1. チャネルメトリクス</a></li>
</ul>
</li>
<li><a href="#kafka-streams">17. Kafka Streams</a></li>
<li><a href="#using-snappy-for-message-compression">18. メッセージ圧縮での Snappy の使用</a></li>
<li><a href="#authentication-with-oauth">19. OAuth を使用した認証</a></li>
<li><a href="#tls-configuration">20. TLS 設定</a></li>
<li><a href="#testing-a-kafka-application">21. Kafka アプリケーションのテスト</a>
<ul class="sectlevel2">
<li><a href="#testing-without-a-broker">21.1. ブローカーなしでのテスト</a></li>
<li><a href="#testing-using-a-kafka-broker">21.2. Kafka ブローカーを使用したテスト</a></li>
</ul>
</li>
<li><a href="#kafka-dev-services">22. Dev Services for Kafka</a>
<ul class="sectlevel2">
<li><a href="#enabling-disabling-dev-services-for-kafka">22.1. KafkaのDev Servicesの有効化／無効化</a></li>
<li><a href="#shared-broker">22.2. 共有ブローカー</a></li>
<li><a href="#setting-the-port">22.3. ポートの設定</a></li>
<li><a href="#configuring-the-image">22.4. イメージの設定</a></li>
<li><a href="#configuring-kafka-topics">22.5. Kafkaトピックの設定</a></li>
<li><a href="#redpanda-transactions">22.6. トランザクションとべき等プロデューサーのサポート</a></li>
<li><a href="#Compose">22.7. Compose</a></li>
<li><a href="#configuration-reference-devservices">22.8. 設定リファレンス</a></li>
</ul>
</li>
<li><a href="#kafka-dev-ui">23. Kafka Dev UI</a></li>
<li><a href="#kubernetes-service-bindings">24. Kubernetes サービスバインディング</a></li>
<li><a href="#execution-model">25. 実行モデル</a></li>
<li><a href="#channel-decorators">26. チャンネルデコレーター</a></li>
<li><a href="#kafka-configuration">27. 設定リファレンス</a>
<ul class="sectlevel2">
<li><a href="#incoming-channel-configuration-polling-from-kafka">27.1. 着信チャネル設定 (Kafka からのポーリング)</a></li>
<li><a href="#outgoing-channel-configuration-writing-to-kafka">27.2. outgoingチャンネルの設定（Kafkaへの書き込み)</a></li>
<li><a href="#kafka-configuration-resolution">27.3. Kafka 設定の解決</a></li>
<li><a href="#conditionally-configure-channels">27.4. 条件付きでチャンネルを設定する</a></li>
</ul>
</li>
<li><a href="#integrating-with-kafka-common-patterns">28. Kafka との統合 - 一般的なパターン</a>
<ul class="sectlevel2">
<li><a href="#writing-to-kafka-from-an-http-endpoint">28.1. HTTP エンドポイントから Kafka への書き込み</a></li>
<li><a href="#persisting-kafka-messages-with-hibernate-with-panache">28.2. Hibernate with Panache での Kafka メッセージの永続化</a></li>
<li><a href="#persisting-kafka-messages-with-hibernate-reactive">28.3. Hibernate Reactive を使用した Kafka メッセージの永続化</a></li>
<li><a href="#writing-entities-managed-by-hibernate-to-kafka">28.4. Hibernate が管理するエンティティーの Kafka への書き込み</a></li>
<li><a href="#writing-entities-managed-by-hibernate-reactive-to-kafka">28.5. Hibernate Reactive が管理するエンティティーの Kafka への書き込み</a></li>
<li><a href="#streaming-kafka-topics-as-server-sent-events">28.6. サーバー送信イベントとしての Kafka トピックのストリーミング</a></li>
<li><a href="#chaining-kafka-transactions-with-hibernate-reactive-transactions">28.7. Kafka トランザクションと Hibernate Reactive トランザクションとのチェーン</a></li>
<li><a href="#chaining-kafka-transactions-with-hibernate-orm-transactions">28.8. KafkaトランザクションとHibernate ORMトランザクションのチェーン</a></li>
</ul>
</li>
<li><a href="#logging">29. ロギング</a></li>
<li><a href="#connecting-to-managed-kafka-clusters">30. マネージド Kafka クラスターへの接続</a>
<ul class="sectlevel2">
<li><a href="#azure-event-hub">30.1. Azure Event Hub</a></li>
<li><a href="#red-hat-openshift-streams-for-apache-kafka">30.2. Red Hat OpenShift Streams for Apache Kafka</a></li>
</ul>
</li>
<li><a href="#going-further">31. さらに詳しく</a></li>
</ul></div>
    </div>
  </div>
  <h2>関連コンテンツ</h2>
  <div class="grid-wrapper relations">
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じエクステンションについて</h3>
      <ul class="related-content">
      
        
        <li class="guide"><a href="/version/3.27/guides/apicurio-registry-dev-services">Dev Services for Apicurio Registry</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-dev-services">Dev Services for Kafka</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-getting-started">Apache Kafkaを使用したQuarkusメッセージング入門</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-dev-ui">Kafka Dev UI</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/messaging-virtual-threads">Reactive MessagingによるQuarkus仮想スレッドのサポート</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-schema-registry-avro"> Schema RegistryとAvroと共にApache Kafkaを使用</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-schema-registry-json-schema">スキーマレジストリとJSONスキーマと共にApache Kafkaを使用する</a></li>
      </ul>
    </div>
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じトピックについて</h3>
      <ul class="related-content">
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-getting-started">Apache Kafkaを使用したQuarkusメッセージング入門</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/messaging-virtual-threads">Reactive MessagingによるQuarkus仮想スレッドのサポート</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/pulsar">Apache Pulsar リファレンス・ガイド</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/apicurio-registry-dev-services">Dev Services for Apicurio Registry</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-dev-services">Dev Services for Kafka</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/pulsar-dev-services">Dev Services for Pulsar</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/rabbitmq-dev-services">Dev Services for RabbitMQ</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/pulsar-getting-started">Apache PulsarによるQuarkusメッセージングの開始</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/rabbitmq">RabbitMQを使用したQuarkusメッセージング入門</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-dev-ui">Kafka Dev UI</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/messaging">Quarkus Messagingエクステンション</a></li>
      
        
        <li class="reference"><a href="/version/3.27/guides/rabbitmq-reference">リアクティブメッセージング RabbitMQ コネクターのリファレンスドキュメント</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-streams">Apache Kafka ストリームの使用</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-schema-registry-avro"> Schema RegistryとAvroと共にApache Kafkaを使用</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/kafka-schema-registry-json-schema">スキーマレジストリとJSONスキーマと共にApache Kafkaを使用する</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/amqp-dev-services">Dev Services for AMQP</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/amqp">AMQP 1.0を使用したQuarkusのメッセージング入門</a></li>
      
        
        <li class="reference"><a href="/version/3.27/guides/amqp-reference">リアクティブメッセージング AMQP1.0 コネクターリファレンスドキュメント</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/jms">JMSの使用</a></li>
      
        
        <li class="guide"><a href="/version/3.27/guides/reactive-event-bus">イベントバスの使用</a></li>
      </ul>
    </div>
    </div>
  </div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license. <i class='fab fa-creative-commons'></i><i class='fab fa-creative-commons-by'></i> <a href='https://creativecommons.org/licenses/by/3.0/' target='_blank'>CC by 3.0</a><br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>GitHub Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
          
            <li><a href="/" target="_blank">ホーム</a></li>
          
          
          
            <li><a href="/about" target="_blank">Quarkusについて</a></li>
          
          
          
            <li><a href="/blog" target="_blank">ブログ</a></li>
          
          
          
            <li><a href="/insights" target="_blank">ポッドキャスト</a></li>
          
          
          
            <li><a href="/events" target="_blank">イベント</a></li>
          
          
          
            <li><a href="/newsletter" target="_blank">ニュースレター</a></li>
          
          
          
            <li><a href="/userstories" target="_blank">ユーザーストーリー</a></li>
          
          
          
            <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" target="_blank">ロードマップ</a></li>
          
          
          
            <li><a href="/security" target="_blank">セキュリティ&nbsp;ポリシー</a></li>
          
          
          
            <li><a href="/usage" target="_blank">使用方法</a></li>
          
          
          
            <li><a href="/brand" target="_blank">Brand</a></li>
          
          
          
            <li><a href="/desktopwallpapers" target="_blank">Wallpapers</a></li>
          
          
          
            <li><a href="https://www.redhat.com/en/about/privacy-policy" target="_blank">Privacy Policy</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォローする</span>
        <ul class="footer-links">
          
          
            <li><a href="https://x.com/quarkusio" target="_blank">X</a></li>
          
          
          
            <li><a href="https://bsky.app/profile/quarkus.io" target="_blank">Bluesky</a></li>
          
          
          
            <li><a rel="me" href="https://fosstodon.org/@quarkusio" target="_blank">Mastodon</a></li>
            
          
          
            <li><a href="https://www.threads.com/@quarkusio" target="_blank">Threads</a></li>
          
          
          
            <li><a href="https://www.facebook.com/quarkusio" target="_blank">Facebook</a></li>
          
          
          
            <li><a href="https://www.linkedin.com/company/quarkusio/" target="_blank">Linkedin</a></li>
          
          
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg" target="_blank">Youtube</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio" target="_blank">GitHub</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
          
            <li><a href="/support" target="_blank">サポート</a></li>
          
          
          
            <li><a href="/guides" target="_blank">ガイド</a></li>
          
          
          
            <li><a href="/faq" target="_blank">FAQ</a></li>
          
          
          
            <li><a href="/get-started" target="_blank">入門</a></li>
          
          
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus" target="_blank">Stack Overflow</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions" target="_blank">ディスカッション</a></li>
          
          
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev" target="_blank">開発メーリングリスト</a></li>
          
          
          
            <li><a href="https://stats.uptimerobot.com/ze1PfweT2p" target="_blank">Quarkus Service Status</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>言語</span>
        <ul class="footer-links">
          
          
            <li><a href=" https://quarkus.io/ " target="_blank">English</a></li>
          
          
          
            <li><a href="https://pt.quarkus.io/" target="_blank">Português&nbsp;(Brasileiro)</a></li>
          
          
          
            <li><a href=" https://es.quarkus.io/ " target="_blank">Español</a></li>
          
          
          
            <li><a href="https://cn.quarkus.io/" target="_blank">简体中文</a></li>
          
          
          
            <li><a href=" https://ja.quarkus.io/ " target="_blank">日本語</a></li>
          
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています</span>
        <ul class="footer-links">
          
            <li><a blah href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a blah href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a blah href="https://hibernate.org" target="_blank">Hibernate ORM</a></li>
          
            <li><a blah href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a blah href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a blah href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a blah href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a blah href="https://code.quarkus.io/" target="_blank">その他多数...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content cf-footer">
  <div class="flexcontainer">
    <div class="cf-logo">
      <a class="cf-logo" href="https://www.commonhaus.org/" target="_blank"><img src="https://raw.githubusercontent.com/commonhaus/artwork/main/foundation/brand/svg/CF_logo_horizontal_single_reverse.svg"/></a>
    </div>
    <div class="license">
      Copyright © Quarkus. All rights reserved. For details on our trademarks, please visit our <a href="https://www.commonhaus.org/policies/trademark-policy/">Trademark Policy</a> and <a href="https://www.commonhaus.org/trademarks/">Trademark List</a>. Trademarks of third parties are owned by their respective holders and their mention here does not suggest any endorsement or association.
    </div>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
  <script src="/assets/javascript/future-date.js" type="text/javascript"></script>
  <script src="/assets/javascript/randomize.js" type="text/javascript"></script>
  <script src="/assets/javascript/time.js" type="text/javascript"></script>
</body>

</html>
