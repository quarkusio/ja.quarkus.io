<!DOCTYPE html>
<html lang="ja">







<head>
  <title>Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム - main - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="
  connect-src 'self' https://dpm.demdex.net https://adobedc.demdex.net https://analytics.ossupstream.org/ https://search.quarkus.io https://smetrics.redhat.com https://ajax.googleapis.com; 
  script-src 'self' 'unsafe-inline' 'unsafe-eval'
      
      https://assets.adobedtm.com
      js.bizographics.com
      https://www.redhat.com
      https://static.redhat.com
      https://app.requestly.io/
      jsonip.com
      https://ajax.googleapis.com
      https://use.fontawesome.com
      http://www.youtube.com
      http://www.googleadservices.com
      https://googleads.g.doubleclick.net
      https://giscus.app
      https://analytics.ossupstream.org/
      https://app.mailjet.com;

  style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; 
  img-src 'self' * data:; 
  media-src 'self'; 
  frame-src https://redhat.demdex.net https://www.youtube.com https://player.restream.io https://app.mailjet.com http://xy0p2.mjt.lu https://mj.quarkus.io https://giscus.app; 
  base-uri 'none'; 
  object-src 'none'; 
  form-action 'none'; 
  font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />

  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/version/main/guides/security-oidc-code-flow-authentication" />
  <meta property="og:title" content="Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム - main" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/security-oidc-code-flow-authentication">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />  
  <script src="/assets/javascript/tracking.js"></script>
  
  <script src="/assets/javascript/colormode.js" type="text/javascript"></script>

</head>

<body class="guides">

  


<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io/version/main/guides/security-oidc-code-flow-authentication">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
        <div class="logo-wrapper">
           <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
        </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="#">Why<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/performance" class="">パフォーマンス</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
          <li><a href="/versatility" class="">多用途性</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/spring" class="">USING SPRING?</a></li>
          <li class="tertiarydropdown">
            <span href="#">AI<i class="fas fa-chevron-down"></i></span>
            <ul class="tertiarymenu">
              <li><a href="/ai" class="">AI OVERVIEW</a></li>
              <li><a href="/java-for-ai" class="">JAVA FOR AI</a></li>
              <li><a href="/quarkus-for-ai" class="">WHY QUARKUS FOR AI</a></li>
              <li><a href="/ai-blueprints" class="">AI BLUEPRINTS</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Learn<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ドキュメント</a></li>
          <li><a href="/userstories/" class="">ユーザーストーリー</a></li>  
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="#">Extensions<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          
          <!-- Note that quarkus.io is hardcoded here, because it is the only url which supports extensions -->
<li><a href="https://quarkus.io/extensions/" class="">エクステンションを探す</a></li>
          <li><a href="/faq/#what-is-a-quarkus-extension" class="">エクステンションの使用</a></li>
          <li><a href="/guides/writing-extensions" class="">エクステンションの作成</a></li>
          <li><a href="https://hub.quarkiverse.io" class="">エクステンションの共有</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Community<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/working-groups" class="">ワーキンググループ</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="">ロードマップ</a></li>
          <li><a href="/benefactors" class="">BENEFACTORS</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/version/main/guides/security-oidc-code-flow-authentication" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://pt.quarkus.io/version/main/guides/security-oidc-code-flow-authentication">ポルトガル（BR）</a></li>
          <li><a href="https://es.quarkus.io/version/main/guides/security-oidc-code-flow-authentication">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/version/main/guides/security-oidc-code-flow-authentication">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/version/main/guides/security-oidc-code-flow-authentication">日本語</a></li>
          </ul>
      </li>
      <li>
        <span href="#" class="modeswitcher" id='theme-toggle'><i class="fas
fa-sun"></i><i class="fas fa-moon"></i><i class="fas fa-cog"></i></span>
      </li>
    </ul>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    







<section class="full-width-version-bg flexfilterbar guides">
  <div class="guideflexcontainer">
    <div class="docslink">
      <a class="returnlink" href="/version/main/guides/"> Back to Guides</a>
    </div>
    <div class="flexlabel">
      <label>バージョン:</label>
    </div>
    <div class="guidepulldown version">
    <select id="guide-version-dropdown">
      
        
        
        <option value="main" selected>Main - SNAPSHOT</option>
        
        
        
        <option value="latest" >3.31.3 - Latest</option>
        
        
        
        <option value="3.27" >3.27</option>
        
        
        
        <option value="3.20" >3.20</option>
        
        
        
        <option value="3.15" >3.15</option>
        
        
        
        <option value="3.8" >3.8</option>
        </select>
    </div>
  </div>
</section>

<div class="guide">
  <div class="grid-wrapper">
    <div class="grid__item width-8-12 width-12-12-m">
      
      <a class="editlink" href="https://github.com/quarkusio/quarkus/edit/main/docs/src/main/asciidoc/security-oidc-code-flow-authentication.adoc">このページを編集</a>
      
      <h1 class="text-caps">Web アプリケーションを保護するための OpenID Connect 認可コードフローメカニズム </h1>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>ウェブアプリケーションを保護するには、Quarkus OIDCエクステンションが提供する業界標準のOpenID Connect（OIDC）認可コードフローメカニズムを使用できます。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview-of-the-oidc-authorization-code-flow-mechanism"><a class="anchor" href="#overview-of-the-oidc-authorization-code-flow-mechanism"></a>OIDC認可コードフローメカニズムの概要</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus OpenID Connect（OIDC）エクステンションは、 <a href="https://www.keycloak.org">Keycloak</a> などのOIDC準拠の認可サーバーでサポートされているOIDC認可コードフローメカニズムを使用して、アプリケーションHTTPエンドポイントを保護できます。</p>
</div>
<div class="paragraph">
<p>このエクステンションは、OpenID Connect Provider (例: Keycloak) にリダイレクトしてログインさせ、認証が完了したら、認証に成功したことを確認するコードを使って、ウェブアプリケーションのユーザーを簡単に認証することができます。エクステンションは、認可コードグラントを使用して OpenID Connect Provider から ID とアクセストークンを要求し、アプリケーションへのアクセスを承認するためにこれらのトークンを検証します。</p>
</div>
<div class="paragraph">
<p>次の図は、Quarkus における認可コードフローメカニズムの概要を示しています。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/authorization_code_flow.png" alt="Authorization Code Flow" width="60%">
</div>
<div class="title">Figure 1. Quarkusにおける認可コードフローメカニズム</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Quarkusユーザーは、Quarkus <code>web-app</code> アプリケーションへのアクセスを要求します。</p>
</li>
<li>
<p>Quarkus Webアプリは、ユーザーを認可エンドポイント、つまり認証用のOIDCプロバイダーにリダイレクトします。</p>
</li>
<li>
<p>OIDCプロバイダは、ユーザーをログインと認証のプロンプトにリダイレクトします。</p>
</li>
<li>
<p>プロンプトで、ユーザーは自分のユーザークレデンシャルを入力します。</p>
</li>
<li>
<p>OIDCプロバイダーは、入力されたユーザーのクレデンシャルを認証し、認証に成功すると認可コードを発行し、そのコードをクエリパラメータとして含めてQuarkusウェブアプリにユーザーをリダイレクトします。</p>
</li>
<li>
<p>Quarkus Webアプリケーションは、この認可コードをOIDCプロバイダーと交換し、ID、アクセス、およびリフレッシュの各トークンを取得します。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>認可コードフローが完了し、Quarkus Webアプリは発行されたトークンを使用してユーザーに関する情報にアクセスし、そのユーザーに関連するロールベースの認可を付与します。発行されるトークンは以下の通りです:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IDトークン: Quarkus <code>web-app</code> アプリケーションは、IDトークンのユーザー情報を使用して、認証されたユーザーが安全にログインできるようにし、Webアプリケーションにロールベースのアクセスを提供します。</p>
</li>
<li>
<p>アクセストークン: Quarkus Webアプリは、アクセストークンを使用してUserInfo APIにアクセスし、認証されたユーザーに関する追加情報を取得したり、別のエンドポイントに伝播したりすることがあります。</p>
</li>
<li>
<p>リフレッシュ トークン: (オプション) ID およびアクセス トークンの有効期限が切れた場合、Quarkus ウェブアプリはリフレッシュ トークンを使用して新しい ID およびアクセス トークンを取得できます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="security-oidc-configuration-properties-reference">OIDC設定プロパティ</a> のリファレンスガイドもご参照ください。</p>
</div>
<div class="paragraph">
<p>OIDC認可コードフローメカニズムを使用してWebアプリケーションを保護する方法については、 <a href="security-oidc-code-flow-authentication-tutorial">OIDC認可コードフローを使用したWebアプリケーションの保護</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>OIDCベアラートークン認証を使用してサービスアプリケーションを保護したい場合は、 <a href="security-oidc-bearer-token-authentication">OIDCベアラートークン認証</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>マルチテナントへの対応方法については、 <a href="security-openid-connect-multitenancy">OpenID Connect (OIDC) マルチテナンシーの使用</a> ガイドをお読みください。</p>
</div>
<div class="paragraph">
<p>If you are a Vert.x OIDC user, learn about migration options in the <a href="security-vertx-oidc-to-quarkus-oidc-migration">Migrate from Vert.x OIDC to Quarkus OIDC</a> guide.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-the-authorization-code-flow-mechanism"><a class="anchor" href="#using-the-authorization-code-flow-mechanism"></a>認可コードフローメカニズムの利用について</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="configuring-quarkus-to-support-authorization-code-flow"><a class="anchor" href="#configuring-quarkus-to-support-authorization-code-flow"></a>認証コードフローをサポートするためのQuarkusの設定</h3>
<div class="paragraph">
<p>認証コードフロー認証を有効にするには、 <code>quarkus.oidc.application-type</code> プロパティを <code>web-app</code> に設定する必要があります。
通常、Quarkus OIDC <code>web-app</code> アプリケーションタイプは、Quarkus アプリケーションが HTML ページを提供するフロントエンドアプリケーションで、OIDC シングルサインオンログインが必要な場合に設定する必要があります。
Quarkus OIDC <code>web-app</code> アプリケーションでは、認可コードフローがユーザー認証の優先方法として定義されています。
アプリケーションが HTML ページを提供すると同時に REST API を提供し、認証コードフロー認証と <a href="security-oidc-bearer-token-authentication">ベアラアクセストークン認証</a>の 両方が必要な場合、代わりに <code>quarkus.oidc.application-type</code> プロパティを <code>hybrid</code> に設定できます。この場合、ベアラ・アクセストークンを含む <code>Bearer</code> 認証スキームを持つ HTTP <code>Authorization</code> リクエスト・ヘッダが設定されていない場合にのみ、認可コード・フローがトリガされます。</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-access-to-the-oidc-provider-endpoint"><a class="anchor" href="#configuring-access-to-the-oidc-provider-endpoint"></a>OIDCプロバイダー・エンドポイントへのアクセス設定</h3>
<div class="paragraph">
<p>OIDC <code>web-app</code> アプリケーションは、OIDC プロバイダーの認可、トークン、 <code>JsonWebKey</code> （JWK）セット、そして場合によっては <code>UserInfo</code> 、イントロスペクション、セッション終了（RP-initiated logout）エンドポイントの URL を必要とします。</p>
</div>
<div class="paragraph">
<p>規約により、 <code>quarkus.oidc.auth-server-url</code> で設定することで <code>/.well-known/openid-configuration</code> のパスを追加することで検出されます。</p>
</div>
<div class="paragraph">
<p>また、ディスカバリー・エンドポイントが利用できない場合や、ディスカバリー・エンドポイントのラウンドトリップを減らしたい場合は、エンドポイントのディスカバリーを無効にし、相対パス値を設定することもできます。
例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.discovery-enabled=false
# Authorization endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/auth
quarkus.oidc.authorization-path=/protocol/openid-connect/auth
# Token endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/token
quarkus.oidc.token-path=/protocol/openid-connect/token
# JWK set endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/certs
quarkus.oidc.jwks-path=/protocol/openid-connect/certs
# UserInfo endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/userinfo
quarkus.oidc.user-info-path=/protocol/openid-connect/userinfo
# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/token/introspect
quarkus.oidc.introspection-path=/protocol/openid-connect/token/introspect
# End-session endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/logout
quarkus.oidc.end-session-path=/protocol/openid-connect/logout</code></pre>
</div>
</div>
<div class="paragraph">
<p>一部の OIDC プロバイダは、メタデータディスカバリーをサポートしていますが、認可コードフローを完了したり、ユーザーログアウトなどのアプリケーション機能をサポートしたりするために必要なすべてのエンドポイント URL 値は返しません。
この制限を回避するには、次の例に示すように、不足しているエンドポイント URL 値をローカルで設定します：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Metadata is auto-discovered but it does not return an end-session endpoint URL

quarkus.oidc.auth-server-url=http://localhost:8180/oidcprovider/account

# Configure the end-session URL locally.
# It can be an absolute or relative (to 'quarkus.oidc.auth-server-url') address
quarkus.oidc.end-session-path=logout</code></pre>
</div>
</div>
<div class="paragraph">
<p>検出されたエンドポイントURLがローカルのQuarkusエンドポイントで機能せず、より具体的な値が必要な場合は、この同じ設定を使用して、エンドポイントURLをオーバーライドできます。
たとえば、グローバルエンドセッションエンドポイントとアプリケーション固有のエンドセッションエンドポイントの両方をサポートするプロバイダは、次のようなグローバルエンドセッションURLを返します。 <code><a href="http://localhost:8180/oidcprovider/account/global-logout" class="bare">http://localhost:8180/oidcprovider/account/global-logout</a></code> .
このURLは、ユーザーが現在ログインしているすべてのアプリケーションからユーザーをログアウトします。
ただし、現在のアプリケーションで特定のアプリケーションのみからユーザーをログアウトさせる必要がある場合は、 <code>quarkus.oidc.end-session-path=logout</code> パラメータを設定することで、グローバル・エンド・セッション URL をオーバーライドできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="oidc-provider-client-authentication"><a class="anchor" href="#oidc-provider-client-authentication"></a>OIDCプロバイダーのクライアント認証</h3>
<div class="paragraph">
<p>OIDCプロバイダは通常、OIDCエンドポイントとやり取りする際に、アプリケーションの識別と認証を行う必要があります。
Quarkus OIDC、特に <code>quarkus.oidc.runtime.OidcProviderClient</code> クラスは、認可コードをID、アクセス、リフレッシュトークンと交換する必要がある場合、またはIDやアクセストークンをリフレッシュまたはイントロスペクトする必要がある場合に、OIDCプロバイダで認証します。</p>
</div>
<div class="paragraph">
<p>通常、クライアントIDとクライアントシークレットは、アプリケーションがOIDCプロバイダに登録する際に定義されます。
すべての <a href="https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">OIDCクライアント認証</a> オプションがサポートされています。
例:</p>
</div>
<div class="listingblock">
<div class="title"><code>client_secret_basic</code> の例:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.secret=mysecret</code></pre>
</div>
</div>
<div class="paragraph">
<p>あるいは:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.client-secret.value=mysecret</code></pre>
</div>
</div>
<div class="paragraph">
<p>次の例は、 <a href="credentials-provider">クレデンシャル・プロバイダ</a> から取得したシークレットを示しています：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app

# This is a key which will be used to retrieve a secret from the map of credentials returned from CredentialsProvider
quarkus.oidc.credentials.client-secret.provider.key=mysecret-key
# This is the keyring provided to the CredentialsProvider when looking up the secret, set only if required by the CredentialsProvider implementation
quarkus.oidc.credentials.client-secret.provider.keyring-name=oidc
# Set it only if more than one CredentialsProvider can be registered
quarkus.oidc.credentials.client-secret.provider.name=oidc-credentials-provider</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>client_secret_post</code> の例</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.client-secret.value=mysecret
quarkus.oidc.credentials.client-secret.method=post</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>client_secret_jwt</code> の例。署名アルゴリズムはHS256:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>client_secret_jwt</code> の例。この場合、シークレットは <a href="credentials-provider">クレデンシャル・プロバイダ</a> から取得されます：</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app

# This is a key which will be used to retrieve a secret from the map of credentials returned from CredentialsProvider
quarkus.oidc.credentials.jwt.secret-provider.key=mysecret-key
# This is the keyring provided to the CredentialsProvider when looking up the secret, set only if required by the CredentialsProvider implementation
quarkus.oidc.credentials.client-secret.provider.keyring-name=oidc
# Set it only if more than one CredentialsProvider can be registered
quarkus.oidc.credentials.jwt.secret-provider.name=oidc-credentials-provider</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PEM キーが application.properties にインライン化され、署名アルゴリズムが <code>RS256</code> である <code>private_key_jwt</code> の例:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.jwt.key=Base64-encoded private key representation</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PEM 鍵ファイルを使用した <code>private_key_jwt</code> の例。署名アルゴリズムは RS256：</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.jwt.key-file=privateKey.pem</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">keystoreファイルによる <code>private_key_jwt</code> の例。署名アルゴリズムはRS256：</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.jwt.key-store-file=keystore.pkcs12
quarkus.oidc.credentials.jwt.key-store-password=mypassword
quarkus.oidc.credentials.jwt.key-password=mykeypassword

# Private key alias inside the keystore
quarkus.oidc.credentials.jwt.key-id=mykeyAlias</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>client_secret_jwt</code> 、または <code>private_key_jwt</code> 認証方法を使用することで、クライアントシークレットがOIDCプロバイダに送信されないため、「中間者」攻撃によってシークレットが傍受されるリスクを回避できます。</p>
</div>
<div class="listingblock">
<div class="title">JWT ベアラートークンを使用したクライアント認証方法の例</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.jwt.source=bearer <i class="conum" data-value="1"></i><b>(1)</b>
quarkus.oidc.credentials.jwt.token-path=/var/run/secrets/tokens <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>JWT ベアラートークンを使用して OIDC プロバイダークライアントを認証します。詳細は、<a href="https://www.rfc-editor.org/rfc/rfc7523#section-2.2">JWT を使用したクライアント認証</a> セクションを参照してください。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>JWT ベアラートークンへのパス。Quarkus はファイルシステムから新しいトークンをロードし、トークンの有効期限が切れると再ロードします。</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="additional-jwt-authentication-options"><a class="anchor" href="#additional-jwt-authentication-options"></a>JWT認証の追加オプション</h4>
<div class="paragraph">
<p><code>client_secret_jwt</code> 、 <code>private_key_jwt</code> 、またはAppleの <code>post_jwt</code> 認証方法が使用されている場合、JWT署名アルゴリズム、キー識別子、audience、subject、およびissuerをカスタマイズすることができます。
例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># private_key_jwt client authentication

quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus/
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.jwt.key-file=privateKey.pem

# This is a token key identifier 'kid' header - set it if your OIDC provider requires it:
# Note if the key is represented in a JSON Web Key (JWK) format with a `kid` property, then
# using 'quarkus.oidc.credentials.jwt.token-key-id' is not necessary.
quarkus.oidc.credentials.jwt.token-key-id=mykey

# Use RS512 signature algorithm instead of the default RS256
quarkus.oidc.credentials.jwt.signature-algorithm=RS512

# The token endpoint URL is the default audience value, use the base address URL instead:
quarkus.oidc.credentials.jwt.audience=${quarkus.oidc-client.auth-server-url}

# custom subject instead of the client id:
quarkus.oidc.credentials.jwt.subject=custom-subject

# custom issuer instead of the client id:
quarkus.oidc.credentials.jwt.issuer=custom-issuer</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="apple-post-jwt"><a class="anchor" href="#apple-post-jwt"></a>Apple POST JWT</h4>
<div class="paragraph">
<p>Apple OIDC プロバイダは、 <code>private_key_jwt</code> 認証方式で生成された JWT をシークレットとする <code>client_secret_post</code> 方式を使用していますが、Apple アカウント固有のissuerとsubjectのクレームを使用しています。</p>
</div>
<div class="paragraph">
<p>Quarkus Securityでは、 <code>quarkus-oidc</code> は、非標準の <code>client_secret_post_jwt</code> 認証方法をサポートされています。この認証方法は、以下のように設定できます：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Apple provider configuration sets a 'client_secret_post_jwt' authentication method
quarkus.oidc.provider=apple

quarkus.oidc.client-id=${apple.client-id}
quarkus.oidc.credentials.jwt.key-file=ecPrivateKey.pem
quarkus.oidc.credentials.jwt.token-key-id=${apple.key-id}
# Apple provider configuration sets ES256 signature algorithm

quarkus.oidc.credentials.jwt.subject=${apple.subject}
quarkus.oidc.credentials.jwt.issuer=${apple.issuer}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mutual-tls-mtls"><a class="anchor" href="#mutual-tls-mtls"></a>相互TLS (mTLS)</h4>
<div class="paragraph">
<p>OIDCプロバイダによっては、相互TLS認証プロセスの一部としてクライアントの認証を要求する場合があります。</p>
</div>
<div class="paragraph">
<p>次の例は、 <code>mTLS</code> をサポートするように <code>quarkus-oidc</code> を設定する方法を示しています：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.tls.tls-configuration-name=oidc

# configure hostname verification if necessary
#quarkus.tls.oidc.hostname-verification-algorithm=NONE

# Keystore configuration
quarkus.tls.oidc.key-store.p12.path=client-keystore.p12
quarkus.tls.oidc.key-store.p12.password=${key-store-password}

# Add more keystore properties if needed:
#quarkus.tls.oidc.key-store.p12.alias=keyAlias
#quarkus.tls.oidc.key-store.p12.alias-password=keyAliasPassword

# Truststore configuration
quarkus.tls.oidc.trust-store.p12.path=client-truststore.p12
quarkus.tls.oidc.trust-store.p12.password=${trust-store-password}
# Add more truststore properties if needed:
#quarkus.tls.oidc.trust-store.p12.alias=certAlias</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-query"><a class="anchor" href="#post-query"></a>POSTクエリ</h4>
<div class="paragraph">
<p><a href="security-openid-connect-providers#strava">Strava OAuth2 プロバイダー</a> などの一部のプロバイダーでは、クライアントクレデンシャルを HTTP POST クエリーパラメーターとして送信する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.provider=strava
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.client-secret.value=mysecret
quarkus.oidc.credentials.client-secret.method=query</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="introspection-endpoint-authentication"><a class="anchor" href="#introspection-endpoint-authentication"></a>イントロスペクションエンドポイント認証</h4>
<div class="paragraph">
<p>OIDC プロバイダの中には、 <code>client_id</code> および <code>client_secret</code> とは異なる認証情報を使用して、Basic 認証を使用してイントロスペクション・エンドポイントへの認証を必要とするものがあります。 
<a href="#oidc-provider-client-authentication">OIDC プロバイダのクライアント認証</a> のセクションで説明したように、 <code>client_secret_basic</code> または <code>client_secret_post</code> のクライアント認証方法のいずれかをサポートするようにセキュリティ認証を以前に構成している場合は、以下のように追加の設定を適用する必要がある場合があります。</p>
</div>
<div class="paragraph">
<p>トークンをイントロスペクションする必要があり、イントロスペクション・エンドポイント固有の 認証メカニズムが必要な場合は、 <code>quarkus-oidc</code> を以下のように設定できます：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.introspection-credentials.name=introspection-user-name
quarkus.oidc.introspection-credentials.secret=introspection-user-secret</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="code-flow-oidc-request-filters"><a class="anchor" href="#code-flow-oidc-request-filters"></a>OIDCリクエストフィルター</h3>
<div class="paragraph">
<p>You can filter OIDC requests made by Quarkus to the OIDC provider by registering one or more <code>OidcRequestFilter</code> implementations, which can update or add new request headers, customize a request body and can also log requests.</p>
</div>
<div class="paragraph">
<p>例えば、以下のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import io.quarkus.oidc.OidcConfigurationMetadata;
import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.common.OidcRequestFilter;
import io.smallrye.mutiny.Uni;

@ApplicationScoped
@Unremovable
public class OidcTokenRequestCustomizer implements OidcRequestFilter {
    @Override
    public Uni&lt;Void&gt; filter(OidcRequestFilterContext requestContext) {
        OidcConfigurationMetadata metadata = requestContext.contextProperties().get(OidcConfigurationMetadata.class.getName()); <i class="conum" data-value="1"></i><b>(1)</b>
        // Metadata URI is absolute, request URI value is relative
        if (metadata.getTokenUri().endsWith(requestContext.request().uri())) { <i class="conum" data-value="2"></i><b>(2)</b>
            requestContext.request().putHeader("TokenGrantDigest", calculateDigest(requestContext.requestBody().toString()));
        }
        return Uni.createFrom().voidItem();
    }
    private String calculateDigest(String bodyString) {
        // Apply the required digest algorithm to the body string
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>サポートされているすべての OIDC エンドポイントアドレスが含まれる <code>OidcConfigurationMetadata</code> を取得します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>OidcConfigurationMetadata</code> を使用して、OIDC トークンエンドポイントへのリクエストのみをフィルターします。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>または、 <code>@OidcEndpoint</code> アノテーションを使用して、このフィルターを OIDC 検出エンドポイントからのレスポンスにのみ適用することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.common.OidcEndpoint;
import io.quarkus.oidc.common.OidcEndpoint.Type;
import io.quarkus.oidc.common.OidcRequestContext;
import io.quarkus.oidc.common.OidcRequestFilter;
import io.smallrye.mutiny.Uni;

@ApplicationScoped
@Unremovable
@OidcEndpoint(value = Type.DISCOVERY) <i class="conum" data-value="1"></i><b>(1)</b>
public class OidcDiscoveryRequestCustomizer implements OidcRequestFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcRequestFilterContext requestContext) {
        requestContext.request().putHeader("Discovery", "OK");
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>このフィルターを、OIDC 検出エンドポイントのみを対象とするリクエストに制限します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OidcRequestContextProperties</code> を使用して、リクエストプロパティーにアクセスできます。
現在、 <code>tenand_id</code> キーを使用して OIDC テナント ID にアクセスし、 <code>grant_type</code> キーを使用して OIDC プロバイダーがトークンを取得するために使用するグラントタイプにアクセスできます。
トークンエンドポイントにリクエストする場合、 <code>grant_type</code> は <code>authorization_code</code> または <code>refresh_token</code> グラントタイプのいずれかにのみ設定できます。それ以外の場合は <code>null</code> になります。</p>
</div>
<div class="paragraph">
<p><code>OidcRequestFilter</code> can customize a request body by preparing an instance of <code>io.vertx.mutiny.core.buffer.Buffer</code>
and setting it on a request context, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.common.OidcEndpoint;
import io.quarkus.oidc.common.OidcEndpoint.Type;
import io.quarkus.oidc.common.OidcRequestContextProperties;
import io.quarkus.oidc.common.OidcRequestFilter;
import io.smallrye.mutiny.Uni;
import io.vertx.mutiny.core.buffer.Buffer;

@ApplicationScoped
@Unremovable
@OidcEndpoint(value = Type.TOKEN)
public class TokenRequestFilter implements OidcRequestFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcRequestFilterContext rc) {
        // Add more required properties to the token request
        rc.requestBody(Buffer.buffer(rc.requestBody().toString() + "&amp;opaque_token_param=opaque_token_value"));
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="code-flow-oidc-response-filters"><a class="anchor" href="#code-flow-oidc-response-filters"></a>OIDC レスポンスフィルター</h3>
<div class="paragraph">
<p>1 つ以上の <code>OidcResponseFilter</code> 実装を登録することで、OIDC プロバイダーからのレスポンスをフィルタリングできます。これにより、レスポンスのステータス、ヘッダー、本文をチェックして、ログに記録したり、その他のアクションを実行したりできます。</p>
</div>
<div class="paragraph">
<p>すべての OIDC レスポンスをインターセプトする単一のフィルターを使用することも、 <code>@OidcEndpoint</code> アノテーションを使用してこのフィルターを特定のエンドポイントレスポンスにのみ適用することもできます。例: </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.logging.Log;
import io.quarkus.oidc.common.OidcEndpoint;
import io.quarkus.oidc.common.OidcEndpoint.Type;
import io.quarkus.oidc.common.OidcResponseFilter;
import io.smallrye.mutiny.Uni;
import io.quarkus.oidc.common.runtime.OidcConstants;
import io.quarkus.oidc.runtime.OidcUtils;

@ApplicationScoped
@Unremovable
@OidcEndpoint(value = Type.TOKEN) <i class="conum" data-value="1"></i><b>(1)</b>
public class TokenEndpointResponseFilter implements OidcResponseFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcResponseFilterContext rc) {
        String contentType = rc.responseHeaders().get("Content-Type"); <i class="conum" data-value="2"></i><b>(2)</b>
        if (contentType.equals("application/json")
                &amp;&amp; OidcConstants.AUTHORIZATION_CODE.equals(rc.requestProperties().get(OidcConstants.GRANT_TYPE)) <i class="conum" data-value="3"></i><b>(3)</b>
                &amp;&amp; "code-flow-user-info-cached-in-idtoken".equals(rc.requestProperties().get(OidcUtils.TENANT_ID_ATTRIBUTE)) <i class="conum" data-value="3"></i><b>(3)</b>
                &amp;&amp; rc.responseBody().toJsonObject().containsKey("id_token")) { <i class="conum" data-value="4"></i><b>(4)</b>
            Log.debug("Authorization code completed for tenant 'code-flow-user-info-cached-in-idtoken'");
        }
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>このフィルターを、OIDC トークンエンドポイントのみを対象とするリクエストに制限します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>レスポンスの <code>Content-Type</code> ヘッダーを確認します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>OidcRequestContextProperties</code> リクエストプロパティーを使用して、 <code>code-flow-user-info-cached-in-idtoken</code> テナントの <code>authorization_code</code> トークングラントレスポンスのみをチェックします。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>レスポンス JSON に <code>id_token</code> プロパティーが含まれていることを確認します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OidcResponseFilter</code> can customize a response body by preparing an instance of <code>io.vertx.mutiny.core.buffer.Buffer</code>
and setting it on a response context, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.common.OidcEndpoint;
import io.quarkus.oidc.common.OidcEndpoint.Type;
import io.quarkus.oidc.common.OidcRequestContextProperties;
import io.quarkus.oidc.common.OidcResponseFilter;
import io.smallrye.mutiny.Uni;
import io.vertx.core.json.JsonObject;
import io.vertx.mutiny.core.buffer.Buffer;

@ApplicationScoped
@Unremovable
@OidcEndpoint(value = Type.TOKEN)
public class TokenResponseFilter implements OidcResponseFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcResponseFilterContext rc) {
        JsonObject body = rc.responseBody().toJsonObject();
        // JSON `scope` property has multiple values separated by a comma character.
        // It must be replaced with a space character.
        String scope = body.getString("scope");
        body.put("scope", scope.replace(",", " "));
        rc.responseBody(Buffer.buffer(body.toString()));
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="restrict-oidc-filter-to-code-flow"><a class="anchor" href="#restrict-oidc-filter-to-code-flow"></a>Restricting OIDC request and response filters to authorization code flow</h3>
<div class="paragraph">
<p>When you have both the authorization code and <a href="security-oidc-bearer-token-authentication">bearer access token</a> flows supported by <a href="security-openid-connect-multitenancy">multiple OIDC tenants</a> and the filters have to deal with a flow specific logic, you can instead have them restricted to the authorization code flow with the <code>io.quarkus.oidc.AuthorizationCodeFlow</code> annotation and <a href="security-oidc-bearer-token-authentication#restrict-oidc-filter-to-bearer-auth-flow">the bearer access token flow with the 'io.quarkus.oidc.BearerTokenAuthentication' annotation</a>.</p>
</div>
<div class="paragraph">
<p>例えば、以下のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.AuthorizationCodeFlow;
import io.quarkus.oidc.common.OidcRequestFilter;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;

@AuthorizationCodeFlow
@ApplicationScoped
@Unremovable
public class CustomOidcRequestFilter implements OidcRequestFilter {

    @Override
    public Uni&lt;Void&gt; filter(OidcRequestFilterContext requestContext) {
        requestContext.request().putHeader("custom-header-name", "custom-header-value");
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redirecting-to-and-from-the-oidc-provider"><a class="anchor" href="#redirecting-to-and-from-the-oidc-provider"></a>OIDC プロバイダーへのリダイレクトと OIDC プロバイダーからのリダイレクト</h3>
<div class="paragraph">
<p>ユーザーが認証のために OIDC プロバイダーにリダイレクトされる場合、リダイレクト URL には <code>redirect_uri</code> クエリーパラメーターが含まれます。このパラメーターは、認証完了後のユーザーのリダイレクト先をプロバイダーに示します。
ここでのリダイレクト先は Quarkus アプリケーションになります。</p>
</div>
<div class="paragraph">
<p>Quarkus は、デフォルトでこのパラメーターを現在のアプリケーションリクエスト URL に設定します。
たとえば、ユーザーが <code><a href="http://localhost:8080/service/1" class="bare">http://localhost:8080/service/1</a></code> にある Quarkus サービスエンドポイントにアクセスしようとしている場合、 <code>redirect_uri</code> パラメーターは <code><a href="http://localhost:8080/service/1" class="bare">http://localhost:8080/service/1</a></code> に設定されます。
同様に、リクエスト URL が <code><a href="http://localhost:8080/service/2" class="bare">http://localhost:8080/service/2</a></code> の場合、 <code>redirect_uri</code> パラメーターは <code><a href="http://localhost:8080/service/2" class="bare">http://localhost:8080/service/2</a></code> に設定されます。</p>
</div>
<div class="paragraph">
<p>一部の OIDC プロバイダーでは、すべてのリダイレクト URL の特定のアプリケーションに対して、 <code>redirect_uri</code> が同じ値 (例: <code><a href="http://localhost:8080/service/callback" class="bare">http://localhost:8080/service/callback</a></code>) を持つことが必要です。
このような場合は、 <code>quarkus.oidc.authentication.redirect-path</code> プロパティーを設定する必要があります。
たとえば、 <code>quarkus.oidc.authentication.redirect-path=/service/callback</code> の場合、Quarkus は <code>redirect_uri</code> パラメーターを <code><a href="http://localhost:8080/service/callback" class="bare">http://localhost:8080/service/callback</a></code> などの絶対 URL に設定します。これは、現在のリクエスト URL に関係なく同じになります。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.redirect-path</code> が設定されているが、ユーザーが <code><a href="http://localhost:8080/service/callback" class="bare">http://localhost:8080/service/callback</a></code> などの一意のコールバック URL にリダイレクトされた後に元のリクエスト URL を復元する必要がある場合は、 <code>quarkus.oidc.authentication.restore-path-after-redirect</code> プロパティーを <code>true</code> に設定します。
これにより、 <code><a href="http://localhost:8080/service/1" class="bare">http://localhost:8080/service/1</a></code> などのリクエスト URL が復元されます。</p>
</div>
<div class="sect3">
<h4 id="customize-authentication-requests"><a class="anchor" href="#customize-authentication-requests"></a>認証リクエストのカスタマイズ</h4>
<div class="paragraph">
<p>デフォルトでは、ユーザーが認証のために OIDC プロバイダーの認可エンドポイントにリダイレクトされる際に、 <code>response_type</code> (<code>code</code> に設定)、 <code>scope</code> (<code>openid</code> に設定)、 <code>client_id</code>、 <code>redirect_uri</code>、および <code>state</code> プロパティーのみが HTTP クエリーパラメーターとして、OIDC プロバイダーの認可エンドポイントに渡されます。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.extra-params</code> を使用して、さらにプロパティーを追加できます。
たとえば、一部の OIDC プロバイダーは、リダイレクト URI のフラグメントの一部として認可コードを返すことを選択する場合があり、これにより認証プロセスが中断されます。
次の例は、この問題を回避する方法を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.authentication.extra-params.response_mode=query</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、カスタムの <code>OidcRedirectFilter</code> を使用して、OIDC 認可エンドポイントへのリダイレクトを含む OIDC リダイレクトをカスタマイズする方法については、<a href="#oidc-redirect-filters">OIDC リダイレクトフィルター</a> セクションを参照してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-the-authentication-error-response"><a class="anchor" href="#customizing-the-authentication-error-response"></a>認証エラーレスポンスのカスタマイズ</h4>
<div class="paragraph">
<p>ユーザーが OIDC 認可エンドポイントにリダイレクトされ、Quarkus アプリケーションを認証し、必要に応じて認可する場合、このリダイレクトリクエストは、リダイレクト URI に無効なスコープが含まれている場合などに失敗する可能性があります。
このような場合、プロバイダーは、想定される <code>code</code> パラメーターではなく、 <code>error</code> および <code>error_description</code> パラメーターを使用してユーザーを Quarkus にリダイレクトします。</p>
</div>
<div class="paragraph">
<p>これは、たとえば、プロバイダーへのリダイレクトに無効なスコープまたはその他の無効なパラメーターが含まれている場合に発生する可能性があります。</p>
</div>
<div class="paragraph">
<p>このような場合、デフォルトで HTTP <code>401</code> エラーが返されます。
ただし、ユーザーにわかりやすいエラーメッセージを返すために、カスタムパブリックエラーエンドポイントを呼び出すようにリクエストできます。
これを行うには、 <code>quarkus.oidc.authentication.error-path</code> プロパティーを以下のように設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.authentication.error-path=/error</code></pre>
</div>
</div>
<div class="paragraph">
<p>プロパティーがフォワードスラッシュ (/) 文字で始まり、パスが現在のエンドポイントのベース URI と相対的であるようにします。
たとえば、これが '/error' に設定され、現在のリクエスト URI が <code><a href="https://localhost:8080/callback?error=invalid_scope" class="bare">https://localhost:8080/callback?error=invalid_scope</a></code> の場合、最終的に <code><a href="https://localhost:8080/error?error=invalid_scope" class="bare">https://localhost:8080/error?error=invalid_scope</a></code> へリダイレクトされます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ユーザーがこのページにリダイレクトされて再認証されないようにするには、このエラーエンドポイントがパブリックリソースであるようにします。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oidc-redirect-filters"><a class="anchor" href="#oidc-redirect-filters"></a>OIDC リダイレクトフィルター</h3>
<div class="paragraph">
<p>1 つ以上の <code>io.quarkus.oidc.OidcRedirectFilter</code> 実装を登録して、OIDC 認可およびログアウトエンドポイントへの OIDC リダイレクトだけでなく、カスタムエラーおよびセッション期限切れページへのローカルリダイレクトもフィルタリングできます。カスタム <code>OidcRedirectFilter</code> は、さらにクエリーパラメーターおよびレスポンスヘッダーを追加して、新しい Cookie を設定できます。</p>
</div>
<div class="paragraph">
<p>たとえば、次の単純なカスタム <code>OidcRedirectFilter</code> は、Quarkus OIDC で実行できるすべてのリダイレクトリクエストに対して追加のクエリーパラメーターとカスタムレスポンスヘッダーを追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.OidcRedirectFilter;

@ApplicationScoped
@Unremovable
public class GlobalOidcRedirectFilter implements OidcRedirectFilter {

    @Override
    public void filter(OidcRedirectContext context) {
        if (context.redirectUri().contains("/session-expired-page")) {
            context.additionalQueryParams().add("redirect-filtered", "true,"); <i class="conum" data-value="1"></i><b>(1)</b>
            context.routingContext().response().putHeader("Redirect-Filtered", "true"); <i class="conum" data-value="2"></i><b>(2)</b>
        }
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>クエリーパラメーターを追加します。クエリーの名前と値は Quarkus OIDC によって URL エンコードされることに注意してください。この場合、リダイレクト URI に <code>redirect-filtered=true%20C</code> クエリーパラメーターが追加されます。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>カスタム HTTP レスポンスヘッダーを追加します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>OIDC 認可ポイントの追加クエリーパラメーターを設定する方法については、<a href="#customize-authentication-requests">認証リクエストのカスタマイズ</a> セクションも参照してください。</p>
</div>
<div class="paragraph">
<p>ローカルエラーおよびセッション期限切れページ用のカスタム <code>OidcRedirectFilter</code> により、そのようなページの生成に役立つセキュアな Cookie を作成することもできます。</p>
</div>
<div class="paragraph">
<p>たとえば、セッションの有効期限が切れた現在のユーザーを、 <code><a href="http://localhost:8080/session-expired-page" class="bare">http://localhost:8080/session-expired-page</a></code> で利用できるカスタムセッション期限切れページにリダイレクトする必要があるとします。次のカスタム <code>OidcRedirectFilter</code> は、OIDC テナントクライアントシークレットを使用して、カスタム <code>session_expired</code> Cookie 内のユーザー名を暗号化します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.jwt.Claims;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.AuthorizationCodeTokens;
import io.quarkus.oidc.OidcRedirectFilter;
import io.quarkus.oidc.Redirect;
import io.quarkus.oidc.Redirect.Location;
import io.quarkus.oidc.TenantFeature;
import io.quarkus.oidc.runtime.OidcUtils;
import io.smallrye.jwt.build.Jwt;

@ApplicationScoped
@Unremovable
@TenantFeature("tenant-refresh")
@Redirect(Location.SESSION_EXPIRED_PAGE) <i class="conum" data-value="1"></i><b>(1)</b>
public class SessionExpiredOidcRedirectFilter implements OidcRedirectFilter {

    @Override
    public void filter(OidcRedirectContext context) {

        if (context.redirectUri().contains("/session-expired-page")) {
        AuthorizationCodeTokens tokens = context.routingContext().get(AuthorizationCodeTokens.class.getName()); <i class="conum" data-value="2"></i><b>(2)</b>
        String userName = OidcUtils.decodeJwtContent(tokens.getIdToken()).getString(Claims.preferred_username.name()); <i class="conum" data-value="3"></i><b>(3)</b>
        String jwe = Jwt.preferredUserName(userName).jwe()
                .encryptWithSecret(context.oidcTenantConfig().credentials.secret.get()); <i class="conum" data-value="4"></i><b>(4)</b>
        OidcUtils.createCookie(context.routingContext(), context.oidcTenantConfig(), "session_expired",
                jwe + "|" + context.oidcTenantConfig().tenantId.get(), 10); <i class="conum" data-value="5"></i><b>(5)</b>
     }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>このリダイレクトフィルターは、セッション期限切れページへのリダイレクト中にのみ呼び出されるようにしてください。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>期限切れになったセッションに関連付けられた <code>AuthorizationCodeTokens</code> トークンに、 <code>RoutingContext</code> 属性としてアクセスします。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ID トークンクレームをデコードし、ユーザー名を取得します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>現在の OIDC テナントのクライアントシークレットで暗号化された JWT トークンにユーザー名を保存します。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>暗号化されたトークンとテナント ID を区切り文字 "|" を使用して結合し、5 秒間有効なカスタム <code>session_expired</code> Cookie を作成します。カスタム Cookie にテナント ID を記録すると、マルチテナント OIDC セットアップで正しいセッション期限切れページを生成する場合に役立ちます。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次に、この Cookie を、セッション期限切れページを生成するパブリック JAX-RS リソースで使用して、このユーザーと対応する OIDC テナントに合わせたページを作成できます。次に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.inject.Inject;
import jakarta.ws.rs.CookieParam;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import org.eclipse.microprofile.jwt.Claims;
import org.eclipse.microprofile.jwt.JsonWebToken;

import io.quarkus.oidc.OidcTenantConfig;
import io.quarkus.oidc.runtime.OidcUtils;
import io.quarkus.oidc.runtime.TenantConfigBean;
import io.smallrye.jwt.auth.principal.DefaultJWTParser;
import io.vertx.ext.web.RoutingContext;

@Path("/session-expired-page")
public class SessionExpiredResource {
    @Inject
    RoutingContext context;

    @Inject
    TenantConfigBean tenantConfig; <i class="conum" data-value="1"></i><b>(1)</b>

    @GET
    public String sessionExpired(@CookieParam("session_expired") String sessionExpired) throws Exception {
        // Cookie format: jwt|&lt;tenant id&gt;

        String[] pair = sessionExpired.split("\\|"); <i class="conum" data-value="2"></i><b>(2)</b>
        OidcTenantConfig oidcConfig = tenantConfig.getStaticTenantsConfig().get(pair[1]).getOidcTenantConfig(); <i class="conum" data-value="3"></i><b>(3)</b>
        JsonWebToken jwt = new DefaultJWTParser().decrypt(pair[0], oidcConfig.credentials.secret.get()); <i class="conum" data-value="4"></i><b>(4)</b>
        OidcUtils.removeCookie(context, oidcConfig, "session_expired"); <i class="conum" data-value="5"></i><b>(5)</b>
        return jwt.getClaim(Claims.preferred_username) + ", your session has expired. "
                + "Please login again at http://localhost:8081/" + oidcConfig.tenantId.get(); <i class="conum" data-value="6"></i><b>(6)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>現在のすべての OIDC テナント設定にアクセスするために使用できる <code>TenantConfigBean</code> を注入します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>カスタム Cookie 値を 2 つの部分に分割します。最初の部分は暗号化されたトークン、最後の部分はテナント ID です。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>OIDC テナント設定を取得します。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>OIDC テナントのクライアントシークレットを使用して Cookie 値を復号化します。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>カスタム Cookie を削除します。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>復号化されたトークン内のユーザー名とテナント ID を使用して、サービス期限切れページのレスポンスを生成します。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="authentication-completion-action"><a class="anchor" href="#authentication-completion-action"></a>Authentication completion actions</h3>
<div class="paragraph">
<p>Sometimes you may need to perform one or more actions upon a successful authorization code flow completion only.</p>
</div>
<div class="paragraph">
<p>One way to achieve it is to <a href="#listen-to-authentication-events">listen to OIDC events such as a user login</a>.
However, when an even listener must perform an asycnhronous action, this action will be completed some time after the request that sent the event was allowed to proceed.</p>
</div>
<div class="paragraph">
<p>When you need an action to be completed before the current request is allowed to proceed, especially when an action requires a blocking call, register one or more <code>io.quarkus.oidc.AuthenticationCompletionAction</code> interface implementations.</p>
</div>
<div class="paragraph">
<p>例えば、以下のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.oidc.test;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.AuthenticationCompletionAction;
import io.smallrye.mutiny.Uni;

@ApplicationScoped
@Unremovable
public class CustomAuthenticationCompletionAction implements AuthenticationCompletionAction {

    @Override
    public Uni&lt;Void&gt; action(AuthenticationCompletionContext authCompletionContext) {
        // perform a required action
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="accessing-authorization-data"><a class="anchor" href="#accessing-authorization-data"></a>認可データへのアクセス</h3>
<div class="paragraph">
<p>認可に関する情報には、さまざまな方法でアクセスできます。</p>
</div>
<div class="sect3">
<h4 id="access_id_and_access_tokens"><a class="anchor" href="#access_id_and_access_tokens"></a>IDやアクセストークンへのアクセス</h4>
<div class="paragraph">
<p>OIDCコード認証メカニズムは、認可コードフロー中に3つのトークンを取得します： <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">IDトークン</a> 、アクセストークン、リフレッシュトークンです。</p>
</div>
<div class="paragraph">
<p>IDトークンは常にJWTトークンであり、JWTクレームによるユーザー認証を表します。
これを使って発行元のOIDCエンドポイントやユーザー名、その他 <em>クレーム</em> と呼ばれる情報を取得することができます。 
<code>JsonWebToken</code> に <code>IdToken</code> という修飾子をつけることで、IDトークンのクレームにアクセスすることができます：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import org.eclipse.microprofile.jwt.JsonWebToken;
import io.quarkus.oidc.IdToken;
import io.quarkus.security.Authenticated;

@Path("/web-app")
@Authenticated
public class ProtectedResource {

    @Inject
    @IdToken
    JsonWebToken idToken;

    @GET
    public String getUserName() {
        return idToken.getName();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>OIDC <code>web-app</code> アプリケーションは通常、アクセストークンを使用して、現在ログインしているユーザーに代わって他のエンドポイントにアクセスします。
raw アクセストークンには次のようにアクセスできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import org.eclipse.microprofile.jwt.JsonWebToken;
import io.quarkus.oidc.AccessTokenCredential;
import io.quarkus.security.Authenticated;

@Path("/web-app")
@Authenticated
public class ProtectedResource {

    @Inject
    JsonWebToken accessToken;

    // or
    // @Inject
    // AccessTokenCredential accessTokenCredential;

    @GET
    public String getReservationOnBehalfOfUser() {
        String rawAccessToken = accessToken.getRawToken();
        //or
        //String rawAccessToken = accessTokenCredential.getToken();

        // Use the raw access token to access a remote endpoint.
        // For example, use RestClient to set this token as a `Bearer` scheme value of the HTTP `Authorization` header:
        // `Authorization: Bearer rawAccessToken`.
        return getReservationfromRemoteEndpoint(rawAccesstoken);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>認可コードフローアクセストークンが <code>JsonWebToken</code> として注入されると、必須の ID トークン検証に加えて、その検証が自動的に有効になります。本当に必要な場合は、 <code>quarkus.oidc.authentication.verify-access-token=false</code> を使用してこのコードフローアクセストークン検証を無効にできます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>AccessTokenCredential</code> は、Quarkus <code>web-app</code> アプリケーションに発行されたアクセストークンが不透明 (バイナリー) で、 <code>JsonWebToken</code> に解析できない場合、または内部コンテンツがアプリケーションに必要な場合に使用されます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>JsonWebToken</code> と <code>AccessTokenCredential</code> の注入は、 <code>@RequestScoped</code> と <code>@ApplicationScoped</code> の両方のコンテキストでサポートされています。</p>
</div>
<div class="paragraph">
<p>Quarkus OIDC は、<a href="#session-management">セッション管理</a> プロセスの一環として、リフレッシュトークンを使用し、現在の ID とアクセストークンを更新します。</p>
</div>
</div>
<div class="sect3">
<h4 id="code-flow-user-info"><a class="anchor" href="#code-flow-user-info"></a>User info</h4>
<div class="paragraph">
<p>ID トークンが現在認証されているユーザーに関する十分な情報を提供しない場合は、 <code>UserInfo</code> エンドポイントから詳細情報を取得できます。
<code>quarkus.oidc.authentication.user-info-required=true</code> プロパティーを設定して、OIDC <code>UserInfo</code> エンドポイントから <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo</a> JSON オブジェクトをリクエストします。</p>
</div>
<div class="paragraph">
<p>認可コードの付与応答で返されたアクセストークンを使用して、OIDC プロバイダーの <code>UserInfo</code> エンドポイントにリクエストが送信され、 <code>io.quarkus.oidc.UserInfo</code> (単純な <code>jakarta.json.JsonObject</code> ラッパー) オブジェクトが作成されます。
<code>io.quarkus.oidc.UserInfo</code> は、SecurityIdentity <code>userinfo</code> 属性として注入またはアクセスできます。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.user-info-required</code> は、次のいずれかの条件が満たされた場合に自動的に有効になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.oidc.roles.source</code> が <code>userinfo</code> に設定されている場合、または <code>quarkus.oidc.token.verify-access-token-with-user-info</code> が <code>true</code> に設定されている場合、または <code>quarkus.oidc.authentication.id-token-required</code> が <code>false</code> に設定されている場合。このような場合、現在の OIDC テナントが UserInfo エンドポイントをサポートしている必要があります。</p>
</li>
<li>
<p><code>io.quarkus.oidc.UserInfo</code> インジェクションポイントが検出された場合。ただし、有効になるのは、現在の OIDC テナントが UserInfo エンドポイントをサポートしている場合だけです。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="code-flow-config-metadata"><a class="anchor" href="#code-flow-config-metadata"></a>OIDC 設定情報へのアクセス</h4>
<div class="paragraph">
<p>現在のテナントの検出された <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID Connect 設定メタデータ</a> は、 <code>io.quarkus.oidc.OidcConfigurationMetadata</code> で表され、 <code>SecurityIdentity</code> <code>configuration-metadata</code> 属性として注入またはアクセスできます。</p>
</div>
<div class="paragraph">
<p>エンドポイントがパブリックの場合、デフォルトのテナントの <code>OidcConfigurationMetadata</code> が注入されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="token-claims-roles"><a class="anchor" href="#token-claims-roles"></a>トークンクレームと <code>SecurityIdentity</code> ロールのマッピング</h4>
<div class="paragraph">
<p>検証済みトークンから SecurityIdentity ロールにロールをマッピングする方法は、<a href="security-oidc-bearer-token-authentication">ベアラートークン</a> の方法と同じです。
唯一の違いは、 <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID トークン</a> がデフォルトでロールのソースとして使用されることです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Keycloak を使用する場合は、ID トークンに <code>groups</code> クレームが含まれるように <code>microprofile-jwt</code> クライアントスコープを設定します。
詳細は、<a href="https://www.keycloak.org/docs/latest/server_admin/#protocol">Keycloak サーバー管理ガイド</a> のリンクを参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ただし、OIDC プロバイダーによっては、ロールがアクセストークンまたはユーザー情報に保存される場合があります。</p>
</div>
<div class="paragraph">
<p>アクセストークンにロールが含まれており、このアクセストークンがダウンストリームエンドポイントに伝播されることを意図していない場合は、 <code>quarkus.oidc.roles.source=accesstoken</code> を設定します。</p>
</div>
<div class="paragraph">
<p>UserInfo がロールのソースである場合は、 <code>quarkus.oidc.roles.source=userinfo</code> を設定し、必要に応じて <code>quarkus.oidc.roles.role-claim-path</code> を設定します。</p>
</div>
<div class="paragraph">
<p>さらに、カスタム <code>SecurityIdentityAugmentor</code> を使用してロールを追加することもできます。
詳細は、<a href="security-customization#security-identity-customization">SecurityIdentity カスタマイズ</a> を参照してください。
また、<a href="security-authorize-web-endpoints-reference#map-security-identity-roles">HTTP Security ポリシー</a> を使用して、トークン要求から作成された <code>SecurityIdentity</code> ロールをデプロイメント固有のロールにマップすることもできます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ensuring-validity-of-tokens-and-authentication-data"><a class="anchor" href="#ensuring-validity-of-tokens-and-authentication-data"></a>トークンと認証データの有効性の確認</h3>
<div class="paragraph">
<p>認証プロセスの中核となるのは、トラストチェーンと情報の有効性を確認することです。
これは、トークンが信頼できることを確認することによって行われます。</p>
</div>
<div class="sect3">
<h4 id="code-flow-token-verification-introspection"><a class="anchor" href="#code-flow-token-verification-introspection"></a>トークン検証・イントロスペクション</h4>
<div class="paragraph">
<p>OIDC 認可コードフロートークンの検証プロセスは、ベアラートークン認証トークンの検証とイントロスペクションのロジックに従います。
詳細は、「Quarkus OpenID Connect (OIDC) ベアラートークン認証」ガイドの <a href="security-oidc-bearer-token-authentication#bearer-token-token-verification-introspection">トークンの検証とイントロスペクション</a> のセクションを参照してください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quarkus の <code>web-app</code> アプリケーションでは、アクセストークンは現在の Quarkus の web-app エンドポイントへのアクセスには使用されず、このアクセストークンを必要とするサービスに伝播されることが意図されているため、デフォルトでは <code>IdToken</code> のみが検証されます。
アクセストークンに現在の Quarkus エンドポイント (<code>quarkus.oidc.roles.source=accesstoken</code>) にアクセスするために必要なロールが含まれていることが予想される場合は、それも検証されます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="code-flow-token-introspection-userinfo-cache"><a class="anchor" href="#code-flow-token-introspection-userinfo-cache"></a>トークンのイントロスペクションとUserInfoのキャッシュ</h4>
<div class="paragraph">
<p>コードフローアクセストークンは、ロールのソースであると期待されない限り、イントロスペクトされません。
ただし、アクセストークンは <code>UserInfo</code> を取得するために使用されます。
トークンイントロスペクション または <code>UserInfo</code>、あるいはその両方が必要な場合は、コードフローアクセストークンを使用したリモート呼び出しが 1 回または 2 回発生します。</p>
</div>
<div class="paragraph">
<p>デフォルトのトークンキャッシュの使用またはカスタムキャッシュ実装の登録の詳細は、<a href="security-oidc-bearer-token-authentication#token-introspection-userinfo-cachexref:security-oidc-bearer-token-authentication.adoc#bearer-token-token-introspection-userinfo-cache">トークンのイントロスペクションと UserInfo のキャッシュ</a> を参照してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="code-flow-jwt-claim-verification"><a class="anchor" href="#code-flow-jwt-claim-verification"></a>JSONウェブトークンのクレーム検証</h4>
<div class="paragraph">
<p><code>iss</code> (発行者) クレームを含むクレーム検証の詳細は、<a href="security-oidc-bearer-token-authentication#bearer-token-jwt-claim-verification">JSON Web Token クレーム検証</a> セクションを参照してください。
これは、ID トークンに適用され、 <code>web-app</code> アプリケーションがアクセストークンの検証をリクエストした場合は、JWT 形式のアクセストークンにも適用されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="jose4j-validator-code"><a class="anchor" href="#jose4j-validator-code"></a>Jose4j Validator</h4>
<div class="paragraph">
<p>You can register a custom Jose4j Validator to customize the JWT claim verification process. See the <a href="security-oidc-bearer-token-authentication#jose4j-validator-bearer">Jose4j</a> section for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="proof-key-for-code-exchange-pkce"><a class="anchor" href="#proof-key-for-code-exchange-pkce"></a>Proof Key for Code Exchange (PKCE)</h3>
<div class="paragraph">
<p><a href="https://datatracker.ietf.org/doc/html/rfc7636">Proof Key for Code Exchange</a> (PKCE) は、認可コードの傍受のリスクを最小限に抑えます。</p>
</div>
<div class="paragraph">
<p>PKCE は、ブラウザーで実行される SPA スクリプトなどのパブリック OIDC クライアントにとって最も重要ですが、Quarkus OIDC <code>web-app</code> アプリケーションに追加の保護を提供することもできます。
PKCE を使用すると、Quarkus OIDC <code>web-app</code> アプリケーションは、クライアントシークレットを安全に保存し、それを使用してトークンのコードを交換できる機密 OIDC クライアントとして機能します。</p>
</div>
<div class="paragraph">
<p>次の例に示すように、 <code>quarkus.oidc.authentication.pkce-required</code> プロパティーと、stateクッキーの PKCE コード検証を暗号化するために必要な 32 文字のシークレットを使用して、OIDC web-app エンドポイントの PKCE を有効にすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.authentication.pkce-required=true
quarkus.oidc.authentication.state-secret=eUk1p7UB3nFiXZGUXi0uph1Y9p34YhBU</code></pre>
</div>
</div>
<div class="paragraph">
<p>すでに 32 文字のクライアントシークレットがある場合は、別のシークレットキーを使用する場合を除き、 <code>quarkus.oidc.authentication.pkce-secret</code> プロパティーを設定する必要はありません。
このシークレットは、設定されていない場合、およびクライアントシークレットの長さが 16 文字未満でクライアントシークレットへのフォールバックが不可能な場合に、自動生成されます。</p>
</div>
<div class="paragraph">
<p>シークレットキーは、ランダムに生成された PKCE <code>code_verifier</code> を暗号化するために必要です。一方、ユーザーは <code>code_challenge</code> クエリーパラメーターを使用して OIDC プロバイダーにリダイレクトされ、認証されます。
<code>code_verifier</code> は、ユーザーが Quarkus にリダイレクトされるときに復号化され、 <code>code</code>、クライアントシークレット、およびその他のパラメーターとともにトークンエンドポイントに送信され、コード交換が完了します。
<code>code_verifier</code> の <code>SHA256</code> ダイジェストが、認証のリクエスト時に提供された <code>code_challenge</code> と一致しない場合、プロバイダーはコード交換に失敗します。</p>
</div>
</div>
<div class="sect2">
<h3 id="pushed-authorization-requests"><a class="anchor" href="#pushed-authorization-requests"></a>Pushed Authorization Requests</h3>
<div class="paragraph">
<p><a href="https://datatracker.ietf.org/doc/html/rfc9126">OAuth 2.0 Pushed Authorization Requests</a> (PAR) allows the authorization server to authenticate the client before any user interaction happens.
It mitigates front-channel attacks by preventing malicious actors from intercepting, tampering with, or spoofing the authorization request details in the user&#8217;s browser.</p>
</div>
<div class="paragraph">
<p>You can enable PAR for your OIDC web-app endpoint by setting the <code>quarkus.oidc.authentication.par.enabled</code> configuration property to <code>true</code>.
It will be enabled automatically if the OIDC metadata contains a <code>require_pushed_authorization_requests</code> property that is set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The PAR endpoint is discovered from the OAuth Authorization Server Metadata parameter <code>pushed_authorization_request_endpoint</code>.
If the metadata discovery is disabled, you must configure the PAR endpoint manually like in the example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.authentication.par.enabled=true
quarkus.oidc.authentication.par.path=/as/par</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rich-authorization-requests"><a class="anchor" href="#rich-authorization-requests"></a>Rich Authorization Requests</h3>
<div class="paragraph">
<p>The <a href="https://datatracker.ietf.org/doc/html/rfc9396">OAuth 2.0 Rich Authorization Requests</a> (RAR) specification allows OAuth2 client applications to specify fine-grained authorization requirements in the authorization code flow request.
Instead of relying solely on traditional OAuth 2.0 scopes, RAR allows to represent required permissions as JSON that must be URL-encoded and passed as an <code>authorization_details</code> query parameter.</p>
</div>
<div class="paragraph">
<p>You can configure authorization details using the properties in the <code>quarkus.oidc.authentication.rar</code> configuration namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.authentication.rar.type=openid_credential  <i class="conum" data-value="1"></i><b>(1)</b>
quarkus.oidc.authentication.rar.simple.credential_configuration_id=vc-scope-mapping <i class="conum" data-value="2"></i><b>(2)</b>
quarkus.oidc.authentication.rar.array.locations=${quarkus.oidc.auth-server-url} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>type</code> field is required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>credential_configuration_id</code> field value <code>vc-scope-mapping</code> is added to the <code>authorization_details</code> as a string.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <a href="https://datatracker.ietf.org/doc/html/rfc9396#name-common-data-fields">common data field</a> <code>locations</code> is added as an array of strings.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With this configuration, the following JSON is created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
    {
        "type": "openid_credential",
        "credential_configuration_id": "vc-scope-mapping",
        "locations": [ "http://localhost:34187/realms/quarkus" ]
    }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, this JSON is URL-encoded and added as an <code>authorization_details</code> query parameter to the authorization code flow redirect URL.</p>
</div>
<div class="sect3">
<h4 id="add-an-authorization_details-query-parameter-with-oidcredirectfilter"><a class="anchor" href="#add-an-authorization_details-query-parameter-with-oidcredirectfilter"></a>Add an <code>authorization_details</code> query parameter with <code>OidcRedirectFilter</code></h4>
<div class="paragraph">
<p>A complex JSON structure that cannot be expressed with configuration properties in the <code>quarkus.oidc.authentication.rar</code> configuration namespace can be added with the <code>OidcRedirectFilter</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import static io.quarkus.oidc.Redirect.Location.OIDC_AUTHORIZATION;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.arc.Unremovable;
import io.quarkus.oidc.OidcRedirectFilter;
import io.quarkus.oidc.Redirect;

@Redirect(OIDC_AUTHORIZATION)
@ApplicationScoped
@Unremovable
class AuthorizationDetailsOidcRedirectFilter implements OidcRedirectFilter {

    @Override
    public void filter(OidcRedirectContext redirectContext) {
        redirectContext.additionalQueryParams().add("authorization_details", """
                [
                    {
                        "type": "openid_credential",
                        "credential_configuration_id": "vc-scope-mapping-1",
                        "locations": [ "http://localhost:34187/realms/quarkus" ]
                    },
                    {
                        "type": "openid_credential",
                        "credential_configuration_id": "vc-scope-mapping-2",
                        "locations": [ "http://localhost:34187/realms/quarkus" ]
                    }
                ]
                """);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handling-and-controlling-the-lifetime-of-authentication"><a class="anchor" href="#handling-and-controlling-the-lifetime-of-authentication"></a>認証のライフタイムの処理と制御</h3>
<div class="paragraph">
<p>認証のもう一つの重要な要件は、ユーザがリクエストのたびに認証を要求することなく、 セッションの基となるデータが最新であることを保証することです。
また、ログアウトイベントが明示的に要求される状況もあります。
以下のポイントを参考に、Quarkusアプリケーションのセキュリティを確保するための適切なバランスを見つけましょう：</p>
</div>
<div class="sect3">
<h4 id="oidc-cookies"><a class="anchor" href="#oidc-cookies"></a>クッキー</h4>
<div class="paragraph">
<p>OIDC アダプターはクッキーを使用して、セッション、コードフロー、ログアウト後の状態を保持します。
この状態は、認証データの寿命を制御する重要な要素です。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.cookie-path</code> プロパティを使用すると、保護されたリソースに重複または異なるルートでアクセスしたときに、同じクッキーが表示されるようになります。
例:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/index.html</code> と <code>/web-app/service</code></p>
</li>
<li>
<p><code>/web-app/service1</code> と <code>/web-app/service2</code></p>
</li>
<li>
<p><code>/web-app1/service</code> と <code>/web-app2/service</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>デフォルトでは、 <code>quarkus.oidc.authentication.cookie-path</code> は <code>/</code> に設定されていますが、必要に応じてこれを <code>/web-app</code> などのより具体的なパスに変更できます。</p>
</div>
<div class="paragraph">
<p>Cookie パスを動的に設定するには、 <code>quarkus.oidc.authentication.cookie-path-header</code> プロパティーを設定します。
たとえば、 <code>X-Forwarded-Prefix</code> HTTP ヘッダーの値を使用して Cookie パスを動的に設定するには、プロパティーを <code>quarkus.oidc.authentication.cookie-path-header=X-Forwarded-Prefix</code> に設定します。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.cookie-path-header</code> が設定されているが、現在のリクエストで設定された HTTP ヘッダーが利用できない場合は、 <code>quarkus.oidc.authentication.cookie-path</code> がチェックされます。</p>
</div>
<div class="paragraph">
<p>アプリケーションが複数のドメインにまたがってデプロイされている場合は、セッションクッキー がすべての保護された Quarkus サービスに表示されるように、 <code>quarkus.oidc.authentication.cookie-domain</code> プロパティーを設定します。
たとえば、次の 2 つのドメインに Quarkus サービスをデプロイしている場合は、 <code>quarkus.oidc.authentication.cookie-domain</code> プロパティーを <code>company.net</code> に設定する必要があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>https://whatever.wherever.company.net/</p>
</li>
<li>
<p>https://another.address.company.net/</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="state-cookies"><a class="anchor" href="#state-cookies"></a>状態 Cookie</h4>
<div class="paragraph">
<p>状態 Cookie は、認可コードフローの完了をサポートするために使用されます。
認可コードフローが開始されると、Quarkus はユーザーを OIDC プロバイダーにリダイレクトする前に、状態 Cookie と一致する <code>state</code> クエリーパラメーターを作成します。
ユーザーが認可コードフローを完了するために Quarkus にリダイレクトされると、Quarkus はリクエスト URI に <code>state</code> クエリーパラメーターが含まれており、それが現在の状態 Cookie の値と一致していると想定します。</p>
</div>
<div class="paragraph">
<p>デフォルトの状態 Cookie の有効期間は 5 分ですが、これは <code>quarkus.oidc.authentication.state-cookie-age</code> Duration プロパティーを使用して変更できます。</p>
</div>
<div class="paragraph">
<p>Quarkus は、マルチタブ認証をサポートするために、新しい認可コードフローが開始されるたびに一意の状態 Cookie 名を作成します。同じユーザーによる多数の同時認証リクエストにより、多数の状態 Cookie が作成される場合があります。
ユーザーに対して、複数のブラウザータブを使用した認証を許可しない場合は、 <code>quarkus.oidc.authentication.allow-multiple-code-flows=false</code> で無効にすることが推奨されます。これにより、新しいユーザー認証ごとに同じ状態 Cookie 名が作成されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="token-state-manager"><a class="anchor" href="#token-state-manager"></a>セッションクッキーとデフォルトのTokenStateManager</h4>
<div class="paragraph">
<p>OIDC <code>CodeAuthenticationMechanism</code> は、デフォルトの <code>io.quarkus.oidc.TokenStateManager</code> インターフェイス実装を使用して、認可コードまたはリフレッシュ付与応答で返された ID、アクセストークン、およびリフレッシュトークンを暗号化されたセッションクッキーに保存します。</p>
</div>
<div class="paragraph">
<p>これにより、Quarkus OIDC エンドポイントは完全にステートレスになり、最高のスケーラビリティー結果を達成するには、このストラテジーに従うことが推奨されます。</p>
</div>
<div class="paragraph">
<p>データベースまたはその他のサーバー側ストレージソリューションにトークンを保存する方法は、このガイドの <a href="#db-token-state-manager">Database TokenStateManager</a> セクションを参照してください。この方法は、何らかの理由でトークンの状態をサーバー上に保存する必要がある場合に適しています。</p>
</div>
<div class="paragraph">
<p>トークン保存の代替方法については、<a href="#custom-token-state-manager">セッションクッキーとカスタムTokenStateManager</a> セクションを参照してください。これは特に、標準のサーバー側ストレージが要件を満たしていないなどの理由から、トークン状態管理のカスタマイズソリューションが必要な場合に最適です。</p>
</div>
<div class="paragraph">
<p>デフォルトの <code>TokenStateManager</code> を設定すると、アクセストークンをセッションクッキーに保存せずに、ID トークンとリフレッシュトークンのみ、または単一の ID トークンのみを保持できます。</p>
</div>
<div class="paragraph">
<p>アクセストークンは、エンドポイントが次のアクションを実行する必要がある場合にのみ必要です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UserInfo</code> の取得</p>
</li>
<li>
<p>このアクセストークンを使用したダウンストリームサービスへのアクセス</p>
</li>
<li>
<p>デフォルトでチェックされるアクセストークンに関連付けられたロールの使用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>このような場合は、 <code>quarkus.oidc.token-state-manager.strategy</code> プロパティーを使用して、トークン状態ストラテジーを次のように設定します。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">以下の場合</th>
<th class="tableblock halign-left valign-top">プロパティーを以下に設定する</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID とリフレッシュトークンのみを保存する場合</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>quarkus.oidc.token-state-manager.strategy=id-refresh-tokens</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID トークンのみを保存する場合</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>quarkus.oidc.token-state-manager.strategy=id-token</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>選択したセッションクッキーストラテジーがトークンを組み合わせ、4 KB を超える大きなセッションクッキー値が生成される場合、一部のブラウザーではそのようなクッキーサイズを処理できない可能性があります。
これは、ID、アクセストークン、およびリフレッシュトークンが JWT トークンで、選択されたストラテジーが <code>keep-all-tokens</code> の場合、またはストラテジーが <code>id-refresh-token</code> の場合にID トークンとリフレッシュトークンで発生する可能性があります。
この問題を回避するには、 <code>quarkus.oidc.token-state-manager.split-tokens=true</code> を設定して、トークンごとに一意のセッショントークンを作成します。
別の解決策として、トークンをデータベースに保存することが挙げられます。
詳細は、<a href="#db-token-state-manager">Database TokenStateManager</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>デフォルトの <code>TokenStateManager</code> は、トークンをセッションクッキーに保存する前に暗号化します。
次の例は、トークンを分割して暗号化するように設定する方法を示しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.secret=secret
quarkus.oidc.application-type=web-app
quarkus.oidc.token-state-manager.split-tokens=true
quarkus.oidc.token-state-manager.encryption-secret=eUk1p7UB3nFiXZGUXi0uph1Y9p34YhBU</code></pre>
</div>
</div>
<div class="paragraph">
<p>トークンの暗号化シークレットは 32 文字以上である必要があります。
このキーが設定されていない場合は、 <code>quarkus.oidc.credentials.secret</code> または <code>quarkus.oidc.credentials.jwt.secret</code> のいずれかがハッシュ化されて暗号化キーが作成されます。</p>
</div>
<div class="paragraph">
<p>Quarkus が次のいずれかの認証方法を使用して OIDC プロバイダーに対して認証する場合は、 <code>quarkus.oidc.token-state-manager.encryption-secret</code> プロパティーを設定してください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mTLS</p>
</li>
<li>
<p><code>private_key_jwt</code> では、秘密の RSA または EC キーを使用して JWT トークンに署名します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これ以外の場合は、ランダムなキーが生成されますが、Quarkus アプリケーションがクラウドで実行され、複数の Pod がリクエストを管理している場合、問題が発生する可能性があります。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.token-state-manager.encryption-required=false</code> を設定することで、セッションクッキーでのトークン暗号化を無効にすることができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="custom-token-state-manager"><a class="anchor" href="#custom-token-state-manager"></a>セッションクッキーとカスタムTokenStateManager</h4>
<div class="paragraph">
<p>トークンをセッションクッキーに関連付ける方法をカスタマイズしたい場合は、カスタム <code>io.quarkus.oidc.TokenStateManager' 実装を `@ApplicationScoped</code> CDI Bean として登録します。</p>
</div>
<div class="paragraph">
<p>たとえば、トークンをキャッシュクラスターに保持し、キーのみをセッションクッキーに保存することを推奨します。
トークンを複数のマイクロサービスノードで利用できるようにする必要がある場合、このアプローチではいくつかの課題が生じる可能性があることに注意してください。</p>
</div>
<div class="paragraph">
<p>簡単な例を挙げてみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.oidc.test;

import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Alternative;
import jakarta.inject.Inject;

import io.quarkus.oidc.AuthorizationCodeTokens;
import io.quarkus.oidc.OidcTenantConfig;
import io.quarkus.oidc.TokenStateManager;
import io.quarkus.oidc.runtime.DefaultTokenStateManager;
import io.smallrye.mutiny.Uni;
import io.vertx.ext.web.RoutingContext;

@ApplicationScoped
@Alternative
@Priority(1)
public class CustomTokenStateManager implements TokenStateManager {

    @Inject
    DefaultTokenStateManager tokenStateManager;

    @Override
    public Uni&lt;String&gt; createTokenState(RoutingContext routingContext, OidcTenantConfig oidcConfig,
            AuthorizationCodeTokens sessionContent, OidcRequestContext&lt;String&gt; requestContext) {
        return tokenStateManager.createTokenState(routingContext, oidcConfig, sessionContent, requestContext)
                .map(t -&gt; (t + "|custom"));
    }

    @Override
    public Uni&lt;AuthorizationCodeTokens&gt; getTokens(RoutingContext routingContext, OidcTenantConfig oidcConfig,
            String tokenState, OidcRequestContext&lt;AuthorizationCodeTokens&gt; requestContext) {
        if (!tokenState.endsWith("|custom")) {
            throw new IllegalStateException();
        }
        String defaultState = tokenState.substring(0, tokenState.length() - 7);
        return tokenStateManager.getTokens(routingContext, oidcConfig, defaultState, requestContext);
    }

    @Override
    public Uni&lt;Void&gt; deleteTokens(RoutingContext routingContext, OidcTenantConfig oidcConfig, String tokenState,
            OidcRequestContext&lt;Void&gt; requestContext) {
        if (!tokenState.endsWith("|custom")) {
            throw new IllegalStateException();
        }
        String defaultState = tokenState.substring(0, tokenState.length() - 7);
        return tokenStateManager.deleteTokens(routingContext, oidcConfig, defaultState, requestContext);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>暗号化されたセッションクッキーにトークンを保存するデフォルトの <code>TokenStateManager</code> の詳細は、<a href="#token-state-manager">セッションクッキーとデフォルトのTokenStateManager</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>トークンをデータベースに保存するカスタム Quarkus <code>TokenStateManager</code> 実装の詳細は、<a href="#db-token-state-manager">Database TokenStateManager</a> を参照してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="db-token-state-manager"><a class="anchor" href="#db-token-state-manager"></a>Database TokenStateManager</h4>
<div class="paragraph">
<p>ステートフルなトークンストレージストラテジーを採用したい場合は、Quarkus が提供するカスタムの <code>TokenStateManager</code> を使用して、アプリケーションがトークンを暗号化されたセッションクッキーに保存するのではなく、データベースに保存することができます。これは、<a href="#token-state-manager">セッションクッキーとデフォルトのTokenStateManager</a> セクションに記載されているとおり、デフォルトで設定されています。</p>
</div>
<div class="paragraph">
<p>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-sync-cli">
<div class="title">コマンドラインインタフェース</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">quarkus extension add oidc-db-token-state-manager</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-sync-maven">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw quarkus:add-extension -Dextensions='oidc-db-token-state-manager'</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-sync-gradle">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./gradlew addExtension --extensions='oidc-db-token-state-manager'</code></pre>
</div>
</div>
<div class="paragraph">
<p>このエクステンションは、デフォルトの `io.quarkus.oidc.TokenStateManager' をデータベースをベースとするものに置き換えます。</p>
</div>
<div class="paragraph">
<p>OIDC Database Token State Manager は、認証が IO スレッドで行われる可能性が高いため、ブロックを回避するために内部で Reactive SQL クライアントを使用します。</p>
</div>
<div class="paragraph">
<p>データベースに応じて、<a href="reactive-sql-clients">Reactive SQL クライアント</a> を 1 つだけ含めて設定します。
次の Reactive SQL クライアントがサポートされています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reactive Microsoft SQL クライアント</p>
</li>
<li>
<p>リアクティブMySQLクライアント</p>
</li>
<li>
<p>リアクティブなPostgreSQLクライアント</p>
</li>
<li>
<p>リアクティブオラクルクライアント</p>
</li>
<li>
<p>リアクティブ DB2 クライアント</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
アプリケーションがすでにいずれかの JDBC ドライバーエクステンションを備えた Hibernate ORM を使用している場合は、Reactive SQL クライアントを使用するように切り替える必要はありません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>たとえば、Hibernate ORM エクステンションと PostgreSQL JDBC ドライバーを併用するアプリケーションがすでにあり、データソースが次のように設定されているとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=quarkus_test
quarkus.datasource.password=quarkus_test
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで、OIDC Database Token State Manager を使用することにした場合は、次の依存関係を追加し、リアクティブドライバー URL を設定する必要があります。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-oidc-db-token-state-manager&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-reactive-pg-client&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-oidc-db-token-state-manager")
implementation("io.quarkus:quarkus-reactive-pg-client")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、トークンをデータベースに保存する準備が整いました。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、トークンの保存に使用されるデータベーステーブルが作成されますが、 <code>quarkus.oidc.db-token-state-manager.create-database-table-if-not-exists</code> 設定プロパティーを使用して、このオプションを無効にすることができます。
代わりに Hibernate ORM エクステンションでこのテーブルを作成する場合は、次のように Entity を含める必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.manager;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Table(name = "oidc_db_token_state_manager") <i class="conum" data-value="1"></i><b>(1)</b>
@Entity
public class OidcDbTokenStateManagerEntity {

    @Id
    String id;

    @Column(name = "id_token", length = 4000) <i class="conum" data-value="2"></i><b>(2)</b>
    String idToken;

    @Column(name = "refresh_token", length = 4000)
    String refreshToken;

    @Column(name = "access_token", length = 4000)
    String accessToken;

    @Column(name = "expires_in")
    Long expiresIn;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hibernate ORM エクステンションは、データベーススキーマが生成された場合にのみ、このテーブルを作成します。
詳細は、<a href="hibernate-orm">Hibernate ORM</a> ガイドを参照してください。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>トークンの長さに応じて列の長さを選択できます。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="redis-token-state-manager"><a class="anchor" href="#redis-token-state-manager"></a>Redis TokenStateManager</h4>
<div class="paragraph">
<p>ステートフルトークンストレージストラテジーの別の方法として、、Quarkus が提供するカスタム <code>TokenStateManager</code> を使用して、アプリケーションでトークンを Redis キャッシュに保存する方法があります。
OIDC Redis Token State Manager を使用する場合は、次の依存関係を追加する必要があります。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-oidc-redis-token-state-manager&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-oidc-redis-token-state-manager")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quarkus はトークンをデフォルトの Redis クライアントに保存します。
別の Redis クライアントを使用する場合は、次の例のように設定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.redis-token-state-manager.redis-client-name=my-redis-client <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>my-redis-client</code> の名前は、 <code>quarkus.redis.my-redis-client.*</code> 設定プロパティーで指定された Redis クライアント設定キーに対応している必要があります。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Redis クライアントの設定方法については、<a href="redis-reference">Quarkus Redis クライアントリファレンス</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logout-and-expiration"><a class="anchor" href="#logout-and-expiration"></a>ログアウトと有効期限</h3>
<div class="paragraph">
<p>認証情報が期限切れになる主な方法は 2 つあります。トークンの有効期限が切れて更新されなかった場合と、明示的なログアウト操作がトリガーされた場合です。</p>
</div>
<div class="paragraph">
<p>最初に、明示的なログアウト操作について説明します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can request setting <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Clear-Site-Data">Clear-Site-Data</a> directives for all of the logout operations with a <code>quarkus.oidc.logout.clear-site-data</code> configuration property. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.logout.clear-site-data=cache,cookies</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="user-initiated-logout"><a class="anchor" href="#user-initiated-logout"></a>ユーザー主導のログアウト</h4>
<div class="paragraph">
<p>ユーザーは、 <code>quarkus.oidc.logout.path</code> プロパティーで設定された Quarkus エンドポイントのログアウトパスにリクエストを送信することで、ログアウトをリクエストできます。
たとえば、エンドポイントアドレスが <code><a href="https://application.com/webapp" class="bare">https://application.com/webapp</a></code> で、 <code>quarkus.oidc.logout.path</code> が <code>/logout</code> に設定されている場合、ログアウトリクエストは <code><a href="https://application.com/webapp/logout" class="bare">https://application.com/webapp/logout</a></code> に送信される必要があります。</p>
</div>
<div class="paragraph">
<p>このログアウト要求は、 <a href="https://openid.net/specs/openid-connect-session-1_0.html#RPLogout">RP-initiated logout</a> を開始します。
ユーザはログアウトするためにOIDCプロバイダにリダイレクトされ、そこでログアウトが本当に意図されたものであるか確認されます。</p>
</div>
<div class="paragraph">
<p>ログアウトが完了し、 <code>quarkus.oidc.logout.post-logout-path</code> プロパティーが設定されている場合、ユーザーはエンドポイントのログアウト後のページに戻されます。
たとえば、エンドポイントアドレスが <code><a href="https://application.com/webapp" class="bare">https://application.com/webapp</a></code> で、 <code>quarkus.oidc.logout.post-logout-path</code> が <code>/signin</code> に設定されている場合、ユーザーは <code><a href="https://application.com/webapp/signin" class="bare">https://application.com/webapp/signin</a></code> に戻されます。
この URI は、OIDC プロバイダーで有効な <code>post_logout_redirect_uri</code> として登録されている必要があることに注意してください。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.logout.post-logout-path</code> が設定されている場合、 <code>q_post_logout</code> クッキーが作成され、一致する <code>state</code> クエリーパラメーターがログアウトリダイレクト URI に追加され、ログアウトが完了すると OIDC プロバイダーはこの <code>state</code> を返します。
Quarkus の <code>web-app</code> アプリケーションでは、 <code>state</code> クエリーパラメーターが <code>q_post_logout</code> クッキーの値と一致することを確認することを推奨します。これは、たとえば Jakarta REST フィルターで実行できます。</p>
</div>
<div class="paragraph">
<p><a href="security-openid-connect-multitenancy">OpenID Connect Multi-Tenancy</a> を使用する場合、クッキー名が異なることに注意してください。
たとえば、 <code>tenant_1</code> ID を持つテナントの場合は <code>q_post_logout_tenant_1</code> という名前になります。</p>
</div>
<div class="paragraph">
<p>ログアウトフローを開始するように Quarkus アプリケーションを設定する方法の例を次に示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.client-id=frontend
quarkus.oidc.credentials.secret=secret
quarkus.oidc.application-type=web-app

quarkus.oidc.logout.path=/logout
# Logged-out users should be returned to the /welcome.html site which will offer an option to re-login:
quarkus.oidc.logout.post-logout-path=/welcome.html

# Only the authenticated users can initiate a logout:
quarkus.http.auth.permission.authenticated.paths=/logout
quarkus.http.auth.permission.authenticated.policy=authenticated

# All users can see the Welcome page:
quarkus.http.auth.permission.public.paths=/welcome.html
quarkus.http.auth.permission.public.policy=permit</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、 <code>quarkus.oidc.authentication.cookie-path</code> をすべてのアプリケーションリソースに共通のパス値 (この例では <code>/</code>) に設定することも推奨します。
詳細は、<a href="#oidc-cookies">Cookies</a> セクションを参照してください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一部の OIDC プロバイダーは、<a href="https://openid.net/specs/openid-connect-session-1_0.html#RPLogout">RP-initiated ログアウト</a> 仕様をサポートしておらず、OpenID Connect の周知の（well-knownの） <code>end_session_endpoint</code> メタデータプロパティーを返しません。
ただし、このような OIDC プロバイダーの特定のログアウトメカニズムは、ログアウト URL クエリーパラメーターの命名方法のみが異なるため、Quarkus にとってはこれは問題ではありません。</p>
</div>
<div class="paragraph">
<p><a href="https://openid.net/specs/openid-connect-session-1_0.html#RPLogout">RP-initiated ログアウト</a> 仕様によれば、 <code>quarkus.oidc.logout.post-logout-path</code> プロパティーは <code>post_logout_redirect_uri</code> クエリーパラメーターとして表されますが、この仕様をサポートしていないプロバイダーでは認識されません。</p>
</div>
<div class="paragraph">
<p>この問題を回避するには、 <code>quarkus.oidc.logout.post-logout-url-param</code> を使用できます。 <code>quarkus.oidc.logout.extra-params</code> で追加されたログアウトクエリーパラメーターをさらにリクエストすることもできます。たとえば、 <code>Auth0</code> でログアウトをサポートする方法は次のとおりです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=https://dev-xxx.us.auth0.com
quarkus.oidc.client-id=redacted
quarkus.oidc.credentials.secret=redacted
quarkus.oidc.application-type=web-app

quarkus.oidc.tenant-logout.logout.path=/logout
quarkus.oidc.tenant-logout.logout.post-logout-path=/welcome.html

# Auth0 does not return the `end_session_endpoint` metadata property. Instead, you must configure it:
quarkus.oidc.end-session-path=v2/logout
# Auth0 will not recognize the 'post_logout_redirect_uri' query parameter so ensure it is named as 'returnTo':
quarkus.oidc.logout.post-logout-uri-param=returnTo

# Set more properties if needed.
# For example, if 'client_id' is provided, then a valid logout URI should be set as the Auth0 Application property, without it - as Auth0 Tenant property:
quarkus.oidc.logout.extra-params.client_id=${quarkus.oidc.client-id}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="back-channel-logout"><a class="anchor" href="#back-channel-logout"></a>バックチャネルログアウト</h4>
<div class="paragraph">
<p>OIDC プロバイダは、認証データを使用して、すべてのアプリケーションを強制的にログアウトさせることができます。
これはバックチャネルログアウトとして知られています。
この場合、OIDC は各アプリケーションから特定の URL を呼び出し、ログアウトをトリガーします。</p>
</div>
<div class="paragraph">
<p>OIDCプロバイダは、 <a href="https://openid.net/specs/openid-connect-backchannel-1_0.html">バックチャネルログアウト</a> を使用して、ユーザエージェントをバイパスして、そのユーザが現在ログインしているすべてのアプリケーションから現在のユーザをログアウトします。</p>
</div>
<div class="paragraph">
<p>バックチャネルログアウトをサポートするようにQuarkusを設定するには、次のようにします：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.client-id=frontend
quarkus.oidc.credentials.secret=secret
quarkus.oidc.application-type=web-app

quarkus.oidc.logout.backchannel.path=/back-channel-logout</code></pre>
</div>
</div>
<div class="paragraph">
<p>絶対的な <code>back-channel logout</code> URL は、現在のエンドポイント URL に <code>quarkus.oidc.back-channel-logout.path</code> を追加することによって計算されます (例: <code><a href="http://localhost:8080/back-channel-logout" class="bare">http://localhost:8080/back-channel-logout</a></code>)。
この URL は、OIDC プロバイダーの管理コンソールで設定する必要があります。</p>
</div>
<div class="paragraph">
<p>OIDC プロバイダーが、現在のログアウトトークンに有効期限を設定していない場合、ログアウトトークンの検証が成功するようにトークンの有効期間プロパティーを設定する必要もあります。
たとえば、ログアウトトークンの <code>iat</code> (発行時刻) から 10 秒超過しないようにするには、 <code>quarkus.oidc.token.age=10S</code> を設定します。</p>
</div>
</div>
<div class="sect3">
<h4 id="front-channel-logout"><a class="anchor" href="#front-channel-logout"></a>フロントチャンネルログアウト</h4>
<div class="paragraph">
<p><a href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">フロントチャネルログアウト</a> を使用すると、ユーザエージェント（ブラウザなど）から現在のユーザを直接ログアウトすることができます。
これは <a href="#back-channel-logout">バックチャネルログアウト</a> と似ていますが、ログアウトの手順はOIDCプロバイダによってバックグラウンドで実行されるのではなく、ブラウザなどのユーザーエージェントによって実行されます。
このオプションはほとんど使用されません。</p>
</div>
<div class="paragraph">
<p>Quarkusでフロントチャンネルのログアウトをサポートするには、以下のように設定します：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.client-id=frontend
quarkus.oidc.credentials.secret=secret
quarkus.oidc.application-type=web-app

quarkus.oidc.logout.frontchannel.path=/front-channel-logout</code></pre>
</div>
</div>
<div class="paragraph">
<p>このパスは現在のリクエストのパスと比較され、これらのパスがマッチする 場合、ユーザはログアウトします。</p>
</div>
</div>
<div class="sect3">
<h4 id="local-logout"><a class="anchor" href="#local-logout"></a>ローカルログアウト</h4>
<div class="paragraph">
<p><a href="#user-initiated-logout">ユーザーによるログアウト</a> は、ユーザーをOIDCプロバイダーからログアウトさせます。シングルサインオンとして使用される場合、それはあなたが必要とするものではないかもしれません。例えば、あなたのOIDCプロバイダがGoogleの場合、あなたはGoogleとそのサービスからログアウトすることになります。代わりに、ユーザーは特定のアプリケーションからログアウトしたいだけかもしれません。もう1つのユースケースは、OIDCプロバイダがログアウトエンドポイントを持っていない場合です。</p>
</div>
<div class="paragraph">
<p><a href="#oidc-session">OidcSession</a> を使用することで、次の例に示すように、ローカル・セッション・クッキーだけがクリアされるローカル・ログアウトをサポートすることができます：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.quarkus.oidc.OidcSession;

@Path("/service")
public class ServiceResource {

    @Inject
    OidcSession oidcSession;

    @GET
    @Path("logout")
    public String logout() {
        oidcSession.logout().await().indefinitely();
        return "You are logged out";
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oidc-session"><a class="anchor" href="#oidc-session"></a><code>OidcSession</code> をローカルログアウトに使用</h4>
<div class="paragraph">
<p><code>io.quarkus.oidc.OidcSession</code> は現在の <code>IdToken</code> のラッパーで、<a href="#local-logout">Local logout</a> の実行、現行セッションのテナント識別子の取得、セッションの有効期限の確認を行う上で役に立ちます。
今後、より便利なメソッドが追加される予定です。</p>
</div>
</div>
<div class="sect3">
<h4 id="session-management"><a class="anchor" href="#session-management"></a>セッション管理</h4>
<div class="paragraph">
<p>デフォルトでは、ログアウトはOIDCプロバイダによって発行されたIDトークンの有効期限に基づいて行われます。
IDトークンの有効期限が切れると、Quarkusエンドポイントでの現在のユーザーセッションは無効になり、ユーザーは認証のために再度OIDCプロバイダーにリダイレクトされます。
OIDCプロバイダのセッションがまだ有効な場合、ユーザーは再度クレデンシャルを入力することなく、自動的に再認証されます。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.token.refresh-expired</code> プロパティーを有効にすると、現在のユーザーセッションを自動的に延長できます。
<code>true</code> に設定すると、現在の ID トークンの有効期限が切れたときに、リフレッシュトークンの付与を使用して、ID トークンだけでなくアクセストークンとリフレッシュトークンもリフレッシュされます。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>keycloak.js</code> などの OIDC プロバイダースクリプトが認可コードフローを管理している <a href="security-oidc-bearer-token-authentication#single-page-applications">サービスアプリケーション用のシングルページアプリケーション</a> がある場合、そのスクリプトは SPA 認証セッションの有効期間も制御します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Quarkus OIDC <code>web-app</code> アプリケーションを使用する場合、Quarkus OIDC コード認証メカニズムがユーザーセッションの有効期間を管理します。</p>
</div>
<div class="paragraph">
<p>リフレッシュトークンを使用するには、セッションクッキーの有効期間を慎重に設定する必要があります。
セッションの有効期間は、ID トークンの有効期間よりも長く、リフレッシュトークンの有効期間と近いか等しい必要があります。</p>
</div>
<div class="paragraph">
<p>セッションの有効期間は、現在の ID トークンの有効期間の値と、 <code>quarkus.oidc.authentication.session-age-extension</code> プロパティーおよび <code>quarkus.oidc.token.lifespan-grace</code> プロパティーの値を加算して計算します。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>必要に応じて、 <code>quarkus.oidc.authentication.session-age-extension</code> プロパティーのみを使用して、セッションの有効期間を大幅に延長します。
<code>quarkus.oidc.token.lifespan-grace</code> プロパティーは、小さなクロックスキューを考慮する場合にのみ使用します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>現在認証されているユーザーが、保護された Quarkus エンドポイントに戻り、セッションクッキーに関連付けられた ID トークンの有効期限が切れると、デフォルトでは、ユーザーは再認証のために OIDC 認可エンドポイントに自動的にリダイレクトされます。
ユーザーとこの OIDC プロバイダー間のセッションがまだアクティブな場合、OIDC プロバイダーはユーザーに再度チャレンジする可能性があります。これは、セッションが ID トークンよりも長く続くように設定されている場合に発生する可能性があります。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.token.refresh-expired</code> が <code>true</code> に設定されている場合、期限切れの ID トークン (およびアクセストークン) は、初期認可コード付与応答で返されたリフレッシュトークンを使用して更新されます。
このリフレッシュトークンも、このプロセスの一環としてリサイクル (リフレッシュ) される可能性があります。
その結果、新しいセッションクッキーが作成され、セッションが延長されます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ユーザーがあまりアクティブでない場合は、 <code>quarkus.oidc.authentication.session-age-extension</code> プロパティーを使用して、期限切れの ID トークンを処理できます。
ID トークンの有効期限が切れると、クッキーの有効期間が経過するため、次のユーザーリクエスト時にセッションクッキーが Quarkus エンドポイントに返されない可能性があります。
Quarkus は、このリクエストが最初の認証リクエストであると想定します。
<code>quarkus.oidc.authentication.session-age-extension</code> を、ほとんどアクティブでないユーザーとセキュリティーポリシーに合わせて、<em>適度に</em> 長い値に設定します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>さらに一歩進んで、期限切れが近づいている ID トークンまたはアクセストークンを事前に更新することもできます。
<code>quarkus.oidc.token.refresh-token-time-skew</code> を、更新を予測する値に設定します。
現在のユーザーリクエスト中に、現在の ID トークンがこの <code>quarkus.oidc.token.refresh-token-time-skew</code> 内に期限切れになると計算された場合、トークンは更新され、新しいセッションクッキーが作成されます。
このプロパティーは、ID トークンの有効期間よりも短い値に設定する必要があります。この有効期間の値に近いほど、ID トークンの更新頻度が高くなります。</p>
</div>
<div class="paragraph">
<p>単純な JavaScript 関数を使用して Quarkus エンドポイントに定期的に ping を送信し、ユーザーアクティビティーをエミュレートすることで、このプロセスをさらに最適化できます。これにより、ユーザーが再認証される必要がある時間枠が最小限に抑えられます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>セッションを更新できない場合、現在認証されているユーザーが OIDC プロバイダーにリダイレクトされ、再認証が行われます。ただし、ユーザーが以前に認証に成功した後、アプリケーションページにアクセスしようとしたときに突然 OIDC 認証チャレンジ画面が表示されるのは、ユーザーエクスペリエンスとして最適ではない可能性があります。</p>
</div>
<div class="paragraph">
<p>代わりに、まずユーザーをパブリックのアプリケーション固有のセッション期限切れページにリダイレクトするようにリクエストできます。このページで、セッションの有効期限が切れたことをユーザーに通知し、保護されたアプリケーションのウェルカムページへのリンクをたどって再認証するように指示します。ユーザーがリンクをクリックすると、Quarkus OIDC が再認証のために OIDC プロバイダーへのリダイレクトを適用します。必要に応じて、 <code>quarkus.oidc.authentication.session-expired-page</code> 相対パスプロパティーを使用します。</p>
</div>
<div class="paragraph">
<p>たとえば、アプリケーションが <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code> で利用できると仮定した場合、 <code>quarkus.oidc.authentication.session-expired-page=/session-expired-page</code> を設定すると、セッションの有効期限が切れたユーザーが <code><a href="http://localhost:8080/session-expired-page" class="bare">http://localhost:8080/session-expired-page</a></code> にリダイレクトされるようになります。</p>
</div>
<div class="paragraph">
<p>また、カスタムの <code>OidcRedirectFilter</code> を使用して、セッション期限切れページへのリダイレクトを含む OIDC リダイレクトをカスタマイズする方法については、<a href="#oidc-redirect-filters">OIDC リダイレクトフィルター</a> セクションを参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このユーザーセッションを無期限に延長することはできません。
有効期限が切れた ID トークンを持つ復帰ユーザーは、リフレッシュトークンの有効期限が切れると、OIDC プロバイダーエンドポイントで再認証する必要があります。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2"><a class="anchor" href="#oauth2"></a>GitHubおよびOIDC以外のOAuth2プロバイダとの統合</h3>
<div class="paragraph">
<p>GitHubやLinkedInのような有名なプロバイダはOpenID Connectプロバイダではなく、 <code>authorization code flow</code> をサポートするOAuth2プロバイダです。 
例えば、 <a href="https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps">GitHub OAuth2</a> や <a href="https://docs.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow">LinkedIn OAuth2</a> などです。
OIDCはOAuth2の上に構築されていることを思い出してください。</p>
</div>
<div class="paragraph">
<p>OIDC プロバイダと OAuth2 プロバイダの主な違いは、OIDC プロバイダは <code>OAuth2</code> プロバイダが返す標準認可コードフロー <code>access</code> および <code>refresh</code> トークンに加えて、ユーザ認証を表す <code>ID Token</code> を返すことです。</p>
</div>
<div class="paragraph">
<p>GitHub などの OAuth2 プロバイダは <code>IdToken</code> を返さないため、ユーザー認証は <code>access</code> トークンによって暗黙的かつ間接的に表現されます。
この <code>access</code> トークンは、現在のQuarkus <code>web-app</code> アプリケーションが認証されたユーザーに代わってデータにアクセスすることを認可する、認証されたユーザーを表します。</p>
</div>
<div class="paragraph">
<p>OIDC の場合は、認証の有効性の証明として ID トークンを検証しますが、OAuth2 の場合はアクセストークンを検証します。
これは、アクセストークンを必要とし、通常はユーザー情報を返すエンドポイントを後で呼び出すことによって実行されます。
これは、OIDC <a href="#code-flow-user-info">UserInfo</a> と同様のアプローチで、ユーザーに代わって Quarkus OIDC が <code>UserInfo</code> を取得します。</p>
</div>
<div class="paragraph">
<p>例えば、GitHubと連携する場合、Quarkusエンドポイントは <code>access</code> トークンを取得できます。これにより、Quarkusエンドポイントは現在のユーザーのGitHubプロファイルを要求できます。</p>
</div>
<div class="paragraph">
<p>このような OAuth2 サーバーとのインテグレーションをサポートするには、 <code>quarkus-oidc</code> を少し異なる方法で設定して、 <code>IdToken</code>: <code>quarkus.oidc.authentication.id-token-required=false</code> なしで認可コードフローの応答を許可する必要があります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>IdToken</code> なしで認可コードフローをサポートするようにエクステンションを設定しても、 <code>quarkus-oidc</code> の動作を標準化するために内部 <code>IdToken</code> が生成されます。
認証セッションをサポートし、リクエストごとにユーザーを GitHub などのプロバイダーにリダイレクトしないようにするには、内部 <code>IdToken</code> を使用します。
この場合、 <code>IdToken</code> の有効期間は、認可コードフローのレスポンス内の標準の <code>expires_in</code> プロパティーの値に設定されます。
ID トークンの有効期間をカスタマイズするには、 <code>quarkus.oidc.authentication.internal-id-token-lifespan</code> プロパティーを使用できます。
ID トークンの有効期間はデフォルトで 5 分ですが、<a href="#session-management">session management</a> セクションで説明されているとおり延長できます。</p>
</div>
<div class="paragraph">
<p>これにより、複数のOIDCプロバイダをサポートするアプリケーションの取り扱いが簡単になります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次の手順は、返されたアクセストークンが有用であり、現在の Quarkus エンドポイントに対して有効だと確認することです。
最初の方法は、 <code>quarkus.oidc.introspection-path</code> を設定して OAuth2 プロバイダーのイントロスペクションエンドポイントを呼び出すことです (プロバイダーがそのようなエンドポイントを提供している場合)。
この場合、 <code>quarkus.oidc.roles.source=accesstoken</code> を使用して、アクセストークンをロールのソースとして使用できます。
イントロスペクションエンドポイントが存在しない場合は、代わりに <a href="#code-flow-user-info">UserInfo</a> (少なくともアクセストークンを検証するため) をプロバイダーにリクエストすることを試行できます。
これを行うには、 <code>quarkus.oidc.token.verify-access-token-with-user-info=true</code> を指定します。
また、 <code>quarkus.oidc.user-info-path</code> プロパティーを、ユーザー情報を取得する URL エンドポイント (またはアクセストークンによって保護されたエンドポイント) に設定する必要もあります。
GitHub の場合、イントロスペクションエンドポイントがないため、UserInfo をリクエストする必要があります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#code-flow-user-info">UserInfo</a> が必要な場合、リクエストごとにリモート呼び出しが実行されます。</p>
</div>
<div class="paragraph">
<p>したがって、 <code>UserInfo</code> は内部で生成された <code>IdToken</code> に埋め込まれ、暗号化されたセッション Cookie に保存されます。これは <code>quarkus.oidc.cache-user-info-in-idtoken=false</code> で無効にできます。</p>
</div>
<div class="paragraph">
<p>デフォルトまたはカスタムの UserInfo キャッシュプロバイダーを使用して <code>UserInfo</code> をキャッシュすることも検討してください。
詳細は、「OpenID Connect (OIDC) ベアラートークン認証」ガイドの <a href="security-oidc-bearer-token-authentication#bearer-token-token-introspection-userinfo-cache">トークンイントロスペクションと UserInfo キャッシュ</a> セクションを参照してください。</p>
</div>
<div class="paragraph">
<p>よく知られているソーシャル OAuth2 プロバイダーのほとんどは帯域制限を実施しているため、UserInfo をキャッシュするのがよい場合が多いでしょう。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>OAuth2 サーバーは、よく知られた設定エンドポイントをサポートしていない可能性があります。
この場合、検出を無効にして、認可、トークン、イントロスペクション、および <code>UserInfo</code> エンドポイントパスを手動で設定する必要があります。</p>
</div>
<div class="paragraph">
<p>Apple、Facebook、GitHub、Google、Microsoft、Spotify、X (旧 Twitter) などのよく知られた OIDC または OAuth2 プロバイダーの場合、Quarkus は <code>quarkus.oidc.provider</code> プロパティーを使用して、アプリケーションの設定を大幅に簡素化できます。
l<a href="https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app">GitHub OAuth アプリケーションを作成</a> した後に、 <code>quarkus-oidc</code> を GitHub と統合する方法は次のとおりです。
Quarkus エンドポイントを次のように設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.provider=github
quarkus.oidc.client-id=github_app_clientid
quarkus.oidc.credentials.secret=github_app_clientsecret

# user:email scope is requested by default, use 'quarkus.oidc.authentication.scopes' to request different scopes such as `read:user`.
# See https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps for more information.

# Consider enabling UserInfo Cache
# quarkus.oidc.token-cache.max-size=1000
# quarkus.oidc.token-cache.time-to-live=5M
#
# Or having UserInfo cached inside IdToken itself
# quarkus.oidc.cache-user-info-in-idtoken=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>他のよく知られているプロバイダーの設定に関する詳細は、<a href="security-openid-connect-providers">OpenID Connect プロバイダー</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>このようなエンドポイントに対して必要なのは、現在認証されているユーザーのプロファイルを <code>GET <a href="http://localhost:8080/github/userinfo" class="bare">http://localhost:8080/github/userinfo</a></code> で返し、個々の <code>UserInfo</code> のプロパティーとしてアクセスすることです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;

import io.quarkus.oidc.UserInfo;
import io.quarkus.security.Authenticated;

@Path("/github")
@Authenticated
public class TokenResource {

    @Inject
    UserInfo userInfo;

    @GET
    @Path("/userinfo")
    @Produces("application/json")
    public String getUserInfo() {
        return userInfo.getUserInfoString();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="security-openid-connect-multitenancy">OpenID Connect Multi-Tenancy</a> を使用して複数のソーシャルプロバイダー (たとえば、 <code>IdToken</code> を返す OIDC プロバイダーの Google と、 <code>IdToken</code> を返さず <code>UserInfo</code> へのアクセスのみを許可する OAuth2 プロバイダーの GitHub) をサポートする場合、Google フローと GitHub フローの両方で、注入された <code>SecurityIdentity</code> のみを使用してエンドポイントを動作させることができます。
GitHub フローがアクティブな場合に、内部で生成された <code>IdToken</code> で作成されたプリンシパルが <code>UserInfo</code> ベースのプリンシパルに置き換えられる場合は、 <code>SecurityIdentity</code> の簡単な拡張が必要になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import java.security.Principal;

import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.oidc.UserInfo;
import io.quarkus.security.identity.AuthenticationRequestContext;
import io.quarkus.security.identity.SecurityIdentity;
import io.quarkus.security.identity.SecurityIdentityAugmentor;
import io.quarkus.security.runtime.QuarkusSecurityIdentity;
import io.smallrye.mutiny.Uni;
import io.vertx.ext.web.RoutingContext;

@ApplicationScoped
public class CustomSecurityIdentityAugmentor implements SecurityIdentityAugmentor {

    @Override
    public Uni&lt;SecurityIdentity&gt; augment(SecurityIdentity identity, AuthenticationRequestContext context) {
        RoutingContext routingContext = identity.getAttribute(RoutingContext.class.getName());
        if (routingContext != null &amp;&amp; routingContext.normalizedPath().endsWith("/github")) {
	        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder(identity);
	        UserInfo userInfo = identity.getAttribute("userinfo");
	        builder.setPrincipal(new Principal() {

	            @Override
	            public String getName() {
	                return userInfo.getString("preferred_username");
	            }

	        });
	        identity = builder.build();
        }
        return Uni.createFrom().item(identity);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、ユーザーが Google または GitHub を使用してアプリケーションにサインインすると、次のコードが機能するようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;

import io.quarkus.security.Authenticated;
import io.quarkus.security.identity.SecurityIdentity;

@Path("/service")
@Authenticated
public class TokenResource {

    @Inject
    SecurityIdentity identity;

    @GET
    @Path("/google")
    @Produces("application/json")
    public String getGoogleUserName() {
        return identity.getPrincipal().getName();
    }

    @GET
    @Path("/github")
    @Produces("application/json")
    public String getGitHubUserName() {
        return identity.getPrincipal().getName();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>おそらく、より簡単な代替案は、 <code>@IdToken JsonWebToken</code> と <code>UserInfo</code> の両方を注入し、 <code>IdToken</code> を返すプロバイダーを処理する際は <code>JsonWebToken</code> を使用して、 <code>IdToken</code> を返さないプロバイダーの場合は <code>UserInfo</code> を使用することです。</p>
</div>
<div class="paragraph">
<p>GitHub OAuth アプリケーション設定に入力するコールバックパスが、GitHub 認証とアプリケーション認可が成功した後にユーザーをリダイレクトするエンドポイントパスと一致していることを確認する必要があります。
この場合は、 <code><a href="http://localhost:8080/github/userinfo" class="bare">http://localhost:8080/github/userinfo</a></code> に設定する必要があります。</p>
</div>
</div>
<div class="sect2">
<h3 id="listen-to-authentication-events"><a class="anchor" href="#listen-to-authentication-events"></a>重要な認証イベントのリッスン</h3>
<div class="paragraph">
<p>重要な OIDC 認証イベントを監視する <code>@ApplicationScoped</code> Bean を登録できます。
ユーザが初めてログインしたり、再認証したり、セッションをリフレッシュしたりすると、リスナーが更新されます。
将来的には、さらに多くのイベントが報告されるようになるかもしれません。
例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;

import io.quarkus.oidc.SecurityEvent;
import io.vertx.ext.web.RoutingContext;

@ApplicationScoped
public class SecurityEventListener {

    public void event(@Observes SecurityEvent event) {
        String tenantId = event.getSecurityIdentity().getAttribute("tenant-id");
        RoutingContext vertxContext = event.getSecurityIdentity().getAttribute(RoutingContext.class.getName());
        vertxContext.put("listener-message", String.format("event:%s,tenantId:%s", event.getEventType().name(), tenantId));
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
「セキュリティのヒントとコツ」ガイドの <a href="security-customization#observe-security-events">セキュリティイベントの監視</a> セクションで説明されているように、他のセキュリティイベントを聞くことができます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="oidc-token-revocation"><a class="anchor" href="#oidc-token-revocation"></a>トークンの失効</h3>
<div class="paragraph">
<p>場合によっては、現在の認可コードフローアクセストークンやリフレッシュトークンを取り消す必要があることもあります。
その場合は、OIDC プロバイダーの UserInfo、トークンイントロスペクション、失効エンドポイントへのアクセスが提供される <code>quarkus.oidc.OidcProviderClient</code> を使用してトークンを取り消すことができます。</p>
</div>
<div class="paragraph">
<p>たとえば、<a href="#oidc-session">OidcSession</a> でローカルログアウトが実行されると、注入された <code>OidcProviderClient</code> を使用して、現在のセッションに関連付けられているアクセストークンとリフレッシュトークンを取り消すことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.quarkus.oidc.AccessTokenCredential;
import io.quarkus.oidc.OidcProviderClient;
import io.quarkus.oidc.OidcSession;
import io.quarkus.oidc.RefreshToken;

import io.smallrye.mutiny.Uni;

@Path("/service")
public class ServiceResource {

    @Inject
    OidcSession oidcSession;

    @Inject
    OidcProviderClient oidcProviderClient;

    @Inject
    AccessTokenCredential accessToken;

    @Inject
    RefreshToken refreshToken;

    @GET
    public Uni&lt;String&gt; logout() {
        return oidcSession.logout() <i class="conum" data-value="1"></i><b>(1)</b>
                   .chain(() -&gt; oidcClient.revokeAccessToken(accessToken.getToken())) <i class="conum" data-value="2"></i><b>(2)</b>
                   .chain(() -&gt; oidcClient.revokeRefreshToken(refreshToken.getToken())) <i class="conum" data-value="3"></i><b>(3)</b>
                   .map((result) -&gt; "You are logged out");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>セッション Cookie をクリアしてローカルログアウトを実行します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>認可コードフローのアクセストークンを取り消します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>認可コードフローのリフレッシュトークンを取り消します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also revoke tokens in the security event listeners.</p>
</div>
<div class="paragraph">
<p>For example, when your application supports a standard <a href="#user-initiated-logout">ユーザー主導のログアウト</a>, you can catch a logout event and revoke tokens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import io.quarkus.oidc.AccessTokenCredential;
import io.quarkus.oidc.OidcProviderClient;
import io.quarkus.oidc.RefreshToken;
import io.quarkus.oidc.SecurityEvent;
import io.quarkus.security.identity.SecurityIdentity;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.ObservesAsync;

@ApplicationScoped
public class SecurityEventListener {

    public CompletionStage&lt;Void&gt; processSecurityEvent(@ObservesAsync SecurityEvent event) {
        if (SecurityEvent.Type.OIDC_LOGOUT_RP_INITIATED == event.getEventType()) { <i class="conum" data-value="1"></i><b>(1)</b>
	    return revokeTokens(event.getSecurityIdentity()).subscribeAsCompletionStage();
	}
	return CompletableFuture.completedFuture(null);
    }
    private Uni&lt;Void&gt; revokeTokens(SecurityIdentity securityIdentity) {
        return Uni.join().all(
                   revokeAccessToken(securityIdentity),
	           revokeRefreshToken(securityIdentity)
               ).andCollectFailures()
                .replaceWithVoid()
                .onFailure().recoverWithUni(t -&gt; logFailure(t));
    }

    private static Uni&lt;Boolean&gt; revokeAccessToken(SecurityIdentity securityIdentity) { <i class="conum" data-value="2"></i><b>(2)</b>
        OidcProviderClient oidcProvider = securityIdentity.getAttribute(OidcProviderClient.class.getName());
        String accessToken = securityIdentity.getCredential(AccessTokenCredential.class).getToken();
        return oidcProvider.revokeAccessToken(accessToken);
    }

    private static Uni&lt;Boolean&gt; revokeRefreshToken(SecurityIdentity securityIdentity) { <i class="conum" data-value="3"></i><b>(3)</b>
        OidcProviderClient oidcProvider = securityIdentity.getAttribute(OidcProviderClient.class.getName());
        String refreshToken = securityIdentity.getCredential(RefreshToken.class).getToken();
        return oidcProvider.revokeRefreshToken(refreshToken);
    }

    private static Uni&lt;Void&gt; logFailure(Throwable t) {
        // Log failure as required
        return Uni.createFrom().voidItem();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Revoke tokens if an RP-initiated logout event is observed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>認可コードフローのアクセストークンを取り消します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>認可コードフローのリフレッシュトークンを取り消します。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="propagating-tokens-to-downstream-services"><a class="anchor" href="#propagating-tokens-to-downstream-services"></a>下流サービスへのトークンの伝播</h3>
<div class="paragraph">
<p>認可コードフローから下流のサービスへのアクセストークンの伝播については、<a href="security-openid-connect-client-reference#token-propagation-rest">トークンの伝播</a> セクションを参照してください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integration-considerations"><a class="anchor" href="#integration-considerations"></a>統合に関する考慮事項</h2>
<div class="sectionbody">
<div class="paragraph">
<p>OIDC によって保護されたアプリケーションは、シングルページアプリケーションから呼び出すことができる環境に統合されます。
これは、よく知られている OIDC プロバイダーと連携し、HTTP リバースプロキシーの背後で実行される必要があるほか、外部および内部アクセスなども必要とされます。</p>
</div>
<div class="paragraph">
<p>このセクションでは、これらの考慮事項について説明します。</p>
</div>
<div class="sect2">
<h3 id="single-page-applications"><a class="anchor" href="#single-page-applications"></a>シングルページ・アプリケーション</h3>
<div class="paragraph">
<p>「OpenID Connect (OIDC) ベアラートークン認証」ガイドの <a href="security-oidc-bearer-token-authentication#single-page-applications">シングルページアプリケーション</a> セクションで提案されている方法でシングルページアプリケーション (SPA) を実装した場合、要件が満たされるか確認できます。</p>
</div>
<div class="paragraph">
<p>Quarkus Web アプリケーションで <code>Fetch</code> や <code>XMLHttpRequest</code>(XHR) などの SPA および JavaScript API を使用する場合は、Quarkus からのリダイレクト後にユーザーが認証される認可エンドポイントに対して、OIDC プロバイダーがクロスオリジンリソース共有 (CORS) をサポートしない可能性があることに注意してください。
Quarkus アプリケーションと OIDC プロバイダーが異なる HTTP ドメイン、ポート、またはその両方でホストされている場合、認証に失敗します。</p>
</div>
<div class="paragraph">
<p>このような場合は、 <code>quarkus.oidc.authentication.java-script-auto-redirect</code> プロパティーを <code>false</code> に設定します。これにより、Quarkus は <code>499</code> ステータスコードと <code>OIDC</code> 値を含む <code>WWW-Authenticate</code> ヘッダーを返すように指示されます。</p>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.java-script-auto-redirect</code> プロパティーが <code>false</code> に設定されている場合に <code>499</code> ステータスコードが返されるようにするには、ブラウザースクリプトで現在のリクエストを JavaScript リクエストとして識別するためのヘッダーを設定する必要があります。</p>
</div>
<div class="paragraph">
<p>スクリプトエンジンがエンジン固有のリクエストヘッダーを設定する場合は、カスタム <code>quarkus.oidc.JavaScriptRequestChecker</code> Bean を登録できます。これにより、現在のリクエストが JavaScript リクエストであるかどうかが Quarkus に通知されます。たとえば、JavaScript エンジンが <code>HX-Request: true</code> などのヘッダーを設定する場合は、次のようにチェックできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;

import io.quarkus.oidc.JavaScriptRequestChecker;
import io.vertx.ext.web.RoutingContext;

@ApplicationScoped
public class CustomJavaScriptRequestChecker implements JavaScriptRequestChecker {

    @Override
    public boolean isJavaScriptRequest(RoutingContext context) {
        return "true".equals(context.request().getHeader("HX-Request"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ステータスコードが <code>499</code> の場合は、最後にリクエストされたページを再度読み込みます。</p>
</div>
<div class="paragraph">
<p>それ以外の場合は、ブラウザースクリプトを更新し、 <code>X-Requested-With</code> ヘッダーに <code>JavaScript</code> 値を設定して、 <code>499</code> ステータスコードの場合は最後にリクエストされたページを再度読み込みする必要があります。</p>
</div>
<div class="paragraph">
<p>例えば、以下のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">Future&lt;void&gt; callQuarkusService() async {
    Map&lt;String, String&gt; headers = Map.fromEntries([MapEntry("X-Requested-With", "JavaScript")]);

    await http
        .get("https://localhost:443/serviceCall")
        .then((response) {
            if (response.statusCode == 499) {
                window.location.assign("https://localhost.com:443/serviceCall");
            }
         });
  }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cross-origin-resource-sharing"><a class="anchor" href="#cross-origin-resource-sharing"></a>クロスオリジンリソース共有</h3>
<div class="paragraph">
<p>別のドメインで実行されているシングルページのアプリケーションからこのアプリケーションを利用する場合は、クロスオリジンリソース共有（CORS）を設定する必要があります。
詳細については、「クロスオリジンリソース共有」ガイドの <a href="security-cors#cors-filter">CORSフィルター</a> のセクションを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="calling-cloud-provider-services"><a class="anchor" href="#calling-cloud-provider-services"></a>クラウドプロバイダーサービスの呼び出し</h3>
<div class="sect3">
<h4 id="google-cloud"><a class="anchor" href="#google-cloud"></a>Google Cloud</h4>
<div class="paragraph">
<p>Google Developer Consoles の <strong>BigQuery</strong> などの <strong>Google Cloud Services</strong> に対して OIDC 認可コードフロー権限を有効化している現在認証済みのユーザーに代わり、Quarkus OIDC <code>web-app</code> アプリケーションが、それらのサービスにアクセスできるようにすることが可能です。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/quarkiverse">Quarkiverse</a> <a href="https://github.com/quarkiverse/quarkiverse-google-cloud-services">Google クラウドサービス</a> を使用して、これを行うことができます。
追加する必要があるのは、
以下の例に示すように、 <a href="https://github.com/quarkiverse/quarkiverse-google-cloud-services/releases/latest">最新タグ</a> サービス依存関係のみです。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkiverse.googlecloudservices&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-google-cloud-bigquery&lt;/artifactId&gt;
    &lt;version&gt;${quarkiverse.googlecloudservices.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkiverse.googlecloudservices:quarkus-google-cloud-bigquery:${quarkiverse.googlecloudservices.version}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、Google OIDC プロパティーを設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.provider=google
quarkus.oidc.client-id={GOOGLE_CLIENT_ID}
quarkus.oidc.credentials.secret={GOOGLE_CLIENT_SECRET}
quarkus.oidc.token.issuer=https://accounts.google.com</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-quarkus-application-behind-a-reverse-proxy"><a class="anchor" href="#running-quarkus-application-behind-a-reverse-proxy"></a>Quarkusアプリケーションをリバースプロキシの背後で実行</h3>
<div class="paragraph">
<p>Quarkus アプリケーションがリバースプロキシー、ゲートウェイ、またはファイアウォールの背後で実行されている場合に、HTTP <code>Host</code> ヘッダーが内部 IP アドレスにリセットされたり、HTTPS 接続が終端されたりするなどして、OIDC 認証メカニズムが影響を受けることがあります。
たとえば、認可コードフローの <code>redirect_uri</code> パラメーターが、予期される外部ホストではなく内部ホストに設定されている場合があります。</p>
</div>
<div class="paragraph">
<p>このような場合、プロキシーによって転送された元のヘッダーを認識するように Quarkus を設定する必要があります。
詳細は、<a href="http-reference#reverse-proxy">リバースプロキシーの背後での実行</a> Vert.x のドキュメントセクションを参照してください。</p>
</div>
<div class="paragraph">
<p>たとえば、Quarkus エンドポイントが Kubernetes Ingress の背後にあるクラスターで実行されている場合、計算された <code>redirect_uri</code> パラメーターが内部エンドポイントアドレスを指している可能性があるため、OIDC プロバイダーからこのエンドポイントへのリダイレクトが機能しない可能性があります。
この問題は、Kubernetes Ingress によって外部エンドポイントアドレスを表すように <code>X-ORIGINAL-HOST</code> が設定されている次の設定を使用することで解決できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.http.proxy.proxy-address-forwarding=true
quarkus.http.proxy.allow-forwarded=false
quarkus.http.proxy.enable-forwarded-host=true
quarkus.http.proxy.forwarded-host-header=X-ORIGINAL-HOST</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>quarkus.oidc.authentication.force-redirect-https-scheme</code> プロパティーは、Quarkus アプリケーションが SSL 終了リバースプロキシーの背後で実行されている場合にも使用できます。</p>
</div>
</div>
<div class="sect2">
<h3 id="external-and-internal-access-to-the-oidc-provider"><a class="anchor" href="#external-and-internal-access-to-the-oidc-provider"></a>OIDCプロバイダーへの外部・内部アクセスについて</h3>
<div class="paragraph">
<p>OIDC プロバイダーの外部からアクセス可能な認可、ログアウト、およびその他のエンドポイントは、自動検出された URL や内部 URL <code>quarkus.oidc.auth-server-url</code> とは異なる HTTP(S) URL を持つ場合があります。
このような場合、エンドポイントは発行者の検証の失敗を報告し、外部からアクセス可能な OIDC プロバイダーエンドポイントへのリダイレクトが失敗する可能性があります。</p>
</div>
<div class="paragraph">
<p>Keycloak を使用する場合は、 <code>KEYCLOAK_FRONTEND_URL</code> システムプロパティーを外部からアクセス可能なベース URL に設定して起動します。
他の OIDC プロバイダーと連携する場合は、プロバイダーのドキュメントを確認してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="oidc-http-client-redirects"><a class="anchor" href="#oidc-http-client-redirects"></a>OIDC HTTP クライアントリダイレクト</h3>
<div class="paragraph">
<p>ファイアウォールの背後にある OIDC プロバイダーは、Quarkus OIDC HTTP クライアントの GET リクエストを、既知の設定エンドポイントなどのエンドポイントにリダイレクトする場合があります。
デフォルトでは、Quarkus OIDC HTTP クライアントは、セキュリティー上の理由からリダイレクトリクエスト中に設定された Cookie を除外して、自動的に HTTP リダイレクトい従います。</p>
</div>
<div class="paragraph">
<p>これは、必要に応じて <code>quarkus.oidc.follow-redirects=false</code> で無効にできます。</p>
</div>
<div class="paragraph">
<p>リダイレクトへの自動対応が無効になっている場合、Quarkus OIDC HTTP クライアントはリダイレクトリクエストを受信すると、リダイレクト URI が元のリクエスト URI とまったく同じで、リダイレクトリクエスト中に 1 つ以上の Cookie が設定されている場合に限り、リダイレクト URI に従って 1 回だけ回復を試みます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="oidc-saml-broker"><a class="anchor" href="#oidc-saml-broker"></a>OIDC SAMLアイデンティティ・ブローカー</h2>
<div class="sectionbody">
<div class="paragraph">
<p>IDプロバイダがOpenID Connectを実装しておらず、従来のXMLベースのSAML2.0 SSOプロトコルのみを実装している場合、 <code>quarkus-oidc</code> がOIDCアダプタとして使用する場合と同じようにQuarkusをSAML 2.0アダプタとして使用することはできません。</p>
</div>
<div class="paragraph">
<p>しかし、Keycloak、Okta、Auth0、Microsoft ADFS などの多くの OIDC プロバイダは、OIDC から SAML 2.0 へのブリッジを提供しています。
OIDCプロバイダでSAML 2.0プロバイダへのIDブローカー接続を作成し、 <code>quarkus-oidc</code> 、OIDCプロバイダがOIDCとSAML 2.0の通信を調整しながら、ユーザーをこのSAML 2.0プロバイダで認証することができます。
Quarkusエンドポイントに関しては、同じQuarkusセキュリティ、OIDC API、 <code>@Authenticated</code> 、 <code>SecurityIdentity</code> などのアノテーションを使用し続けることができます。</p>
</div>
<div class="paragraph">
<p>たとえば、 <code>Okta</code> が SAML 2.0 プロバイダで、 <code>Keycloak</code> が OIDC プロバイダであると仮定しましょう。 
<code>Okta</code> SAML 2.0 プロバイダとブローカするために <code>Keycloak</code> を構成する方法を説明する、典型的なシーケンスを以下に示します。</p>
</div>
<div class="paragraph">
<p>まず、 <code>Okta</code> <code>Dashboard/Applications</code> に新しい <code>SAML2</code> インテグレーションを作成します：</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="./images/okta-create-saml-integration.png" alt="Okta Create SAML Integration">
</div>
</div>
<div class="paragraph">
<p>例えば、 <code>OktaSaml</code> と名前を付けます：</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="./images/okta-saml-general-settings.png" alt="Okta SAML General Settings">
</div>
</div>
<div class="paragraph">
<p>次に、Keycloak SAML ブローカーエンドポイントを指すように設定します。
この時点で、Keycloak レルムの名前 (例: <code>quarkus</code>) を知っておく必要があります。Keycloak SAML ブローカーのエイリアスが <code>saml</code> であると仮定して、エンドポイントアドレスを <code><a href="http://localhost:8081/realms/quarkus/broker/saml/endpoint" class="bare">http://localhost:8081/realms/quarkus/broker/saml/endpoint</a></code> と入力します。
サービスプロバイダー (SP) エンティティー ID を <code><a href="http://localhost:8081/realms/quarkus" class="bare">http://localhost:8081/realms/quarkus</a></code> と入力します。ここで、 <code><a href="http://localhost:8081" class="bare">http://localhost:8081</a></code> は Keycloak ベースアドレスで、 <code>saml</code> はブローカーエイリアスです。</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="./images/okta-saml-configuration.png" alt="Okta SAML Configuration">
</div>
</div>
<div class="paragraph">
<p>次に、この SAML インテグレーションを保存し、その Metadata URL をメモします。</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="./images/okta-saml-metadata.png" alt="Okta SAML Metadata">
</div>
</div>
<div class="paragraph">
<p>次に、SAMLプロバイダーをKeycloakに追加します：</p>
</div>
<div class="paragraph">
<p>まず、通常どおりに、新しいレルムを作成するか、既存のレルムを <code>Keycloak</code> にインポートします。
この場合、レルム名は <code>quarkus</code> にする必要があります。</p>
</div>
<div class="paragraph">
<p>次に、 <code>quarkus</code> レルムのプロパティーで、 <code>Identity Providers</code> に移動し、新しい SAML プロバイダーを追加します。</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="./images/keycloak-add-saml-provider.png" alt="Keycloak Add SAML Provider">
</div>
</div>
<div class="paragraph">
<p>エイリアスは <code>saml</code> に設定され、 <code>Redirect URI</code> は <code><a href="http://localhost:8081/realms/quarkus/broker/saml/endpoint" class="bare">http://localhost:8081/realms/quarkus/broker/saml/endpoint</a></code> で、 <code>Service provider entity ID</code> は <code><a href="http://localhost:8081/realms/quarkus" class="bare">http://localhost:8081/realms/quarkus</a></code> である点に注意してください。これらは、前の手順で Okta SAML Integration を作成するときに入力した値と同じです。</p>
</div>
<div class="paragraph">
<p>最後に、前の手順の最後に書き留めた Okta SAML Integration Metadata URL を指すように <code>Service entity descriptor</code> を設定します。</p>
</div>
<div class="paragraph">
<p>次に、必要に応じて、 <code>Authentication/browser/Identity Provider Redirector config</code> に移動し、 <code>Alias</code> プロパティーと <code>Default Identity Provider</code> プロパティーの両方を <code>saml</code> に設定して、この Keycloak SAML プロバイダーをデフォルトプロバイダーとして登録できます。
デフォルトのプロバイダーとして設定しない場合は、認証時に Keycloak は次の 2 つのオプションを提供します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SAML プロバイダによる認証</p>
</li>
<li>
<p>名前とパスワードを使用した Keycloak への直接認証</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ここで、Quarkus OIDC <code>web-app</code> アプリケーションを、Keycloak <code>quarkus</code> レルム <code>quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus</code> を指すように設定します。
次に、Keycloak OIDC および Okta SAML 2.0 プロバイダーによって提供される OIDC から SAML へのブリッジを使用して、Quarkus ユーザーを Okta SAML 2.0 プロバイダーに認証する準備が整います。</p>
</div>
<div class="paragraph">
<p>Keycloak の場合と同様に、他の OIDC プロバイダーを設定して SAML ブリッジを提供することもできます。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="code-flow-integration-testing"><a class="anchor" href="#code-flow-integration-testing"></a>テスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>別の OIDC のようなサーバーへの認証に関しては、テストが困難になることがよくあります。
Quarkus は、モックから OIDC プロバイダーのローカル実行まで、さまざまなオプションを提供します。</p>
</div>
<div class="paragraph">
<p>テストプロジェクトに以下の依存関係を追加することから始めます。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.htmlunit&lt;/groupId&gt;
    &lt;artifactId&gt;htmlunit&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
            &lt;artifactId&gt;*&lt;/artifactId&gt;
       &lt;/exclusion&gt;
    &lt;/exclusions&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("org.htmlunit:htmlunit")
testImplementation("io.quarkus:quarkus-junit")</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="code-flow-integration-testing-keycloak-devservices"><a class="anchor" href="#code-flow-integration-testing-keycloak-devservices"></a>Dev Services for Keycloak</h3>
<div class="paragraph">
<p>Keycloak に対する結合テストの場合は、<a href="security-openid-connect-dev-services">Dev services for Keycloak</a> を使用します。
このサービスは、テストコンテナーを初期化し、 <code>quarkus</code> レルムを作成し、シークレット <code>secret</code> を使用して <code>quarkus-app</code> クライアントを設定します。
また、 <code>admin</code> および <code>user</code> ロールを持つ <code>alice</code> と、 <code>user</code> ロールを持つ <code>bob</code> の 2 人のユーザーも設定します。</p>
</div>
<div class="paragraph">
<p>まず、 <code>application.properties</code> ファイルを準備します。</p>
</div>
<div class="paragraph">
<p>空の <code>application.properties</code> ファイルから開始する場合、 <code>Dev Services for Keycloak</code> は次のプロパティーを自動的に登録します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>実行中のテストコンテナーを指す <code>quarkus.oidc.auth-server-url</code></p>
</li>
<li>
<p><code>quarkus.oidc.client-id=quarkus-app</code></p>
</li>
<li>
<p><code>quarkus.oidc.credentials.secret=secret</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>必要な <code>quarkus-oidc</code> プロパティーがすでに設定されている場合は、 <code>quarkus.oidc.auth-server-url</code> を <code>prod</code> プロファイルに関連付けます。
これにより、 <code>Dev Services for Keycloak</code> が期待どおりにコンテナーを起動できるようになります。
以下はその例です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus</code></pre>
</div>
</div>
<div class="paragraph">
<p>テストを実行する前にカスタムレルムファイルを Keycloak にインポートするには、次のように <code>Dev services for Keycloak</code> を設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.keycloak.devservices.realm-path=quarkus-realm.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後に、<a href="#code-flow-integration-testing-wiremock">Wiremock</a> セクションで説明されているとおりテストコードを作成します。
唯一の違いは、 <code>@QuarkusTestResource</code> が不要になったことです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class CodeFlowAuthorizationTest {
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="code-flow-integration-testing-wiremock"><a class="anchor" href="#code-flow-integration-testing-wiremock"></a>Wiremock</h3>
<div class="paragraph">
<p>以下の依存関係を追加します。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-oidc-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-oidc-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>REST テストエンドポイントを準備し、 <code>application.properties</code> を設定します。
以下に例を示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># keycloak.url is set by OidcWiremockTestResource
quarkus.oidc.auth-server-url=${keycloak.url:replaced-by-test-resource}/realms/quarkus/
quarkus.oidc.client-id=quarkus-web-app
quarkus.oidc.credentials.secret=secret
quarkus.oidc.application-type=web-app</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後にテストコードを書きます。例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

import org.htmlunit.SilentCssErrorHandler;
import org.htmlunit.WebClient;
import org.htmlunit.html.HtmlForm;
import org.htmlunit.html.HtmlPage;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.oidc.server.OidcWiremockTestResource;

@QuarkusTest
@QuarkusTestResource(OidcWiremockTestResource.class)
public class CodeFlowAuthorizationTest {

    @Test
    public void testCodeFlow() throws Exception {
        try (final WebClient webClient = createWebClient()) {
            // the test REST endpoint listens on '/code-flow'
            HtmlPage page = webClient.getPage("http://localhost:8081/code-flow");

            HtmlForm form = page.getForms().get(0);
            // user 'alice' has the 'user' role
            form.getInputByName("username").type("alice");
            form.getInputByName("password").type("alice");

            page = form.getButtonByName("login").click();

            assertEquals("alice", page.getBody().asNormalizedText());
        }
    }

    private WebClient createWebClient() {
        WebClient webClient = new WebClient();
        webClient.setCssErrorHandler(new SilentCssErrorHandler());
        return webClient;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OidcWiremockTestResource</code> は <code>alice</code> と <code>admin</code> ユーザーを認識します。ユーザー <code>alice</code> にはデフォルトで <code>user</code> ロールしかありませんが、 <code>quarkus.test.oidc.token.user-roles</code> システムプロパティーでカスタマイズできます。ユーザー <code>admin</code> にはデフォルトで <code>user</code> と <code>admin</code> ロールがありますが、 <code>quarkus.test.oidc.token.user-roles</code> システムプロパティーでカスタマイズできます。</p>
</div>
<div class="paragraph">
<p>さらに、 <code>OidcWiremockTestResource</code> はトークンの発行者と対象ユーザーを <code><a href="https://service.example.com" class="bare">https://service.example.com</a></code> に設定します。これは、 <code>quarkus.test.oidc.token.issuer</code> および <code>quarkus.test.oidc.token.audience</code> システムプロパティーを使用してカスタマイズできます。</p>
</div>
<div class="paragraph">
<p><code>OidcWiremockTestResource</code> は、すべてのOIDCプロバイダーをエミュレートするために使用できます。</p>
</div>
</div>
<div class="sect2">
<h3 id="code-flow-integration-testing-keycloak"><a class="anchor" href="#code-flow-integration-testing-keycloak"></a>KeecycloakTestResourceLifecycleManagerの使用</h3>
<div class="paragraph">
<p><code>Dev Services for Keycloak</code> を使用しない正当な理由がある場合にのみ、テストには <code>KeycloakTestResourceLifecycleManager</code> を使用してください。
Keycloak に対する結合テストが必要な場合は、<a href="#code-flow-integration-testing-keycloak-devservices">Dev Services for Keycloak</a> を使用してテストすることを推奨します。</p>
</div>
<div class="paragraph">
<p>まず、以下の依存関係を追加します：</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-test-keycloak-server&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-test-keycloak-server")</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、Keycloak コンテナーを起動する <code>io.quarkus.test.common.QuarkusTestResourceLifecycleManager</code> の実装である <code>io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager</code> を提供します。</p>
</div>
<div class="paragraph">
<p>次に、Maven Surefire プラグインを次のように設定します (ネイティブイメージでテストする場合は、Maven Failsafe プラグインを同様に設定します)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;systemPropertyVariables&gt;
            &lt;!-- or, alternatively, configure 'keycloak.version' --&gt;
            &lt;keycloak.docker.image&gt;${keycloak.docker.image}&lt;/keycloak.docker.image&gt;
            &lt;!--
              Disable HTTPS if required:
              &lt;keycloak.use.https&gt;false&lt;/keycloak.use.https&gt;
            --&gt;
        &lt;/systemPropertyVariables&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、設定を行い、<a href="#code-flow-integration-testing-wiremock">Wiremock</a> セクションに説明されているのと同じ方法でテストコードを記述します。
唯一の違いは <code>QuarkusTestResource</code> の名前です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager;

@QuarkusTest
@QuarkusTestResource(KeycloakTestResourceLifecycleManager.class)
public class CodeFlowAuthorizationTest {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>KeycloakTestResourceLifecycleManager</code> は <code>alice</code> と <code>admin</code> ユーザーを登録します。ユーザー <code>alice</code> にはデフォルトで <code>user</code> ロールしかありませんが、 <code>keycloak.token.user-roles</code> システムプロパティーでカスタマイズできます。ユーザー <code>admin</code> にはデフォルトで <code>user</code> と <code>admin</code> ロールがありますが、 <code>keycloak.token.admin-roles</code> システムプロパティーでカスタマイズできます。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、 <code>KeycloakTestResourceLifecycleManager</code> がHTTPSを使用してKeycloakインスタンスを初期化します。これは、 <code>keycloak.use.https=false</code> を指定することで無効にすることができます。
デフォルトのrealm名は <code>quarkus</code> 、クライアントIDは <code>quarkus-web-app</code> です。必要に応じて、 <code>keycloak.realm</code> 、 <code>keycloak.web-app.client</code> システム・プロパティを設定して値をカスタマイズしてください。</p>
</div>
</div>
<div class="sect2">
<h3 id="code-flow-integration-testing-security-annotation"><a class="anchor" href="#code-flow-integration-testing-security-annotation"></a>TestSecurity アノテーション</h3>
<div class="paragraph">
<p><code>@TestSecurity</code> および <code>@OidcSecurity</code> アノテーションを使用して、次の注入のいずれか、または 4 つすべてに依存する <code>web-app</code> アプリケーションエンドポイントコードをテストできます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ID <code>JsonWebToken</code></p>
</li>
<li>
<p>Access <code>JsonWebToken</code></p>
</li>
<li>
<p><code>UserInfo</code></p>
</li>
<li>
<p><code>OidcConfigurationMetadata</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>詳細は、<a href="security-oidc-bearer-token-authentication#bearer-token-integration-testing-security-annotation">注入された JsonWebToken での TestingSecurityの使用</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="checking-errors-in-the-logs"><a class="anchor" href="#checking-errors-in-the-logs"></a>ログでエラー確認</h3>
<div class="paragraph">
<p>トークン検証エラーの詳細を確認するには、 <code>io.quarkus.oidc.runtime.OidcProvider</code> の <code>TRACE</code> レベルのロギングを有効にする必要があります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".level=TRACE
quarkus.log.category."io.quarkus.oidc.runtime.OidcProvider".min-level=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>OidcProviderクライアントの初期化エラーの詳細を確認するには、 <code>io.quarkus.oidc.runtime.OidcRecorder</code> の <code>TRACE</code> レベルのロギングを有効にしてください:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.oidc.runtime.OidcRecorder".level=TRACE
quarkus.log.category."io.quarkus.oidc.runtime.OidcRecorder".min-level=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>アプリケーションのグローバルログレベルを変更するには、 <code>quarkus dev</code> コンソールから <code>j</code> と入力します。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="programmatic-oidc-start-up"><a class="anchor" href="#programmatic-oidc-start-up"></a>プログラムによる OIDC のスタートアップ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>OIDC テナントは、次の例のようにプログラムで作成できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import io.quarkus.oidc.Oidc;
import jakarta.enterprise.event.Observes;

public class OidcStartup {

    void observe(@Observes Oidc oidc) {
        oidc.createWebApp("http://localhost:8180/realms/quarkus", "quarkus-app", "mysecret");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記のコードは、 <code>application.properties</code> ファイル内の次の設定とプログラム的に同等です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus
quarkus.oidc.application-type=web-app
quarkus.oidc.client-id=quarkus-app
quarkus.oidc.credentials.secret=mysecret</code></pre>
</div>
</div>
<div class="paragraph">
<p>さらに多くの OIDC テナントプロパティーを設定する必要がある場合は、次の例のように <code>OidcTenantConfig</code> ビルダーを使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.oidc;

import io.quarkus.oidc.Oidc;
import io.quarkus.oidc.OidcTenantConfig;
import io.quarkus.oidc.common.runtime.config.OidcClientCommonConfig.Credentials.Secret.Method;
import jakarta.enterprise.event.Observes;

public class OidcStartup {

    void createDefaultTenant(@Observes Oidc oidc) {
        var defaultTenant = OidcTenantConfig
                .authServerUrl("http://localhost:8180/realms/quarkus/")
                .clientId("quarkus-app")
                .credentials().clientSecret("mysecret", Method.POST).end()
                .build();
        oidc.create(defaultTenant);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>複数のテナントが関係するより複雑な設定については、OpenID Connect マルチテナンシーガイドの <a href="security-openid-connect-multitenancy#programmatic-startup">マルチテナントアプリケーション用のプログラムによる OIDC の起動</a> 
セクションを参照してください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references"><a class="anchor" href="#references"></a>参照</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="security-oidc-configuration-properties-reference">OIDC設定プロパティリファレンス</a></p>
</li>
<li>
<p><a href="security-oidc-expanded-configuration">Expanded OIDC Configuration Reference</a></p>
</li>
<li>
<p><a href="security-openid-connect-providers">よく知られたOpenID Connectプロバイダーの設定</a></p>
</li>
<li>
<p><a href="security-openid-connect-client-reference">OpenID ConnectおよびOAuth2クライアントとフィルターのリファレンスガイド</a></p>
</li>
<li>
<p><a href="security-openid-connect-dev-services">Dev Services for Keycloak</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms#oidc-jwt-oauth2-comparison">OpenID Connect、SmallRye JWT、OAuth2の認証メカニズムの選択</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms#combining-authentication-mechanisms">認証メカニズムの組み合わせ</a></p>
</li>
<li>
<p><a href="security-overview">Quarkus Securityの概要</a></p>
</li>
<li>
<p><a href="https://www.keycloak.org/documentation.html">Keycloakドキュメント</a></p>
</li>
<li>
<p><a href="https://openid.net/connect/">OpenID Connect</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a></p>
</li>
</ul>
</div>
</div>
</div>
    </div>
    <div class="grid__item width-4-12 width-12-12-m tocwrapper">
      <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#overview-of-the-oidc-authorization-code-flow-mechanism">OIDC認可コードフローメカニズムの概要</a></li>
<li><a href="#using-the-authorization-code-flow-mechanism">認可コードフローメカニズムの利用について</a>
<ul class="sectlevel2">
<li><a href="#configuring-quarkus-to-support-authorization-code-flow">認証コードフローをサポートするためのQuarkusの設定</a></li>
<li><a href="#configuring-access-to-the-oidc-provider-endpoint">OIDCプロバイダー・エンドポイントへのアクセス設定</a></li>
<li><a href="#oidc-provider-client-authentication">OIDCプロバイダーのクライアント認証</a>
<ul class="sectlevel3">
<li><a href="#additional-jwt-authentication-options">JWT認証の追加オプション</a></li>
<li><a href="#apple-post-jwt">Apple POST JWT</a></li>
<li><a href="#mutual-tls-mtls">相互TLS (mTLS)</a></li>
<li><a href="#post-query">POSTクエリ</a></li>
<li><a href="#introspection-endpoint-authentication">イントロスペクションエンドポイント認証</a></li>
</ul>
</li>
<li><a href="#code-flow-oidc-request-filters">OIDCリクエストフィルター</a></li>
<li><a href="#code-flow-oidc-response-filters">OIDC レスポンスフィルター</a></li>
<li><a href="#restrict-oidc-filter-to-code-flow">Restricting OIDC request and response filters to authorization code flow</a></li>
<li><a href="#redirecting-to-and-from-the-oidc-provider">OIDC プロバイダーへのリダイレクトと OIDC プロバイダーからのリダイレクト</a>
<ul class="sectlevel3">
<li><a href="#customize-authentication-requests">認証リクエストのカスタマイズ</a></li>
<li><a href="#customizing-the-authentication-error-response">認証エラーレスポンスのカスタマイズ</a></li>
</ul>
</li>
<li><a href="#oidc-redirect-filters">OIDC リダイレクトフィルター</a></li>
<li><a href="#authentication-completion-action">Authentication completion actions</a></li>
<li><a href="#accessing-authorization-data">認可データへのアクセス</a>
<ul class="sectlevel3">
<li><a href="#access_id_and_access_tokens">IDやアクセストークンへのアクセス</a></li>
<li><a href="#code-flow-user-info">User info</a></li>
<li><a href="#code-flow-config-metadata">OIDC 設定情報へのアクセス</a></li>
<li><a href="#token-claims-roles">トークンクレームと <code>SecurityIdentity</code> ロールのマッピング</a></li>
</ul>
</li>
<li><a href="#ensuring-validity-of-tokens-and-authentication-data">トークンと認証データの有効性の確認</a>
<ul class="sectlevel3">
<li><a href="#code-flow-token-verification-introspection">トークン検証・イントロスペクション</a></li>
<li><a href="#code-flow-token-introspection-userinfo-cache">トークンのイントロスペクションとUserInfoのキャッシュ</a></li>
<li><a href="#code-flow-jwt-claim-verification">JSONウェブトークンのクレーム検証</a></li>
<li><a href="#jose4j-validator-code">Jose4j Validator</a></li>
</ul>
</li>
<li><a href="#proof-key-for-code-exchange-pkce">Proof Key for Code Exchange (PKCE)</a></li>
<li><a href="#pushed-authorization-requests">Pushed Authorization Requests</a></li>
<li><a href="#rich-authorization-requests">Rich Authorization Requests</a>
<ul class="sectlevel3">
<li><a href="#add-an-authorization_details-query-parameter-with-oidcredirectfilter">Add an <code>authorization_details</code> query parameter with <code>OidcRedirectFilter</code></a></li>
</ul>
</li>
<li><a href="#handling-and-controlling-the-lifetime-of-authentication">認証のライフタイムの処理と制御</a>
<ul class="sectlevel3">
<li><a href="#oidc-cookies">クッキー</a></li>
<li><a href="#state-cookies">状態 Cookie</a></li>
<li><a href="#token-state-manager">セッションクッキーとデフォルトのTokenStateManager</a></li>
<li><a href="#custom-token-state-manager">セッションクッキーとカスタムTokenStateManager</a></li>
<li><a href="#db-token-state-manager">Database TokenStateManager</a></li>
<li><a href="#redis-token-state-manager">Redis TokenStateManager</a></li>
</ul>
</li>
<li><a href="#logout-and-expiration">ログアウトと有効期限</a>
<ul class="sectlevel3">
<li><a href="#user-initiated-logout">ユーザー主導のログアウト</a></li>
<li><a href="#back-channel-logout">バックチャネルログアウト</a></li>
<li><a href="#front-channel-logout">フロントチャンネルログアウト</a></li>
<li><a href="#local-logout">ローカルログアウト</a></li>
<li><a href="#oidc-session"><code>OidcSession</code> をローカルログアウトに使用</a></li>
<li><a href="#session-management">セッション管理</a></li>
</ul>
</li>
<li><a href="#oauth2">GitHubおよびOIDC以外のOAuth2プロバイダとの統合</a></li>
<li><a href="#listen-to-authentication-events">重要な認証イベントのリッスン</a></li>
<li><a href="#oidc-token-revocation">トークンの失効</a></li>
<li><a href="#propagating-tokens-to-downstream-services">下流サービスへのトークンの伝播</a></li>
</ul>
</li>
<li><a href="#integration-considerations">統合に関する考慮事項</a>
<ul class="sectlevel2">
<li><a href="#single-page-applications">シングルページ・アプリケーション</a></li>
<li><a href="#cross-origin-resource-sharing">クロスオリジンリソース共有</a></li>
<li><a href="#calling-cloud-provider-services">クラウドプロバイダーサービスの呼び出し</a>
<ul class="sectlevel3">
<li><a href="#google-cloud">Google Cloud</a></li>
</ul>
</li>
<li><a href="#running-quarkus-application-behind-a-reverse-proxy">Quarkusアプリケーションをリバースプロキシの背後で実行</a></li>
<li><a href="#external-and-internal-access-to-the-oidc-provider">OIDCプロバイダーへの外部・内部アクセスについて</a></li>
<li><a href="#oidc-http-client-redirects">OIDC HTTP クライアントリダイレクト</a></li>
</ul>
</li>
<li><a href="#oidc-saml-broker">OIDC SAMLアイデンティティ・ブローカー</a></li>
<li><a href="#code-flow-integration-testing">テスト</a>
<ul class="sectlevel2">
<li><a href="#code-flow-integration-testing-keycloak-devservices">Dev Services for Keycloak</a></li>
<li><a href="#code-flow-integration-testing-wiremock">Wiremock</a></li>
<li><a href="#code-flow-integration-testing-keycloak">KeecycloakTestResourceLifecycleManagerの使用</a></li>
<li><a href="#code-flow-integration-testing-security-annotation">TestSecurity アノテーション</a></li>
<li><a href="#checking-errors-in-the-logs">ログでエラー確認</a></li>
</ul>
</li>
<li><a href="#programmatic-oidc-start-up">プログラムによる OIDC のスタートアップ</a></li>
<li><a href="#references">参照</a></li>
</ul></div>
    </div>
  </div>
  <h2>関連コンテンツ</h2>
  <div class="grid-wrapper relations">
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じエクステンションについて</h3>
      <ul class="related-content">
      
        
        <li class="concepts"><a href="/version/main/guides/security-openid-connect-providers">よく知られたOpenID Connect プロバイダーの設定</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-openid-connect-dev-services">OpenID Connect (OIDC)のDev ServicesとDev UI</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-vertx-oidc-to-quarkus-oidc-migration">Migrate from Vert.x OIDC to Quarkus OIDC</a></li>
      
        
        <li class="concepts"><a href="/version/main/guides/security-oidc-bearer-token-authentication">OpenID Connect (OIDC) ベアラートークン認証</a></li>
      
        
        <li class="reference"><a href="/version/main/guides/security-oidc-configuration-properties-reference">OpenID Connect (OIDC) 設定プロパティ</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-oidc-bearer-token-authentication-tutorial">OpenID Connect（OIDC）ベアラートークン認証によるサービスアプリケーションの保護</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-oidc-code-flow-authentication-tutorial">Quarkus - 認可コードフローのOpenID Connectを使用してWebアプリケーションを保護</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-keycloak-authorization">OpenID Connect (OIDC)とKeycloakを使用した認可の一元化</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-openid-connect-multitenancy">OpenID Connect (OIDC)のマルチテナンシーの使用</a></li>
      </ul>
    </div>
    <div class="grid__item width-6-12 width-12-12-m">
      <h3>同じトピックについて</h3>
      <ul class="related-content">
      
        
        <li class="concepts"><a href="/version/main/guides/security-oidc-bearer-token-authentication">OpenID Connect (OIDC) ベアラートークン認証</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-oidc-bearer-token-authentication-tutorial">OpenID Connect（OIDC）ベアラートークン認証によるサービスアプリケーションの保護</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-keycloak-authorization">OpenID Connect (OIDC)とKeycloakを使用した認可の一元化</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-openid-connect-dev-services">OpenID Connect (OIDC)のDev ServicesとDev UI</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-oidc-code-flow-authentication-tutorial">Quarkus - 認可コードフローのOpenID Connectを使用してWebアプリケーションを保護</a></li>
      
        
        <li class="guide"><a href="/version/main/guides/security-keycloak-admin-client">Keycloak Admin Clientの使用</a></li>
      
        
        <li class="concepts"><a href="/version/main/guides/security-authentication-mechanisms">Quarkusの認証メカニズム</a></li>
      
        
        <li class="concepts"><a href="/version/main/guides/security-basic-authentication">Basic認証</a></li>
      
        
        <li class="concepts"><a href="/version/main/guides/security-openid-connect-providers">よく知られたOpenID Connect プロバイダーの設定</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-basic-authentication-howto">ベーシック認証の有効化</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-getting-started-tutorial">Basic認証とJakarta Persistenceを使用したセキュリティの入門</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-vertx-oidc-to-quarkus-oidc-migration">Migrate from Vert.x OIDC to Quarkus OIDC</a></li>
      
        
        <li class="reference"><a href="/version/main/guides/security-openid-connect-client-reference">OpenID Connect (OIDC) と OAuth2 クライアントおよびフィルター</a></li>
      
        
        <li class="reference"><a href="/version/main/guides/security-openid-connect-client-registration">OpenID Connect (OIDC) と OAuth2 の動的クライアント登録</a></li>
      
        
        <li class="reference"><a href="/version/main/guides/security-oidc-configuration-properties-reference">OpenID Connect (OIDC) 設定プロパティ</a></li>
      
        
        <li class="tutorial"><a href="/version/main/guides/security-openid-connect-client">OpenID Connectクライアントとトークン伝搬クイックスタート</a></li>
      
        
        <li class="concepts"><a href="/version/main/guides/security-proactive-authentication">プロアクティブ認証</a></li>
      
        
        <li class="howto"><a href="/version/main/guides/security-openid-connect-multitenancy">OpenID Connect (OIDC)のマルチテナンシーの使用</a></li>
      
        
        <li class="reference"><a href="/version/main/guides/security-authorize-web-endpoints-reference">ウェブエンドポイントの認可</a></li>
      
        
        <li class="guide"><a href="/version/main/guides/security-jwt-build">JSON Web トークン (JWT) のビルド、署名、暗号化</a></li>
      </ul>
    </div>
    </div>
  </div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license. <i class='fab fa-creative-commons'></i><i class='fab fa-creative-commons-by'></i> <a href='https://creativecommons.org/licenses/by/3.0/' target='_blank'>CC by 3.0</a><br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>GitHub Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
          
            <li><a href="/" target="_blank">ホーム</a></li>
          
          
          
            <li><a href="/about" target="_blank">Quarkusについて</a></li>
          
          
          
            <li><a href="/blog" target="_blank">ブログ</a></li>
          
          
          
            <li><a href="/insights" target="_blank">ポッドキャスト</a></li>
          
          
          
            <li><a href="/events" target="_blank">イベント</a></li>
          
          
          
            <li><a href="/newsletter" target="_blank">ニュースレター</a></li>
          
          
          
            <li><a href="/userstories" target="_blank">ユーザーストーリー</a></li>
          
          
          
            <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" target="_blank">ロードマップ</a></li>
          
          
          
            <li><a href="/security" target="_blank">セキュリティ&nbsp;ポリシー</a></li>
          
          
          
            <li><a href="/usage" target="_blank">使用方法</a></li>
          
          
          
            <li><a href="https://github.com/commonhaus/artwork/tree/main/projects/quarkus" target="_blank">Brand</a></li>
          
          
          
            <li><a href="/desktopwallpapers" target="_blank">Wallpapers</a></li>
          
          
          
            <li><a href="https://www.redhat.com/en/about/privacy-policy" target="_blank">Privacy Policy</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォローする</span>
        <ul class="footer-links">
          
          
            <li><a href="https://x.com/quarkusio" target="_blank">X</a></li>
          
          
          
            <li><a href="https://bsky.app/profile/quarkus.io" target="_blank">Bluesky</a></li>
          
          
          
            <li><a rel="me" href="https://fosstodon.org/@quarkusio" target="_blank">Mastodon</a></li>
            
          
          
            <li><a href="https://www.threads.com/@quarkusio" target="_blank">Threads</a></li>
          
          
          
            <li><a href="https://www.facebook.com/quarkusio" target="_blank">Facebook</a></li>
          
          
          
            <li><a href="https://www.linkedin.com/company/quarkusio/" target="_blank">Linkedin</a></li>
          
          
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg" target="_blank">Youtube</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio" target="_blank">GitHub</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
          
            <li><a href="/support" target="_blank">サポート</a></li>
          
          
          
            <li><a href="/guides" target="_blank">ガイド</a></li>
          
          
          
            <li><a href="/faq" target="_blank">FAQ</a></li>
          
          
          
            <li><a href="/get-started" target="_blank">入門</a></li>
          
          
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus" target="_blank">Stack Overflow</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions" target="_blank">ディスカッション</a></li>
          
          
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev" target="_blank">開発メーリングリスト</a></li>
          
          
          
            <li><a href="https://stats.uptimerobot.com/ze1PfweT2p" target="_blank">Quarkus Service Status</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>言語</span>
        <ul class="footer-links">
          
          
            <li><a href=" https://quarkus.io/ " target="_blank">English</a></li>
          
          
          
            <li><a href="https://pt.quarkus.io/" target="_blank">Português&nbsp;(Brasileiro)</a></li>
          
          
          
            <li><a href=" https://es.quarkus.io/ " target="_blank">Español</a></li>
          
          
          
            <li><a href="https://cn.quarkus.io/" target="_blank">简体中文</a></li>
          
          
          
            <li><a href=" https://ja.quarkus.io/ " target="_blank">日本語</a></li>
          
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています</span>
        <ul class="footer-links">
          
            <li><a blah href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a blah href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a blah href="https://hibernate.org" target="_blank">Hibernate ORM</a></li>
          
            <li><a blah href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a blah href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a blah href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a blah href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a blah href="https://code.quarkus.io/" target="_blank">その他多数...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content cf-footer">
  <div class="flexcontainer">
    <div class="cf-logo">
      <a class="cf-logo" href="https://www.commonhaus.org/" target="_blank"><img src="https://raw.githubusercontent.com/commonhaus/artwork/main/foundation/brand/svg/CF_logo_horizontal_single_reverse.svg"/></a>
    </div>
    <div class="license">
      Copyright © Quarkus. All rights reserved. For details on our trademarks, please visit our <a href="https://www.commonhaus.org/policies/trademark-policy/">Trademark Policy</a> and <a href="https://www.commonhaus.org/trademarks/">Trademark List</a>. Trademarks of third parties are owned by their respective holders and their mention here does not suggest any endorsement or association.
    </div>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
  <script src="/assets/javascript/future-date.js" type="text/javascript"></script>
  <script src="/assets/javascript/randomize.js" type="text/javascript"></script>
  <script src="/assets/javascript/time.js" type="text/javascript"></script>
</body>

</html>
